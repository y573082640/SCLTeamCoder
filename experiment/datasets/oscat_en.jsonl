{"title": "Hyperbolic Arctangent Function (ATANH)", "description": "ATANH calculates the Arcus Hyperbolic tangent as follows:", "type": "FUNCTION", "name": "ATANH", "input": [{"name": "X", "type": "REAL", "description": "A real number input for which the hyperbolic arctangent is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The hyperbolic arctangent of the input value X.", "fields": []}}
{"title": "Convert DATE and TOD to Structured Date Time (SDT)", "description": "ATANH calculates the Arcus Hyperbolic tangent as follows:", "type": "FUNCTION", "name": "DT2_TO_SDT", "input": [{"name": "DI", "type": "DATE", "description": "Input variable of type DATE representing the date to convert."}, {"name": "TI", "type": "TOD", "description": "Input variable of type TOD representing the time of day to convert."}], "output": [{"name": "SDT", "type": "SDT", "description": "Output structure containing the converted date and time components.", "fields": [{"name": "YEAR", "type": "INT", "description": "The year extracted from the DATE."}, {"name": "MONTH", "type": "INT", "description": "The month extracted from the DATE."}, {"name": "DAY", "type": "INT", "description": "The day of the month extracted from the DATE."}, {"name": "WEEKDAY", "type": "INT", "description": "The weekday corresponding to the DATE (0 = Sunday, 1 = Monday, etc.)."}, {"name": "MS", "type": "INT", "description": "The milliseconds component extracted from the TOD."}, {"name": "SECOND", "type": "INT", "description": "The seconds component extracted from the TOD."}, {"name": "MINUTE", "type": "INT", "description": "The minutes component extracted from the TOD."}, {"name": "HOUR", "type": "INT", "description": "The hours component extracted from the TOD."}]}], "in/out": [], "return_value": {"type": "SDT", "description": "Returns the structured date time containing all the extracted date and time information.", "fields": [{"name": "YEAR", "type": "INT", "description": "The year of the structured date time."}, {"name": "MONTH", "type": "INT", "description": "The month of the structured date time."}, {"name": "DAY", "type": "INT", "description": "The day of the structured date time."}, {"name": "WEEKDAY", "type": "INT", "description": "The weekday of the structured date time."}, {"name": "MS", "type": "INT", "description": "The milliseconds of the structured date time."}, {"name": "SECOND", "type": "INT", "description": "The seconds of the structured date time."}, {"name": "MINUTE", "type": "INT", "description": "The minutes of the structured date time."}, {"name": "HOUR", "type": "INT", "description": "The hours of the structured date time."}]}}
{"title": "Convert Day to Time", "description": "DAY_TO_TIME calculates a value (TIME) from the input value\nin days as REAL.", "type": "FUNCTION", "name": "DAY_TO_TIME", "input": [{"name": "IN", "type": "REAL", "description": "The input value representing a duration in days that needs to be converted into time."}], "output": [{"name": "TIME", "type": "TIME", "description": "The output value representing the equivalent time format after conversion from the input days."}], "in/out": [], "return_value": {"type": "TIME", "description": "The TIME value that represents the input duration in days converted to time.", "fields": []}}
{"title": "Calculate Day of Year", "description": "DAY_OF_YEAR function calculates the day of the year from the input\ndate IDATE. Leap years are taken into account according to the Gregorian\ncalendar. The function is defned for the years 1970 - 2099.", "type": "FUNCTION", "name": "DAY_OF_YEAR", "input": [{"name": "IDATE", "type": "DATE", "description": "The input date from which the day of the year needs to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The calculated day of the year as an integer value."}}
{"title": "Byte to Gray Code Conversion", "description": "BYTE_TO_GRAY converts a byte value (IN) in the Gray code.", "type": "FUNCTION", "name": "BYTE_TO_GRAY", "input": [{"name": "IN", "type": "BYTE", "description": "An 8-bit byte that needs to be converted to Gray code."}], "output": [{"name": "BYTE_TO_GRAY", "type": "BYTE", "description": "The resulting Gray code representation of the input byte."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The Gray code equivalent of the input byte.", "fields": []}}
{"title": "Delete Characters from String", "description": "DEL_CHARS deletes all characters from a string which are contained in the\nstring CX.\nCLEAN('Nr.1 23#', ' #ABCDEFG') = 'Nr.123'", "type": "FUNCTION", "name": "DEL_CHARS", "input": [{"name": "IN", "type": "STRING", "description": "The input string from which characters will be deleted."}, {"name": "CX", "type": "STRING[80]", "description": "A string containing the characters to be deleted from the input string."}], "output": [{"name": "DEL_CHARS", "type": "STRING", "description": "The modified string after the specified characters have been deleted."}], "in/out": [], "return_value": {"type": "string", "description": "The resulting string after all specified characters have been removed.", "fields": []}}
{"title": "Click Counter Function Block", "description": "CLICK_CNT determines the number of pulses within the unit time TC. at in￾put IN. A rising edge at IN will start an internal timer with time TC. During\nthe course of Timers the module counts the falling edges of IN and review￾es after the expiry of the time TC whether N pulses are within the time TC.\nJust when exactly N pluses within TC will happen, the output Q is set for a\nPLC cycle to TRUE. The module decodes also N = 0, which corresponds to\na rising edge but not falling edge within TC.", "type": "FUNCTION_BLOCK", "name": "CLICK_CNT", "input": [{"name": "IN", "type": "BOOL", "description": "A boolean input signal that indicates when an event occurs."}, {"name": "N", "type": "INT", "description": "An integer that specifies the number of falling edges that should be counted before setting the output Q."}, {"name": "TC", "type": "TIME", "description": "A time parameter that defines the time interval for which the input signal is observed."}], "output": [{"name": "Q", "type": "BOOL", "description": "A boolean output that is activated for one cycle when the defined count of falling edges is reached."}], "in/out": [], "return_value": {}}
{"title": "Floor Function Conversion", "description": "CLICK_CNT determines the number of pulses within the unit time TC. at in￾put IN. A rising edge at IN will start an internal timer with time TC. During\nthe course of Timers the module counts the falling edges of IN and review￾es after the expiry of the time TC whether N pulses are within the time TC.\nJust when exactly N pluses within TC will happen, the output Q is set for a\nPLC cycle to TRUE. The module decodes also N = 0, which corresponds to\na rising edge but not falling edge within TC.", "type": "FUNCTION", "name": "FLOOR2", "input": [{"name": "X", "type": "REAL", "description": "A real number which will be converted to a DINT by flooring."}], "output": [], "in/out": [], "return_value": {"type": "DINT", "description": "The floored integer value derived from the input real number.", "fields": []}}
{"title": "Coth Function Calculation", "description": "COTH calculates the hyperbolic cotangent by the following formula:\nFor input values larger than 20 or less than -20 COTH provides the appro￾ximate value +1 or -1 corresponding to an accuracy better than 8 digits\nand is thus below the resolution of type REAL.", "type": "FUNCTION", "name": "COTH", "input": [{"name": "X", "type": "REAL", "description": "The real number input for which the hyperbolic cotangent will be calculated."}], "output": [{"name": "COTH", "type": "REAL", "description": "The calculated hyperbolic cotangent value based on the input X."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the computed hyperbolic cotangent value."}}
{"title": "Check if a Byte is a Valid Hex Character", "description": "ISC_HEX tests whether a sign IN is a hex character, If IN is a sign 0..9, A..F,\na..f the function returns TRUE if the function returns FALSE.\nThe signs are 0..9 are the codes (48..57)\nThe characters A..F are the codes (65..70)\nThe characters a..f are the codes (97..102)", "type": "FUNCTION", "name": "ISC_HEX", "input": [{"name": "IN", "type": "BYTE", "description": "The input byte to be checked if it is a valid hexadecimal character."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the input byte is a valid hexadecimal character, FALSE otherwise."}}
{"title": "Calculate Day of Date", "description": "DAY_OF_DATE day since 1.1.1970. The result of\nthe function is of type DINT because the entire DATE Range Includes\n49,710 days.", "type": "FUNCTION", "name": "DAY_OF_DATE", "input": [{"name": "idate", "type": "DATE", "description": "The date for which the day of the date is to be calculated."}], "output": [{"name": "DAY_OF_DATE", "type": "DINT", "description": "The calculated day of the date as a DINT value, which accommodates a range of 49710 days."}], "in/out": [], "return_value": {"type": "DINT", "description": "The computed day of the date returned as a DINT value.", "fields": []}}
{"title": "FF_D2E Function Block", "description": "DAY_OF_DATE day since 1.1.1970. The result of\nthe function is of type DINT because the entire DATE Range Includes\n49,710 days.", "type": "FUNCTION_BLOCK", "name": "FF_D2E", "input": [{"name": "D0", "type": "BOOL", "description": "Boolean input signal to determine the state of output Q0."}, {"name": "D1", "type": "BOOL", "description": "Boolean input signal to determine the state of output Q1."}, {"name": "CLK", "type": "BOOL", "description": "Clock input signal that triggers the state change on the flip-flop."}, {"name": "RST", "type": "BOOL", "description": "Reset input signal that sets the output values to false when activated."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal representing the state determined by input D0."}, {"name": "Q1", "type": "BOOL", "description": "Output signal representing the state determined by input D1."}], "in/out": [], "return_value": null}
{"title": "Delay Function Block", "description": "DELAY delays an input signal (IN) for N cycles. The input RESET is asyn￾chronous, and may delete the Delay bufer. \nThe", "type": "FUNCTION_BLOCK", "name": "DELAY", "input": [{"name": "IN", "type": "REAL", "description": "The real number input value to be processed by the delay block."}, {"name": "N", "type": "INT", "description": "The number of cycles to delay the input. This value is limited to a maximum of 32."}, {"name": "RST", "type": "BOOL", "description": "A boolean flag to reset the block. If true, the buffer will be reset."}], "output": [{"name": "OUT", "type": "REAL", "description": "The output value from the delay block, which is the delayed version of the input."}], "in/out": [], "return_value": null}
{"title": "Increment/Decrement Counter Function Block", "description": "INC_DEC is a decoder for incremental encoder. Encoder (rotation encoder)\ndeliver two overlapping pulses, channel A and channel B. By the two chan￾nels, the direction and angle of rotation is decoded. INC_DEC detect each\nedge of the encoder, so 4 times the resolution is achieved. The output DIR\nshows the direction of rotation, and at the output CNT is an integer value\nprovided, which outputs the number of counted pulses. For a full rotation\nof an encoder with 100 pulses CNT counts to 400, because each edge is\ncounted at both channels, so 4 times the resolution is achieved. A RST in￾put allows any time to set the counter to 0. The counter counts up when\nDIR = TRUE, and down if DIR = FALSE.\nIn the following", "type": "FUNCTION_BLOCK", "name": "INC_DEC", "input": [{"name": "CHa", "type": "BOOL", "description": "Input signal for channel A. Determines if an increment or decrement pulse is generated."}, {"name": "CHb", "type": "BOOL", "description": "Input signal for channel B. Determines if an increment or decrement pulse is generated."}, {"name": "RST", "type": "BOOL", "description": "Reset signal. When active, resets the counter to zero."}], "output": [{"name": "dir", "type": "BOOL", "description": "Output indicating the direction of counting. TRUE for increment, FALSE for decrement."}, {"name": "cnt", "type": "INT", "description": "Output showing the current value of the counter."}], "in/out": [], "return_value": null}
{"title": "Set R2 Parameters", "description": "INC_DEC is a decoder for incremental encoder. Encoder (rotation encoder)\ndeliver two overlapping pulses, channel A and channel B. By the two chan￾nels, the direction and angle of rotation is decoded. INC_DEC detect each\nedge of the encoder, so 4 times the resolution is achieved. The output DIR\nshows the direction of rotation, and at the output CNT is an integer value\nprovided, which outputs the number of counted pulses. For a full rotation\nof an encoder with 100 pulses CNT counts to 400, because each edge is\ncounted at both channels, so 4 times the resolution is achieved. A RST in￾put allows any time to set the counter to 0. The counter counts up when\nDIR = TRUE, and down if DIR = FALSE.\nIn the following", "type": "FUNCTION", "name": "R2_SET", "input": [{"name": "X", "type": "REAL", "description": "Input parameter representing a real number value to set RX."}], "output": [], "in/out": [], "return_value": {"type": "REAL2", "description": "Returns the modified R2 entity which includes RX set to the input value and R1 set to 0.0."}}
{"title": "Control Character String Checker", "description": "IS_CTRL tests whether the string STR are only control characters included.\nIf another character is found the function returns FALSE. If in STR are only\ncontrol characters included, the function returns TRUE. Control characters\nare the characters with the decimal 0..31 and 127", "type": "FUNCTION", "name": "IS_CTRL", "input": [{"name": "STR", "type": "STRING", "description": "The input string to be checked for control characters."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "The function returns TRUE if the string consists only of control characters, otherwise FALSE."}}
{"title": "Complementary Error Function Calculation", "description": "ERFC calculates the inverse error function of X.", "type": "FUNCTION", "name": "ERFC", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the complementary error function is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The value of the complementary error function computed from the input X."}}
{"title": "Filter Block", "description": "FILTER_W Output The main application is the fltering of sensor signals for noise re￾duction. The basic functionality of a flter of the frst degree can be found\nin the module FT_PT1.", "type": "FUNCTION_BLOCK", "name": "FILTER_W", "input": [{"name": "X", "type": "WORD", "description": "Input value to be filtered."}, {"name": "T", "type": "TIME", "description": "Time interval for filtering."}], "output": [{"name": "Y", "type": "WORD", "description": "Filtered output value."}], "in/out": [], "return_value": null}
{"title": "Convert Local Time to UTC", "description": "LTIME_TO_UTC calculates UTC (Universal Time) from a given local time. \nThe world time is calculated by subtracting from the TIME_ZONE_OFFSET\nLTIME local time. If the DST is active (DST = TRUE), an additional hour of\nLTIME is deducted.\nNote: The summer time is not regulated the same in all countries. The\nfunction assumes that in addition to summer time a further hour is added\nto ofset.", "type": "FUNCTION", "name": "LTIME_TO_UTC", "input": [{"name": "LOCAL_TIME", "type": "DT", "description": "The local time to be converted to UTC."}, {"name": "DST", "type": "BOOL", "description": "A boolean flag indicating if Daylight Saving Time should be considered."}, {"name": "TIME_ZONE_OFFSET", "type": "INT", "description": "The offset of the local time from UTC in minutes."}], "output": [], "in/out": [], "return_value": {"type": "DT", "description": "The converted UTC time.", "fields": []}}
{"title": "Ramp Function Block", "description": "FT_RMP calculates every time where the output\nshould be and sets this value to the output. The main change is therefore\ndependent on the cycle time and is not in equal steps. If a ramp out of\nsheer same steps are required, are the modules RMP_B and RMP_W are\navailable. The module is only active when the input RMP = TRUE.\nThe following chart shows the profle of the output as a function of an in￾put signal:", "type": "FUNCTION_BLOCK", "name": "FT_RMP", "input": [{"name": "Rmp", "type": "BOOL", "description": "Control flag to enable or disable ramping behavior."}, {"name": "in", "type": "REAL", "description": "Target input value to which the output will ramp."}, {"name": "KR", "type": "REAL", "description": "Ramp-up rate; determines how quickly the output will increase towards the input value."}, {"name": "KF", "type": "REAL", "description": "Ramp-down rate; determines how quickly the output will decrease towards the input value."}], "output": [{"name": "out", "type": "REAL", "description": "Current output value being ramped, based on the input value."}, {"name": "busy", "type": "BOOL", "description": "Indicates whether the output is currently in the process of ramping."}, {"name": "UD", "type": "BOOL", "description": "Direction flag indicating whether the output is ramping up (TRUE) or down (FALSE)."}], "in/out": [], "return_value": null}
{"title": "String Cleaning Function", "description": "CLEAN removes all characters from a string that are not included in the\nstring CX.\nCLEAN('Nr.1 23#', '0123456789 ') = '123'", "type": "FUNCTION", "name": "CLEAN", "input": [{"name": "IN", "type": "STRING[STRING_LENGTH]", "description": "The input string that needs to be cleaned."}, {"name": "CX", "type": "STRING[80]", "description": "A string containing the allowed characters. Only characters found in this string will remain in the output."}], "output": [{"name": "CLEAN", "type": "STRING", "description": "The cleaned string, containing only allowed characters."}], "in/out": [], "return_value": {"type": "string", "description": "The final cleaned version of the input string.", "fields": []}}
{"title": "Complex Division Function", "description": "CDIV dividing two complex numbers X / Y.", "type": "FUNCTION", "name": "CDIV", "input": [{"name": "X", "type": "complex", "description": "The first complex number to be divided, represented by its real and imaginary components."}, {"name": "Y", "type": "complex", "description": "The second complex number, which is the divisor in the division operation."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The result of the division of complex number X by complex number Y.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the result of the complex division."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the result of the complex division."}]}}
{"title": "Scheduler Function Block", "description": "CDIV dividing two complex numbers X / Y.", "type": "FUNCTION_BLOCK", "name": "SCHEDULER_2", "input": [{"name": "E0", "type": "BOOL", "description": "Event input signal 0 that affects output Q0."}, {"name": "E1", "type": "BOOL", "description": "Event input signal 1 that affects output Q1."}, {"name": "E2", "type": "BOOL", "description": "Event input signal 2 that affects output Q2."}, {"name": "E3", "type": "BOOL", "description": "Event input signal 3 that affects output Q3."}, {"name": "C0", "type": "UINT", "description": "Cycle count threshold for input E0."}, {"name": "C1", "type": "UINT", "description": "Cycle count threshold for input E1."}, {"name": "C2", "type": "UINT", "description": "Cycle count threshold for input E2."}, {"name": "C3", "type": "UINT", "description": "Cycle count threshold for input E3."}, {"name": "O0", "type": "UINT", "description": "Offset value for input signal E0."}, {"name": "O1", "type": "UINT", "description": "Offset value for input signal E1."}, {"name": "O2", "type": "UINT", "description": "Offset value for input signal E2."}, {"name": "O3", "type": "UINT", "description": "Offset value for input signal E3."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal 0 indicating if the condition for E0 is met."}, {"name": "Q1", "type": "BOOL", "description": "Output signal 1 indicating if the condition for E1 is met."}, {"name": "Q2", "type": "BOOL", "description": "Output signal 2 indicating if the condition for E2 is met."}, {"name": "Q3", "type": "BOOL", "description": "Output signal 3 indicating if the condition for E3 is met."}], "in/out": [], "return_value": null}
{"title": "Check Real Number", "description": "CHK_REAL reviewes X for valid values.\nThe return values are:\n#00 valid foating-point\n#20 + Infnity\n#40 - Infnity\n#80 NAN\nFor more information see the IEEE754 foating point specifcation.", "type": "FUNCTION", "name": "CHK_REAL", "input": [{"name": "X", "type": "REAL", "description": "The real number to be checked."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "Returns a byte indicating the status of the real number according to IEEE754 standards.", "fields": []}}
{"title": "Complex Exponential Function", "description": "CEXP calculates the complex exponent to base E, CEXP = E^X.", "type": "FUNCTION", "name": "CEXP", "input": [{"name": "X", "type": "COMPLEX", "description": "The input complex number for which the exponential is to be calculated."}], "output": [{"name": "CEXP", "type": "complex", "description": "The resulting complex number after computing the exponential of the input."}], "in/out": [], "return_value": {"type": "complex", "description": "Returns the computed complex exponential value.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the computed complex exponential."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the computed complex exponential."}]}}
{"title": "Complex Subtraction Function", "description": "CSUB Subtracts two complex numbers, Csub = X - Y.", "type": "FUNCTION", "name": "CSUB", "input": [{"name": "X", "type": "COMPLEX", "description": "The first complex number from which the second complex number will be subtracted."}, {"name": "Y", "type": "COMPLEX", "description": "The second complex number which will be subtracted from the first complex number."}], "output": [], "in/out": [], "return_value": {"type": "COMPLEX", "description": "The complex result obtained by subtracting Y from X.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the result."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the result."}]}}
{"title": "Real-Time Clock Management Function Block", "description": "RTC_MS is a clock component with a resolution of milliseconds and date.\nThe time is automatically every time you SET = TRUE to the value of SDT\nand SMS. If SET = FALSE the time is running on their own and provides the\noutput XDT the current date and time, and at the output XMS milliseconds.\nThe output XMS counts every second 0-999 and begins with the next se￾cond again at 0. The accuracy of the clock depends on the millisecond Ti￾mer of the PLC.", "type": "FUNCTION_BLOCK", "name": "RTC_MS", "input": [{"name": "SET", "type": "BOOL", "description": "A boolean flag to initiate the clock setting process."}, {"name": "SDT", "type": "DT", "description": "The current date and time to set the clock to."}, {"name": "SMS", "type": "INT", "description": "The initial count of milliseconds to set."}], "output": [{"name": "XDT", "type": "DT", "description": "The updated date and time after processing."}, {"name": "XMS", "type": "INT", "description": "The updated count of milliseconds since the last clock update."}], "in/out": [], "return_value": null}
{"title": "Dead Zone Function Block", "description": "RTC_MS is a clock component with a resolution of milliseconds and date.\nThe time is automatically every time you SET = TRUE to the value of SDT\nand SMS. If SET = FALSE the time is running on their own and provides the\noutput XDT the current date and time, and at the output XMS milliseconds.\nThe output XMS counts every second 0-999 and begins with the next se￾cond again at 0. The accuracy of the clock depends on the millisecond Ti￾mer of the PLC.", "type": "FUNCTION_BLOCK", "name": "DEAD_ZONE2", "input": [{"name": "X", "type": "REAL", "description": "The input value that is processed by the dead zone logic."}, {"name": "L", "type": "REAL", "description": "The dead zone threshold value. If the absolute value of 'X' is less than or equal to 'L', 'Y' will be set to either 'L' or '-L'."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value after applying the dead zone logic based on the input 'X' and threshold 'L'."}], "in/out": [], "return_value": {}}
{"title": "Status to ESR Data Converter", "description": "STATUS_TO_ESR generates a record from the input values.\nA STATUS in the range between 1.. 99 is an error message and will be mar￾ked as Type 1. Status 100 .. 199 is characterized as type 2 and 200 .. 255\nis marked as Type 3 ( Debug I nformation). \nThe ESR data at the output consist of the following items:\n.TYPE 1 = error, 2 = State, 3 = Debug \n.ADRESS Byte address of ISR data recording\n.LINE Line number (input) of the ESR data recording\n.DS Date stamp of type DATE_TIME\n.DT Timestamp of type TIME (PLC-timer)\n.Data Data block of 8 bytes\n 5. Mathematics", "type": "FUNCTION", "name": "STATUS_TO_ESR", "input": [{"name": "status", "type": "BYTE", "description": "A byte representing the status value which determines the type of ESR data."}, {"name": "adress", "type": "STRING[10]", "description": "A string of up to 10 characters representing the address associated with the ESR data."}, {"name": "DT_in", "type": "DT", "description": "A date and time input that represents the timestamp to be stored in the ESR data."}, {"name": "TS", "type": "TIME", "description": "A time input that indicates the time to be included in the ESR data."}], "output": [{"name": "esr_data", "type": "Struct", "description": "The output ESR data structure filled based on the input parameters and logic applied within the function.", "fields": [{"name": "typ", "type": "INT", "description": "The type classification of the ESR data, determined by the status value."}, {"name": "adress", "type": "STRING[10]", "description": "The address associated with the ESR data."}, {"name": "DS", "type": "DT", "description": "The date and time input retained in the ESR data."}, {"name": "TS", "type": "TIME", "description": "The time input retained in the ESR data."}, {"name": "data", "type": "ARRAY[0..10] OF BYTE", "description": "An array storing the status input at index 0."}]}], "in/out": [], "return_value": {"type": "Struct", "description": "This function does not return a value directly, but modifies the output variable 'esr_data' instead.", "fields": []}}
{"title": "String to DateTime Conversion", "description": "FSTRING_TO_DT convert a formatted string to a DATETIME value. Useing\nthe string FMT a format is given for decoding. The character '#' followed\nby a letter defnes the information to be decoded.\n#Y Year in the spelling in 08 or 2008\n#M Month in the spelling of 01 or 1\n#N Month in the spelling of 'Jan' or 'January' (Big and small letters are ignored)\n#D Day in the spelling of 01 or 1\n#h Hour in the spelling of 01 or 1\n#m Minute in the spelling of 01 or 1\n#s Second in the spelling of 01 or 1", "type": "FUNCTION", "name": "FSTRING_TO_DT", "input": [{"name": "SDT", "type": "STRING[60]", "description": "Input variable for the source data text which contains the date and time as a string."}, {"name": "FMT", "type": "STRING[60]", "description": "Input variable for the format that specifies how to interpret the source data text."}], "output": [{"name": "FSTRING_TO_DT", "type": "DT", "description": "The resulting DateTime value extracted from the provided string based on the specified format."}], "in/out": [], "return_value": {"type": "DT", "description": "The return value is the DateTime constructed from the parsed string.", "fields": []}}
{"title": "Sun Position Calculation", "description": "SUN_POS calculated the position of the sun (B, H) at the current time. The\ntime is expressed as Universal Time (UTC). Any possible local time must\nfrst be converted to UTC. At the sun position HR, the atmospheric refracti￾on for 1010mbar and 10°C is already taken into account. The accuracy is\nbetter than 0.1 degrees for the period from 2000 to 2050. Possible appli￾cations of SUN_POS are the tracking of solar panels or a sun dependent\ntracking of the slats of blinds. SUN_POS is a complicated algorithm, but\ndelivers the exact values. To keep the load of a PLC as low as possible, the\ncalculation can be performed, for example, only every 10 seconds, which\ncorresponds to an uncertainty of 0.04 degrees. The output B passes the\nsolar angle in degrees from north (south = 180 °). H is the Astronomical\nangle above the horizon (the horizon = 0 °). HR is the sun above the hori￾zon to the atmospheric corrected by the refraction (refraction). An obser￾ver on the Earth sees the sun in a, by the refraction raised position, of the\nhorizon, which will cause the sun is shining already, but it is still slightly\nbelow the horizon.", "type": "FUNCTION_BLOCK", "name": "SUN_POS", "input": [{"name": "latitude", "type": "REAL", "description": "Latitude of the geographical position."}, {"name": "longitude", "type": "REAL", "description": "Longitude of the geographical position."}, {"name": "utc", "type": "DT", "description": "World time in UTC."}], "output": [{"name": "B", "type": "REAL", "description": "Solar zenith angle in degrees."}, {"name": "H", "type": "REAL", "description": "Solar altitude angle in degrees."}, {"name": "HR", "type": "REAL", "description": "Hour angle in degrees."}], "in/out": [], "return_value": null}
{"title": "Minimum and Maximum Value Calculation", "description": "FT_MIN_MAX stores the minimum and maximum value of an input signal\nIN and provides these two values at the outputs of MN and MX until clea￾red by a reset. A reset sets MN and MX on the reset applied input values.", "type": "FUNCTION_BLOCK", "name": "FT_MIN_MAX", "input": [{"name": "in", "type": "REAL", "description": "The input value for which the minimum or maximum is to be calculated."}, {"name": "rst", "type": "BOOL", "description": "A reset flag that, when true, resets the minimum and maximum values."}], "output": [{"name": "mx", "type": "REAL", "description": "The current maximum value calculated."}, {"name": "mn", "type": "REAL", "description": "The current minimum value calculated."}], "in/out": [], "return_value": null}
{"title": "Determine Month of a Given Date", "description": "MONTH_OF_DATE(D#2007-12-31) = 12\nMONTH_OF_DATE(D#2006-1-1) = 1", "type": "FUNCTION", "name": "MONTH_OF_DATE", "input": [{"name": "IDATE", "type": "DATE", "description": "The date for which the month needs to be determined."}], "output": [{"name": "MONTH_OF_DATE", "type": "INT", "description": "The month of the year corresponding to the given date, as an integer value."}], "in/out": [], "return_value": {"type": "INT", "description": "Returns the calculated month of the year based on the input date."}}
{"title": "Factorial Calculation Function", "description": "FACT calculates the factorial of X. \nIt is defned for input values from 0 .. 12. For values less than zero and\ngreater than 12 is the result -1. For the factorial of larger numbers, the\nGAMMA function is suitable.\nFor natural numbers X: X! = 1*2*3...*(X-1)*X, 0! = 1\nFaculties of negative or non-whole numbers are not defned.", "type": "FUNCTION", "name": "FACT", "input": [{"name": "X", "type": "INT", "description": "The integer input for which the factorial is to be calculated."}], "output": [{"name": "FACT", "type": "DINT", "description": "Returns the factorial of the input integer X, or -1 if the input is out of valid range."}], "in/out": [], "return_value": {"type": "DINT", "description": "The factorial of the integer X or -1 if X is out of the acceptable range."}}
{"title": "Find Number in String", "description": "FIND_NUM STR from position POS from left to right\nand returns the frst position that is a number.\nNumbers are the letters \"0..9\" and \".\"", "type": "FUNCTION", "name": "FIND_NUM", "input": [{"name": "str", "type": "STRING", "description": "The string to be searched for numeric characters.", "fields": []}, {"name": "pos", "type": "INT", "description": "The starting position from which to begin the search for numeric characters.", "fields": []}], "output": [{"name": "FIND_NUM", "type": "INT", "description": "The index of the first numeric character found in the string; returns 0 if no numeric character is found.", "fields": []}], "in/out": [], "return_value": {"type": "INT", "description": "Returns the index of the first numeric character or 0 if none is found.", "fields": []}}
{"title": "Counting Block", "description": "COUNT_BR is a byte count from 0 to MX and starts again at 0. The counter\ncan, using two edge-triggered inputs UP and DN, both forward and back￾ward counting. when reaching a fnal value 0 or MX it counts again at 0 or\nMX. The STEP input sets the increment value of the counter. With a TRUE\nat input SET the counter is set to present value at the IN input. A reset in￾put RST resets the counter at any time to 0.\nSET IN UP DN STEP RST CNT\nReset - - - - - 1 0\nSet 1 N - - - 0 N\nup 0 - ↑ 0 N 0 CNT + N\ndown 0 - 0 ↑ N 0 CNT - N\nIf the independent inputs UP and DN with CLK and a control input UP/DN\nshould be replaced, id can be done using two AND gates at the inputs:\nCOUNT_BR may work with individual step width at UP or Down command,\nit is important to note that the counter behaves as if it internally counts\nthe number of STEP steps forward or backward.", "type": "FUNCTION_BLOCK", "name": "COUNT_BR", "input": [{"name": "SET", "type": "BOOL", "description": "A boolean input that, when true, sets the count to the input value."}, {"name": "IN", "type": "BYTE", "description": "A byte input representing the value to reset to when SET is activated."}, {"name": "UP", "type": "BOOL", "description": "A boolean input indicating an increment request for the count."}, {"name": "DN", "type": "BOOL", "description": "A boolean input indicating a decrement request for the count."}, {"name": "STEP", "type": "BYTE", "description": "A byte parameter that defines the step size for increments and decrements. Defaults to 1.", "fields": []}, {"name": "MX", "type": "BYTE", "description": "A byte parameter that sets the maximum limit for the count. Defaults to 255.", "fields": []}, {"name": "RST", "type": "BOOL", "description": "A boolean input that, when true, resets the count to zero."}], "output": [{"name": "CNT", "type": "BYTE", "description": "The current count value after processing the inputs."}], "in/out": [], "return_value": {}}
{"title": "16-Element Stack Function Block", "description": "COUNT_BR is a byte count from 0 to MX and starts again at 0. The counter\ncan, using two edge-triggered inputs UP and DN, both forward and back￾ward counting. when reaching a fnal value 0 or MX it counts again at 0 or\nMX. The STEP input sets the increment value of the counter. With a TRUE\nat input SET the counter is set to present value at the IN input. A reset in￾put RST resets the counter at any time to 0.\nSET IN UP DN STEP RST CNT\nReset - - - - - 1 0\nSet 1 N - - - 0 N\nup 0 - ↑ 0 N 0 CNT + N\ndown 0 - 0 ↑ N 0 CNT - N\nIf the independent inputs UP and DN with CLK and a control input UP/DN\nshould be replaced, id can be done using two AND gates at the inputs:\nCOUNT_BR may work with individual step width at UP or Down command,\nit is important to note that the counter behaves as if it internally counts\nthe number of STEP steps forward or backward.", "type": "FUNCTION_BLOCK", "name": "STACK_16", "input": [{"name": "Din", "type": "DWORD", "description": "The data input to be written to the stack."}, {"name": "E", "type": "BOOL", "description": "Enable input, which must be TRUE for read or write operations to occur. Defaults to TRUE."}, {"name": "RD", "type": "BOOL", "description": "Read signal, which when TRUE and stack is not empty, triggers the reading of the top element from the stack."}, {"name": "WD", "type": "BOOL", "description": "Write signal, which when TRUE and stack is not full, triggers the writing of the input data to the stack."}, {"name": "RST", "type": "BOOL", "description": "Reset signal, when TRUE resets the stack to its initial state."}], "output": [{"name": "Dout", "type": "DWORD", "description": "The data output that provides the most recently read value from the stack."}, {"name": "EMPTY", "type": "BOOL", "description": "Indicates if the stack is empty. TRUE if the stack is empty."}, {"name": "FULL", "type": "BOOL", "description": "Indicates if the stack is full. TRUE if the stack is full."}], "in/out": [], "return_value": null}
{"title": "Check if a 3D Vector is Null", "description": "COUNT_BR is a byte count from 0 to MX and starts again at 0. The counter\ncan, using two edge-triggered inputs UP and DN, both forward and back￾ward counting. when reaching a fnal value 0 or MX it counts again at 0 or\nMX. The STEP input sets the increment value of the counter. With a TRUE\nat input SET the counter is set to present value at the IN input. A reset in￾put RST resets the counter at any time to 0.\nSET IN UP DN STEP RST CNT\nReset - - - - - 1 0\nSet 1 N - - - 0 N\nup 0 - ↑ 0 N 0 CNT + N\ndown 0 - 0 ↑ N 0 CNT - N\nIf the independent inputs UP and DN with CLK and a control input UP/DN\nshould be replaced, id can be done using two AND gates at the inputs:\nCOUNT_BR may work with individual step width at UP or Down command,\nit is important to note that the counter behaves as if it internally counts\nthe number of STEP steps forward or backward.", "type": "FUNCTION", "name": "V3_NUL", "input": [{"name": "A", "type": "Vector_3", "description": "A 3D vector whose components will be checked to determine if it is a null vector."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the vector A is a null vector (all components are zero); otherwise, returns FALSE."}}
{"title": "Check Even Number", "description": "EVEN = TRUE if the input IN is even and FALSE for odd IN.", "type": "FUNCTION", "name": "EVEN", "input": [{"name": "in", "type": "DINT", "description": "Input variable that represents the integer to be checked for evenness."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "The boolean result indicating if the input number is even (TRUE) or odd (FALSE)."}}
{"title": "Driver Control Function Block", "description": "EVEN = TRUE if the input IN is even and FALSE for odd IN.", "type": "FUNCTION_BLOCK", "name": "DRIVER_4", "input": [{"name": "Toggle_Mode", "type": "BOOL", "description": "A boolean value indicating the mode of operation to toggle."}, {"name": "Timeout", "type": "TIME", "description": "A time duration which sets the timeout for the drivers."}, {"name": "SET", "type": "BOOL", "description": "A boolean signal to set the driver functionality."}, {"name": "IN0", "type": "BOOL", "description": "Input signal for the first driver instance."}, {"name": "IN1", "type": "BOOL", "description": "Input signal for the second driver instance."}, {"name": "IN2", "type": "BOOL", "description": "Input signal for the third driver instance."}, {"name": "IN3", "type": "BOOL", "description": "Input signal for the fourth driver instance."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to clear the driver states."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output state of the first driver instance."}, {"name": "Q1", "type": "BOOL", "description": "Output state of the second driver instance."}, {"name": "Q2", "type": "BOOL", "description": "Output state of the third driver instance."}, {"name": "Q3", "type": "BOOL", "description": "Output state of the fourth driver instance."}], "in/out": [], "return_value": null}
{"title": "Shift Right Operation", "description": "EVEN = TRUE if the input IN is even and FALSE for odd IN.", "type": "FUNCTION", "name": "SHR1", "input": [{"name": "IN", "type": "DWORD", "description": "The input DWORD value to be shifted."}, {"name": "N", "type": "INT", "description": "The number of bits to shift the input value to the right."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The result of the logical right shift operation on the input value.", "fields": []}}
{"title": "Array Absolute Value Calculation", "description": "_ARRAY_ABS calculates the elements of an arbitrary array Of\nREAL in an absolute value. When called, a pointer to the array and its size\nin bytes is transferred to the function. Under CoDeSys the call reads: _AR￾RAY_ABS(ADR(Array), SIZEOF(array)), where array is the name of the array\nto be manipulated. ADR() is a standard function which identifes the poin￾ter to the array and SIZEOF() is a standard function, which determines the\nsize of the array. The function only returns TRUE. The array specifed by\nthe pointer is manipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.\nCall: _ARRAY_ABS(ADR(bigarray), SIZEOF(bigarray))", "type": "FUNCTION", "name": "_ARRAY_ABS", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "A pointer to the array of real numbers whose absolute values need to be calculated."}, {"name": "size", "type": "UINT", "description": "The number of elements in the array."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the absolute values were successfully calculated."}}
{"title": "Holiday Calculation", "description": "HOLIDAYS: ARRAY [0..29] of HOLIDAY_DATA\nOutput Y: BOOL (TRUE if DATE_IN is a holiday)\nName: STRING(30) (name of present-day holiday)\nThe HOLIDAY function shows the output Y with TRUE holidays and also pro￾vides the name of the current holiday at the output NAME. HOLIDAY can,\nin addition to celebration days during the weekdays Friday, Saturday or\nSunday be active and deliver at the output Y TRUE, depending on whether\nthe inputs are FRIDAY, SATURDAY or SUNDAY set to TRUE. In the array HO￾LIDAYS are name and date of holidays defned and also universally adapta￾ble to other countries. Holidays can be defned as a fxed date, with a di￾stance of Easter or the week before a fxed date. The input LANGU selects\nthe appropriate language from the setup data so that expenditure for Fri￾day, Saturday and Sunday can be customized language-specifc. [fzy] The\nlanguages are global constants in the \"LOCATION SETUP\" defned and can\nbe expanded or adapted.\nIn the external array HOLIDAYS up to 30 holidays can be defned. Examp￾les are located in the description of the data type HOLYDAY_DATA.", "type": "FUNCTION_BLOCK", "name": "HOLIDAY", "input": [{"name": "DATE_IN", "type": "DATE", "description": "The date to check for a holiday."}, {"name": "LANGU", "type": "INT", "description": "The language code to determine the holiday name."}, {"name": "FRIDAY", "type": "BOOL", "description": "Indicates whether Friday should be considered as a weekend."}, {"name": "SATURDAY", "type": "BOOL", "description": "Indicates whether Saturday should be considered as a weekend."}, {"name": "SUNDAY", "type": "BOOL", "description": "Indicates whether Sunday should be considered as a weekend."}], "output": [{"name": "Y", "type": "BOOL", "description": "Indicates whether the date is a holiday."}, {"name": "NAME", "type": "STRING[30]", "description": "The name of the holiday, if any, corresponding to the given date."}], "in/out": [{"name": "HOLIDAYS", "type": "ARRAY[0..29] OF HOLIDAY_DATA", "description": "An array containing holiday data to be checked against the input date."}], "return_value": {"type": null, "description": null}}
{"title": "Conversion from SDT to DT", "description": "SDT_TO_DT generates a date-time value of a structured date-time value", "type": "FUNCTION", "name": "SDT_TO_DT", "input": [{"name": "DTI", "type": "SDT", "description": "Input parameter of type SDT that holds the structured date time information."}], "output": [], "in/out": [], "return_value": {"type": "DT", "description": "The resulting date time value in DT format after conversion from the SDT input.", "fields": []}}
{"title": "Extract Bit from DWORD", "description": "BIT_OF_DWORD extracts a bit of the DWORD at the input IN.\nBit0 für N=0, Bit1 für N=1 and so on.", "type": "FUNCTION", "name": "BIT_OF_DWORD", "input": [{"name": "in", "type": "DWORD", "description": "The DWORD input value from which the bit is extracted."}, {"name": "N", "type": "INT", "description": "The position of the bit to check in the DWORD input."}], "output": [{"name": "BIT_OF_DWORD", "type": "BOOL", "description": "A boolean value indicating if the specified bit is set in the input DWORD."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the specified bit is set, otherwise FALSE."}}
{"title": "8-channel Digital Output Controller", "description": "BIT_OF_DWORD extracts a bit of the DWORD at the input IN.\nBit0 für N=0, Bit1 für N=1 and so on.", "type": "FUNCTION_BLOCK", "name": "DEC_8", "input": [{"name": "D", "type": "BOOL", "description": "The input data signal that will be assigned to one of the output channels based on the address."}, {"name": "A0", "type": "BOOL", "description": "The least significant bit of the address that specifies which channel to control."}, {"name": "A1", "type": "BOOL", "description": "The middle bit of the address that specifies which channel to control."}, {"name": "A2", "type": "BOOL", "description": "The most significant bit of the address that specifies which channel to control."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output channel 0, which receives the value of D if the address is 0."}, {"name": "Q1", "type": "BOOL", "description": "Output channel 1, which receives the value of D if the address is 1."}, {"name": "Q2", "type": "BOOL", "description": "Output channel 2, which receives the value of D if the address is 2."}, {"name": "Q3", "type": "BOOL", "description": "Output channel 3, which receives the value of D if the address is 3."}, {"name": "Q4", "type": "BOOL", "description": "Output channel 4, which receives the value of D if the address is 4."}, {"name": "Q5", "type": "BOOL", "description": "Output channel 5, which receives the value of D if the address is 5."}, {"name": "Q6", "type": "BOOL", "description": "Output channel 6, which receives the value of D if the address is 6."}, {"name": "Q7", "type": "BOOL", "description": "Output channel 7, which receives the value of D if the address is 7."}], "in/out": [], "return_value": {}}
{"title": "Convert Structured Date Time to Date", "description": "SDT_TO_DATE produces a date value of a structured date-time value", "type": "FUNCTION", "name": "SDT_TO_DATE", "input": [{"name": "DTI", "type": "SDT", "description": "The structured date time input that contains the year, month, and day."}], "output": [], "in/out": [], "return_value": {"type": "DATE", "description": "The resulting date generated from the structured date time.", "fields": []}}
{"title": "Ramp Control Block", "description": "_RMP_B Is an 8-bit ramp generator. The ramp is generated in an externally\ndeclared variable. The ramp is rising when DIR = TRUE and falling if DIR =\nFALSE. Reaching a fnal value of the ramp, the generator remains at this\nvalue. With the input E the ramp can be stopped at any time, when E =\nTRUE the ramp runs. The input TR shows the time which is needed to cy￾cle through 0-255 or the other way around.", "type": "FUNCTION_BLOCK", "name": "_RMP_B", "input": [{"name": "DIR", "type": "BOOL", "description": "Indicates the direction of the ramp. 'true' means ramping up."}, {"name": "E", "type": "BOOL", "description": "Enable signal for the ramp control. Defaults to TRUE."}, {"name": "TR", "type": "TIME", "description": "Timing reference to control the ramping duration."}], "output": [{"name": "RMP", "type": "BYTE", "description": "Output value representing the current state of the ramp."}], "in/out": [], "return_value": null}
{"title": "Check Parity", "description": "CHECK_PARITY checks an input byte IN and an associated paritybit P to\neven parity. The output is TRUE if the number of bits in the byte IN have\nthe value TRUE together with the parity-bit results is an even number.", "type": "FUNCTION", "name": "CHECK_PARITY", "input": [{"name": "in", "type": "DWORD", "description": "A DWORD input whose parity is to be checked."}, {"name": "p", "type": "BOOL", "description": "A boolean parameter that is used to adjust the final parity result."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "The computed parity result, where TRUE indicates odd parity and FALSE indicates even parity."}}
{"title": "Band Operation Function", "description": "BAND_B hides at the input areas 0..255\nthe areas 0..B and 255-B.. 255, in this\nareas the output is 0 respectively 255.", "type": "FUNCTION", "name": "BAND_B", "input": [{"name": "X", "type": "BYTE", "description": "The first input value for the band operation."}, {"name": "B", "type": "BYTE", "description": "The second input value for the band operation."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "The result of the band operation based on the input values.", "fields": []}}
{"title": "Minute Extraction from DateTime", "description": "MINUTE_OF_DT extracts the current minute from a DT value.\nMINUTE_OF_DT(DT#2008-6-6-10:22:20) = 22", "type": "FUNCTION", "name": "MINUTE_OF_DT", "input": [{"name": "XDT", "type": "DT", "description": "The DateTime value from which the minute is to be extracted."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The extracted minute value from the given DateTime.", "fields": []}}
{"title": "Calculate Temperature from Resistance", "description": "TEMP_PT calculates the temperature of a PT-resistance from the RES sen￾sor input values (measured resistance value) and R0 (resistance at 0°C). If\nthe inputs has a temperature outside the range of -200.. + 850°C, at the\noutput the temperature output +10000.0°C is passed.\nThe calculation is done using the formula:\nfor temperatures > 0 °C\nRES_PT = R0 * (1 + A*T + B*T²)\nand for temperatures below 0 ° C\nRES_PT = R0 * (1 + A*T + B*T² + C*(T-100)*T³\nA = 3.90802E-3; B = -5.80195E-7; C = -427350E-12", "type": "FUNCTION", "name": "TEMP_PT", "input": [{"name": "Res", "type": "REAL", "description": "The resistance value to be used for temperature calculation."}, {"name": "R0", "type": "REAL", "description": "The reference resistance value used for comparison."}], "output": [{"name": "TEMP_PT", "type": "REAL", "description": "The calculated temperature in degrees Celsius based on the input resistance."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the computed temperature value."}}
{"title": "Calculate Year-End Date from Year Integer", "description": "YEAR_END calculates '31 December in the year Y.", "type": "FUNCTION", "name": "YEAR_END", "input": [{"name": "y", "type": "INT", "description": "The input variable representing the year as an integer."}], "output": [], "in/out": [], "return_value": {"type": "DATE", "description": "The calculated year-end date corresponding to the input year."}}
{"title": "Calibration Block", "description": "CALIBRATE serves for calibrating an analog signal. In order to allow a cali￾brating two reference values (Y_OFFSET and Y_SCALE) must be set by dou￾ble-clicking on the icon of the module. Y_OFFSET is the starting value at\nwhich the ofset is set by a pulse at CO and Y_SCALE is the value at which\nthe gain is determined. A calibration can only be successful if the frst of￾set and gain are then calibrated.", "type": "FUNCTION_BLOCK", "name": "CALIBRATE", "input": [{"name": "X", "type": "REAL", "description": "Input value that will be calibrated."}, {"name": "CO", "type": "BOOL", "description": "Control signal to adjust the offset."}, {"name": "CS", "type": "BOOL", "description": "Control signal to adjust the scale."}, {"name": "Y_Offset", "type": "REAL", "description": "Constant value for offset adjustment."}, {"name": "Y_Scale", "type": "REAL", "description": "Constant value for scale adjustment."}], "output": [{"name": "Y", "type": "REAL", "description": "Calibrated output value based on the input and calibration parameters."}], "in/out": [], "return_value": {}}
{"title": "Clock N Function Block", "description": "CLK_N generates a pulse every X milliseconds, based on the PLC internal 1\nms reference. The pulses are exactly one PLC cycle length and are genera￾ted every 2^N milliseconds.\nThe period is 1 ms for N = 0, 2ms for N = 1, 4ms, for N=2\nCLK_N replaces the modules CLK_1ms, CLK_2ms, CLK_4ms and CLK_8ms\nfrom older libraries.\nThe following picture shows the output signal for N=0:", "type": "FUNCTION_BLOCK", "name": "CLK_N", "input": [{"name": "N", "type": "INT", "description": "An integer that specifies the number of milliseconds for the clock period."}], "output": [{"name": "Q", "type": "BOOL", "description": "A boolean output that represents the current state of the clock."}], "in/out": [], "return_value": {}}
{"title": "Manual Control Function Block", "description": "CLK_N generates a pulse every X milliseconds, based on the PLC internal 1\nms reference. The pulses are exactly one PLC cycle length and are genera￾ted every 2^N milliseconds.\nThe period is 1 ms for N = 0, 2ms for N = 1, 4ms, for N=2\nCLK_N replaces the modules CLK_1ms, CLK_2ms, CLK_4ms and CLK_8ms\nfrom older libraries.\nThe following picture shows the output signal for N=0:", "type": "FUNCTION_BLOCK", "name": "MANUAL_4", "input": [{"name": "I0", "type": "BOOL", "description": "Input boolean signal 0."}, {"name": "I1", "type": "BOOL", "description": "Input boolean signal 1."}, {"name": "I2", "type": "BOOL", "description": "Input boolean signal 2."}, {"name": "I3", "type": "BOOL", "description": "Input boolean signal 3."}, {"name": "MAN", "type": "BOOL", "description": "Manual control signal; when true, switches to manual mode."}, {"name": "STP", "type": "BOOL", "description": "Stop signal; when true, triggers state change."}, {"name": "M0", "type": "BOOL", "description": "Manual mode output 0."}, {"name": "M1", "type": "BOOL", "description": "Manual mode output 1."}, {"name": "M2", "type": "BOOL", "description": "Manual mode output 2."}, {"name": "M3", "type": "BOOL", "description": "Manual mode output 3."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output boolean signal 0."}, {"name": "Q1", "type": "BOOL", "description": "Output boolean signal 1."}, {"name": "Q2", "type": "BOOL", "description": "Output boolean signal 2."}, {"name": "Q3", "type": "BOOL", "description": "Output boolean signal 3."}, {"name": "STATUS", "type": "BYTE", "description": "Status indicator reflecting current operation mode and state."}], "in/out": [], "return_value": {}}
{"title": "Calculate Argument of Complex Number", "description": "CARG calculates the angle of a complex number in the coordinate system.\nThe range of values of the result is between [-π , +π ].", "type": "FUNCTION", "name": "CARG", "input": [{"name": "X", "type": "COMPLEX", "description": "A complex number for which the argument needs to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated argument (angle in radians) of the complex number X.", "fields": []}}
{"title": "Calculate Day of Month", "description": "DAY_OF_MONTH function calculates the day of the month from the in￾put date IDATE.", "type": "FUNCTION", "name": "DAY_OF_MONTH", "input": [{"name": "IDATE", "type": "DATE", "description": "The input date for which the day of the month is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The calculated day of the month based on the input date, adjusted for leap years and month offsets."}}
{"title": "Generator for Ramp Modulated Pulse (RMP)", "description": "GEN_RMP is a sawtooth generator. It generates a ramp at the output OUT \nwith the duration of PT and repeats this continuously. The output Q is for \nexactly one cycle TRUE when the ramp starts at the output OUT. The input \nAM and OS set the amplitude and the ofset for the output OUT. If the \ninputs OS and AM are not connected the default values are 0 and 1. The \noutput OUT then generates a sawtooth signal of 0 .. 1. The input DL can \nmove the output up to a period (PT) and is used to produce multiple \nshifted signals to each other. A 0 at the input DL means no displacement. \nA value between 0 and 1 shifts the signal by up to a period. \nThe following example shows a trace recording of the input values PT =\n10s, AM = 1 and OS = 0", "type": "FUNCTION_BLOCK", "name": "GEN_RMP", "input": [{"name": "PT", "type": "TIME", "description": "Pulse time duration for the generation of the ramp-modulated pulse."}, {"name": "AM", "type": "REAL", "description": "Amplitude of the ramp signal."}, {"name": "OS", "type": "REAL", "description": "Offset added to the ramp signal."}, {"name": "DL", "type": "REAL", "description": "Duty cycle of the pulse signal, represented as a fraction between 0 and 1."}], "output": [{"name": "Q", "type": "BOOL", "description": "Boolean flag indicating if the current output is less than the previous output."}, {"name": "OUT", "type": "REAL", "description": "Calculated output value of the ramp signal."}], "in/out": [], "return_value": {}}
{"title": "Ceil2 Function", "description": "GEN_RMP is a sawtooth generator. It generates a ramp at the output OUT \nwith the duration of PT and repeats this continuously. The output Q is for \nexactly one cycle TRUE when the ramp starts at the output OUT. The input \nAM and OS set the amplitude and the ofset for the output OUT. If the \ninputs OS and AM are not connected the default values are 0 and 1. The \noutput OUT then generates a sawtooth signal of 0 .. 1. The input DL can \nmove the output up to a period (PT) and is used to produce multiple \nshifted signals to each other. A 0 at the input DL means no displacement. \nA value between 0 and 1 shifts the signal by up to a period. \nThe following example shows a trace recording of the input values PT =\n10s, AM = 1 and OS = 0", "type": "FUNCTION", "name": "CEIL2", "input": [{"name": "X", "type": "REAL", "description": "The real number input for which the ceiling needs to be computed."}], "output": [{"name": "CEIL2", "type": "DINT", "description": "The computed ceiling value of the input real number, represented as an integer."}], "in/out": [], "return_value": {"type": "DINT", "description": "Returns the ceiling of the input real number as an integer."}}
{"title": "Character Name Generation", "description": "CHARNAME determines the character name for a character code.", "type": "FUNCTION", "name": "CHARNAME", "input": [{"name": "C", "type": "BYTE", "description": "A BYTE value used to determine the character name."}], "output": [{"name": "CHARNAME", "type": "string", "description": "The resulting character name string constructed from the input BYTE."}], "in/out": [], "return_value": {"type": "string", "description": "The character name generated from the BYTE input."}}
{"title": "CYCLE_4 Function Block", "description": "CHARNAME determines the character name for a character code.", "type": "FUNCTION_BLOCK", "name": "CYCLE_4", "input": [{"name": "E", "type": "BOOL", "description": "Enable flag that allows the state machine to operate."}, {"name": "T0", "type": "TIME", "description": "Duration for waiting in state 0."}, {"name": "T1", "type": "TIME", "description": "Duration for waiting in state 1."}, {"name": "T2", "type": "TIME", "description": "Duration for waiting in state 2."}, {"name": "T3", "type": "TIME", "description": "Duration for waiting in state 3."}, {"name": "S0", "type": "BOOL", "description": "Control signal to reset the state machine to state 0."}, {"name": "SX", "type": "INT", "description": "Input for directly controlling the state when greater than 0."}, {"name": "SL", "type": "BOOL", "description": "Status flag to indicate that the state should be forced based on SX."}], "output": [{"name": "STATE", "type": "INT", "description": "Current state of the state machine."}], "in/out": [], "return_value": null}
{"title": "Calculate Greatest Common Divisor (GCD)", "description": "GCD function calculates the greatest common divisor (GCD) of A and\nB.", "type": "FUNCTION", "name": "GCD", "input": [{"name": "A", "type": "DINT", "description": "The first integer for which the GCD is to be calculated."}, {"name": "B", "type": "DINT", "description": "The second integer for which the GCD is to be calculated."}], "output": [{"name": "GCD", "type": "INT", "description": "The greatest common divisor of A and B."}], "in/out": [], "return_value": {"type": "INT", "description": "The calculated GCD value that is returned by the function."}}
{"title": "Complex Hyperbolic Cotangent Function", "description": "CTANH calculates the hyperbolic tangent of a complex number\n 8. Arithmetics with Double Precision", "type": "FUNCTION", "name": "CTANH", "input": [{"name": "X", "type": "complex", "description": "A complex number for which the hyperbolic cotangent is to be calculated."}], "output": [{"name": "CTANH", "type": "complex", "description": "The complex hyperbolic cotangent of the input complex number X.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the complex hyperbolic cotangent."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the complex hyperbolic cotangent."}]}], "in/out": [], "return_value": {"type": "complex", "description": "Returns the result of the complex hyperbolic cotangent as a complex number.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the resulting complex number."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the resulting complex number."}]}}
{"title": "Buffer Clear Function", "description": "_BUFFER_CLEAR initialize any array of Byte with 0. When cal￾led, a pointer to the array and its size in bytes is passed to the function.\nUnder CoDeSys is the call: _BUFFER_CLEAR(ADR(Array), SIZEOF(Array)),\nwhere array is the name of the array to be manipulated. ADR() is a stan￾dard function which identifes the pointer to the array and SIZEOF() is a\nstandard function, which determines the size of the array. The function\nonly returns TRUE. The array specifed by the pointer is manipulated di￾rectly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "_BUFFER_CLEAR", "input": [{"name": "PT", "type": "POINTER TO BYTE", "description": "A pointer indicating the start of the buffer to be cleared."}, {"name": "SIZE", "type": "UINT", "description": "The size of the buffer in bytes that needs to be cleared."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the buffer was successfully cleared.", "fields": []}}
{"title": "Find Control Character in String", "description": "FIND_CTRL searches the string str starting at position POS and returns the\nposition at which the next control character is. Control characters are all\ncharacters whose value is less than 32 or 127.", "type": "FUNCTION", "name": "FIND_CTRL", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The string in which to search for control characters."}, {"name": "pos", "type": "INT", "description": "The position in the string from which to start the search."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The position of the first control character found in the string. Returns 0 if no control character is found."}}
{"title": "Vector Dot Product Calculation", "description": "FIND_CTRL searches the string str starting at position POS and returns the\nposition at which the next control character is. Control characters are all\ncharacters whose value is less than 32 or 127.", "type": "FUNCTION", "name": "V3_DPRO", "input": [{"name": "A", "type": "Vector_3", "description": "The first 3-dimensional vector used in the dot product calculation."}, {"name": "B", "type": "Vector_3", "description": "The second 3-dimensional vector used in the dot product calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The resulting dot product of vectors A and B."}}
{"title": "4-channel Driver Function Block", "description": "FIND_CTRL searches the string str starting at position POS and returns the\nposition at which the next control character is. Control characters are all\ncharacters whose value is less than 32 or 127.", "type": "FUNCTION_BLOCK", "name": "DRIVER_4C", "input": [{"name": "IN", "type": "BOOL", "description": "Input signal indicating a trigger event."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to reset the counter."}, {"name": "Timeout", "type": "TIME", "description": "Timeout duration for automatic reset of the output when active."}, {"name": "SX", "type": "ARRAY[1..7] OF BYTE", "description": "An array of byte values used to generate output signals, initialized with specific values."}], "output": [{"name": "SN", "type": "INT", "description": "Current count of the input edges."}, {"name": "Q0", "type": "BOOL", "description": "Output signal corresponding to the first channel."}, {"name": "Q1", "type": "BOOL", "description": "Output signal corresponding to the second channel."}, {"name": "Q2", "type": "BOOL", "description": "Output signal corresponding to the third channel."}, {"name": "Q3", "type": "BOOL", "description": "Output signal corresponding to the fourth channel."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "Sequential Control Block for Multiple Inputs", "description": "FIND_CTRL searches the string str starting at position POS and returns the\nposition at which the next control character is. Control characters are all\ncharacters whose value is less than 32 or 127.", "type": "FUNCTION_BLOCK", "name": "SEQUENCE_4", "input": [{"name": "in0", "type": "BOOL", "description": "Boolean input control for step 0."}, {"name": "in1", "type": "BOOL", "description": "Boolean input control for step 1."}, {"name": "in2", "type": "BOOL", "description": "Boolean input control for step 2."}, {"name": "in3", "type": "BOOL", "description": "Boolean input control for step 3."}, {"name": "start", "type": "BOOL", "description": "Start signal to initiate the sequence."}, {"name": "rst", "type": "BOOL", "description": "Reset signal to reset the sequence and outputs."}, {"name": "wait0", "type": "TIME", "description": "Wait time for step 0."}, {"name": "delay0", "type": "TIME", "description": "Delay time after step 0."}, {"name": "wait1", "type": "TIME", "description": "Wait time for step 1."}, {"name": "delay1", "type": "TIME", "description": "Delay time after step 1."}, {"name": "wait2", "type": "TIME", "description": "Wait time for step 2."}, {"name": "delay2", "type": "TIME", "description": "Delay time after step 2."}, {"name": "wait3", "type": "TIME", "description": "Wait time for step 3."}, {"name": "delay3", "type": "TIME", "description": "Delay time after step 3."}, {"name": "stop_on_error", "type": "BOOL", "description": "Flag to stop the sequence on the first error detected."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output for step 0."}, {"name": "Q1", "type": "BOOL", "description": "Output for step 1."}, {"name": "Q2", "type": "BOOL", "description": "Output for step 2."}, {"name": "Q3", "type": "BOOL", "description": "Output for step 3."}, {"name": "QX", "type": "BOOL", "description": "Combined output status indicating active steps."}, {"name": "run", "type": "BOOL", "description": "Indicates whether the sequence is currently running."}, {"name": "step", "type": "INT", "description": "Current step in the sequence, initialized to -1 indicating no active step."}, {"name": "status", "type": "BYTE", "description": "Status of the sequence execution."}], "in/out": [], "return_value": null}
{"title": "Scale B8 Function", "description": "FIND_CTRL searches the string str starting at position POS and returns the\nposition at which the next control character is. Control characters are all\ncharacters whose value is less than 32 or 127.", "type": "FUNCTION", "name": "SCALE_B8", "input": [{"name": "in1", "type": "BYTE", "description": "First input value to be scaled."}, {"name": "in2", "type": "BYTE", "description": "Second input value to be scaled."}, {"name": "in3", "type": "BYTE", "description": "Third input value to be scaled."}, {"name": "in4", "type": "BYTE", "description": "Fourth input value to be scaled."}, {"name": "in5", "type": "BYTE", "description": "Fifth input value to be scaled."}, {"name": "in6", "type": "BYTE", "description": "Sixth input value to be scaled."}, {"name": "in7", "type": "BYTE", "description": "Seventh input value to be scaled."}, {"name": "in8", "type": "BYTE", "description": "Eighth input value to be scaled."}, {"name": "K", "type": "REAL", "description": "Scaling factor applied to the normalized sum."}, {"name": "O", "type": "REAL", "description": "Offset added to the scaled result."}, {"name": "in1_min", "type": "REAL", "description": "Minimum value for the first input."}, {"name": "in1_max", "type": "REAL", "description": "Maximum value for the first input. Defaults to 1000.0.", "fields": []}, {"name": "in2_min", "type": "REAL", "description": "Minimum value for the second input."}, {"name": "in2_max", "type": "REAL", "description": "Maximum value for the second input. Defaults to 1000.0.", "fields": []}, {"name": "in3_min", "type": "REAL", "description": "Minimum value for the third input."}, {"name": "in3_max", "type": "REAL", "description": "Maximum value for the third input. Defaults to 1000.0.", "fields": []}, {"name": "in4_min", "type": "REAL", "description": "Minimum value for the fourth input."}, {"name": "in4_max", "type": "REAL", "description": "Maximum value for the fourth input. Defaults to 1000.0.", "fields": []}, {"name": "in5_min", "type": "REAL", "description": "Minimum value for the fifth input."}, {"name": "in5_max", "type": "REAL", "description": "Maximum value for the fifth input. Defaults to 1000.0.", "fields": []}, {"name": "in6_min", "type": "REAL", "description": "Minimum value for the sixth input."}, {"name": "in6_max", "type": "REAL", "description": "Maximum value for the sixth input. Defaults to 1000.0.", "fields": []}, {"name": "in7_min", "type": "REAL", "description": "Minimum value for the seventh input."}, {"name": "in7_max", "type": "REAL", "description": "Maximum value for the seventh input. Defaults to 1000.0.", "fields": []}, {"name": "in8_min", "type": "REAL", "description": "Minimum value for the eighth input."}, {"name": "in8_max", "type": "REAL", "description": "Maximum value for the eighth input. Defaults to 1000.0.", "fields": []}], "output": [{"name": "SCALE_B8", "type": "REAL", "description": "The scaled output value resulting from the scaling operation."}], "in/out": [], "return_value": {"type": "REAL", "description": "The resulting scaled value after applying the function's calculations."}}
{"title": "Check if Array is Sorted", "description": "IS_SORTED checks whether any array of REAL is sorted in\nascending order. When called, a pointer to the array and its size in bytes is\ntransferred to the function. Under CoDeSys the call is:\n_ARRAY_SORT(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array.\nThe function returns TRUE if the array is sorted in ascending order.\nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "IS_SORTED", "input": [{"name": "pt", "type": "pointer to ARRAY[0..32000] of REAL", "description": "A pointer to an array containing REAL numbers."}, {"name": "size", "type": "UINT", "description": "The size of the array, specifying the number of elements in the pointer array."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the array is sorted in ascending order, otherwise returns FALSE."}}
{"title": "Count Set Bits in a DWORD", "description": "BIT_COUNT determines the number of bits in IN, which have the value\nTRUE (1). The input IN is DWORD and can also process the types Byte and\nWord.", "type": "FUNCTION", "name": "BIT_COUNT", "input": [{"name": "IN", "type": "DWORD", "description": "A DWORD value for which the set bits are to be counted."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The total count of set bits (1s) in the input DWORD.", "fields": []}}
{"title": "Byte to Bits Conversion", "description": "BYTE_TO_BITS split a byte (IN) into its individual bits (B0 .. B7). The input\nIN is defned as a DWORD to handle either byte, word, or DWORD at the\ninput. If a Word or DWORD used at the input, only the bits 0th .7 are pro￾cessed. A DWORD can then, using the default command SHR , be shifted\nby 8 bits to the right and then the next byte can be processed.", "type": "FUNCTION_BLOCK", "name": "BYTE_TO_BITS", "input": [{"name": "IN", "type": "BYTE", "description": "A single BYTE input that will be converted to individual bits."}], "output": [{"name": "B0", "type": "BOOL", "description": "Output representing the least significant bit (bit 0) of the input BYTE."}, {"name": "B1", "type": "BOOL", "description": "Output representing the second least significant bit (bit 1) of the input BYTE."}, {"name": "B2", "type": "BOOL", "description": "Output representing the third least significant bit (bit 2) of the input BYTE."}, {"name": "B3", "type": "BOOL", "description": "Output representing the fourth least significant bit (bit 3) of the input BYTE."}, {"name": "B4", "type": "BOOL", "description": "Output representing the fifth least significant bit (bit 4) of the input BYTE."}, {"name": "B5", "type": "BOOL", "description": "Output representing the sixth least significant bit (bit 5) of the input BYTE."}, {"name": "B6", "type": "BOOL", "description": "Output representing the seventh least significant bit (bit 6) of the input BYTE."}, {"name": "B7", "type": "BOOL", "description": "Output representing the most significant bit (bit 7) of the input BYTE."}], "in/out": [], "return_value": null}
{"title": "Error Function Calculation", "description": "ERF function calculates the error function of X. The error function is\ncalculated using an approximation formula, the maximum relative error is\nsmaller than 1,3 * 10-4 \n.", "type": "FUNCTION", "name": "ERF", "input": [{"name": "X", "type": "REAL", "description": "A real number input for which the error function is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated value of the error function for the input X."}}
{"title": "Timer Counting using System Timer", "description": "TC_US determines the last cycle time, that is the time since the last call of\nthe module has passed. The time comes in milliseconds. The module calls\nthe function T_PLC_US(). T_PLC_US () returns the internal PLC Timer in mi￾croseconds with a step width of 1000 microseconds. If a higher resolution\nis required the function T_PLC_US() has to be adjusted to the appropriate\nsystem. \n 22. Calculations", "type": "FUNCTION_BLOCK", "name": "TC_US", "input": [], "output": [{"name": "TC", "type": "DWORD", "description": "The elapsed time in microseconds since the last update."}], "in/out": [], "return_value": null}
{"title": "Offset Calculation Function", "description": "OFFSET addes diferent ofsets to an input signal depending on \nthe binary value of O1.. O4. The ofsets can be added individually or \nsimultaneously. With the input D a Default value instead of the input X can \nbe switched to the adder. The ofset and Default value be defned through \nthe setup variables.\nThe following example illustrates the operation of ofset:", "type": "FUNCTION", "name": "OFFSET", "input": [{"name": "X", "type": "REAL", "description": "The initial value to which offsets may be applied."}, {"name": "O1", "type": "BOOL", "description": "A boolean indicating whether to add 'Offset_1' to the result."}, {"name": "O2", "type": "BOOL", "description": "A boolean indicating whether to add 'Offset_2' to the result."}, {"name": "O3", "type": "BOOL", "description": "A boolean indicating whether to add 'Offset_3' to the result."}, {"name": "O4", "type": "BOOL", "description": "A boolean indicating whether to add 'Offset_4' to the result."}, {"name": "D", "type": "BOOL", "description": "A boolean flag that, if true, will cause the function to return the 'default' value instead of the calculated offset value."}, {"name": "Offset_1", "type": "REAL", "description": "The offset value to add if 'O1' is true."}, {"name": "Offset_2", "type": "REAL", "description": "The offset value to add if 'O2' is true."}, {"name": "Offset_3", "type": "REAL", "description": "The offset value to add if 'O3' is true."}, {"name": "Offset_4", "type": "REAL", "description": "The offset value to add if 'O4' is true."}, {"name": "default", "type": "REAL", "description": "The default value that will be returned if 'D' is true."}], "output": [{"name": "OFFSET", "type": "REAL", "description": "The resulting offset value after applying the initial value and any additional offsets, or the default value if 'D' is true."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the final offset value calculated based on the specified conditions."}}
{"title": "Array Average Calculation", "description": "ARRAY_AVG calculates the median value of an arbitrary ar￾ray ofREAL. When called, a pointer to the array and its size in bytes is pas￾sed to the function. Under CoDeSys the call reads:\nARRAY_AVG(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the maximum, the array refe￾renced by the pointer is scanned directly in memory. The function\nARRAY_AVG does not change the content of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_AVG", "input": [{"name": "pt", "type": "POINTER TO ARRAY [0..32000] OF REAL", "description": "A pointer to the array of REAL numbers for which the average is to be calculated."}, {"name": "size", "type": "UINT", "description": "The number of elements in the array indicated by the pointer."}], "output": [{"name": "ARRAY_AVG", "type": "REAL", "description": "The computed average of the REAL numbers in the array."}], "in/out": [], "return_value": {"type": "REAL", "description": "The average value of the elements in the array.", "fields": []}}
{"title": "PID Controller with Derivative Action", "description": "FT_PIDWL is a PID controller with dynamic Wind- Up reset and works accor￾ding to the following formula: \nY = KP * ( IN + 1/TN * INTEG(IN) + TV *DERIV(IN))\nThe control parameters are given in the form of KP, TN and TV, and if the￾re are parameters KP, KI and KD they can be converted using the following\nformula:\nTN = KP/KI und TV = KD/KP\nThe input values LIM_H and LIM_L limit the range of the output Y. With\nRST, the internal Integrator can always be set to 0. The output LIM indica￾tes that the Output Y runs to one of the limits LIM_L orL IM_H. The PI con￾troller is free running and uses the trapezoidal rule to calculate the inte￾grator for the highest accuracy and optimal speed. The default values of\nthe input parameters are predefned as follows: KP = 1, TN = 1s, TV = 1s,\nILIM_L =-1E38 and ILIM_H = +1 E38.\nAnti Wind-Up: Control modules with Integrator tend to the so-called Wind￾Up Efect. A Wind-Up means that the integrator module continuously run\nagain because, for example, the control signal Y is at a limit and the sys￾tem can not compensate the deviation, which then leads to subsequent\ntransition into the control range until a long and time-consuming dismant￾ling of the integrator value and the scheme only respond delayed. Since\nthe integrator is only necessary to compensate the deviation for all other\ncontrol units, and the range of the integrator should be limited with the\nvalues of ILIM.\nThe module FT_PIW has a so-called dynamic-wind Up Reset which resets\nreaching a limit (LIM_L, LIM_H) the the Integrator to a value corresponding\nof the output limit. After reaching a Limits the controller re-enters the work\narea must the Integrator are not frst or Down-integrated, and the control￾ler is ready for use without delay. The dynamic Anti-Wind Up Method is\nthat in most cases without drawbacks preferred method, because it does\nnot negatively afect the control and prevents the disadvantages of\nWind_Up . \nThe following graph illustrates the internal structure of the controller:\nFT_PD can be used in conjunction with the modules CTRL_IN and\nCTRL_OUT to establish a PD controller.", "type": "FUNCTION_BLOCK", "name": "FT_PIDWL", "input": [{"name": "IN", "type": "REAL", "description": "The input value to the PID controller."}, {"name": "KP", "type": "REAL", "description": "The proportional gain, default value is 1.0."}, {"name": "TN", "type": "REAL", "description": "The time constant for the integral term, default value is 1.0."}, {"name": "TV", "type": "REAL", "description": "The time constant for the derivative term, default value is 1.0."}, {"name": "LIM_L", "type": "REAL", "description": "Lower limit for the output, default value is -1E+38."}, {"name": "LIM_H", "type": "REAL", "description": "Upper limit for the output, default value is 1E+38."}, {"name": "RST", "type": "BOOL", "description": "Boolean flag to reset the controller state."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value of the PID controller after processing."}, {"name": "LIM", "type": "BOOL", "description": "Indicates whether the output has been limited."}], "in/out": [], "return_value": null}
{"title": "Moving Average Filter", "description": "FILTER_MAV_DW is a flter with moving average. The flter with moving\naverage (also Moving Average Filter called) the average of N successive\nreadings is output as an average. \nY:= (X0 + X1 + … + Xn-1) / N\nX0 is the value of X in the current cycle, X1 is the value in the previous cy￾cle, etc. The number of values over which the average has to be calcula￾ted is specifed at the input N. The range of values of N is between 1 and\n32", "type": "FUNCTION_BLOCK", "name": "FILTER_MAV_DW", "input": [{"name": "X", "type": "DWORD", "description": "The input data value to be filtered."}, {"name": "N", "type": "UINT", "description": "The number of samples to consider for the moving average. It is limited to a maximum of 32."}, {"name": "RST", "type": "BOOL", "description": "A reset signal that, when TRUE, reinitializes the buffer and the output."}], "output": [{"name": "Y", "type": "DWORD", "description": "The output value representing the current moving average."}], "in/out": [], "return_value": null}
{"title": "Calculate RES_NI for temperature and resistance", "description": "RES_NI calculated the resistance of a NI-resistance sensor from the input\nvalues T (temperature in°C) and R0 (resistance at 0°C).\nThe calculation is done using the formula:\nRES_NI = R0 + A*T + B*T²+C*T4\nA = 0.5485\nB = 0.665E-3\nC = 2.805E-9\nThe calculation is suitable for temperatures from -60.. +180 °C.", "type": "FUNCTION", "name": "RES_NI", "input": [{"name": "T", "type": "REAL", "description": "The input temperature in degrees Celsius at which the resistance is calculated."}, {"name": "R0", "type": "REAL", "description": "The reference resistance at 0°C."}], "output": [{"name": "RES_NI", "type": "REAL", "description": "The calculated resistance value based on the input temperature and reference resistance."}], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated resistance value (RES_NI) returned from the function."}}
{"title": "Control Set Parameters for PID and PI Controllers", "description": "RES_NI calculated the resistance of a NI-resistance sensor from the input\nvalues T (temperature in°C) and R0 (resistance at 0°C).\nThe calculation is done using the formula:\nRES_NI = R0 + A*T + B*T²+C*T4\nA = 0.5485\nB = 0.665E-3\nC = 2.805E-9\nThe calculation is suitable for temperatures from -60.. +180 °C.", "type": "FUNCTION_BLOCK", "name": "CONTROL_SET2", "input": [{"name": "KS", "type": "REAL", "description": "Gain factor for the system."}, {"name": "TU", "type": "REAL", "description": "Time constant for the system."}, {"name": "TG", "type": "REAL", "description": "Transport delay time."}, {"name": "PI", "type": "BOOL", "description": "Flag to indicate if PI control is to be used."}, {"name": "PID", "type": "BOOL", "description": "Flag to indicate if PID control is to be used."}, {"name": "P_K", "type": "REAL", "description": "Proportional gain for the PI controller, default is 1.0."}, {"name": "PI_K", "type": "REAL", "description": "Proportional gain for the PID controller, default is 0.9."}, {"name": "PI_TN", "type": "REAL", "description": "Integral time for the PI controller, default is 3.33."}, {"name": "PID_K", "type": "REAL", "description": "Proportional gain for the PI controller, default is 1.2."}, {"name": "PID_TN", "type": "REAL", "description": "Integral time for the PID controller, default is 2.0."}, {"name": "PID_TV", "type": "REAL", "description": "Derivative time for the PID controller, default is 0.5."}], "output": [{"name": "KP", "type": "REAL", "description": "Calculated proportional gain."}, {"name": "TN", "type": "REAL", "description": "Calculated integral time."}, {"name": "TV", "type": "REAL", "description": "Calculated derivative time."}, {"name": "KI", "type": "REAL", "description": "Calculated integral gain."}, {"name": "KD", "type": "REAL", "description": "Calculated derivative gain."}], "in/out": [], "return_value": null}
{"title": "32-Element Stack Function Block", "description": "RES_NI calculated the resistance of a NI-resistance sensor from the input\nvalues T (temperature in°C) and R0 (resistance at 0°C).\nThe calculation is done using the formula:\nRES_NI = R0 + A*T + B*T²+C*T4\nA = 0.5485\nB = 0.665E-3\nC = 2.805E-9\nThe calculation is suitable for temperatures from -60.. +180 °C.", "type": "FUNCTION_BLOCK", "name": "STACK_32", "input": [{"name": "Din", "type": "DWORD", "description": "The data value to be written to the stack."}, {"name": "E", "type": "BOOL", "description": "Enable signal that allows the operation of the stack. If FALSE, the stack does not process read/write requests."}, {"name": "RD", "type": "BOOL", "description": "Read request signal. When TRUE, an element will be read from the stack if it is not empty."}, {"name": "WD", "type": "BOOL", "description": "Write request signal. When TRUE, the value of Din will be written to the stack if it is not full."}, {"name": "RST", "type": "BOOL", "description": "Asynchronous reset signal. When TRUE, it resets the stack to its initial state."}], "output": [{"name": "Dout", "type": "DWORD", "description": "The data value that has been read from the stack when RD is TRUE."}, {"name": "EMPTY", "type": "BOOL", "description": "Indicates whether the stack is empty. TRUE if it is empty, FALSE otherwise."}, {"name": "FULL", "type": "BOOL", "description": "Indicates whether the stack is full. TRUE if it is full, FALSE otherwise."}], "in/out": [], "return_value": null}
{"title": "Year of Date Calculation", "description": "YEAR_OF_DATE calculates the corresponding year from the\ndate of input IDATE.", "type": "FUNCTION", "name": "YEAR_OF_DATE", "input": [{"name": "IDATE", "type": "DATE", "description": "The input date from which the year is to be extracted."}], "output": [{"name": "year", "type": "INT", "description": "The calculated year derived from the input date."}], "in/out": [], "return_value": {"type": "INT", "description": "The function returns the year as an integer.", "fields": []}}
{"title": "Hyperbolic Complex Inverse Sine Function", "description": "CASINH calculates the arc hyperbolic sine of a complex number\n[fzy] The range of values of the result is between [-  ,+  ] For the imagi￾nary part.", "type": "FUNCTION", "name": "CASINH", "input": [{"name": "X", "type": "complex", "description": "A complex number for which the hyperbolic inverse sine is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The hyperbolic inverse sine of the input complex number.", "fields": [{"name": "re", "type": "real", "description": "The real part of the hyperbolic inverse sine result."}, {"name": "im", "type": "real", "description": "The imaginary part of the hyperbolic inverse sine result."}]}}
{"title": "String to Buffer Conversion", "description": "_STRING_TO_BUFFER copies a string in any array of Byte .\nThe string is stored from any position POS in the bufer. The frst element\nin the array has the position number 0. When called, a pointer to the array\nand its size in bytes is passed to the function. Under CoDeSys the call\nreads: _STRING_TO_BUFFER(STR, POS, ADR(Array), SIZEOF(Array)), where\narray is the name of the array to be manipulated. ADR() is a standard\nfunction which identifes the pointer to the array and SIZEOF() is a stan￾dard function, which determines the size of the array. The function returns\nthe string copied from the bufer as STRING. The array specifed by the\npointer is manipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "_STRING_TO_BUFFER", "input": [{"name": "STR", "type": "STRING[STRING_LENGTH]", "description": "The input string to be converted to a byte buffer."}, {"name": "POS", "type": "INT", "description": "The starting position in the byte buffer to begin writing the bytes."}, {"name": "PT", "type": "POINTER TO ARRAY[0..32767] OF BYTE", "description": "A pointer to the byte array where the converted bytes are stored."}, {"name": "SIZE", "type": "UINT", "description": "The size of the buffer, which defines the maximum number of bytes that can be written."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The position in the byte buffer after the last byte written from the input string."}}
{"title": "Calculate Harmonic Average of an Array", "description": "ARRAY_HAV calculates the harmonic median value of an ar￾bitrary array of REAL. When called, a pointer to the array and its size in\nbytes is passed to the function. Under CoDeSys the call reads:\nARRAY_HAV(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the maximum, the array refe￾renced by the pointer is scanned directly in memory. The function\nARRAY_HAV does not change the content of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_HAV", "input": [{"name": "pt", "type": "POINTER TO ARRAY [0..32000] OF REAL", "description": "Pointer to the array of real numbers for which the harmonic average is to be calculated."}, {"name": "size", "type": "UINT", "description": "The size of the array, indicating the number of elements to consider for the calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The harmonic average of the array elements.", "fields": []}}
{"title": "Convert MS to BFT", "description": "MS_TO_BFT converts wind speeds of meters per second in the Beaufort\nscale.\nThe calculation is done using the formula:\nMS_TO_BFT = (MS * 1.196172)^2/3", "type": "FUNCTION", "name": "MS_TO_BFT", "input": [{"name": "MS", "type": "REAL", "description": "The input value in Meteo Standard (MS) that needs to be converted to Beaufort scale."}], "output": [{"name": "BFT", "type": "INT", "description": "The resulting integer value in the Beaufort scale corresponding to the input MS value."}], "in/out": [], "return_value": {"type": "INT", "description": "The integer result of the conversion from MS to BFT.", "fields": []}}
{"title": "Reflect Function", "description": "REFLECT reverses the order specifed by the number of L BitsBits in a\nDWORD. The most signifcant bits than specifed by the length L remain\nunchanged.", "type": "FUNCTION", "name": "REFLECT", "input": [{"name": "D", "type": "DWORD", "description": "The DWORD value to be reflected."}, {"name": "L", "type": "INT", "description": "The length defining how many bits to reflect from the DWORD value."}], "output": [{"name": "REFLECT", "type": "DWORD", "description": "The resulting DWORD value after the reflection operation."}], "in/out": [], "return_value": {"type": "DWORD", "description": "The resulting DWORD value from the reflection process."}}
{"title": "Get Hour from TIME_OF_DAY", "description": "HOUR function extracts the current hour of the day.", "type": "FUNCTION", "name": "HOUR", "input": [{"name": "itod", "type": "TIME_OF_DAY", "description": "The input variable representing the time of day from which the hour will be extracted."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The hour value extracted from the input TIME_OF_DAY, represented as an integer."}}
{"title": "DCF77 Time Receiver Function Block", "description": "HOUR function extracts the current hour of the day.", "type": "FUNCTION_BLOCK", "name": "DCF77", "input": [{"name": "REC", "type": "BOOL", "description": "Reception signal indicating whether a DCF77 signal is currently being received."}, {"name": "SET", "type": "BOOL", "description": "Trigger signal to set the RTC with the received time information."}, {"name": "SDT", "type": "DT", "description": "Initial date and time to set the RTC on first power up."}, {"name": "DSI", "type": "BOOL", "description": "Daylight Saving Time indication to control DST adjustments."}, {"name": "SYNC_TIMEOUT", "type": "TIME", "description": "Timeout duration to determine the validity of the synchronization signal.", "fields": []}, {"name": "TIME_OFFSET", "type": "INT", "description": "Offset for time zone adjustments relative to UTC.", "fields": []}, {"name": "DST_EN", "type": "BOOL", "description": "Enable signal for daylight saving time adjustments.", "fields": []}], "output": [{"name": "TP", "type": "BOOL", "description": "Trigger output that indicates whether the time processing is active."}, {"name": "DS", "type": "BOOL", "description": "Output signal indicating whether daylight saving time is currently active."}, {"name": "WDAY", "type": "INT", "description": "Output representing the day of the week as an integer."}, {"name": "ERROR", "type": "BOOL", "description": "Error flag indicating if an error occurred during the decoding process."}, {"name": "RTC", "type": "DT", "description": "Real-time clock output that reflects the current date and time based on the DCF77 signal."}, {"name": "RTC1", "type": "DT", "description": "Secondary RTC output, adjusted based on time zone and daylight saving time settings."}, {"name": "MSEC", "type": "INT", "description": "Milliseconds elapsed since the last synchronization."}, {"name": "SYNC", "type": "BOOL", "description": "Signal indicating successful synchronization with the DCF77 signal."}], "in/out": [], "return_value": {}}
{"title": "Convert Month Integer to String Representation", "description": "MONTH_TO_STRING convert a month number to its equivalent string. The\ninput MTH passes the month: 1 =January, 12 = December. The input LANG\nchooses the language: 1 = English and 2 = German. LANG = 0 used as\nDefault the language specifed in the Global Setup variable\nLANGUAGE_DEFAULT. The input LX sets the length of the string to be gene￾rated: 0 = full month name, 3 = 3-letter abbreviation, all other values at\nthe input LX are undefned. \nThe strings produced by the module, and the supported languages are de￾fned in the Global Constants and can be expanded and changed. \nMONTH_TO_STRING(1,0,0) = 'January'\ndependent on the global constant LANGUAGE_DEFAULT\nMONTH_TO_STRING(1,2,0) = 'Januar'\nMONTH_TO_STRING(1,2,3) = 'Jan'", "type": "FUNCTION", "name": "MONTH_TO_STRING", "input": [{"name": "MTH", "type": "INT", "description": "The month integer to convert, should be between 1 and 12."}, {"name": "LANG", "type": "INT", "description": "An integer representing the language setting for the month name. A value less than or equal to 0 indicates the default language."}, {"name": "LX", "type": "INT", "description": "An integer indicating the format of the month name. 0 for the default length, 3 for a three-letter abbreviation."}], "output": [{"name": "MONTH_TO_STRING", "type": "string", "description": "The string representation of the month in the specified language and format."}], "in/out": [], "return_value": {"type": "string", "description": "The output month name as a string.", "fields": []}}
{"title": "Calculate the Hypotenuse", "description": "HYPOT The Mortgage function calculates the hypotenuse of a right triangle, by\nthe theorem of Pythagoras.", "type": "FUNCTION", "name": "HYPOT", "input": [{"name": "X", "type": "REAL", "description": "The length of one side of the right triangle."}, {"name": "Y", "type": "REAL", "description": "The length of the other side of the right triangle."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated length of the hypotenuse."}}
{"title": "Time Calculation Function Block", "description": "TC_S determines the last cycle time, that is the time since the last call of\nthe module has passed. The time will be delivered in seconds, but has an\naccuracy in microseconds. The module calls the function T_PLC_US().\nT_PLC_US () returns the internal PLC Timer in microseconds with a step\nwidth of 1000 microseconds. If a higher resolution is required the function\nT_PLC_US() has to be adjusted to the appropriate system.", "type": "FUNCTION_BLOCK", "name": "TC_S", "input": [], "output": [{"name": "TC", "type": "REAL", "description": "The elapsed time in seconds since the last invocation of the block."}], "in/out": [], "return_value": null}
{"title": "Scale Function Implementation", "description": "TC_S determines the last cycle time, that is the time since the last call of\nthe module has passed. The time will be delivered in seconds, but has an\naccuracy in microseconds. The module calls the function T_PLC_US().\nT_PLC_US () returns the internal PLC Timer in microseconds with a step\nwidth of 1000 microseconds. If a higher resolution is required the function\nT_PLC_US() has to be adjusted to the appropriate system.", "type": "FUNCTION", "name": "SCALE_B4", "input": [{"name": "in1", "type": "BYTE", "description": "First input value to be scaled."}, {"name": "in2", "type": "BYTE", "description": "Second input value to be scaled."}, {"name": "in3", "type": "BYTE", "description": "Third input value to be scaled."}, {"name": "in4", "type": "BYTE", "description": "Fourth input value to be scaled."}, {"name": "K", "type": "REAL", "description": "Scaling factor to adjust the output."}, {"name": "O", "type": "REAL", "description": "Offset value added to the final result."}, {"name": "in1_min", "type": "REAL", "description": "Minimum value for the first input."}, {"name": "in1_max", "type": "REAL", "description": "Maximum value for the first input. Defaults to 1000.0."}, {"name": "in2_min", "type": "REAL", "description": "Minimum value for the second input."}, {"name": "in2_max", "type": "REAL", "description": "Maximum value for the second input. Defaults to 1000.0."}, {"name": "in3_min", "type": "REAL", "description": "Minimum value for the third input."}, {"name": "in3_max", "type": "REAL", "description": "Maximum value for the third input. Defaults to 1000.0."}, {"name": "in4_min", "type": "REAL", "description": "Minimum value for the fourth input."}, {"name": "in4_max", "type": "REAL", "description": "Maximum value for the fourth input. Defaults to 1000.0."}], "output": [{"name": "SCALE_B4", "type": "REAL", "description": "The scaled output value based on the provided inputs, minimums, maximums, scaling factor, and offset."}], "in/out": [], "return_value": {"type": "REAL", "description": "The final scaled and offset output value.", "fields": []}}
{"title": "Convert Meters per Second to Kilometers per Hour", "description": "MS_TO_KMH calculates a speed value of meters/second to kilometers/hour \nto.\nMS_TO_KMH := MS * 3.6", "type": "FUNCTION", "name": "MS_TO_KMH", "input": [{"name": "ms", "type": "REAL", "description": "The velocity in meters per second."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The converted velocity in kilometers per hour."}}
{"title": "Convert Degrees to Direction", "description": "DEG_TO_DIR calculates a direction (0 .360 degrees) into to compass rea￾dings. At the input DEG the direction in degrees is available (0 = North, 90\n= East, 180 = South and 270 = West ). The output represents the directi￾on as String NNE. With the input N the maximum length of the direction in￾dication is limited. When N = 1, only in the 4 cardinal directions N, E, S, W\ndissolved. If N = 2 between each another direction is inserted: NE, SE, SW,\nNW. At N = 3 are also directions as NNO ... are dissolved, with N = 3 a to￾tal of 16 directions are evaluated. The input L allows the switching of the\nlanguages defned in the language setup. 0L = 0 means Default Langua￾ge, a number > 0 is one of the predefned languages. more info about the\npre-defned data types can be found at CONSTANTS_LANGUAGE.", "type": "FUNCTION", "name": "DEG_TO_DIR", "input": [{"name": "DEG", "type": "INT", "description": "The degree input to be converted to a direction."}, {"name": "N", "type": "INT", "description": "An additional input variable that influences the calculation of the direction."}, {"name": "L", "type": "INT", "description": "Length input that determines the language used for direction output."}], "output": [{"name": "DEG_TO_DIR", "type": "string", "description": "The resulting string that represents the direction based on the degree input."}], "in/out": [], "return_value": {"type": "string", "description": "Returns the direction corresponding to the given degree input."}}
{"title": "Vector Parallelism Check", "description": "DEG_TO_DIR calculates a direction (0 .360 degrees) into to compass rea￾dings. At the input DEG the direction in degrees is available (0 = North, 90\n= East, 180 = South and 270 = West ). The output represents the directi￾on as String NNE. With the input N the maximum length of the direction in￾dication is limited. When N = 1, only in the 4 cardinal directions N, E, S, W\ndissolved. If N = 2 between each another direction is inserted: NE, SE, SW,\nNW. At N = 3 are also directions as NNO ... are dissolved, with N = 3 a to￾tal of 16 directions are evaluated. The input L allows the switching of the\nlanguages defned in the language setup. 0L = 0 means Default Langua￾ge, a number > 0 is one of the predefned languages. more info about the\npre-defned data types can be found at CONSTANTS_LANGUAGE.", "type": "FUNCTION", "name": "V3_PAR", "input": [{"name": "A", "type": "Vector_3", "description": "The first 3-dimensional vector to check for parallelism."}, {"name": "B", "type": "Vector_3", "description": "The second 3-dimensional vector to check for parallelism."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the vectors A and B are parallel, otherwise returns FALSE."}}
{"title": "Calculate the Arctangent of Two Variables", "description": "DEG_TO_DIR calculates a direction (0 .360 degrees) into to compass rea￾dings. At the input DEG the direction in degrees is available (0 = North, 90\n= East, 180 = South and 270 = West ). The output represents the directi￾on as String NNE. With the input N the maximum length of the direction in￾dication is limited. When N = 1, only in the 4 cardinal directions N, E, S, W\ndissolved. If N = 2 between each another direction is inserted: NE, SE, SW,\nNW. At N = 3 are also directions as NNO ... are dissolved, with N = 3 a to￾tal of 16 directions are evaluated. The input L allows the switching of the\nlanguages defned in the language setup. 0L = 0 means Default Langua￾ge, a number > 0 is one of the predefned languages. more info about the\npre-defned data types can be found at CONSTANTS_LANGUAGE.", "type": "FUNCTION", "name": "ATAN2", "input": [{"name": "Y", "type": "REAL", "description": "The Y-coordinate used to calculate the arctangent."}, {"name": "X", "type": "REAL", "description": "The X-coordinate used to calculate the arctangent."}], "output": [{"name": "ATAN2", "type": "REAL", "description": "The resulting angle in radians based on the input coordinates Y and X."}], "in/out": [], "return_value": {"type": "REAL", "description": "The angle in radians computed from the given Y and X coordinates."}}
{"title": "Offset Calculation Function", "description": "DEG_TO_DIR calculates a direction (0 .360 degrees) into to compass rea￾dings. At the input DEG the direction in degrees is available (0 = North, 90\n= East, 180 = South and 270 = West ). The output represents the directi￾on as String NNE. With the input N the maximum length of the direction in￾dication is limited. When N = 1, only in the 4 cardinal directions N, E, S, W\ndissolved. If N = 2 between each another direction is inserted: NE, SE, SW,\nNW. At N = 3 are also directions as NNO ... are dissolved, with N = 3 a to￾tal of 16 directions are evaluated. The input L allows the switching of the\nlanguages defned in the language setup. 0L = 0 means Default Langua￾ge, a number > 0 is one of the predefned languages. more info about the\npre-defned data types can be found at CONSTANTS_LANGUAGE.", "type": "FUNCTION", "name": "OFFSET2", "input": [{"name": "X", "type": "REAL", "description": "The primary input value that may receive an offset."}, {"name": "O1", "type": "BOOL", "description": "Flag indicating whether to add Offset_1."}, {"name": "O2", "type": "BOOL", "description": "Flag indicating whether to add Offset_2."}, {"name": "O3", "type": "BOOL", "description": "Flag indicating whether to add Offset_3."}, {"name": "O4", "type": "BOOL", "description": "Flag indicating whether to add Offset_4."}, {"name": "D", "type": "BOOL", "description": "Flag that determines if the default value should be returned instead of the adjusted X."}, {"name": "Offset_1", "type": "REAL", "description": "Value to be added if O1 is true."}, {"name": "Offset_2", "type": "REAL", "description": "Value to be added if O2 is true."}, {"name": "Offset_3", "type": "REAL", "description": "Value to be added if O3 is true."}, {"name": "Offset_4", "type": "REAL", "description": "Value to be added if O4 is true."}, {"name": "default", "type": "REAL", "description": "The default value returned if D is true."}], "output": [{"name": "OFFSET2", "type": "REAL", "description": "The calculated offset value which is either the adjusted X or the default value."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the final computed offset value.", "fields": []}}
{"title": "Scale Input Values with Constants", "description": "DEG_TO_DIR calculates a direction (0 .360 degrees) into to compass rea￾dings. At the input DEG the direction in degrees is available (0 = North, 90\n= East, 180 = South and 270 = West ). The output represents the directi￾on as String NNE. With the input N the maximum length of the direction in￾dication is limited. When N = 1, only in the 4 cardinal directions N, E, S, W\ndissolved. If N = 2 between each another direction is inserted: NE, SE, SW,\nNW. At N = 3 are also directions as NNO ... are dissolved, with N = 3 a to￾tal of 16 directions are evaluated. The input L allows the switching of the\nlanguages defned in the language setup. 0L = 0 means Default Langua￾ge, a number > 0 is one of the predefned languages. more info about the\npre-defned data types can be found at CONSTANTS_LANGUAGE.", "type": "FUNCTION", "name": "SCALE_X8", "input": [{"name": "in1", "type": "BOOL", "description": "The first boolean input that determines whether the first minimum or maximum value is considered."}, {"name": "in2", "type": "BOOL", "description": "The second boolean input that determines whether the second minimum or maximum value is considered."}, {"name": "in3", "type": "BOOL", "description": "The third boolean input that determines whether the third minimum or maximum value is considered."}, {"name": "in4", "type": "BOOL", "description": "The fourth boolean input that determines whether the fourth minimum or maximum value is considered."}, {"name": "in5", "type": "BOOL", "description": "The fifth boolean input that determines whether the fifth minimum or maximum value is considered."}, {"name": "in6", "type": "BOOL", "description": "The sixth boolean input that determines whether the sixth minimum or maximum value is considered."}, {"name": "in7", "type": "BOOL", "description": "The seventh boolean input that determines whether the seventh minimum or maximum value is considered."}, {"name": "in8", "type": "BOOL", "description": "The eighth boolean input that determines whether the eighth minimum or maximum value is considered."}, {"name": "K", "type": "REAL", "description": "The scaling factor to be applied to the sum of the selected minimum and maximum values."}, {"name": "O", "type": "REAL", "description": "The offset to be added to the scaled sum."}, {"name": "in1_min", "type": "REAL", "description": "Minimum value for the first input."}, {"name": "in1_max", "type": "REAL", "description": "Maximum value for the first input, default is 1000.0."}, {"name": "in2_min", "type": "REAL", "description": "Minimum value for the second input."}, {"name": "in2_max", "type": "REAL", "description": "Maximum value for the second input, default is 1000.0."}, {"name": "in3_min", "type": "REAL", "description": "Minimum value for the third input."}, {"name": "in3_max", "type": "REAL", "description": "Maximum value for the third input, default is 1000.0."}, {"name": "in4_min", "type": "REAL", "description": "Minimum value for the fourth input."}, {"name": "in4_max", "type": "REAL", "description": "Maximum value for the fourth input, default is 1000.0."}, {"name": "in5_min", "type": "REAL", "description": "Minimum value for the fifth input."}, {"name": "in5_max", "type": "REAL", "description": "Maximum value for the fifth input, default is 1000.0."}, {"name": "in6_min", "type": "REAL", "description": "Minimum value for the sixth input."}, {"name": "in6_max", "type": "REAL", "description": "Maximum value for the sixth input, default is 1000.0."}, {"name": "in7_min", "type": "REAL", "description": "Minimum value for the seventh input."}, {"name": "in7_max", "type": "REAL", "description": "Maximum value for the seventh input, default is 1000.0."}, {"name": "in8_min", "type": "REAL", "description": "Minimum value for the eighth input."}, {"name": "in8_max", "type": "REAL", "description": "Maximum value for the eighth input, default is 1000.0."}], "output": [{"name": "SCALE_X8", "type": "REAL", "description": "The calculated scaled and offset sum of the selected input values."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the scaling operation based on the input parameters."}}
{"title": "J-K Flip-Flop Function Block", "description": "FF_JKE is an edge-triggered JK-fop-fop with asynchronous Set and Reset\ninputs. The JK-Flip-Flop sets the output Q when with a rising edge of the\nCLK the Input J is TRUE. Q is FALSE when on a rising clock edge the input K\nis TRUE. If the two inputs J and K on a rising clock edge are TRUE, the out￾put will be negated. It switches the output signal in each cycle. \nD\nCLK\nRST\nQ\nSET", "type": "FUNCTION_BLOCK", "name": "FF_JKE", "input": [{"name": "SET", "type": "BOOL", "description": "Input to set the flip-flop to high."}, {"name": "J", "type": "BOOL", "description": "Input that determines the next state of Q when activated."}, {"name": "CLK", "type": "BOOL", "description": "Clock signal that synchronizes state changes."}, {"name": "K", "type": "BOOL", "description": "Input that determines the next state of Q when activated."}, {"name": "RST", "type": "BOOL", "description": "Input to reset the flip-flop to low."}], "output": [{"name": "Q", "type": "BOOL", "description": "Current state of the flip-flop output."}], "in/out": [], "return_value": null}
{"title": "8-Bit Storage Function Block", "description": "FF_JKE is an edge-triggered JK-fop-fop with asynchronous Set and Reset\ninputs. The JK-Flip-Flop sets the output Q when with a rising edge of the\nCLK the Input J is TRUE. Q is FALSE when on a rising clock edge the input K\nis TRUE. If the two inputs J and K on a rising clock edge are TRUE, the out￾put will be negated. It switches the output signal in each cycle. \nD\nCLK\nRST\nQ\nSET", "type": "FUNCTION_BLOCK", "name": "STORE_8", "input": [{"name": "Set", "type": "BOOL", "description": "A signal to enable setting the storage values."}, {"name": "D0", "type": "BOOL", "description": "Input for the first bit in the storage."}, {"name": "D1", "type": "BOOL", "description": "Input for the second bit in the storage."}, {"name": "D2", "type": "BOOL", "description": "Input for the third bit in the storage."}, {"name": "D3", "type": "BOOL", "description": "Input for the fourth bit in the storage."}, {"name": "D4", "type": "BOOL", "description": "Input for the fifth bit in the storage."}, {"name": "D5", "type": "BOOL", "description": "Input for the sixth bit in the storage."}, {"name": "D6", "type": "BOOL", "description": "Input for the seventh bit in the storage."}, {"name": "D7", "type": "BOOL", "description": "Input for the eighth bit in the storage."}, {"name": "Clr", "type": "BOOL", "description": "A signal to clear the stored values."}, {"name": "Rst", "type": "BOOL", "description": "A signal to reset the storage values."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output for the first stored bit."}, {"name": "Q1", "type": "BOOL", "description": "Output for the second stored bit."}, {"name": "Q2", "type": "BOOL", "description": "Output for the third stored bit."}, {"name": "Q3", "type": "BOOL", "description": "Output for the fourth stored bit."}, {"name": "Q4", "type": "BOOL", "description": "Output for the fifth stored bit."}, {"name": "Q5", "type": "BOOL", "description": "Output for the sixth stored bit."}, {"name": "Q6", "type": "BOOL", "description": "Output for the seventh stored bit."}, {"name": "Q7", "type": "BOOL", "description": "Output for the eighth stored bit."}], "in/out": [], "return_value": null}
{"title": "Calendar Calculation Function Block", "description": "CALENDAR_CALC automatically calculates all the values in a CALENDAR\nstructure based on the value of the type UTC in the structure. XCAL is a\nPointer an external or global variable of type CALENDAR. CALENDAR_CALC\ncan thus deliver calendar values based on the structure XCAL throughout\nthe module. CALENDAR_CALC determines at each change of the value UTC\nin XCAL automatically all other values in the structure. Alone the value of\nUTC in a structure must be fed by the RTC module. The defnition of the\nstructured type CALENDAR you can fnd in section data structures. The\ncontinuous calculation of the sun position can weigh heavily on a PLC wi￾thout FPU, which is why the current sun position is calculated only once\nevery 25 seconds if SPE = TRUE. This corresponds to an accuracy of 0.1\ndegrees which is quite sufcient for normal applications. If SPE is FALSE,\nthe position of the sun is not calculated. By an external array HOLIDAYS of\ntype HOLYDAY_DATA, the user can specify specifc holidays according to\nhis needs, for more information on the defnition of public holidays see the\nmodule data structures. \nIf several structures of the type CALENDAR are required (for example, or\nvarious local and UTC times) then more modules CALENDAR_CALC can be\nused with diferent structures of TYPE CALENDAR in accordance .\nThe following example shows how the module SYSRTCGETTIME reads the\nRTC of the CPU and writes the current time in SYSTEMCAL.UTC. CALEN￾DAR_CALC checks every cycle if the value in .UTC has changed and if so it\ncalculates the other values of the structure automatically. The output\nWDAY shows how the structure reads data for further processing. CALEN￾DAR_CALC accounts of the setup data from the data structure (OFFSET\nDST_EN, LONGITUDE, LATITUDE).\nIn the external array HOLIDAYS up to 30 holidays can be defned. For ex￾amples, see the description of the data type HOLIDAY_DATA. This array of\nHOLIDAY_DATA must be defned outside of the module and be pre-assi￾gned as a variable with the holiday dates.", "type": "FUNCTION_BLOCK", "name": "CALENDAR_CALC", "input": [{"name": "SPE", "type": "BOOL", "description": "A boolean flag that enables the calculation of the sun's position every 25 seconds if set to TRUE."}, {"name": "H", "type": "REAL", "description": "Twilight offset parameter for sunrise/sunset calculations, defaults to -0.8333."}], "output": [{"name": "XCAL", "type": "CALENDAR", "description": "The calendar data structure that contains local date, time, holidays, and sun information."}, {"name": "HOLIDAYS", "type": "ARRAY[0..29] OF HOLIDAY_DATA", "description": "An array of holiday data to be used for local holiday calculations."}], "in/out": [], "return_value": null}
{"title": "Real-Time Clock Function Block (RTC_2)", "description": "CALENDAR_CALC automatically calculates all the values in a CALENDAR\nstructure based on the value of the type UTC in the structure. XCAL is a\nPointer an external or global variable of type CALENDAR. CALENDAR_CALC\ncan thus deliver calendar values based on the structure XCAL throughout\nthe module. CALENDAR_CALC determines at each change of the value UTC\nin XCAL automatically all other values in the structure. Alone the value of\nUTC in a structure must be fed by the RTC module. The defnition of the\nstructured type CALENDAR you can fnd in section data structures. The\ncontinuous calculation of the sun position can weigh heavily on a PLC wi￾thout FPU, which is why the current sun position is calculated only once\nevery 25 seconds if SPE = TRUE. This corresponds to an accuracy of 0.1\ndegrees which is quite sufcient for normal applications. If SPE is FALSE,\nthe position of the sun is not calculated. By an external array HOLIDAYS of\ntype HOLYDAY_DATA, the user can specify specifc holidays according to\nhis needs, for more information on the defnition of public holidays see the\nmodule data structures. \nIf several structures of the type CALENDAR are required (for example, or\nvarious local and UTC times) then more modules CALENDAR_CALC can be\nused with diferent structures of TYPE CALENDAR in accordance .\nThe following example shows how the module SYSRTCGETTIME reads the\nRTC of the CPU and writes the current time in SYSTEMCAL.UTC. CALEN￾DAR_CALC checks every cycle if the value in .UTC has changed and if so it\ncalculates the other values of the structure automatically. The output\nWDAY shows how the structure reads data for further processing. CALEN￾DAR_CALC accounts of the setup data from the data structure (OFFSET\nDST_EN, LONGITUDE, LATITUDE).\nIn the external array HOLIDAYS up to 30 holidays can be defned. For ex￾amples, see the description of the data type HOLIDAY_DATA. This array of\nHOLIDAY_DATA must be defned outside of the module and be pre-assi￾gned as a variable with the holiday dates.", "type": "FUNCTION_BLOCK", "name": "RTC_2", "input": [{"name": "SET", "type": "BOOL", "description": "Boolean value to set the RTC."}, {"name": "SDT", "type": "DT", "description": "Start date and time for the RTC."}, {"name": "SMS", "type": "INT", "description": "Milliseconds to set for the RTC."}, {"name": "DEN", "type": "BOOL", "description": "Boolean value indicating if daylight savings time adjustment is needed."}, {"name": "OFS", "type": "INT", "description": "Offset in minutes to adjust the local time."}], "output": [{"name": "UDT", "type": "DT", "description": "Updated date and time from the RTC."}, {"name": "LOCAL_DT", "type": "DT", "description": "Calculated local date and time after applying offset."}, {"name": "DSO", "type": "BOOL", "description": "Boolean value indicating if daylight savings time is in effect."}, {"name": "XMS", "type": "INT", "description": "Milliseconds value derived from the RTC."}], "in/out": [], "return_value": {}}
{"title": "Check Uppercase String", "description": "IS_UPPER checks if in the string STR all capital letters are included. If an\nincorrect, non capital character is found the function returns FALSE. If in\nSTR are only capital letters included, the function returns TRUE. In exami￾ning the Global Setup EXTENDED_ASCII constant is considered. If EXTEN￾DED_ASCII = TRUE the extended ASCII character-set to be considered in\naccordance with ISO 8859-1. Umlauts like Ä, Ö, Ü are considered only if\nthe global constant EXTENDED_ASCII = TRUE.", "type": "FUNCTION", "name": "IS_UPPER", "input": [{"name": "str", "type": "STRING", "description": "The input string to be checked for uppercase characters."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "True if all characters in the string are uppercase, false otherwise."}}
{"title": "Decimal to DWORD Conversion Function", "description": "DEC_TO_DWORD converts a decimal encoded string into a\nbyte value. Here only decimal characters '0 '.. '9' are interpreted, others in\nDEC occurring characters are ignored .", "type": "FUNCTION", "name": "DEC_TO_DWORD", "input": [{"name": "DEC", "type": "STRING[20]", "description": "A string of up to 20 characters representing a decimal number."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The resulting DWORD value obtained from the decimal string conversion."}}
{"title": "Multi Input Selector Function", "description": "MULTI_IN is a sensor interface that accepts up to 3 sensors to check for er￾rors, and depending on the input mode, an output value is calculated.\nMode Function\n0 MULTI_in = average of the inputs in_1.. 3\n1 MULTI_in = input in_1\n2 MULTI_in = input in_2\n3 MULTI_in = input in_3\n4 MULTI_in = Default Input \n5 MULTI_in = smallest value of the inputs in_1.. 3\n6 MULTI_in = largest value of the inputs in_1 .. 3\n7 MULTI_in = mean value of the inputs in_1..3\n>7 MULTI_in = 0\nRegardless of the mode input values that are greater than IN_MAX or less\nthan IN_MIN be ignored. If no calculation is possible as defned by mode,\nthe input Default is used as a output value. Multi_in is used when diferent\nsensors measures the same value and high security and reliability is requi￾red. A possible application is to measure the outside temperature at va￾rious points and the surveillance on cable or sensor failure.", "type": "FUNCTION", "name": "MULTI_IN", "input": [{"name": "in_1", "type": "REAL", "description": "The first input value."}, {"name": "in_2", "type": "REAL", "description": "The second input value."}, {"name": "in_3", "type": "REAL", "description": "The third input value."}, {"name": "default", "type": "REAL", "description": "The default value used when no inputs meet the criteria."}, {"name": "in_min", "type": "REAL", "description": "The minimum threshold value for validation of inputs."}, {"name": "in_max", "type": "REAL", "description": "The maximum threshold value for validation of inputs."}, {"name": "mode", "type": "BYTE", "description": "The mode which determines the operational behavior of the function."}], "output": [{"name": "MULTI_IN", "type": "REAL", "description": "The computed result based on the selected inputs and mode."}], "in/out": [], "return_value": {"type": "REAL", "description": "The resulting value after processing inputs according to the selected mode."}}
{"title": "Manual Control Function Block", "description": "MULTI_IN is a sensor interface that accepts up to 3 sensors to check for er￾rors, and depending on the input mode, an output value is calculated.\nMode Function\n0 MULTI_in = average of the inputs in_1.. 3\n1 MULTI_in = input in_1\n2 MULTI_in = input in_2\n3 MULTI_in = input in_3\n4 MULTI_in = Default Input \n5 MULTI_in = smallest value of the inputs in_1.. 3\n6 MULTI_in = largest value of the inputs in_1 .. 3\n7 MULTI_in = mean value of the inputs in_1..3\n>7 MULTI_in = 0\nRegardless of the mode input values that are greater than IN_MAX or less\nthan IN_MIN be ignored. If no calculation is possible as defned by mode,\nthe input Default is used as a output value. Multi_in is used when diferent\nsensors measures the same value and high security and reliability is requi￾red. A possible application is to measure the outside temperature at va￾rious points and the surveillance on cable or sensor failure.", "type": "FUNCTION_BLOCK", "name": "MANUAL_1", "input": [{"name": "IN", "type": "BOOL", "description": "Input signal that determines the output state when manual control is not active."}, {"name": "MAN", "type": "BOOL", "description": "Manual control signal to enable manual operation."}, {"name": "M_I", "type": "BOOL", "description": "Immediate input signal that defines the output state when manual control is inactive."}, {"name": "SET", "type": "BOOL", "description": "Set signal to transition the output state to TRUE."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to transition the output state to FALSE."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output signal representing the current state controlled by the function block."}, {"name": "STATUS", "type": "BYTE", "description": "Status code indicating the current state of the function block."}], "in/out": [], "return_value": null}
{"title": "List Length Calculation", "description": "LIST_LENGTH) (input list)\nOutput INT (number of items in the list)\nLIST_LEN determines the number of items in a list.\nLIST_LEN('&0&1&2&3', 38) = 4\nLIST_LEN('',21) = 0", "type": "FUNCTION", "name": "LIST_LEN", "input": [{"name": "SEP", "type": "BYTE", "description": "The separator byte used to mark the boundaries between elements in the list."}], "output": [{"name": "LIST_LEN", "type": "INT", "description": "The total number of elements in the list as determined by counting the occurrences of the separator."}], "in/out": [{"name": "LIST", "type": "STRING(LIST_LENGTH)", "description": "The string representation of the list where elements are separated by the specified separator."}], "return_value": {"type": "INT", "description": "The return value indicates the count of elements in the list based on the separator provided."}}
{"title": "Integration Function Block", "description": "INTEGRATE is a Integrator which integrates the value of X to an external\nvalue Y. The integrator operates when E = TRUE, the internal Default of E\n= TRUE.", "type": "FUNCTION_BLOCK", "name": "INTEGRATE", "input": [{"name": "E", "type": "BOOL", "description": "Enable flag to execute the integration calculation. Default is TRUE."}, {"name": "X", "type": "REAL", "description": "The current value to be integrated."}, {"name": "K", "type": "REAL", "description": "Scaling factor for the integration calculation. Default value is 1.0."}], "output": [{"name": "Y", "type": "REAL", "description": "The resulting integrated value."}], "in/out": [], "return_value": null}
{"title": "FT_PT2 Function Block", "description": "INTEGRATE is a Integrator which integrates the value of X to an external\nvalue Y. The integrator operates when E = TRUE, the internal Default of E\n= TRUE.", "type": "FUNCTION_BLOCK", "name": "FT_PT2", "input": [{"name": "in", "type": "REAL", "description": "The input signal value to be processed by the function block."}, {"name": "T", "type": "TIME", "description": "The time duration for the integration process."}, {"name": "D", "type": "REAL", "description": "The damping factor used in the integration calculation."}, {"name": "K", "type": "REAL", "description": "The gain constant for scaling the input, with a default value of 1.0."}], "output": [{"name": "out", "type": "REAL", "description": "The output result after processing the input through the function block."}], "in/out": [], "return_value": null}
{"title": "Random Number Generation", "description": "RND in￾ternally uses the standard function TRUNC() which converts the input va￾lue to an INTEGER type DINT. This may come as an overfow because DINT\ncan store in maximum +/-2.14*10^9. The range of the RND is therefore li-\nmited to +/-2.14*10^9 . See also the ROUND function which rounds the in￾put value to N decimal places.", "type": "FUNCTION", "name": "RND", "input": [{"name": "X", "type": "REAL", "description": "The input value for which a random number is to be generated."}, {"name": "N", "type": "INT", "description": "The precision level that determines how finely the random number is generated."}], "output": [{"name": "RND", "type": "REAL", "description": "The randomly generated number based on input 'X' and precision 'N'."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the random number generation, which can be zero or a scaled version of 'X'."}}
{"title": "GEN_RDT Function Block", "description": "GEN_RDT generates pulses with a defned pulse width and random spa￾cing. The output pulses with the pulse width TP_Q be generated at random\nintervals TX. TX fuctuates randomly between time MIN_TIME_MS and\nMAX_TIME_MS. The module generates output pulses at XQ only when the\nENABLE input is TRUE.", "type": "FUNCTION_BLOCK", "name": "GEN_RDT", "input": [{"name": "Enable", "type": "BOOL", "description": "A boolean to enable or disable the function block operation."}, {"name": "Min_Time_ms", "type": "TIME", "description": "The minimum time interval (Taktzeit) for the output generation."}, {"name": "Max_Time_ms", "type": "TIME", "description": "The maximum time interval (Taktzeit) for the output generation."}, {"name": "TP_Q", "type": "TIME", "description": "The duration for which the output should remain in the TRUE state."}], "output": [{"name": "xQ", "type": "BOOL", "description": "A boolean output that indicates the state of the output based on the timing conditions."}], "in/out": [], "return_value": null}
{"title": "Conversion of Individual Boolean Values to a Single Byte", "description": "BYTE_OF_BIT uses one byte of 8 individual bits (B0 .. B7) together.", "type": "FUNCTION", "name": "BYTE_OF_BIT", "input": [{"name": "B0", "type": "BOOL", "description": "The least significant bit of the byte."}, {"name": "B1", "type": "BOOL", "description": "The second least significant bit of the byte."}, {"name": "B2", "type": "BOOL", "description": "The third least significant bit of the byte."}, {"name": "B3", "type": "BOOL", "description": "The fourth bit of the byte."}, {"name": "B4", "type": "BOOL", "description": "The fifth bit of the byte."}, {"name": "B5", "type": "BOOL", "description": "The sixth bit of the byte."}, {"name": "B6", "type": "BOOL", "description": "The seventh bit of the byte."}, {"name": "B7", "type": "BOOL", "description": "The most significant bit of the byte."}], "output": [{"name": "Byte_of_bit", "type": "BYTE", "description": "The resulting byte composed of the input boolean values."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The final byte representation of the boolean inputs.", "fields": []}}
{"title": "Control Set 1 Configuration", "description": "BYTE_OF_BIT uses one byte of 8 individual bits (B0 .. B7) together.", "type": "FUNCTION_BLOCK", "name": "CONTROL_SET1", "input": [{"name": "Kt", "type": "REAL", "description": "The gain factor that affects the control outputs."}, {"name": "Tt", "type": "REAL", "description": "The time constant used for calculating integral and derivative parameters."}, {"name": "PI", "type": "BOOL", "description": "Boolean flag to indicate if a PI controller is used."}, {"name": "PID", "type": "BOOL", "description": "Boolean flag to indicate if a PID controller is used."}, {"name": "P_K", "type": "REAL", "description": "Proportional gain for the basic control (default = 0.5)."}, {"name": "PI_K", "type": "REAL", "description": "Proportional gain for the PI controller (default = 0.45)."}, {"name": "PI_TN", "type": "REAL", "description": "Time constant for the integral part of the PI controller (default = 0.83)."}, {"name": "PID_K", "type": "REAL", "description": "Proportional gain for the PID controller (default = 0.6)."}, {"name": "PID_TN", "type": "REAL", "description": "Time constant for the integral part of the PID controller (default = 0.5)."}, {"name": "PID_TV", "type": "REAL", "description": "Time constant for the derivative part of the PID controller (default = 0.125)."}], "output": [{"name": "KP", "type": "REAL", "description": "Calculated proportional gain based on the selected controller."}, {"name": "TN", "type": "REAL", "description": "Calculated time constant for the integral component."}, {"name": "TV", "type": "REAL", "description": "Calculated time constant for the derivative component."}, {"name": "KI", "type": "REAL", "description": "Calculated integral gain based on KP and TN."}, {"name": "KD", "type": "REAL", "description": "Calculated derivative gain based on KP and TV."}], "in/out": [], "return_value": null}
{"title": "FILL Function", "description": "FILL creates a string consisting of the symbol C with the length L.\nFILL(49,5) = '11111'\nThe FILL function evaluates the Global Setup constant STRING_LENGTH\nand limits the maximum length L of the string to STRING_LENGTH.", "type": "FUNCTION", "name": "FILL", "input": [{"name": "C", "type": "BYTE", "description": "A byte value to be converted to a string."}, {"name": "L", "type": "INT", "description": "An integer specifying how many times the character should be appended, limited to a maximum of 80 characters."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The resulting concatenated string after processing the input byte and limit."}}
{"title": "Calculate Array Trend", "description": "ARRAY_TREND calculates the trend development of all va￾lues of an arbitrary array of REAL. When called a pointer to the array and\nits size in bytes is passed to the function. Under CoDeSys the call reads:\nARRAY_TREND(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function, which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the trend, the array referenced\nby the pointer is scanned directly in memory. The function ARRAY_TREND\ndoes not change the content of the array. This type of processing arrays is\nvery efcient because no additional memory is required and no surrender\nvalues must be copied. The trend is determined by subtract the average\nof the lower half of the values of the array from the average of the values\nof the upper half of the array.", "type": "FUNCTION", "name": "ARRAY_TREND", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "Pointer to the array of real numbers whose trend needs to be calculated."}, {"name": "size", "type": "UINT", "description": "The total number of elements in the array."}], "output": [{"name": "ARRAY_TREND", "type": "REAL", "description": "The calculated trend value of the array, which is the average based on the input size."}], "in/out": [], "return_value": {"type": "REAL", "description": "Average trend of the array values.", "fields": []}}
{"title": "Cauchy Function Calculation", "description": "CAUCHY calculates the density function for Cauchy.", "type": "FUNCTION", "name": "CAUCHY", "input": [{"name": "X", "type": "REAL", "description": "The first parameter of the Cauchy function."}, {"name": "T", "type": "REAL", "description": "The second parameter, which alters the position of the distribution."}, {"name": "U", "type": "REAL", "description": "The scale parameter for the Cauchy distribution."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed value of the Cauchy function based on the provided input parameters."}}
{"title": "Add Item to List", "description": "LIST_ADD adds another element to the end of a list. The list consists of\nStrings (elements) that begin with the separation character SEP.", "type": "FUNCTION", "name": "LIST_ADD", "input": [{"name": "SEP", "type": "BYTE", "description": "The separation character that will be converted to a string and prefixed to the input string."}, {"name": "INS", "type": "STRING(LIST_LENGTH)", "description": "The input string that is to be added to the list."}], "output": [], "in/out": [{"name": "LIST", "type": "STRING(LIST_LENGTH)", "description": "The list to which the input string will be added. It is modified in place."}], "return_value": {"type": "BOOL", "description": "A boolean value indicating the success of the addition operation to the list.", "fields": []}}
{"title": "Check Uppercase Character", "description": "ISC_UPPER tests whether a sign IN is a captial letter, if IN is a capital let￾ter, the function returns TRUE, if not the function returns FALSE. In exami￾ning the Global Setup EXTENDED_ASCII constant is considered. If EXTEN￾DED_ASCII = TRUE the extended ASCII character-set to be considered in\naccordance with ISO 8859-1.\nThe The following table describes the character codes:\nCode EXTENDED_ASCII=TRUE EXTENDED_ASCII = FASLE\n0..64,91..191,215, 223..255 FALSE FALSE\n65..90 TRUE TRUE\n192..214 TRUE FALSE\n216..222 TRUE FALSE", "type": "FUNCTION", "name": "ISC_UPPER", "input": [{"name": "IN", "type": "BYTE", "description": "The byte value to be checked for uppercase character status."}], "output": [{"name": "ISC_UPPER", "type": "BOOL", "description": "Returns TRUE if the input byte corresponds to an uppercase ASCII character; otherwise, FALSE."}], "in/out": [], "return_value": {"type": "BOOL", "description": "The result indicating whether the input byte is an uppercase letter, based on ASCII definitions.", "fields": []}}
{"title": "TP_1 Timer Function Block", "description": "ISC_UPPER tests whether a sign IN is a captial letter, if IN is a capital let￾ter, the function returns TRUE, if not the function returns FALSE. In exami￾ning the Global Setup EXTENDED_ASCII constant is considered. If EXTEN￾DED_ASCII = TRUE the extended ASCII character-set to be considered in\naccordance with ISO 8859-1.\nThe The following table describes the character codes:\nCode EXTENDED_ASCII=TRUE EXTENDED_ASCII = FASLE\n0..64,91..191,215, 223..255 FALSE FALSE\n65..90 TRUE TRUE\n192..214 TRUE FALSE\n216..222 TRUE FALSE", "type": "FUNCTION_BLOCK", "name": "TP_1", "input": [{"name": "IN", "type": "BOOL", "description": "Boolean input that starts the timing operation when set to TRUE."}, {"name": "PT", "type": "TIME", "description": "Duration for which the output Q remains TRUE after IN is activated."}, {"name": "RST", "type": "BOOL", "description": "Boolean input that resets the output Q to FALSE when set to TRUE."}], "output": [{"name": "Q", "type": "BOOL", "description": "Boolean output that indicates the status of the timer; TRUE when timing is active, otherwise FALSE."}], "in/out": [], "return_value": null}
{"title": "Vector 3 Reversal Function", "description": "ISC_UPPER tests whether a sign IN is a captial letter, if IN is a capital let￾ter, the function returns TRUE, if not the function returns FALSE. In exami￾ning the Global Setup EXTENDED_ASCII constant is considered. If EXTEN￾DED_ASCII = TRUE the extended ASCII character-set to be considered in\naccordance with ISO 8859-1.\nThe The following table describes the character codes:\nCode EXTENDED_ASCII=TRUE EXTENDED_ASCII = FASLE\n0..64,91..191,215, 223..255 FALSE FALSE\n65..90 TRUE TRUE\n192..214 TRUE FALSE\n216..222 TRUE FALSE", "type": "FUNCTION", "name": "V3_REV", "input": [{"name": "A", "type": "Vector_3", "description": "The input vector whose components are to be reversed."}], "output": [], "in/out": [], "return_value": {"type": "vector_3", "description": "The output vector which is the negation of the input vector A.", "fields": [{"name": "X", "type": "REAL", "description": "The X component of the output vector, which is the negative of the X component of input vector A."}, {"name": "Y", "type": "REAL", "description": "The Y component of the output vector, which is the negative of the Y component of input vector A."}, {"name": "Z", "type": "REAL", "description": "The Z component of the output vector, which is the negative of the Z component of input vector A."}]}}
{"title": "Calculate Area of Triangle", "description": "TRIANGLE_A calculates the area of any triangle. The triangle can be def￾ned by either through 2 pages and the pages spanned by the angles 1 and\n2 (S1, S2 and A), or if A = 0 then the area is calculated from three sides\n(S1, S2 and S3).\n 11. Vector Mathematics", "type": "FUNCTION", "name": "TRIANGLE_A", "input": [{"name": "S1", "type": "REAL", "description": "Length of the first side of the triangle."}, {"name": "A", "type": "REAL", "description": "Included angle in degrees. If A is 0, Heron's formula is used."}, {"name": "S2", "type": "REAL", "description": "Length of the second side of the triangle."}, {"name": "S3", "type": "REAL", "description": "Length of the third side of the triangle."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated area of the triangle.", "fields": []}}
{"title": "Boolean Logic Function Block", "description": "TRIANGLE_A calculates the area of any triangle. The triangle can be def￾ned by either through 2 pages and the pages spanned by the angles 1 and\n2 (S1, S2 and A), or if A = 0 then the area is calculated from three sides\n(S1, S2 and S3).\n 11. Vector Mathematics", "type": "FUNCTION_BLOCK", "name": "DEC_2", "input": [{"name": "D", "type": "BOOL", "description": "Boolean input that influences both outputs."}, {"name": "A", "type": "BOOL", "description": "Boolean input that determines the value of Q1 along with D."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Boolean output representing the result of D AND NOT A."}, {"name": "Q1", "type": "BOOL", "description": "Boolean output representing the result of D AND A."}], "in/out": [], "return_value": null}
{"title": "Buffer Uppercase Conversion", "description": "_BUFFER_UPPERCASE interprets each byte in the bufer as\nASCII characters and converts it to uppercase . When called, a pointer to\nthe array and its size in bytes is passed to the function. Under CoDeSys\nthe call reads: _BUFFER_INIT(ADR(Array), SIZEOF(Array), INIT), where array\nis the name of the array to be manipulated. ADR is a standard function,\nwhich identifes the Pointer the array and SIZEOF is a standard function,\nwhich determines the size of the array. The function only returns TRUE. By\nthe Pointer given array is manipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "_BUFFER_UPPERCASE", "input": [{"name": "PT", "type": "POINTER TO ARRAY [0..32000] OF BYTE", "description": "A pointer to an array of bytes that will be converted to uppercase."}, {"name": "SIZE", "type": "INT", "description": "The number of bytes in the array to be converted."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Indicates whether the uppercase conversion was successful.", "fields": []}}
{"title": "Complex Logarithm Calculation", "description": "CLOG calculates the natural logarithm of a complex number raised to E.\nCLOG(X) = LOG(e)(X).", "type": "FUNCTION", "name": "CLOG", "input": [{"name": "X", "type": "COMPLEX", "description": "A complex number represented by its real and imaginary parts."}], "output": [], "in/out": [], "return_value": {"type": "COMPLEX", "description": "The complex logarithm of the input number, represented in its real and imaginary parts.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the complex logarithm."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the complex logarithm."}]}}
{"title": "Gaussian Function", "description": "GAUSS The function calculates the Gaussian normal distribution using the followi￾ng formula:\nThe normal distribution is the density function normally distributed ran￾dom variables. With the parameters U = 0 and SI = 1, it follows the stan￾dard normal distribution.", "type": "FUNCTION", "name": "GAUSS", "input": [{"name": "X", "type": "REAL", "description": "The value at which to evaluate the Gaussian function."}, {"name": "U", "type": "REAL", "description": "The mean (average) of the distribution."}, {"name": "SI", "type": "REAL", "description": "The standard deviation of the distribution."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed value of the Gaussian function at the specified point X."}}
{"title": "Scale a Value", "description": "SCALE_R scales an input value REAL and calculates an output value in\nREAL. The input value X is limited here to I_LO and I_HI. SCALE_D\n(IN,4,20,0,100) scales an input with 4 .. 20mA to the output 0..100.\nSCALE_R can also be negative output values and work with a negative slo￾pe, the values I_LO and I_HI but must always be specifed that ILO < I_HI.", "type": "FUNCTION", "name": "SCALE_R", "input": [{"name": "X", "type": "REAL", "description": "The value to be scaled."}, {"name": "I_LO", "type": "REAL", "description": "The lower bound of the input range."}, {"name": "I_HI", "type": "REAL", "description": "The upper bound of the input range."}, {"name": "O_LO", "type": "REAL", "description": "The lower bound of the output range."}, {"name": "O_HI", "type": "REAL", "description": "The upper bound of the output range."}], "output": [{"name": "SCALE_R", "type": "REAL", "description": "The scaled output value corresponding to the input value X."}], "in/out": [], "return_value": {"type": "REAL", "description": "The final scaled value based on the input parameters.", "fields": []}}
{"title": "Difference Check Function", "description": "DIFFER is TRUE if in1 and in2 difer by more than X from each\nother.", "type": "FUNCTION", "name": "DIFFER", "input": [{"name": "in1", "type": "REAL", "description": "The first real number input for the difference calculation."}, {"name": "in2", "type": "REAL", "description": "The second real number input for the difference calculation."}, {"name": "X", "type": "REAL", "description": "The threshold value. The function checks if the absolute difference exceeds this value."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the absolute difference between in1 and in2 is greater than X; otherwise, returns FALSE."}}
{"title": "2-to-1 Multiplexer Function", "description": "DIFFER is TRUE if in1 and in2 difer by more than X from each\nother.", "type": "FUNCTION", "name": "MUX_2", "input": [{"name": "D0", "type": "BOOL", "description": "The first data input to the multiplexer."}, {"name": "D1", "type": "BOOL", "description": "The second data input to the multiplexer."}, {"name": "A0", "type": "BOOL", "description": "The selection input that determines which data input to output."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "The output of the multiplexer, which is either D0 or D1 based on the value of A0."}}
{"title": "Linear Function Calculation", "description": "F_LIN = A*X + B)\nThe function F_LIN returns the Y value of a linear equation.\nF_LIN = A*X + B", "type": "FUNCTION", "name": "F_LIN", "input": [{"name": "X", "type": "REAL", "description": "The independent variable for the linear equation."}, {"name": "A", "type": "REAL", "description": "The coefficient representing the slope of the linear function."}, {"name": "B", "type": "REAL", "description": "The constant term that represents the y-intercept of the linear function."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the linear function calculation, which is the value of A * X + B."}}
{"title": "Square Wave Generator", "description": "GEN_SQ is a generator with programmable period time and a fxed duty\ncycle of 50%. The input PT defnes the period time and the output Q pas￾ses the output signal.", "type": "FUNCTION_BLOCK", "name": "GEN_SQ", "input": [{"name": "PT", "type": "TIME", "description": "The period of the square wave signal, defining the time interval for toggling the output."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output signal that represents the state of the square wave, toggling between TRUE and FALSE."}], "in/out": [], "return_value": null}
{"title": "Override Calculation Function", "description": "OVERRIDE supplies at the output Y the input value (X1, X2, X3), whose ab￾solute value is the largest of all. The inputs X1, X2 and X3 may each indivi￾dually be enabled with the inputs E1, E2 and E3. if one of the input signals\nE1, E2 or E3 to FALSE, the corresponding input X1, X2 or X3 is not conside￾red. One of many possible applications of OVERRIDE is for example, the\nquery of three sensors with the highest value overrides the others. With\nthe inputs of E in the diagnosis case, each sensor can be queried indivi￾dually, or a defective sensor can be switched of.", "type": "FUNCTION", "name": "OVERRIDE", "input": [{"name": "X1", "type": "REAL", "description": "The first input value used in the override calculation."}, {"name": "X2", "type": "REAL", "description": "The second input value used in the override calculation."}, {"name": "X3", "type": "REAL", "description": "The third input value used in the override calculation."}, {"name": "E1", "type": "BOOL", "description": "Enable flag for the first input value."}, {"name": "E2", "type": "BOOL", "description": "Enable flag for the second input value."}, {"name": "E3", "type": "BOOL", "description": "Enable flag for the third input value."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated override value based on the input parameters."}}
{"title": "PIN Code Verification", "description": "PIN_CODE checks a stream of bytes for the presence of a specifc se￾quence. If the sequence is found, this is indicated by a TRUE at output TP.\nIn the following example, two modules PIN_CODE be used to decode two\nCODE_SEQUENCES of a matrix keyboard.", "type": "FUNCTION_BLOCK", "name": "PIN_CODE", "input": [{"name": "CB", "type": "BYTE", "description": "The byte value representing the current code input by the user."}, {"name": "E", "type": "BOOL", "description": "A boolean flag indicating whether the input verification should be processed."}, {"name": "PIN", "type": "STRING[8]", "description": "The PIN code string that the user needs to match, up to 8 characters long."}], "output": [{"name": "TP", "type": "BOOL", "description": "A boolean output indicating whether the proper PIN code has been detected (TRUE) or not (FALSE)."}], "in/out": [], "return_value": null}
{"title": "Check Date Period", "description": "PERIOD ignores the\nyears in the dates D1, D2 and DX. The test is performed only for months\nand days, so this function works for each year. The test period can also af￾ter 31 Extend beyond December, so for example from 9/1 - 3/15, a typical\napplication is to determine whether there is a heating period. That PERIOD\nwork properly the two dates D1 and D2 may not be in a leap year. It can,\nfor example, always be 2001, or even any other year that is not a leap\nyear.\nPERIOD (10/1/2001, 11/11/2007, 31/03/2001) returns TRUE, because the\ntest date within the period from 10/1 - 3/31 content.", "type": "FUNCTION", "name": "PERIOD", "input": [{"name": "d1", "type": "DATE", "description": "The start date of the period."}, {"name": "dx", "type": "DATE", "description": "The date to check if it falls within the period."}, {"name": "d2", "type": "DATE", "description": "The end date of the period."}], "output": [{"name": "PERIOD", "type": "BOOL", "description": "A boolean value indicating if the date dx is within the period defined by d1 and d2."}], "in/out": [], "return_value": {"type": "BOOL", "description": "The result of whether dx is within the period between d1 and d2.", "fields": []}}
{"title": "Parsing Input Data and Generating Output Parameters", "description": "PERIOD ignores the\nyears in the dates D1, D2 and DX. The test is performed only for months\nand days, so this function works for each year. The test period can also af￾ter 31 Extend beyond December, so for example from 9/1 - 3/15, a typical\napplication is to determine whether there is a heating period. That PERIOD\nwork properly the two dates D1 and D2 may not be in a leap year. It can,\nfor example, always be 2001, or even any other year that is not a leap\nyear.\nPERIOD (10/1/2001, 11/11/2007, 31/03/2001) returns TRUE, because the\ntest date within the period from 10/1 - 3/31 content.", "type": "FUNCTION_BLOCK", "name": "PARSET2", "input": [{"name": "X", "type": "REAL", "description": "Input variable representing a real number."}, {"name": "X01", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X02", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X03", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X04", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X11", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X12", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X13", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X14", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X21", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X22", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X23", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X24", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X31", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X32", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X33", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "X34", "type": "REAL", "description": "Input variable representing a real number for the parameter set."}, {"name": "L1", "type": "REAL", "description": "Threshold value for condition checking."}, {"name": "L2", "type": "REAL", "description": "Threshold value for condition checking."}, {"name": "L3", "type": "REAL", "description": "Threshold value for condition checking."}, {"name": "TC", "type": "TIME", "description": "Time parameter used for initialization of parameter set."}], "output": [{"name": "P1", "type": "REAL", "description": "Output variable representing the first calculated parameter."}, {"name": "P2", "type": "REAL", "description": "Output variable representing the second calculated parameter."}, {"name": "P3", "type": "REAL", "description": "Output variable representing the third calculated parameter."}, {"name": "P4", "type": "REAL", "description": "Output variable representing the fourth calculated parameter."}], "in/out": [], "return_value": null}
{"title": "Pulse Generator Function Block", "description": "GEN_PULSE (ENQ: = TRUE, PTH: = T # 0s, PTL:\n= T # 0s) generates an output signal which has one cycle TRUE and one\ncycle FALSE. The Default ENQ value is TRUE.", "type": "FUNCTION_BLOCK", "name": "GEN_PULSE", "input": [{"name": "ENQ", "type": "BOOL", "description": "Enable input for the pulse generator, should be set to TRUE to generate pulses."}, {"name": "PTH", "type": "TIME", "description": "Time duration for which the output should be held in the 'high' state."}, {"name": "PTL", "type": "TIME", "description": "Time duration for which the output should be in the 'low' state before switching back to 'high'."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output pulse signal, toggles between TRUE and FALSE based on the elapsed time."}], "in/out": [], "return_value": null}
{"title": "Celsius to Kelvin Conversion", "description": "C_TO_K converts a temperature reading from Celsius to Kelvin.", "type": "FUNCTION", "name": "C_TO_K", "input": [{"name": "Celsius", "type": "REAL", "description": "The temperature in degrees Celsius that needs to be converted to Kelvin."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The converted temperature value in Kelvin, calculated by adjusting the Celsius input.", "fields": []}}
{"title": "Calculate Array Variance", "description": "ARRAY_VAR calculates the variance of an arbitrary array of\nREAL. When called a pointer to the array and its size in bytes is passed to\nthe function. Under CoDeSys the call reads: ARRAY_VAR(ADR(Array), SI￾ZEOF(Array)), where array is the name of the array to be manipulated.\nADR() is a standard function, which identifes the pointer to the array and\nSIZEOF() is a standard function, which determines the size of the array. In\norder to determine the maximum, the array referenced by the pointer is\nscanned directly in memory. The function ARRAY_VAR does not change the\ncontent of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_VAR", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "Pointer to an array of real numbers whose variance will be calculated."}, {"name": "size", "type": "UINT", "description": "The size of the array, indicating the number of elements present within the array."}], "output": [{"name": "ARRAY_VAR", "type": "REAL", "description": "The calculated variance of the real numbers in the array."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the computed variance of the array of real numbers."}}
{"title": "Pulse Width Modulation Generator", "description": "ARRAY_VAR calculates the variance of an arbitrary array of\nREAL. When called a pointer to the array and its size in bytes is passed to\nthe function. Under CoDeSys the call reads: ARRAY_VAR(ADR(Array), SI￾ZEOF(Array)), where array is the name of the array to be manipulated.\nADR() is a standard function, which identifes the pointer to the array and\nSIZEOF() is a standard function, which determines the size of the array. In\norder to determine the maximum, the array referenced by the pointer is\nscanned directly in memory. The function ARRAY_VAR does not change the\ncontent of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION_BLOCK", "name": "GEN_PW2", "input": [{"name": "ENQ", "type": "BOOL", "description": "Enable signal to start the timing operation."}, {"name": "TH1", "type": "TIME", "description": "Time duration for the high state in the first timing configuration."}, {"name": "TL1", "type": "TIME", "description": "Time duration for the low state in the first timing configuration."}, {"name": "TH2", "type": "TIME", "description": "Time duration for the high state in the second timing configuration."}, {"name": "TL2", "type": "TIME", "description": "Time duration for the low state in the second timing configuration."}, {"name": "TS", "type": "BOOL", "description": "Selects between the first or second timing configuration."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output signal indicating the state of the PWM (TRUE for high, FALSE for low)."}, {"name": "TH", "type": "TIME", "description": "Elapsed time in the high state since the last transition."}, {"name": "TL", "type": "TIME", "description": "Elapsed time in the low state since the last transition."}], "in/out": [], "return_value": {}}
{"title": "Hysteresis Function Block", "description": "ARRAY_VAR calculates the variance of an arbitrary array of\nREAL. When called a pointer to the array and its size in bytes is passed to\nthe function. Under CoDeSys the call reads: ARRAY_VAR(ADR(Array), SI￾ZEOF(Array)), where array is the name of the array to be manipulated.\nADR() is a standard function, which identifes the pointer to the array and\nSIZEOF() is a standard function, which determines the size of the array. In\norder to determine the maximum, the array referenced by the pointer is\nscanned directly in memory. The function ARRAY_VAR does not change the\ncontent of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION_BLOCK", "name": "HYST_3", "input": [{"name": "in", "type": "REAL", "description": "The input value which is compared against the threshold values."}, {"name": "hyst", "type": "REAL", "description": "The hysteresis value that defines the margin for threshold comparison."}, {"name": "val1", "type": "REAL", "description": "The first threshold value used in determining the output Q1."}, {"name": "val2", "type": "REAL", "description": "The second threshold value used in determining the output Q2."}], "output": [{"name": "Q1", "type": "BOOL", "description": "Output boolean value indicating the state of the first control based on comparisons with val1."}, {"name": "Q2", "type": "BOOL", "description": "Output boolean value indicating the state of the second control based on comparisons with val2."}], "in/out": [], "return_value": {}}
{"title": "Calculate Parity", "description": "PARITY calculates even parity over the input byte IN. The output is TRUE if\nthe number of true bits in the byte (IN) is odd.", "type": "FUNCTION", "name": "PARITY", "input": [{"name": "in", "type": "DWORD", "description": "The DWORD input value for which the parity is to be calculated."}], "output": [{"name": "PARITY", "type": "BOOL", "description": "The result indicating the parity of the input value, TRUE if the number of set bits is odd, otherwise FALSE."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns the parity result of the input value.", "fields": []}}
{"title": "Time Conversion and Correction Function", "description": "T_PLC_MS returns the current internal PLC time in milliseconds. This has\nnothing to do with a possibly existing clock (real time module), but is the\ninternal Timer of a PLC, which is used as a time reference. \nThe source code of the module has the following characteristics:\nFUNCTION T_PLC_MS : DWORD\nVAR CONSTANT\nDEBUG : BOOL := FALSE;\nN : INT := 0;\nOFFSET := 0;\nEND_VAR\nVAR\nTEMP : DWORD := 1;\nEND_VAR\nT_PLC_MS := TIME_TO_DWORD(TIME());\nIF DEBUG THEN\nT_PLC_MS := SHL(T_PLC_US,N) OR SHL(TEMP,N)-1 + OFFSET;\nEND_IF;\nIn normal operation, the module reads the function TIME() the internal\nTimer of the PLC, and returns it. The internal Timer the PLC according to\nIEC standard has one millisecond resolution. \nAnother feature of T_PLC_MS is a debug mode, which allows to test the\noverfow of the internal PLC Timers and verify the developed software shu￾re. The internal Timer of any PLC has, independent of manufacturer and\ntype of implementation, after a fxed time an overfow. That means that it\nis running against .. FF FFFF (highest value of the corresponding type can\nbe stored) and then starts again at 000..0000. At standard PLC Timers is\nthe overfow time 2^32 -1 milliseconds, which is about 49.71 days. Since\nthis Timer is implemented in a hardware, it initial value can not be set, so\nthat after starting the PLC it always starts at 0 and runs up to the maxi￾mum value . After reaching the maximum value, the infamous Timer Over￾fow arises, which causes fatal consequences in the application software ,\nbut can only be tested extremely difcult. \nT_PLC_MS ofers several ways to test the overfow and time-dependent\nsoftware. With the constant DEBUG, the test mode is switched on and\nthen, using the constants N and ofset , starts the timer at a certain level,\nthus specifcally the overfow can be tested without waiting the 49. Ofset\ndefnces which ist addeed to the value of the internal Timer . With the con￾stant N is determined by how many bits of the internal Timer Value is shif￾ted to the left, while the lower N bits are flled with 1. With N thus the\nspeed of the internal Timers can be increased by factors of 2,4,8,16 and\nso on. \nT_PLC_US thus ofers all possibilities to test time-dependent software, both\nfor the problem of overfow, and for very slow time-dependent functions.\nThe constant DEBUG, N and OFFSET were intentionally not implemented\nas inputs of the function to avoid accidental misuse.", "type": "FUNCTION", "name": "T_PLC_MS", "input": [{"name": "debug", "type": "BOOL", "description": "Flag to enable debug mode for detailed processing."}, {"name": "N", "type": "INT", "description": "Shift value used for adjusting the timer."}, {"name": "offset", "type": "DWORD", "description": "Additive offset to adjust the timer value."}], "output": [{"name": "T_PLC_MS", "type": "DWORD", "description": "Resulting timer value in DWORD format after conversion and correction."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Final timer value in DWORD format."}}
{"title": "Convert Process Time to Frequency", "description": "PT_TO_F expects a period of seconds in the appropriate frequency to fre￾quency in Hz.", "type": "FUNCTION", "name": "PT_TO_F", "input": [{"name": "PT", "type": "TIME", "description": "The input process time that needs to be converted to frequency."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The frequency value calculated from the process time.", "fields": []}}
{"title": "Matrix Function Block", "description": "MATRIX is a matrix keyboard controller for up to 4 columns and 5 rows.\nWith each PLC cycle on the MATRIX column switch the output further for a\ncolumn so that the lines Y1 to Y4 are queried one by one. For each co￾lumn, the row inputs X1 to X5 are queried and if a button is pressed, the\ncorresponding key code is displayed on the output. The output of TP is a\ncycle set to TRUE if the output CODE indicating a new value. If the setup\nvariable RELEASE is set to TRUE, then for pressing and releasing a button\neach sent a key code. If RELEASE is set to FALSE, a key code is generated\nonly when a button is a pressed. The key code of the output is as follows:\nBit CODE Output\n7 1 when key is pressed, 0 when key is released\n6 Line number Bit 2\n5 Line number Bit 1\n4 Line number Bit 0\n3 Always 0\n2 Row number Bit 2\n1 Row Number Bit 1\n0 Row Number Bit 0\nThe matrix controller is wired as follows:\nThis simple circuit can analyze up to 20 (4 * 5) keys. However, it should be\nnoted here that only in cases a number of keys can be pressed simulta￾neously. The controller can handle with this circuit, several buttons in a co￾lumn in any doubt, but not when keys are pressed simultaneously on dife￾rent columns. The wiring may be extended by each button is decoupled\nvia diodes, and thus the in fuence of di ferent \ncolumns to one another is prevented. In the circuit with diodes, any num￾ber of keys at a time and be evaluated safely. The outputs of the matrix\ncontroller continuously scan the rows of the keyboard matrix. On every\nPLC cycle one line is read. If in a row more keys have been pressed or\nchanged, the changes are displayed as codes of the following cycles. The\nmodule stores the individual key codes and gives each cycle consisting of\nonly one code so that no code can be lost. \nThe following timing diagram shows the scanning of rows of keys:", "type": "FUNCTION_BLOCK", "name": "MATRIX", "input": [{"name": "x1", "type": "BOOL", "description": "First input boolean signal."}, {"name": "x2", "type": "BOOL", "description": "Second input boolean signal."}, {"name": "x3", "type": "BOOL", "description": "Third input boolean signal."}, {"name": "x4", "type": "BOOL", "description": "Fourth input boolean signal."}, {"name": "x5", "type": "BOOL", "description": "Fifth input boolean signal."}, {"name": "Release", "type": "BOOL", "description": "A constant input signal indicating whether to release the generated code."}], "output": [{"name": "code", "type": "BYTE", "description": "The generated code based on the input changes."}, {"name": "TP", "type": "BOOL", "description": "A flag indicating whether a change has been detected."}, {"name": "y1", "type": "BOOL", "description": "Output signal derived from the processed code (default TRUE)."}, {"name": "y2", "type": "BOOL", "description": "Second output signal derived from the processed code."}, {"name": "y3", "type": "BOOL", "description": "Third output signal derived from the processed code."}, {"name": "y4", "type": "BOOL", "description": "Fourth output signal derived from the processed code."}], "in/out": [], "return_value": null}
{"title": "Array Spread Calculation", "description": "ARRAY_SPR determines the dispersion of an arbitrary array of\nREAL. The dispersion is the maximum value in the array minus the mini￾mum value of the array. When called, a Pointer to the array and its size in\nbytes is transferred to the function. Under CoDeSys the call reads:\nARRAY_SPR(ADR(Array), SIZEOF(Array)), where array is the name of the ar￾ray to be manipulated. ADR() is a standard function which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the maximum, the array refe￾renced by the pointer is scanned directly in memory. The function\nARRAY_SPR does not change the content of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_SPR", "input": [{"name": "pt", "type": "^ARRAY [0..32000] OF REAL", "description": "Pointer to the array of REAL numbers."}, {"name": "size", "type": "UINT", "description": "The number of elements in the array."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The difference between the maximum and minimum values in the array.", "fields": []}}
{"title": "First-Order Transfer Function Implementation", "description": "FT_IMP is a high-pass flter with time constant T and multiplier K. An ab￾rupt change at the input is visible at the output, but after the time T the\nvalue is already smoother by 63% and after 3 * T by 95%. Thus, after an\nabrupt change of the input signal from 0 to 10, the output passes 10 at\nthe beginning and reduces after 1* T to 3.7 and after 3 * T to 0.5 and then\ngradually to 0.\nStructure diagram:", "type": "FUNCTION_BLOCK", "name": "FT_IMP", "input": [{"name": "in", "type": "REAL", "description": "The input signal to the transfer function."}, {"name": "T", "type": "TIME", "description": "The time constant of the transfer function."}, {"name": "K", "type": "REAL", "description": "The scaling factor applied to the output, default is 1.0."}], "output": [{"name": "out", "type": "REAL", "description": "The output signal after applying the transfer function."}], "in/out": [], "return_value": null}
{"title": "Character Code Retrieval", "description": "CHARCODE returns the byte code of a Named Characters. A List the Codes\nwith Name located under the function charName. If no character known,\nfor the name in STR 0 is returned. If STR consists of only one character,\nthen the code of this character returned. CHARCODE uses the global va￾riables SETUP.CHARNAMES which include the list of names with codes.", "type": "FUNCTION", "name": "CHARCODE", "input": [{"name": "STR", "type": "STRING[10]", "description": "A string input with a maximum length of 10 characters whose character code needs to be retrieved."}], "output": [{"name": "CHARCODE", "type": "BYTE", "description": "The character code of the input string returned as a byte."}], "in/out": [], "return_value": {"type": "BYTE", "description": "Returns the character code of the input string as a byte."}}
{"title": "Range Checking Function", "description": "CHARCODE returns the byte code of a Named Characters. A List the Codes\nwith Name located under the function charName. If no character known,\nfor the name in STR 0 is returned. If STR consists of only one character,\nthen the code of this character returned. CHARCODE uses the global va￾riables SETUP.CHARNAMES which include the list of names with codes.", "type": "FUNCTION", "name": "WINDOW2", "input": [{"name": "LOW", "type": "REAL", "description": "The lower bound of the range."}, {"name": "IN", "type": "REAL", "description": "The input value to be checked against the range."}, {"name": "HIGH", "type": "REAL", "description": "The upper bound of the range."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the input value is within the specified range (inclusive), otherwise returns FALSE."}}
{"title": "Check if String is Numeric", "description": "IS_NUM tests whether the string STR contains only numbers. If another\ncharacter is found the function returns FALSE. If in STR are only numbers\nincluded, the function returns TRUE. Numbers are the character 0..9.", "type": "FUNCTION", "name": "IS_NUM", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "Input variable of type STRING with specified length which needs to be checked for numeric characters."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns true if the input string consists only of numeric characters and has a length greater than zero; otherwise, returns false."}}
{"title": "Calculate Work Week from Date", "description": "WORK_WEEK calculates the week from the date of input IDA￾TE. The week starts with 1 for the frst week of the year. The frst Thursday\nof the year is always in the frst week. If a year starts with a Thursday or\nend on a Thursday this year has 53 calendar weeks. If the frst day of the\nyear a Tuesday, Wednesday or Thursday so the week begins one early as\nDecember of last year. If the frst day of the year is Friday, Saturday or\nSunday, the last week of the year extends into January. The calculation is\ndone in accordance with ISO8601.\nAs the work week (Work Week ) International is not always used consis￾tent, before the application of the function is to clarify, whether the work\nweek according to ISO8601 is desired in the desired application function.", "type": "FUNCTION", "name": "WORK_WEEK", "input": [{"name": "idate", "type": "DATE", "description": "The input date from which the work week number is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The work week number for the given date according to ISO8601 standards."}}
{"title": "8-Stage Shift Register with Control Inputs", "description": "WORK_WEEK calculates the week from the date of input IDA￾TE. The week starts with 1 for the frst week of the year. The frst Thursday\nof the year is always in the frst week. If a year starts with a Thursday or\nend on a Thursday this year has 53 calendar weeks. If the frst day of the\nyear a Tuesday, Wednesday or Thursday so the week begins one early as\nDecember of last year. If the frst day of the year is Friday, Saturday or\nSunday, the last week of the year extends into January. The calculation is\ndone in accordance with ISO8601.\nAs the work week (Work Week ) International is not always used consis￾tent, before the application of the function is to clarify, whether the work\nweek according to ISO8601 is desired in the desired application function.", "type": "FUNCTION_BLOCK", "name": "SHR_8UDE", "input": [{"name": "SET", "type": "BOOL", "description": "Input to set the state of the shift register."}, {"name": "D0", "type": "BOOL", "description": "Input data for the first stage of the shift register."}, {"name": "D7", "type": "BOOL", "description": "Input data for the last stage of the shift register."}, {"name": "CLK", "type": "BOOL", "description": "Clock input signal that triggers the shifting of the register."}, {"name": "DN", "type": "BOOL", "description": "Control input to determine the direction of data shifting."}, {"name": "RST", "type": "BOOL", "description": "Input to reset all registers to a known state."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Current output state of the first stage of the shift register."}, {"name": "Q1", "type": "BOOL", "description": "Current output state of the second stage of the shift register."}, {"name": "Q2", "type": "BOOL", "description": "Current output state of the third stage of the shift register."}, {"name": "Q3", "type": "BOOL", "description": "Current output state of the fourth stage of the shift register."}, {"name": "Q4", "type": "BOOL", "description": "Current output state of the fifth stage of the shift register."}, {"name": "Q5", "type": "BOOL", "description": "Current output state of the sixth stage of the shift register."}, {"name": "Q6", "type": "BOOL", "description": "Current output state of the seventh stage of the shift register."}, {"name": "Q7", "type": "BOOL", "description": "Current output state of the eighth stage of the shift register."}], "in/out": [], "return_value": null}
{"title": "Check If Byte Is Numeric", "description": "ISC_NUM tests whether a sign IN is a number, if IN is a character 0..9, the\nfunction returns TRUE, if not the function returns FALSE. The character 0..9\nare codes (48..57)", "type": "FUNCTION", "name": "ISC_NUM", "input": [{"name": "IN", "type": "BYTE", "description": "The input byte to be checked."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns true if the input byte is within the ASCII range for numeric characters, otherwise returns false."}}
{"title": "Convert DWORD to String with Length Limitation", "description": "DWORD_TO_STRF converts a DWORD, Word or byte in a STRING of fxed\nlength. The output string is exactly N digits, with leading zeros inserted or\nleading digits truncated. The maximum permitted length N is 20 digits.", "type": "FUNCTION", "name": "DWORD_TO_STRF", "input": [{"name": "IN", "type": "DWORD", "description": "The DWORD value to be converted to a string."}, {"name": "N", "type": "INT", "description": "The maximum length of the resulting string, which should be limited to a maximum of 20."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The resulting string representation of the DWORD input, limited to the specified length N.", "fields": []}}
{"title": "Date Addition Function", "description": "DATE_ADD add days, weeks, months, and add years to a\ndate. First the module adds the specifed days and weeks, then months\nand fnally the years. \nThe input values can be both positive as well be negative. So it can also\nbe subtracted from a date.\nNote that especially for negative input values the sum of negative values,\ni.e. -3000 days does not run below 1.1.1970 because this would have an\noverfow of data type DATE and undefned values are obtained.", "type": "FUNCTION", "name": "DATE_ADD", "input": [{"name": "IDATE", "type": "DATE", "description": "The initial date to which the adjustments will be made."}, {"name": "D", "type": "INT", "description": "The number of days to add to the initial date."}, {"name": "W", "type": "INT", "description": "The number of weeks to add to the initial date."}, {"name": "M", "type": "INT", "description": "The number of months to add to the initial date."}, {"name": "Y", "type": "INT", "description": "The number of years to add to the initial date."}], "output": [], "in/out": [], "return_value": {"type": "DATE", "description": "The resulting date after the specified additions."}}
{"title": "Check if Input is Alphabetic", "description": "ISC_ALPHA tests whether the character IN is an alphabetic character. If IN\nis a sign A..Z, a..z or any umlaut, the function returns TRUE, if not the\nfunction returns FALSE. In examining the Global Setup EXTENDED_ASCII\nconstant is considered. If EXTENDED_ASCII = TRUE the extended ASCII\ncharacter-set to be considered in accordance with ISO 8859-1. Umlauts\nlike Ä, Ö, Ü are considered only if the global constant EXTENDED_ASCII =\nTRUE.\nThe following Table Explains the code:\nCode EXTENDED_ASCII = TRUE EXTENDED_ASCII = FAS￾LE 0..64 FALSE FALSE\n65..90 TRUE TRUE\n91..96 FALSE FALSE\n97..122 TRUE TRUE\n123..191 FALSE FALSE\n192..214 TRUE FALSE\n215 FALSE FALSE\n216..246 TRUE FALSE\n247 FALSE FALSE\n248..255 TRUE FALSE", "type": "FUNCTION", "name": "ISC_ALPHA", "input": [{"name": "IN", "type": "BYTE", "description": "The input byte to be checked to see if it represents an alphabet character."}], "output": [{"name": "ISC_ALPHA", "type": "BOOL", "description": "Returns true if the input byte is an alphabet character, otherwise returns false."}], "in/out": [], "return_value": {"type": "BOOL", "description": "The boolean result indicating if the input is an alphabetic character."}}
{"title": "PWM Control Function Block", "description": "CTRL_PWM converts the input value of CI (0 .1) in a pulse width modulated\noutput signal Q. When MANUAL is TRUE at the output Q the input value of\nMAN_IN is passed. CTRL_OUT can be used to build own rule modules.\nBlock diagram of CTRL_PWM:\nThe following example shows a PI controller with PWM output:", "type": "FUNCTION_BLOCK", "name": "CTRL_PWM", "input": [{"name": "CI", "type": "REAL", "description": "The control input value used for PWM calculation."}, {"name": "MAN_IN", "type": "REAL", "description": "The manual input value that can override the control input when MANUAL is true."}, {"name": "MANUAL", "type": "BOOL", "description": "A boolean flag indicating whether to use MAN_IN (true) or CI (false) for the PWM calculation."}, {"name": "F", "type": "REAL", "description": "The frequency used for PWM signal generation."}], "output": [{"name": "Q", "type": "BOOL", "description": "The output status indicating whether the PWM signal is active."}], "in/out": [], "return_value": null}
{"title": "List Cleaning Function", "description": "LIST_CLEAN cleans a list of empty elements. The list consists of Strings\n(elements) that begin with the separation character SEP.\nLIST_CLEAN('&ABC$23&&NEXT', 38) = '&ABC&23&NEXT'\nLIST_CLEAN('&&23&&NEXT&', 38) = '&23&NEXT'\nLIST_CLEAN('&&&&', 38) = ''", "type": "FUNCTION", "name": "LIST_CLEAN", "input": [{"name": "SEP", "type": "BYTE", "description": "The separator character used to determine element boundaries in the list."}], "output": [], "in/out": [{"name": "LIST", "type": "STRING[LIST_LENGTH]", "description": "The list of strings that will be cleaned. The function modifies this list in-place."}], "return_value": {"type": "BOOL", "description": "Indicates the success of the cleaning operation. The function returns TRUE upon successful completion."}}
{"title": "Ticker Function Block", "description": "TICKER generate at the output DISPLAY a running script. At the output DIS￾PLAY a substring of text with the length N is output. DISPLAY is passed to\noutput in a time frame of PT and starts at each pass from one place to the\nleft of the input string TEXT. The scrolling text is generated only when N <\nthan the length of TEXT. If N >= length of text then the String TEXT is di￾rectly represented at the output of DISPLAY.", "type": "FUNCTION_BLOCK", "name": "TICKER", "input": [{"name": "N", "type": "INT", "description": "The starting index of the ticker text to display."}, {"name": "PT", "type": "TIME", "description": "The time period for which the delay is set before the next ticker update."}], "output": [{"name": "Display", "type": "STRING[STRING_LENGTH]", "description": "The portion of text to be displayed in the ticker."}], "in/out": [{"name": "Text", "type": "STRING[STRING_LENGTH]", "description": "The full text that is processed to create the ticker display."}], "return_value": null}
{"title": "Array Addition Function", "description": "_ARRAY_ADD(ADR(Array), SIZEOF(Array), X), where array is the name of\nthe array to be manipulated. ADR() is a standard function which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. The function only returns TRUE. The array spe￾cifed by the pointer is manipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.\nCall: _ARRAY_ADD(ADR(bigarray), SIZEOF(bigarray), X)", "type": "FUNCTION", "name": "_ARRAY_ADD", "input": [{"name": "pt", "type": "POINTER TO ARRAY [0..32000] OF REAL", "description": "A pointer to the array of real numbers that will be modified."}, {"name": "size", "type": "UINT", "description": "The size of the array to determine how many elements will be processed."}, {"name": "X", "type": "REAL", "description": "The real number value to be added to each element of the array."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "A boolean value indicating the success of the operation.", "fields": []}}
{"title": "Control Input Function", "description": "CTRL_IN calculates the process deviation (SET_POINT _ ACTUAL) and pas￾ses them at the output. If the diference is less than the value at the input\nNOISE of the output remains at 0. CTRL_IN can be used to build own rule\nmodules.\nBlock diagram of CTRL_IN:", "type": "FUNCTION", "name": "CTRL_IN", "input": [{"name": "SET_POINT", "type": "REAL", "description": "The desired target value that the system aims to achieve."}, {"name": "ACTUAL", "type": "REAL", "description": "The current value of the system that is being evaluated."}, {"name": "NOISE", "type": "REAL", "description": "The acceptable range of fluctuation around the set point which will be considered as 'noise'."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated process error after applying the dead zone function.", "fields": []}}
{"title": "Parameter Set Function Block", "description": "CTRL_IN calculates the process deviation (SET_POINT _ ACTUAL) and pas￾ses them at the output. If the diference is less than the value at the input\nNOISE of the output remains at 0. CTRL_IN can be used to build own rule\nmodules.\nBlock diagram of CTRL_IN:", "type": "FUNCTION_BLOCK", "name": "PARSET", "input": [{"name": "A0", "type": "BOOL", "description": "Boolean input to select the first set of parameters."}, {"name": "A1", "type": "BOOL", "description": "Boolean input to select the second set of parameters."}, {"name": "X01", "type": "REAL", "description": "The first parameter of set 0."}, {"name": "X02", "type": "REAL", "description": "The second parameter of set 0."}, {"name": "X03", "type": "REAL", "description": "The third parameter of set 0."}, {"name": "X04", "type": "REAL", "description": "The fourth parameter of set 0."}, {"name": "X11", "type": "REAL", "description": "The first parameter of set 1."}, {"name": "X12", "type": "REAL", "description": "The second parameter of set 1."}, {"name": "X13", "type": "REAL", "description": "The third parameter of set 1."}, {"name": "X14", "type": "REAL", "description": "The fourth parameter of set 1."}, {"name": "X21", "type": "REAL", "description": "The first parameter of set 2."}, {"name": "X22", "type": "REAL", "description": "The second parameter of set 2."}, {"name": "X23", "type": "REAL", "description": "The third parameter of set 2."}, {"name": "X24", "type": "REAL", "description": "The fourth parameter of set 2."}, {"name": "X31", "type": "REAL", "description": "The first parameter of set 3."}, {"name": "X32", "type": "REAL", "description": "The second parameter of set 3."}, {"name": "X33", "type": "REAL", "description": "The third parameter of set 3."}, {"name": "X34", "type": "REAL", "description": "The fourth parameter of set 3."}, {"name": "TC", "type": "TIME", "description": "Time duration for the ramping process."}], "output": [{"name": "P1", "type": "REAL", "description": "Output parameter corresponding to the first selected set value."}, {"name": "P2", "type": "REAL", "description": "Output parameter corresponding to the second selected set value."}, {"name": "P3", "type": "REAL", "description": "Output parameter corresponding to the third selected set value."}, {"name": "P4", "type": "REAL", "description": "Output parameter corresponding to the fourth selected set value."}], "in/out": [], "return_value": {}}
{"title": "Comparison Function", "description": "CMP compares two REAL values if the frst N points are equal.", "type": "FUNCTION", "name": "CMP", "input": [{"name": "X", "type": "REAL", "description": "The first real number to be compared."}, {"name": "Y", "type": "REAL", "description": "The second real number to be compared."}, {"name": "N", "type": "INT", "description": "An integer that determines the precision for the comparison."}], "output": [{"name": "CMP", "type": "BOOL", "description": "The result of the comparison; TRUE if the absolute difference between X and Y is less than the computed threshold, FALSE otherwise."}], "in/out": [], "return_value": {"type": "BOOL", "description": "The Boolean result indicating if X and Y are considered equal within the defined precision.", "fields": []}}
{"title": "Calculate Temperature Adjustment", "description": "TEMP_SI calculates the temperature of a resistor sensor input values from\nthe RES (resistance in ohms) and RS, Resistance at TS in °C. It is specifed\nin contrast to the modules TEMP_NI and TEMP_PT with their R0 at 0°, the\nresistance RS is given in SI sensors at diferent temperatures (eg 25° C for\nKTY10). Therefore, the module has an input for RS and another for TS.\nThe calculation is done using the formula:\nRES_SI = RS + A*(T-TS) + B*(T-TS)²\nA = 7.64E-3; B = 1.66E-5\nThe calculation is suitable for temperatures from -50.. +150 °C.\n 21. Measuring Modules", "type": "FUNCTION", "name": "TEMP_SI", "input": [{"name": "Res", "type": "REAL", "description": "The resistance value input for the temperature calculation."}, {"name": "RS", "type": "REAL", "description": "The reference resistance used in the formula."}, {"name": "TS", "type": "REAL", "description": "The target temperature that influences the adjustment calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed adjusted temperature based on the inputs provided."}}
{"title": "Timing Measurement Function Block (M_TX)", "description": "M_TX determined from the input signal IN the time which the signal IN was\nTRUE (TH) and the time the signal was set to FALSE (TL). The times of TH\nand TL are only measured after a rising or falling edge. If IN is at the frst\ncall of the module already high, this is not seen as a rising edge. From the\nmeasured values of TH and TL the Duty Cycle and the frequency in Hz are\ncalculated. A Duty Cycle of 0.4 means the signal was 40% TRUE and 60%\nFALSE. Output ET of type TIME is started with each rising edge at 0 and\nruns up until the next rising edge it starts again at 0. With a TRUE at the\ninput RST, the outputs can be reset at any time to 0. The input TMAX sets,\nafter which the elapsed time at ET, the outputs automatically are reseted.\nTMAX is internally assigned a default value of T#10d and can normally be\nleft open. The input TMAX is primarily used to reset in the absence of input\nsignal for a defned time the outputs. An example of a possible application\nis to measure the speed of a wave, indicating absence of the sensor si￾gnals to the speed (frequency) 0. TMAX is used with caution because, for\nexample, a TMAX of 10 seconds at the same time limits the smallest mea￾surable frequency to 0.1 Hz.", "type": "FUNCTION_BLOCK", "name": "M_TX", "input": [{"name": "in", "type": "BOOL", "description": "The input signal to be monitored for edges (rising and falling)."}, {"name": "tmax", "type": "TIME", "description": "The maximum allowed timing duration; after this duration, the block will reset the measurements.", "fields": []}, {"name": "rst", "type": "BOOL", "description": "Reset signal to initialize the measurement outputs."}], "output": [{"name": "TH", "type": "TIME", "description": "The duration of the high state (rising edge) in time."}, {"name": "TL", "type": "TIME", "description": "The duration of the low state (falling edge) in time."}, {"name": "DC", "type": "REAL", "description": "The duty cycle computed as the ratio of the high time to the total period."}, {"name": "F", "type": "REAL", "description": "The frequency calculated based on the high and low durations."}, {"name": "ET", "type": "TIME", "description": "Elapsed time since the last rising edge."}], "in/out": [], "return_value": null}
{"title": "Convert Octal String to DWORD", "description": "OCT_TO_DWORD converts an octal encoded string into a byte\nvalue. Only the octal characters are '0 '..'7' are interpreted, others in HEX\noccurring characters are ignored.", "type": "FUNCTION", "name": "OCT_TO_DWORD", "input": [{"name": "OCT", "type": "STRING[20]", "description": "A string of octal digits that needs to be converted to a DWORD."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The converted DWORD value representing the octal input string.", "fields": []}}
{"title": "Time-based Value Storage and Retrieval", "description": "OCT_TO_DWORD converts an octal encoded string into a byte\nvalue. Only the octal characters are '0 '..'7' are interpreted, others in HEX\noccurring characters are ignored.", "type": "FUNCTION_BLOCK", "name": "FT_TN64", "input": [{"name": "in", "type": "REAL", "description": "The real input value to be stored."}, {"name": "T", "type": "TIME", "description": "The duration that determines how frequently the input values are stored."}], "output": [{"name": "out", "type": "REAL", "description": "The most recent stored input value."}, {"name": "trig", "type": "BOOL", "description": "Boolean trigger indicating that a new value has been stored."}], "in/out": [], "return_value": null}
{"title": "Count Character in String", "description": "COUNT_CHAR determines how often the sign of CHR in the string STR oc￾curs. To search for special characters and control characters, the search\ncharacter CHR is specifed as BYTE.", "type": "FUNCTION", "name": "COUNT_CHAR", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "Input variable of type STRING with the specified length."}, {"name": "chr", "type": "BYTE", "description": "Input variable of type BYTE representing the character to count."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "Returns the count of occurrences of the specified character in the string."}}
{"title": "Complex Arc Cosine Function", "description": "COUNT_CHAR determines how often the sign of CHR in the string STR oc￾curs. To search for special characters and control characters, the search\ncharacter CHR is specifed as BYTE.", "type": "FUNCTION", "name": "CACOS", "input": [{"name": "X", "type": "COMPLEX", "description": "The input complex number for which the arc cosine is to be calculated."}], "output": [{"name": "CACOS", "type": "COMPLEX", "description": "The arc cosine of the input complex number, represented as a complex number."}], "in/out": [], "return_value": {"type": "COMPLEX", "description": "The computed arc cosine value of the input complex number as a complex number.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the calculated arc cosine."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the calculated arc cosine."}]}}
{"title": "Calculate Resistance at Non-Temperature Coefficient (NTC)", "description": "RES_NTC calculated the resistance of an NTC resistance sensor from the\ninput values T (temperature in °C) and RN (resistance at 25°C). The input\nvalue B is a constant value which must be read in the data sheets of that\nsensor. Typical values are at NTC sensors 2000 - 4000 Kelvin.\nThe calculation is done using the formula:\nThe formula provides a sufcient accuracy for small temperature ranges,\neg 0-100°C. For wide temperature ranges the formula according to Stein￾hart is more suitable.", "type": "FUNCTION", "name": "RES_NTC", "input": [{"name": "T", "type": "REAL", "description": "The temperature in degrees Celsius."}, {"name": "RN", "type": "REAL", "description": "The reference resistance at a specified temperature."}, {"name": "B", "type": "REAL", "description": "The material characteristic constant for the NTC thermistor."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated resistance value based on the provided inputs."}}
{"title": "Decimal to Byte Conversion", "description": "DEC_TO_BYTE converts a decimal encoded string into a byte\nvalue. Here only decimal characters '0 '.. '9' are interpreted, others in DEC\noccurring characters are ignored .", "type": "FUNCTION", "name": "DEC_TO_BYTE", "input": [{"name": "DEC", "type": "STRING(10)", "description": "A string representation of a decimal number to be converted to byte."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "The byte representation of the input decimal string.", "fields": []}}
{"title": "3D Vector Addition", "description": "DEC_TO_BYTE converts a decimal encoded string into a byte\nvalue. Here only decimal characters '0 '.. '9' are interpreted, others in DEC\noccurring characters are ignored .", "type": "FUNCTION", "name": "V3_ADD", "input": [{"name": "A", "type": "Vector_3", "description": "The first input vector for the addition operation.", "fields": [{"name": "X", "type": "REAL", "description": "The X component of the vector A."}, {"name": "Y", "type": "REAL", "description": "The Y component of the vector A."}, {"name": "Z", "type": "REAL", "description": "The Z component of the vector A."}]}, {"name": "B", "type": "Vector_3", "description": "The second input vector for the addition operation.", "fields": [{"name": "X", "type": "REAL", "description": "The X component of the vector B."}, {"name": "Y", "type": "REAL", "description": "The Y component of the vector B."}, {"name": "Z", "type": "REAL", "description": "The Z component of the vector B."}]}], "output": [{"name": "V3_ADD", "type": "Vector_3", "description": "The resultant vector from the addition of vectors A and B.", "fields": [{"name": "X", "type": "REAL", "description": "The X component of the resultant vector."}, {"name": "Y", "type": "REAL", "description": "The Y component of the resultant vector."}, {"name": "Z", "type": "REAL", "description": "The Z component of the resultant vector."}]}], "in/out": [], "return_value": {"type": "void", "description": "The function does not return a value, but modifies the output parameter V3_ADD."}}
{"title": "List Next Function Block", "description": "LIST_NEXT always delivers the next item from a list. The list is a STRING\nwhose elements are separated with the character SEP. The frst element\nof the list has the position 1. After the frst call to LIST_NEXT or a reset, at\noutput LEL the frst element of the list is passed. For each subsequent call\nthe module returns the next element of the list. When the end of the list is\nreached, an empty string Issued and set the output NUL = TRUE. With the\ncommand RST = TRUE, the list can be edited again and again.", "type": "FUNCTION_BLOCK", "name": "LIST_NEXT", "input": [{"name": "SEP", "type": "BYTE", "description": "The separator byte used to delimit items in the list."}, {"name": "RST", "type": "BOOL", "description": "A boolean flag to reset the position in the list to the beginning."}], "output": [{"name": "LEL", "type": "STRING(LIST_LENGTH)", "description": "The output string containing the next list element extracted from the input list."}, {"name": "NUL", "type": "BOOL", "description": "A boolean flag indicating whether the list is empty or fully processed."}], "in/out": [{"name": "LIST", "type": "STRING(LIST_LENGTH)", "description": "The input string representing the entire list to be processed."}], "return_value": null}
{"title": "Extracting a Byte from a DWORD", "description": "BYTE_OF_DWORD extracts a byte (B0 .. B3) a DWORD. The individual by￾tes are selected with 0-3 at the input IN.", "type": "FUNCTION", "name": "BYTE_OF_DWORD", "input": [{"name": "in", "type": "DWORD", "description": "The DWORD value from which a byte will be extracted."}, {"name": "N", "type": "BYTE", "description": "The index of the byte to extract from the DWORD, multiplied by 8 to account for bit shifts."}], "output": [{"name": "BYTE_OF_DWORD", "type": "BYTE", "description": "The extracted byte from the specified position of the input DWORD."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The resulting byte obtained from the extraction process."}}
{"title": "Addition of Two Real2 Values", "description": "BYTE_OF_DWORD extracts a byte (B0 .. B3) a DWORD. The individual by￾tes are selected with 0-3 at the input IN.", "type": "FUNCTION", "name": "R2_ADD2", "input": [{"name": "X", "type": "REAL2", "description": "The first 'REAL2' structure that contains the first set of values to be added."}, {"name": "Y", "type": "REAL2", "description": "The second 'REAL2' structure that contains the second set of values to be added."}], "output": [], "in/out": [], "return_value": {"type": "REAL2", "description": "The 'REAL2' structure that contains the result of the addition of 'X' and 'Y'.", "fields": [{"name": "R1", "type": "REAL", "description": "The first real part of the 'REAL2' structure which is the sum of 'X.R1' and 'Y.R1'."}, {"name": "RX", "type": "REAL", "description": "The second real part of the 'REAL2' structure which is the sum of 'X.RX' and 'Y.RX'."}]}}
{"title": "Integer Truncation Function", "description": "D_TRUNC \nreviewes what result the IEC functions provides, and uses the appropriate \nfunction to deliver a useful result.\nD_TRUNC(1.6) = 1\nD_TRUNC(-1.6) = -1", "type": "FUNCTION", "name": "D_TRUNC", "input": [{"name": "X", "type": "REAL", "description": "The real number to be truncated to an integer."}], "output": [], "in/out": [], "return_value": {"type": "DINT", "description": "The truncated integer value of the input real number.", "fields": []}}
{"title": "Array Shuffle Function", "description": "_ARRAY_SHUFFLE(ADR(Array), SIZEOF(Array)), where array is the name of\nthe array to be manipulated. ADR() is a standard function, which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. The array referenced by the Pointer is manipu￾lated directly in memory and is available directly after exit the function.\nThe function _ARRAY_SHUFFLE thus changes the contents of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.\nIf an array is processed, which should not be changed, so it has to be co￾pied to a temporary array before handing over the Pointer and calling the\nfunction.", "type": "FUNCTION", "name": "_ARRAY_SHUFFLE", "input": [{"name": "pt", "type": "POINTER TO ARRAY [0..32000] OF REAL", "description": "A pointer to the array of real numbers that needs to be shuffled."}, {"name": "size", "type": "UINT", "description": "The size of the array, determining how many elements will be shuffled."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the array was shuffled successfully."}}
{"title": "Convert Geographic Coordinates to Decimal Degrees", "description": "GEO_TO_DEG calculates an angle expressed in degrees from the input\ndata level. Minutes, seconds.\nGEO_TO_DEG (2,59,60.0) is 3.0 degrees", "type": "FUNCTION", "name": "GEO_TO_DEG", "input": [{"name": "D", "type": "INT", "description": "The degree component of the geographic coordinate"}, {"name": "M", "type": "INT", "description": "The minute component of the geographic coordinate"}, {"name": "SEC", "type": "REAL", "description": "The second component of the geographic coordinate"}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The resulting decimal degrees calculated from the input geographic coordinates"}}
{"title": "Temperature Calculation Function", "description": "TEMP_NI calculates the temperature of a NI-resistance from the RES sensor\ninput values (measured resistance value) and R0 (resistance at 0°C).\nThe calculation is suitable for a temperature range of -60.. +180 ° C and\nmade by the following formal:\nRES_NI = R0 + A*T + B*T²+C*T4\nA = 0.5485; B = 0.665E-3; C = 2.805E-9\nRP\nRS\nRX\nA B", "type": "FUNCTION", "name": "TEMP_NI", "input": [{"name": "Res", "type": "REAL", "description": "The resistance value measured."}, {"name": "R0", "type": "REAL", "description": "The reference resistance value for the calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated temperature derived from the formula using Res and R0."}}
{"title": "Calculate Array Median", "description": "_ARRAY_MEDIAN calculates the median value of an arbitrary\narray of REAL. When called a pointer to the array and its size in bytes is\npassed to the function. Under CoDeSys the call reads:\n_ARRAY_MEDIAN(ADR(Array), SIZEOF(Array)), where array is the name of\nthe array to be manipulated. ADR() is a standard function, which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. In order to determine the median value the ar￾ray referenced by the pointer is sorted in the memory and remains after\nfunction end sorted. The function _ARRAY_MEDIAN thus changes the con￾tents of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.\nIf an array is processed, which should not be changed, so it has to be co￾pied to a temporary array before handing over the Pointer and calling the\nfunction.", "type": "FUNCTION", "name": "_ARRAY_MEDIAN", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "A pointer to an array of real numbers whose median is to be calculated."}, {"name": "size", "type": "UINT", "description": "The number of elements in the array pointed to by pt."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The median value of the array.", "fields": []}}
{"title": "R2_MUL Function", "description": "_ARRAY_MEDIAN calculates the median value of an arbitrary\narray of REAL. When called a pointer to the array and its size in bytes is\npassed to the function. Under CoDeSys the call reads:\n_ARRAY_MEDIAN(ADR(Array), SIZEOF(Array)), where array is the name of\nthe array to be manipulated. ADR() is a standard function, which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. In order to determine the median value the ar￾ray referenced by the pointer is sorted in the memory and remains after\nfunction end sorted. The function _ARRAY_MEDIAN thus changes the con￾tents of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.\nIf an array is processed, which should not be changed, so it has to be co￾pied to a temporary array before handing over the Pointer and calling the\nfunction.", "type": "FUNCTION", "name": "R2_MUL", "input": [{"name": "X", "type": "REAL2", "description": "Input structure containing two REAL components RX and R1 to be multiplied."}, {"name": "Y", "type": "REAL", "description": "A REAL value to multiply with the components of the structure X."}], "output": [], "in/out": [], "return_value": {"type": "REAL2", "description": "The new REAL2 structure resulting from multiplying the components of X by Y.", "fields": [{"name": "RX", "type": "REAL", "description": "The result of multiplying the RX component of X by Y."}, {"name": "R1", "type": "REAL", "description": "The result of multiplying the R1 component of X by Y."}]}}
{"title": "Range to Byte Conversion", "description": "RANGE_TO_BYTE converts a real value in a BYTE value. An input value of X\ncorresponds to the value of LOW is converted it into an output value of 0\nand an input value X of the input value corresponds to HIGH is converted\ninto an output value of 255. The input X is limited to the range from LOW\nto HIGH, an overfow of the output BYTE can therefore not happen.", "type": "FUNCTION", "name": "RANGE_TO_BYTE", "input": [{"name": "X", "type": "REAL", "description": "The real number input that is to be converted to a byte."}, {"name": "low", "type": "REAL", "description": "The lower bound of the range."}, {"name": "high", "type": "REAL", "description": "The upper bound of the range."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "The resulting byte value after the conversion from the real number based on the defined range."}}
{"title": "Integer Floor Function", "description": "FLOOR function returns the greatest integer value less or equal to X.", "type": "FUNCTION", "name": "FLOOR", "input": [{"name": "X", "type": "REAL", "description": "The real number input for which the floor value needs to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The integer floor value of the input real number X.", "fields": []}}
{"title": "Modulo Operation Function", "description": "MODR returns the remainder of a division similar to the stan￾dard MOD function, but for REAL numbers. MODR internally uses the data\nformat of type DINT. This may come to an overfow because DINT can sto￾re a maximum of +/-2.14 * 10^9 The range of MODR is therefore limited\nto +/- 2.14 * 10^9. For DIVI = 0 the function returns 0. \nMODR(A, M) = A - M * FLOOR2(A / M).", "type": "FUNCTION", "name": "MODR", "input": [{"name": "IN", "type": "REAL", "description": "The number to be divided."}, {"name": "DIVI", "type": "REAL", "description": "The divisor used for the modulo operation."}], "output": [{"name": "MODR", "type": "REAL", "description": "The result of the modulo operation."}], "in/out": [], "return_value": {"type": "REAL", "description": "The modulo result, which is either the computed modulo or zero if DIVI is zero."}}
{"title": "Clock Pulse Generator", "description": "CLK_PRG generates clock pulses with a programmable period PT. The out￾put pulses are only one PLC cycle.", "type": "FUNCTION_BLOCK", "name": "CLK_PRG", "input": [{"name": "PT", "type": "TIME", "description": "The time period for which the output pulse should remain HIGH. Default value is set to 10 milliseconds."}], "output": [{"name": "Q", "type": "BOOL", "description": "A boolean output which is HIGH when the output pulse is generated."}], "in/out": [], "return_value": null}
{"title": "Byte Reversal Function", "description": "REVERSE reverses the order of the bits in a byte. Bit7 of IN becomes bit 0,\nbit 6 to bit 1, etc.", "type": "FUNCTION", "name": "REVERSE", "input": [{"name": "IN", "type": "BYTE", "description": "The input byte value to be reversed."}], "output": [{"name": "REVERSE", "type": "BYTE", "description": "The output byte value resulting from the bitwise operations on the input byte."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The return value represents the modified byte resulting from the function's operations."}}
{"title": "Calculate Beginning of Month from a Given Date", "description": "MONTH_BEGIN calculates the date of frst Day of the current month and\ncurrent year.\nMONTH_BEGIN(D#2008-2-13) = D#2008-2-1", "type": "FUNCTION", "name": "MONTH_BEGIN", "input": [{"name": "idate", "type": "DATE", "description": "The input date from which the beginning of the month is to be calculated."}], "output": [{"name": "MONTH_BEGIN", "type": "DATE", "description": "The calculated beginning date of the month derived from the input date."}], "in/out": [], "return_value": {"type": "DATE", "description": "The date representing the start of the month for the given input date."}}
{"title": "Integrator Function Block", "description": "FT_INT is an integrator module which provides the integral of the input si￾gnal at the output. The input K is a multiplier for the output signal. Run\nswitches the integrator on if TRUE and of when FALSE. RST (reset) sets\nthe output to 0. The inputs OUT_MIN and OUT_MAX serve upper and lower\nlimits for the output of the integrator . FT_INT \nworks internally in microseconds and is thus fulfll also the requirements\nvery fast PLC controller with cycle times under one millisecond.\nA fundamental problem with integrator is the resolution.The output of type\nreal has a resolution of 7-8 points. This will result in a calculated integrati-\non step of 1 at an output value of more than one hundred million (1E8).\nThus the step can not be added up because it falls below the resolution li￾mit of a maximum of 8 points in type Real. This limitation is important\nwhen using FT_INT.\nFor example, an input signal of 0.0001 would be at a sampling time of 1\nmillisecond and a baseline of 100000 to add a value of 0.0001 * 0.001 se￾conds = 0.000001 to the baseline of 100000, which inevitably results in\nthe value of 100000 again, because the resolution of the data type Real\ncan only collect up to 8. This should be considered especially if FT_INT\nshould serve as a utility meter or similar applications.\nStructure diagram:", "type": "FUNCTION_BLOCK", "name": "FT_INT", "input": [{"name": "IN", "type": "REAL", "description": "The input value to be integrated."}, {"name": "K", "type": "REAL", "description": "The integration factor, default is set to 1."}, {"name": "RUN", "type": "BOOL", "description": "A boolean indicating whether the integration should run or not, default is TRUE."}, {"name": "RST", "type": "BOOL", "description": "A reset flag that, when TRUE, resets the output to zero."}, {"name": "OUT_MIN", "type": "REAL", "description": "The minimum limit for the output, default is set to -1E+37."}, {"name": "OUT_MAX", "type": "REAL", "description": "The maximum limit for the output, default is set to 1E+37."}], "output": [{"name": "OUT", "type": "REAL", "description": "The result of the integration process."}, {"name": "LIM", "type": "BOOL", "description": "A boolean indicating if the output has reached a limit."}], "in/out": [], "return_value": null}
{"title": "4-to-1 Multiplexer Function", "description": "FT_INT is an integrator module which provides the integral of the input si￾gnal at the output. The input K is a multiplier for the output signal. Run\nswitches the integrator on if TRUE and of when FALSE. RST (reset) sets\nthe output to 0. The inputs OUT_MIN and OUT_MAX serve upper and lower\nlimits for the output of the integrator . FT_INT \nworks internally in microseconds and is thus fulfll also the requirements\nvery fast PLC controller with cycle times under one millisecond.\nA fundamental problem with integrator is the resolution.The output of type\nreal has a resolution of 7-8 points. This will result in a calculated integrati-\non step of 1 at an output value of more than one hundred million (1E8).\nThus the step can not be added up because it falls below the resolution li￾mit of a maximum of 8 points in type Real. This limitation is important\nwhen using FT_INT.\nFor example, an input signal of 0.0001 would be at a sampling time of 1\nmillisecond and a baseline of 100000 to add a value of 0.0001 * 0.001 se￾conds = 0.000001 to the baseline of 100000, which inevitably results in\nthe value of 100000 again, because the resolution of the data type Real\ncan only collect up to 8. This should be considered especially if FT_INT\nshould serve as a utility meter or similar applications.\nStructure diagram:", "type": "FUNCTION", "name": "MUX_4", "input": [{"name": "D0", "type": "BOOL", "description": "First data input for the multiplexer."}, {"name": "D1", "type": "BOOL", "description": "Second data input for the multiplexer."}, {"name": "D2", "type": "BOOL", "description": "Third data input for the multiplexer."}, {"name": "D3", "type": "BOOL", "description": "Fourth data input for the multiplexer."}, {"name": "A0", "type": "BOOL", "description": "First select line for selecting the input."}, {"name": "A1", "type": "BOOL", "description": "Second select line for selecting the input."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "The output of the multiplexer, representing the selected boolean input."}}
{"title": "Multiply and Add Function", "description": "MUL_ADD multiplies the input value X with K and adds O.\nMUL_ADD = X * K + O.\nMUL_ADD (0.5, 10, 2) is 0.5 * 10 + 2 = 7", "type": "FUNCTION", "name": "MUL_ADD", "input": [{"name": "X", "type": "REAL", "description": "The first input value that will be multiplied."}, {"name": "K", "type": "REAL", "description": "The second input value that will multiply with X."}, {"name": "O", "type": "REAL", "description": "The value that will be added to the product of X and K."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the operation, which is the value of X multiplied by K, plus O."}}
{"title": "Proportional-Integral Controller", "description": "FT_PI is a PI controller which works following the formula:\nY = KP * IN + KI * INTEG(IN)\nThe input values ILIM_H and ILIM_L limits the working area of the internal\nintegrator. With RST, the internal Integrator can always be set to 0. The\noutput LIM indicates that the Integrator has reached one of the limits\nILIM_L oe ILIM_H. The PI controller is free running and uses the trapezoidal\nrule to calculate the integrator for the highest accuracy and optimal\nspeed. The default values of the input parameters are predefned as fol￾lows: KP = 1, CI = 1, ILIM_L= -1E38 and ILIM_H = +1E38. \nAnti Wind-Up: Control modules with Integrator tend to the so-called Wind￾Up Efect. A Wind-Up means that the integrator module continuously run\nagain because, for example, the control signal Y is at a limit and the sys￾tem can not compensate the deviation, which then leads to subsequent\ntransition into the control range until a long and time-consuming dismant￾ling of the integrator value and the scheme only respond delayed. Since\nthe integrator is only necessary to compensate the deviation for all other\ncontrol units, and the range of the integrator should be limited with the\nvalues of ILIM. The Integrator then reaches a limit and stops remaining at\nthe last valid value. For other wind- Up Action, the Integrator can be con￾trolled with the input IEN = FALSE any time separately, the Integrator only\nruns when IEN = TRUE. \nThe following graph illustrates the internal structure of the controller:\nFT_PI can be used in conjunction with the modules CTRL_IN and CTRL_OUT\nto build a PI controller.", "type": "FUNCTION_BLOCK", "name": "FT_PI", "input": [{"name": "IN", "type": "REAL", "description": "The input value to the PI controller."}, {"name": "KP", "type": "REAL", "description": "The proportional gain parameter, default is 1.0."}, {"name": "KI", "type": "REAL", "description": "The integral gain parameter, default is 1.0."}, {"name": "ILIM_L", "type": "REAL", "description": "The lower limit for the integrator output, default is -1E+38."}, {"name": "ILIM_H", "type": "REAL", "description": "The upper limit for the integrator output, default is 1E+38."}, {"name": "IEN", "type": "BOOL", "description": "Indicator to enable or disable the integrator, default is TRUE."}, {"name": "RST", "type": "BOOL", "description": "Reset signal for the integrator."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value of the PI controller after applying the gains."}, {"name": "LIM", "type": "BOOL", "description": "Indicator that shows if the integrator has reached its output limits."}], "in/out": [], "return_value": {}}
{"title": "Convert DateTime to Structured DateTime", "description": "DT_TO_SDT converts a date value into a structured date day of type SDT.", "type": "FUNCTION", "name": "DT_TO_SDT", "input": [{"name": "DTI", "type": "TIME_DT", "description": "The input DateTime value that needs to be converted into Structured DateTime."}], "output": [{"name": "DT_TO_SDT", "type": "SDT", "description": "The output Structured DateTime that contains the year, month, day, weekday, hour, minute, and second extracted from the input DateTime."}], "in/out": [], "return_value": {"type": "SDT", "description": "The return value is a Structured DateTime containing the detailed components of the input DateTime value.", "fields": [{"name": "YEAR", "type": "INT", "description": "The year component extracted from the input DateTime."}, {"name": "MONTH", "type": "INT", "description": "The month component extracted from the input DateTime."}, {"name": "DAY", "type": "INT", "description": "The day component extracted from the input DateTime."}, {"name": "WEEKDAY", "type": "INT", "description": "The weekday component extracted from the input DateTime, representing the day of the week."}, {"name": "HOUR", "type": "INT", "description": "The hour component extracted from the input DateTime."}, {"name": "MINUTE", "type": "INT", "description": "The minute component extracted from the input DateTime."}, {"name": "SECOND", "type": "INT", "description": "The second component extracted from the input DateTime."}]}}
{"title": "Decrement Function", "description": "DT_TO_SDT converts a date value into a structured date day of type SDT.", "type": "FUNCTION", "name": "DEC1", "input": [{"name": "X", "type": "INT", "description": "An integer input value that will be decremented."}, {"name": "N", "type": "INT", "description": "An integer input value used for calculation when X is zero."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The decremented integer value based on the conditions provided. Returns N - 1 if X is 0, otherwise returns X - 1."}}
{"title": "Calculate the Gold Value", "description": "GOLD calculates the result of the golden feature. GOLD (1) gives the gol￾den ratio, and GOLD (0) returns 1. GOLD (X) * GOLD (-X) is always 1. GOLD\n(X) is the positive result of the quadratic equation and -GOLD(-X) is the ne￾gative result of the quadratic equation.\nThe calculation is done using the formula:", "type": "FUNCTION", "name": "GOLD", "input": [{"name": "X", "type": "REAL", "description": "The input real number for which the Gold value will be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated Gold value based on the input X."}}
{"title": "Calculate Resistance Based on Temperature Differences", "description": "RES_SI calculates the resistance of a SI-resistance sensor from the input\nvalues T (temperature in °C) and RS, resistance at TS in °C. In contrast to\nthe modules RES_NI and RES_PT which R0 is given at 0°C, the resistance\nspecifed for RS for SI sensors at diferent temperatures (eg 25°C for\nKTY10). Therefore, the module has an input for RS and another for TS.\nThe calculation is done using the formula:\nRES_SI = RS + A*(T-TS) + B*(T-TS)²\nA = 7.64E-3\nB = 1.66E-5\nThe calculation is suitable for a temperature range of -50 .. +150°C.", "type": "FUNCTION", "name": "RES_SI", "input": [{"name": "T", "type": "REAL", "description": "The current temperature value."}, {"name": "RS", "type": "REAL", "description": "The base resistance value."}, {"name": "TS", "type": "REAL", "description": "The reference temperature value."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated resistance value based on the inputs and constants.", "fields": []}}
{"title": "Sine Wave Generator Function Block", "description": "GEN_SIN is a sine wave generator with programmable period, adjustable\namplitude and signal ofset. A special feature is a adjustable delay so that\nwith multiple generators overlapping signals can be generated. A Binary\nOutput Q passes a logical signal, which is generated phase equal to the\nsine signal. The input DL is a delay for the output signal. The Delay is spe￾cifed with DL * PT. A DL of 0.5 delays the signal by half a period. \nThe following example shows GEN_SIN with a trace recording of the sine\nsignal and the binary output Q.\nThe above example generates a sine wave with 0.1 Hz (PT = 10 s) and a\nlower peak value of 0 and upper peak value of 10.", "type": "FUNCTION_BLOCK", "name": "GEN_SIN", "input": [{"name": "PT", "type": "TIME", "description": "The period of the sine wave."}, {"name": "AM", "type": "REAL", "description": "The amplitude of the sine wave. Default is 1.0."}, {"name": "OS", "type": "REAL", "description": "The offset of the sine wave."}, {"name": "DL", "type": "REAL", "description": "The duty cycle of the sine wave, which affects the waveform shape."}], "output": [{"name": "Q", "type": "BOOL", "description": "A boolean output indicating the signal state, true if the sine wave is positive."}, {"name": "Out", "type": "REAL", "description": "The current value of the generated sine wave."}], "in/out": [], "return_value": {}}
{"title": "SHR_4UDE Function Block", "description": "GEN_SIN is a sine wave generator with programmable period, adjustable\namplitude and signal ofset. A special feature is a adjustable delay so that\nwith multiple generators overlapping signals can be generated. A Binary\nOutput Q passes a logical signal, which is generated phase equal to the\nsine signal. The input DL is a delay for the output signal. The Delay is spe￾cifed with DL * PT. A DL of 0.5 delays the signal by half a period. \nThe following example shows GEN_SIN with a trace recording of the sine\nsignal and the binary output Q.\nThe above example generates a sine wave with 0.1 Hz (PT = 10 s) and a\nlower peak value of 0 and upper peak value of 10.", "type": "FUNCTION_BLOCK", "name": "SHR_4UDE", "input": [{"name": "SET", "type": "BOOL", "description": "Control signal to set the output state."}, {"name": "D0", "type": "BOOL", "description": "Input data bit to be shifted into the register at Q0."}, {"name": "D3", "type": "BOOL", "description": "Input data bit to be shifted into the register at Q3."}, {"name": "CLK", "type": "BOOL", "description": "Clock signal for controlling the shifting operation."}, {"name": "DN", "type": "BOOL", "description": "Control signal for direct loading of data into the register."}, {"name": "RST", "type": "BOOL", "description": "Control signal to reset the output state."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output of the least significant bit of the shift register."}, {"name": "Q1", "type": "BOOL", "description": "Output of the second bit of the shift register."}, {"name": "Q2", "type": "BOOL", "description": "Output of the third bit of the shift register."}, {"name": "Q3", "type": "BOOL", "description": "Output of the most significant bit of the shift register."}], "in/out": [], "return_value": null}
{"title": "Signal Processing Block", "description": "GEN_SIN is a sine wave generator with programmable period, adjustable\namplitude and signal ofset. A special feature is a adjustable delay so that\nwith multiple generators overlapping signals can be generated. A Binary\nOutput Q passes a logical signal, which is generated phase equal to the\nsine signal. The input DL is a delay for the output signal. The Delay is spe￾cifed with DL * PT. A DL of 0.5 delays the signal by half a period. \nThe following example shows GEN_SIN with a trace recording of the sine\nsignal and the binary output Q.\nThe above example generates a sine wave with 0.1 Hz (PT = 10 s) and a\nlower peak value of 0 and upper peak value of 10.", "type": "FUNCTION_BLOCK", "name": "SIGNAL_4", "input": [{"name": "IN1", "type": "BOOL", "description": "Boolean input representing the first signal."}, {"name": "IN2", "type": "BOOL", "description": "Boolean input representing the second signal."}, {"name": "IN3", "type": "BOOL", "description": "Boolean input representing the third signal."}, {"name": "IN4", "type": "BOOL", "description": "Boolean input representing the fourth signal."}, {"name": "TS", "type": "TIME", "description": "Timestamp indicating the time at which the signals are processed."}, {"name": "S1", "type": "BYTE", "description": "Byte pattern for the first signal, initialized to 16#FF."}, {"name": "S2", "type": "BYTE", "description": "Byte pattern for the second signal, initialized to 16#F0."}, {"name": "S3", "type": "BYTE", "description": "Byte pattern for the third signal, initialized to 16#AA."}, {"name": "S4", "type": "BYTE", "description": "Byte pattern for the fourth signal, initialized to 16#A0."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output boolean indicating whether an alarm condition is present."}], "in/out": [], "return_value": null}
{"title": "Calculate End of Month Date", "description": "MONTH_END calculates the date of the last day of the current month and\ncurrent year.\nMONTH_END(D#2008-2-13) = D#2008-2-29", "type": "FUNCTION", "name": "MONTH_END", "input": [{"name": "IDATE", "type": "DATE", "description": "The input date for which the end of month is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "DATE", "description": "The last date of the month corresponding to the provided input date."}}
{"title": "Byte Swap Function", "description": "MONTH_END calculates the date of the last day of the current month and\ncurrent year.\nMONTH_END(D#2008-2-13) = D#2008-2-29", "type": "FUNCTION", "name": "SWAP_BYTE2", "input": [{"name": "IN", "type": "DWORD", "description": "The DWORD value whose bytes are to be swapped."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The resulting DWORD after the bytes have been swapped.", "fields": []}}
{"title": "Convert String to Week Representation", "description": "FSTRING_TO_WEEK decode a list of days on the form 'MO,TU,3'in a Bitpat￾tern (bit6 = MO...Bit0 = So) For the evaluation each of the frst two letters\nof the list elements are evaluated, the rest are ignored. If the string con￾tains spaces they will be removed. The days of the week can be present in\nboth upper-or lowercase. LANG specifes the language used, 1 = English, 2\n= German, 0 is the default language defned in the setup.\nMo = 1; Di, Tu = 2; We, Mi = 3; Th, Do = 4; Fr = 5; Sa = 6; So, Su = 7\nSince the function evaluates only the frst two characters, the weekdays\nmay also be spelled out (Monday) format.\nAs an alternative form, the weekday can be specifed as number 1..7.\nThe list includes the weekdays unsorted and separated by commas.\nFSTRING_TO_WEEK ('Mo,Tu,Sa',2) = 2#01100010.", "type": "FUNCTION", "name": "FSTRING_TO_WEEK", "input": [{"name": "WEEK", "type": "STRING[60]", "description": "A string containing the weekdays separated by commas."}, {"name": "LANG", "type": "INT", "description": "An integer representing the language index for weekday conversion."}], "output": [{"name": "FSTRING_TO_WEEK", "type": "BYTE", "description": "A byte value representing the converted weekdays."}], "in/out": [], "return_value": {"type": "BYTE", "description": "Returns a byte value that encodes the weekdays from the input string.", "fields": []}}
{"title": "Length Conversion Function Block", "description": "LENGTH converts diferent in common used units for units of\nlength. Normally, only the input to be converted is occupied and the re￾maining inputs remain free. However, if several inputs loaded with values,\nthe values of all inputs are converted accordingly and then summed.\n1 P = 0.376065 mm (unit from the printing industry)\n1 IN = 25,4 mm\n1 FT = 0,3048 m\n1 YD = 0,9144 m\n1 MILE = 1609,344 m\n1 SM = 1852 m\n1 FM = 1,829 m", "type": "FUNCTION_BLOCK", "name": "LENGTH", "input": [{"name": "m", "type": "REAL", "description": "Length in meters (SI base unit)."}, {"name": "p", "type": "REAL", "description": "Length in typographical points."}, {"name": "in", "type": "REAL", "description": "Length in inches."}, {"name": "ft", "type": "REAL", "description": "Length in feet."}, {"name": "yd", "type": "REAL", "description": "Length in yards."}, {"name": "mile", "type": "REAL", "description": "Length in miles."}, {"name": "sm", "type": "REAL", "description": "Length in international sea miles."}, {"name": "fm", "type": "REAL", "description": "Length in fathoms."}], "output": [{"name": "Ym", "type": "REAL", "description": "Converted length in meters."}, {"name": "Yp", "type": "REAL", "description": "Converted length in typographical points."}, {"name": "Yin", "type": "REAL", "description": "Converted length in inches."}, {"name": "Yft", "type": "REAL", "description": "Converted length in feet."}, {"name": "Yyd", "type": "REAL", "description": "Converted length in yards."}, {"name": "Ymile", "type": "REAL", "description": "Converted length in miles."}, {"name": "Ysm", "type": "REAL", "description": "Converted length in international sea miles."}, {"name": "Yfm", "type": "REAL", "description": "Converted length in fathoms."}], "in/out": [], "return_value": null}
{"title": "Cycle Time Measurement", "description": "CYCLE_TIME monitors the cycle time of a PLC and provides the user with a\nrange of information about cycle times and run times. The total number of\ncycles is also measured. Hereby, the user can, for example ensure that a\nfunction is called every 100 cycles. Control modules can report errors if\nthe cycle time is too long and therefore the control parameters can not be\nguaranteed.", "type": "FUNCTION_BLOCK", "name": "CYCLE_TIME", "input": [{"name": "RST", "type": "BOOL", "description": "A boolean flag to reset the cycle time measurements."}], "output": [{"name": "ct_min", "type": "TIME", "description": "The minimum cycle time recorded."}, {"name": "ct_max", "type": "TIME", "description": "The maximum cycle time recorded."}, {"name": "ct_last", "type": "TIME", "description": "The last cycle time measured."}, {"name": "systime", "type": "TIME", "description": "The accumulated system time."}, {"name": "sysdays", "type": "INT", "description": "The number of days accounted for in system time."}, {"name": "cycles", "type": "DWORD", "description": "The total count of cycles that have occurred."}], "in/out": [], "return_value": null}
{"title": "Set Date Function", "description": "SET_DATE calculates a Date (DATE) from the input values,\nday, month and year. SET_DATE does not test the validity of a date. For\nexample, also be February, 30th will be set, which, of course results the\n1st March or in a leap year, the March, 2nd. SET_DATE can therefore also\nbe used to generate any day of the year. This can be a quite practicable\napplication. In this case, the monthly amount may also be 0. An invalid\nmonth always gives a date in relation to January. An invalid month (month\n< 1 or month > 12) is always interpreted as January.", "type": "FUNCTION", "name": "SET_DATE", "input": [{"name": "YEAR", "type": "INT", "description": "The year of the date to be set."}, {"name": "MONTH", "type": "INT", "description": "The month of the date to be set."}, {"name": "DAY", "type": "INT", "description": "The day of the date to be set."}], "output": [], "in/out": [], "return_value": {"type": "DATE", "description": "The calculated date based on the provided year, month, and day.", "fields": []}}
{"title": "Holiday Event Checker", "description": "EVENTS shows the output Y with TRUE special days and also\nprovides the names of the events at the output NAME. EVENTS can also\ntake into account events over several days. The array ELIST name, date\nand duration of events are set.\nIn the external array ELIST can defne up to 50 such events in the followi￾ng format.\n*.NAME : STRING(30) specifes the name of the event\n*.DAY : SINT Events of the month\n*.MONTH : SINT Month of Events\n*.USE : SINT Duration of the event in days", "type": "FUNCTION_BLOCK", "name": "EVENTS", "input": [{"name": "DATE_IN", "type": "DATE", "description": "The date to check for holiday events."}, {"name": "ENA", "type": "BOOL", "description": "Enable signal to determine if the holiday event check should be processed."}], "output": [{"name": "Y", "type": "BOOL", "description": "Output indicating if a holiday event is active."}, {"name": "NAME", "type": "STRING(30)", "description": "The name of the holiday if an event is active, otherwise an empty string."}], "in/out": [{"name": "ELIST", "type": "ARRAY[0..49] OF HOLIDAY_DATA", "description": "An array of holiday data structures to check against the input date."}], "return_value": null}
{"title": "FRMP_B Function", "description": "FRMP_B calculates the value of a ramp at a given time TD. The module en￾sures that no bufer overrun or underrun can take place at the output. The\noutput value is limited in all cases to 0 .. 255. TR sets the time for a full\nramp 0 .. 255 and TD is the elapsed time. If DIR = TRUE, a rising ramp is\ncalculated and if DIR = FALSE a falling edge. With the start value an edge\ncan be calculated from any starting point.", "type": "FUNCTION", "name": "FRMP_B", "input": [{"name": "START", "type": "BYTE", "description": "The starting byte value to be used in calculations."}, {"name": "DIR", "type": "BOOL", "description": "Direction flag, where TRUE indicates an increment operation and FALSE indicates a decrement operation."}, {"name": "TD", "type": "TIME", "description": "The first time duration to be compared with TR."}, {"name": "TR", "type": "TIME", "description": "The second time duration used for comparison with TD."}], "output": [{"name": "FRMP_B", "type": "BYTE", "description": "The resulting byte value calculated based on the input parameters."}], "in/out": [], "return_value": {"type": "BYTE", "description": "This return value represents the calculated byte value based on the function logic."}}
{"title": "4-bit Latch Function Block", "description": "FRMP_B calculates the value of a ramp at a given time TD. The module en￾sures that no bufer overrun or underrun can take place at the output. The\noutput value is limited in all cases to 0 .. 255. TR sets the time for a full\nramp 0 .. 255 and TD is the elapsed time. If DIR = TRUE, a rising ramp is\ncalculated and if DIR = FALSE a falling edge. With the start value an edge\ncan be calculated from any starting point.", "type": "FUNCTION_BLOCK", "name": "LTCH_4", "input": [{"name": "D0", "type": "BOOL", "description": "First data input for the latch."}, {"name": "D1", "type": "BOOL", "description": "Second data input for the latch."}, {"name": "D2", "type": "BOOL", "description": "Third data input for the latch."}, {"name": "D3", "type": "BOOL", "description": "Fourth data input for the latch."}, {"name": "L", "type": "BOOL", "description": "Control signal that determines if the latch is transparent."}, {"name": "RST", "type": "BOOL", "description": "Asynchronous reset signal that resets the output."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output corresponding to the first data input."}, {"name": "Q1", "type": "BOOL", "description": "Output corresponding to the second data input."}, {"name": "Q2", "type": "BOOL", "description": "Output corresponding to the third data input."}, {"name": "Q3", "type": "BOOL", "description": "Output corresponding to the fourth data input."}], "in/out": [], "return_value": {}}
{"title": "Square Root to the Nth Power Calculation", "description": "SQRTN calculates the N-fold root of X as follows:", "type": "FUNCTION", "name": "SQRTN", "input": [{"name": "X", "type": "REAL", "description": "The base number for which the Nth root needs to be calculated."}, {"name": "N", "type": "INT", "description": "The exponent indicating the degree of the root to compute. Must be greater than 0."}], "output": [{"name": "SQRTN", "type": "REAL", "description": "The computed Nth root of X, or 0 if N is less than or equal to 0."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the Nth root calculation."}}
{"title": "Array Sum Function", "description": "ARRAY_SUM calculates the sum of all values of an arbitrary\narray of REAL. When called a pointer to the array and its size in bytes is\npassed to the function. Under CoDeSys the call reads:\nARRAY_SUM(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function, which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the maximum, the array refe￾renced by the pointer is scanned directly in memory. The function\nARRAY_SUM does not change the content of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_SUM", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "Pointer to the array of real numbers to be summed."}, {"name": "size", "type": "UINT", "description": "The size of the array. This indicates the number of elements in the array to be processed."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The sum of the elements of the array.", "fields": []}}
{"title": "Multiply Time by a Real Number", "description": "MULTIME function multiplies a time value with a multiplier.", "type": "FUNCTION", "name": "MULTIME", "input": [{"name": "t", "type": "TIME", "description": "The TIME value to be multiplied."}, {"name": "M", "type": "REAL", "description": "The REAL multiplier to scale the TIME value."}], "output": [], "in/out": [], "return_value": {"type": "TIME", "description": "The resulting TIME after multiplying the input TIME with the REAL multiplier.", "fields": []}}
{"title": "Increment Function with Bounds", "description": "MULTIME function multiplies a time value with a multiplier.", "type": "FUNCTION", "name": "INC2", "input": [{"name": "X", "type": "INT", "description": "The integer value to be incremented."}, {"name": "D", "type": "INT", "description": "The increment value to be added to X."}, {"name": "L", "type": "INT", "description": "The lower boundary limit for the incremented value."}, {"name": "U", "type": "INT", "description": "The upper boundary limit for the incremented value."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The incremented value of X after applying the increment D within the specified limits.", "fields": []}}
{"title": "Calculate Angle from Z-Axis", "description": "MULTIME function multiplies a time value with a multiplier.", "type": "FUNCTION", "name": "V3_ZANG", "input": [{"name": "A", "type": "Vector_3", "description": "A 3D vector containing the X, Y, and Z components."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The angle in radians between the vector and the Z-axis.", "fields": []}}
{"title": "PI Controller Function Block", "description": "FT_PIWL is a PI controller with dynamic anti-wind Up and works according\nthe following formular: \nY = KP * IN + KI * INTEG(IN)\nThe input values LIM_H and LIM_L limit the range of the output Y. With\nRST, the internal Integrator can always be set to 0. The output LIM indica￾tes that the Output Y runs to one of the limits LIM_L orL IM_H. The PI con￾troller is free running and uses the trapezoidal rule to calculate the inte￾grator for the highest accuracy and optimal speed. The default values of\nthe input parameters are predefned as follows: KP = 1, CI = 1, ILIM_L=\n-1E38 and ILIM_H = +1E38. \nAnti Wind-Up: Control modules with Integrator tend to the so-called Wind￾Up Efect. A Wind-Up means that the integrator module continuously run\nagain because, for example, the control signal Y is at a limit and the sys￾tem can not compensate the deviation, which then leads to subsequent\ntransition into the control range until a long and time-consuming dismant￾ling of the integrator value and the scheme only respond delayed. Since\nthe integrator is only necessary to compensate the deviation for all other\ncontrol units, and the range of the integrator should be limited with the\nvalues of ILIM.\nThe module FT_PIWL has a so-called dynamic-wind Up Reset which resets\nreaching a limit (LIM_L, LIM_H) the Integrator to a value corresponding of\nthe output limit. After reaching a Limits the controller re-enters the work\narea must the Integrator are not frst or Down-integrated, and the control￾ler is ready for use without delay. The dynamic Anti-Wind Up Method is\nthat in most cases without drawbacks preferred method, because it does\nnot negatively afect the control and prevents the disadvantages of\nWind_Up . \nThe following graph illustrates the internal structure of the controller:\nFT_PIWL can used together with the modules CTRL_IN and CTRL_OUT to\nbuild complex controllers.", "type": "FUNCTION_BLOCK", "name": "FT_PIWL", "input": [{"name": "IN", "type": "REAL", "description": "The input signal for the PI controller."}, {"name": "KP", "type": "REAL", "description": "The proportional gain coefficient (default is 1.0)."}, {"name": "KI", "type": "REAL", "description": "The integral gain coefficient (default is 1.0)."}, {"name": "LIM_L", "type": "REAL", "description": "The lower limit for the output signal (default is -1E+38)."}, {"name": "LIM_H", "type": "REAL", "description": "The upper limit for the output signal (default is 1E+38)."}, {"name": "RST", "type": "BOOL", "description": "A boolean flag to reset the internal state."}], "output": [{"name": "Y", "type": "REAL", "description": "The output signal from the PI controller."}, {"name": "LIM", "type": "BOOL", "description": "Indicates whether the output signal is within the defined limits."}], "in/out": [], "return_value": null}
{"title": "Check Non-Containment of Substring", "description": "IS_NCC tests whether the string STR none of the in STR listed characters\nare included. Is a character of CMP found in STR, the function returns FAL￾SE.", "type": "FUNCTION", "name": "IS_NCC", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The main string in which to search for the substring."}, {"name": "cmp", "type": "STRING[STRING_LENGTH]", "description": "The substring that needs to be checked for containment in the main string."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Boolean value indicating whether the substring is not contained in the main string. TRUE if not found; FALSE if found."}}
{"title": "4-Bit Digital Decoder", "description": "IS_NCC tests whether the string STR none of the in STR listed characters\nare included. Is a character of CMP found in STR, the function returns FAL￾SE.", "type": "FUNCTION_BLOCK", "name": "DEC_4", "input": [{"name": "D", "type": "BOOL", "description": "Data input that controls the activation of the outputs."}, {"name": "A0", "type": "BOOL", "description": "Address input bit 0."}, {"name": "A1", "type": "BOOL", "description": "Address input bit 1."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal 0, active when D is TRUE, A0 is FALSE, and A1 is FALSE."}, {"name": "Q1", "type": "BOOL", "description": "Output signal 1, active when D is TRUE, A0 is TRUE, and A1 is FALSE."}, {"name": "Q2", "type": "BOOL", "description": "Output signal 2, active when D is TRUE, A0 is FALSE, and A1 is TRUE."}, {"name": "Q3", "type": "BOOL", "description": "Output signal 3, active when D is TRUE, A0 is TRUE, and A1 is TRUE."}], "in/out": [], "return_value": null}
{"title": "Array Multiplication Function", "description": "_ARRAY_MUL multiply each element of an arbitrary array of\nREAL with the value X. When called a Pointer to the array and its size in\nbytes is passed to the function. Under CoDeSys the call reads:\n_ARRAY_MUL(ADR(Array), SIZEOF(Array), X), where array is the name of\nthe array to be manipulated. ADR() is a standard function which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. The function only returns TRUE. The array spe￾cifed by the pointer is manipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.\nCall: _ARRAY_MUL(ADR(bigarray), SIZEOF(bigarray), X)", "type": "FUNCTION", "name": "_ARRAY_MUL", "input": [{"name": "pt", "type": "POINTER TO ARRAY [0..32000] OF REAL", "description": "A pointer to the array of real numbers that will be modified."}, {"name": "size", "type": "UINT", "description": "The size of the array indicating how many elements are present."}, {"name": "X", "type": "REAL", "description": "The real number by which each element of the array will be multiplied."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE to indicate successful completion of the multiplication operation."}}
{"title": "ESR Data Collection Function Block", "description": "ESR_COLLECT collects ESR data from up to 8 ESR modules and stores the\nlog in an array. The output POS indicates the position at which in the array\nESR_OUT is currently the last message is ESR. Collects the module more\nthan 64 messages so the messages are discarded and restarted at positi￾on 0. With the asynchronous reset input, the device can be reset at any\ntime. By resetting, all the collected data will be deleted and the pointer is\nmoved to -1. The module collects data in the output array ESR_OUT and\nmoves POS the last position of the array that contains data. When there\nare no messages POS remains to -1. If the output data are read, the varia￾ble POS has to be set to -1, or if only readed a part POS can be set to the\nlast valid value.\nThe following example demonstrates how ESR_COLLECT is connected with\nESR modules.\nThe output ESR_OUT is made up as follows:\n.\nTYPE\n.ADRESS .DS .TS .DATA [0..7]\n1 Label Date TIME Status, 1 Byte ESR Error\n2 Label Date TIME Status, 1 Byte ESR Status\n3 Label Date TIME Status, 1 Byte ESR Debug\n10 Label Date TIME not used Boolean input low transition\n11 Label Date TIME not used Boolean input high transi￾tion\n20 Label Date TIME Byte 0 - 3 Real Value Real Value change\nThe ESR data includes the following:\nESR_DATA.TYP Data type, see table above\nESR_DATA.ADRESS up to 10 characters long String Identifer \nESR_DATA.DS Date stamp of type TIME DATA\nESR_DATA.TS Timestamp of type TIME (PLC Timer ) \nESR_DATA.DATA up to 8 bytes of data block", "type": "FUNCTION_BLOCK", "name": "ESR_COLLECT", "input": [{"name": "ESR_0", "type": "ARRAY[0..3] OF esr_data", "description": "First array of ESR data containing up to 4 elements."}, {"name": "ESR_1", "type": "ARRAY[0..3] OF esr_data", "description": "Second array of ESR data containing up to 4 elements."}, {"name": "ESR_2", "type": "ARRAY[0..3] OF esr_data", "description": "Third array of ESR data containing up to 4 elements."}, {"name": "ESR_3", "type": "ARRAY[0..3] OF esr_data", "description": "Fourth array of ESR data containing up to 4 elements."}, {"name": "ESR_4", "type": "ARRAY[0..3] OF esr_data", "description": "Fifth array of ESR data containing up to 4 elements."}, {"name": "ESR_5", "type": "ARRAY[0..3] OF esr_data", "description": "Sixth array of ESR data containing up to 4 elements."}, {"name": "ESR_6", "type": "ARRAY[0..3] OF esr_data", "description": "Seventh array of ESR data containing up to 4 elements."}, {"name": "ESR_7", "type": "ARRAY[0..3] OF esr_data", "description": "Eighth array of ESR data containing up to 4 elements."}, {"name": "rst", "type": "BOOL", "description": "A boolean flag to reset the output position."}], "output": [{"name": "ESR_OUT", "type": "ARRAY[0..31] OF esr_data", "description": "Output array containing up to 32 collected ESR data elements."}], "in/out": [{"name": "pos", "type": "INT", "description": "Current position index for output storage, can be modified to determine where to place the next valid ESR data."}], "return_value": null}
{"title": "Quadratic Function Calculator", "description": "F_QUAD = A * X² + B * X + C)\nF_QUAD calculates the result of a quadratic equation using the formula\nf_QUAD = A * X ² + B * X + C.", "type": "FUNCTION", "name": "F_QUAD", "input": [{"name": "X", "type": "REAL", "description": "The value of the variable X for which the quadratic function is calculated."}, {"name": "A", "type": "REAL", "description": "The coefficient A in the quadratic equation."}, {"name": "B", "type": "REAL", "description": "The coefficient B in the quadratic equation."}, {"name": "C", "type": "REAL", "description": "The coefficient C in the quadratic equation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed value of the quadratic function based on the input parameters X, A, B, and C."}}
{"title": "Sequencer Function Block", "description": "F_QUAD = A * X² + B * X + C)\nF_QUAD calculates the result of a quadratic equation using the formula\nf_QUAD = A * X ² + B * X + C.", "type": "FUNCTION_BLOCK", "name": "SEQUENCE_8", "input": [{"name": "in0", "type": "BOOL", "description": "Input signal for step 0 activation."}, {"name": "in1", "type": "BOOL", "description": "Input signal for step 1 activation."}, {"name": "in2", "type": "BOOL", "description": "Input signal for step 2 activation."}, {"name": "in3", "type": "BOOL", "description": "Input signal for step 3 activation."}, {"name": "in4", "type": "BOOL", "description": "Input signal for step 4 activation."}, {"name": "in5", "type": "BOOL", "description": "Input signal for step 5 activation."}, {"name": "in6", "type": "BOOL", "description": "Input signal for step 6 activation."}, {"name": "in7", "type": "BOOL", "description": "Input signal for step 7 activation."}, {"name": "start", "type": "BOOL", "description": "Start signal to initialize the sequence."}, {"name": "rst", "type": "BOOL", "description": "Reset signal to reset the sequence state."}, {"name": "wait0", "type": "TIME", "description": "Wait time before executing step 0."}, {"name": "delay0", "type": "TIME", "description": "Delay time after completing step 0."}, {"name": "wait1", "type": "TIME", "description": "Wait time before executing step 1."}, {"name": "delay1", "type": "TIME", "description": "Delay time after completing step 1."}, {"name": "wait2", "type": "TIME", "description": "Wait time before executing step 2."}, {"name": "delay2", "type": "TIME", "description": "Delay time after completing step 2."}, {"name": "wait3", "type": "TIME", "description": "Wait time before executing step 3."}, {"name": "delay3", "type": "TIME", "description": "Delay time after completing step 3."}, {"name": "wait4", "type": "TIME", "description": "Wait time before executing step 4."}, {"name": "delay4", "type": "TIME", "description": "Delay time after completing step 4."}, {"name": "wait5", "type": "TIME", "description": "Wait time before executing step 5."}, {"name": "delay5", "type": "TIME", "description": "Delay time after completing step 5."}, {"name": "wait6", "type": "TIME", "description": "Wait time before executing step 6."}, {"name": "delay6", "type": "TIME", "description": "Delay time after completing step 6."}, {"name": "wait7", "type": "TIME", "description": "Wait time before executing step 7."}, {"name": "delay7", "type": "TIME", "description": "Delay time after completing step 7."}, {"name": "stop_on_error", "type": "BOOL", "description": "Flag to indicate if the sequence should stop on error."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output for step 0."}, {"name": "Q1", "type": "BOOL", "description": "Output for step 1."}, {"name": "Q2", "type": "BOOL", "description": "Output for step 2."}, {"name": "Q3", "type": "BOOL", "description": "Output for step 3."}, {"name": "Q4", "type": "BOOL", "description": "Output for step 4."}, {"name": "Q5", "type": "BOOL", "description": "Output for step 5."}, {"name": "Q6", "type": "BOOL", "description": "Output for step 6."}, {"name": "Q7", "type": "BOOL", "description": "Output for step 7."}, {"name": "QX", "type": "BOOL", "description": "Any output active indicator."}, {"name": "run", "type": "BOOL", "description": "Indicator if the sequencer is currently running."}, {"name": "step", "type": "INT", "description": "Current step of the sequence."}, {"name": "status", "type": "BYTE", "description": "Current status of the sequencer."}], "in/out": [], "return_value": {}}
{"title": "UML Character Replacement Function", "description": "REPLACE_UML replaces umlauts with a combination of two characters so\nthat the result contains no more umlauts. The large and small letters are\nconsidered here. If a word is all upper case and is an umlaut is mentioned,\nthis is replaced by a capital letter followed by a lowercase letter, in the\ncase of a ß which has no capitals there will always be replaced with two\nsmall letters. If the function REPLACE_UML is used on a uppercase word,\nthen it must be ensured using the function UPPERCASE() that all capital\nletters that the lower case are again converted to uppercase.\nÄ > Ae, Ö > Oe, Ü > Ue, ä > ae, ö > oe, ü > oe, ß > ss.", "type": "FUNCTION", "name": "REPLACE_UML", "input": [{"name": "str", "type": "STRING", "description": "The input string that may contain umlaut characters which need to be replaced."}], "output": [], "in/out": [], "return_value": {"type": "STRING", "description": "The output string after replacing umlaut characters, with appropriate handling for non-umlaut characters.", "fields": []}}
{"title": "Tuning Function Block", "description": "TUNE sets, using up and down buttons, an output signal Y. By correspon￾ding setup variables, the increment will be programmed individually. An\nupper and lower limit for the output Y can be specifed by LIMIT_L and LI￾MIT_H . with the buttons SU and SD up or down steps are generated. If a\nkey is held down longer than the time T1, then the output Y is continuously\nadjusted up or down. The speed, which with the output is adjusted here, is\ngiven by S1. S1 and S2 indicate the units per second. Is a button held\ndown longer than the time T2, the device automatically switches to a se￾cond speed S2. With the inputs RST and SET the output can at any time be\nadjusted by RST_VAL resp. SET_VAL to a predetermined value.", "type": "FUNCTION_BLOCK", "name": "TUNE", "input": [{"name": "SET", "type": "BOOL", "description": "A boolean flag to set the value of Y to SET_val."}, {"name": "SU", "type": "BOOL", "description": "A boolean flag indicating a request to increment the value of Y slowly."}, {"name": "SD", "type": "BOOL", "description": "A boolean flag indicating a request to decrement the value of Y slowly."}, {"name": "RST", "type": "BOOL", "description": "A boolean flag to reset the value of Y to RST_val."}, {"name": "SS", "type": "REAL", "description": "A real number representing the step size for slow adjustments, default value is 0.1."}, {"name": "Limit_L", "type": "REAL", "description": "The lower limit for the output value Y."}, {"name": "LIMIT_H", "type": "REAL", "description": "The upper limit for the output value Y, default value is 100.0."}, {"name": "RST_val", "type": "REAL", "description": "The value to set Y to when RST is true."}, {"name": "SET_val", "type": "REAL", "description": "The value to set Y to when SET is true, default value is 100.0."}, {"name": "T1", "type": "TIME", "description": "The duration for the slow ramp operation, default value is 500 ms."}, {"name": "T2", "type": "TIME", "description": "The duration for the fast ramp operation, default value is 2 s."}, {"name": "S1", "type": "REAL", "description": "The step size for the slow ramp up operation, default value is 2.0."}, {"name": "S2", "type": "REAL", "description": "The step size for the fast ramp up operation, default value is 10.0."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value that is adjusted based on the input states and limits."}], "in/out": [], "return_value": null}
{"title": "Complex Power Calculation", "description": "CPOW calculates the power of two Complex numbers, CPOW = X^Y.", "type": "FUNCTION", "name": "CPOW", "input": [{"name": "X", "type": "Complex", "description": "The base complex number that is to be raised to a power."}, {"name": "Y", "type": "Complex", "description": "The exponent complex number that indicates the power to which X is raised."}], "output": [{"name": "CPOW", "type": "complex", "description": "The result of raising the complex number X to the power of the complex number Y."}], "in/out": [], "return_value": {"type": "complex", "description": "The calculated complex power result of X raised to Y."}}
{"title": "M_D Function Block", "description": "M_D measures the time between a rising edge of START and a rising edge \non STOP. PT is the result of the last measurement. Output ET is the elapsed \ntime since the last rising edge of START. M_d requires a rising edge to start \nthe measurement. If at the frst call already START is TRUE, it is not seen \nas a rising edge. Even if STOP is TRUE, a rising edge of START is not \ncounted. Only when all start conditions (STOP = FALSE, RST: = FALSE and \nrising edge at START) are present, the output RUN gets TRUE and a \nmeasurement is started. With TRUE at the input RST, the outputs can \nalways be reset to 0. If ET reaches the value of TMAX, automatically a \nreset is generated in the module to reset all outputs to 0. TMAX is \ninternally assigned with default value of T#10d and normally can be \nunconnected. TMAX serves to defne a maximum value range for PT. The \noutput RUN is TRUE if is a measurement is processed.", "type": "FUNCTION_BLOCK", "name": "M_D", "input": [{"name": "start", "type": "BOOL", "description": "A boolean input to start the timer."}, {"name": "stop", "type": "BOOL", "description": "A boolean input to stop the timer."}, {"name": "tmax", "type": "TIME", "description": "The maximum preset time for the timer, defaults to 14400 minutes."}, {"name": "rst", "type": "BOOL", "description": "A boolean input to reset the timer."}], "output": [{"name": "PT", "type": "TIME", "description": "The preset time that has been set or retained when stopping."}, {"name": "ET", "type": "TIME", "description": "The elapsed time counted while the timer is running."}, {"name": "run", "type": "BOOL", "description": "A boolean output indicating whether the timer is currently running."}], "in/out": [], "return_value": null}
{"title": "Calculate Geometric Average of an Array", "description": "ARRAY_GAV calculates the median value of an arbi￾trary array of REAL. When called, a pointer to the array and its size in by￾tes is passed to the function. Under CoDeSys the call reads:\nARRAY_GAV(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the maximum, the array refe￾renced by the pointer is scanned directly in memory. The function\nARRAY_GAV does not change the content of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_GAV", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "A pointer to the array of real numbers whose geometric average is to be calculated."}, {"name": "size", "type": "UINT", "description": "The size of the array, indicating how many elements are present."}], "output": [{"name": "ARRAY_GAV", "type": "REAL", "description": "The computed geometric average of the array. Returns 0.0 if any array element is non-positive."}], "in/out": [], "return_value": {"type": "REAL", "description": "The geometric average of the input array computed from the positive elements.", "fields": []}}
{"title": "Inverse Function", "description": "INV calculates the inverse of X:", "type": "FUNCTION", "name": "INV", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the inverse is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed inverse of the input value X.", "fields": []}}
{"title": "Resistance Temperature Detector Calculation", "description": "RES_PT calculates the resistance of a PT resistance sensor from the input\nvalues T (temperature in °C) and R0 (resistance at 0°C).\nThe calculation is done using the formula:\nfor temperatures > 0 °C\nRES_PT = R0 * (1 + A*T + B*T²)\nand for temperatures below 0 ° C\nRES_PT = R0 * (1 + A*T + B*T² + C*(T-100)*T³\nA = 3.90802E-3\nB = -5.80195E-7\nC = -427350E-12\nThe calculation is suitable for temperatures from -200.. +850°C.", "type": "FUNCTION", "name": "RES_PT", "input": [{"name": "T", "type": "REAL", "description": "The temperature in degrees Celsius for which the resistance is to be calculated."}, {"name": "R0", "type": "REAL", "description": "The reference resistance of the Pt100 sensor at 0 degrees Celsius."}], "output": [{"name": "RES_PT", "type": "REAL", "description": "The calculated resistance of the Pt100 sensor based on the input temperature and reference resistance."}], "in/out": [], "return_value": {"type": "REAL", "description": "The resistance value computed from the input parameters for a Pt100 sensor."}}
{"title": "Linear Interpolation Function", "description": "LINEAR_INT is a linear interpolation module. A characteristic is described\nby a maximum of 20 coordinate values (X, Y) and is cut up to 19 linear\nsegments. The defnition of the coordinate values is passed in an array\nwhich describes the characteristic with individual X, Y describes value\npairs. The value pairs must be sorted by the x_value. If an X value is called\noutside range which is described by the value pairs, then the frst respecti￾ve last linear segment is extrapolated and the corresponding value Issued.\nTo keep the number of defnition points fexible, at the input PTS is given\nthe number of points. The possible score is in the range from 3 to 20, whe￾rein each individual dot is shown with X-and Y-value.", "type": "FUNCTION", "name": "LINEAR_INT", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the linear interpolation is to be calculated."}, {"name": "XY", "type": "ARRAY[1..20, 0..1] OF REAL", "description": "A two-dimensional array containing the points for interpolation, where each row represents a point with X and Y coordinates."}, {"name": "Pts", "type": "INT", "description": "The number of points defined in the XY array that should be used for interpolation."}], "output": [{"name": "LINEAR_INT", "type": "REAL", "description": "The result of the linear interpolation calculation for the given input X."}], "in/out": [], "return_value": {"type": "REAL", "description": "The real number result obtained from the linear interpolation."}}
{"title": "Celsius to Fahrenheit Conversion Function", "description": "C_TO_F converts a temperature reading from Celsius to Fahrenheit.", "type": "FUNCTION", "name": "C_TO_F", "input": [{"name": "celsius", "type": "REAL", "description": "The temperature value in degrees Celsius to be converted to Fahrenheit."}], "output": [{"name": "C_TO_F", "type": "REAL", "description": "The temperature value in degrees Fahrenheit obtained from the conversion."}], "in/out": [], "return_value": {"type": "REAL", "description": "The converted temperature value in degrees Fahrenheit.", "fields": []}}
{"title": "A_TRIG Function Block", "description": "A_TRIG monitors an input value on change and every time when the input\nvalue changes by more than RES, the module generates an output pulse\nfor a cycle so that the new value can be processed. At the same time, the\ndevice remembers the current input value with which it compares with the\ninput IN at the next cycle. At the output D the diference between IN and\nthe stored value is displayed.", "type": "FUNCTION_BLOCK", "name": "A_TRIG", "input": [{"name": "IN", "type": "REAL", "description": "The current input value to be evaluated."}, {"name": "RES", "type": "REAL", "description": "The threshold value for the change detection."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output indicating whether a significant change has occurred."}, {"name": "D", "type": "REAL", "description": "The calculated difference between the current input and the last input."}], "in/out": [], "return_value": null}
{"title": "Sensor Intensity Calculation", "description": "SENSOR_INT calculate the sensor resistance, taking into account the para￾sitic resistances, which usually afect the measurement. The A / D conver￾ter measures either current at a fxed voltage or voltage at a fxed current.\nThe resulting resistance is not only the resistance of the sensor, but is\ncomposed of the resistance of the sensor and two parasitic resistances RS\nand RP. Since the parasitic resistances remain constant, they can be com￾pensated and the real resistance of the sensor can be calculated.\nBetween the terminals A and B measured resistance (measured by current\nand voltage) is a total resistance of the sensor resistance in parallel to the\nparasitic resistance RP and the line resistance RS. RS and RP, are compen￾sated the real resistance RX is calculated. The modules can TEMP_ then be\ncalculated as the exact temperature.", "type": "FUNCTION", "name": "SENSOR_INT", "input": [{"name": "Voltage", "type": "REAL", "description": "The voltage input to the function."}, {"name": "Current", "type": "REAL", "description": "The current input to the function."}, {"name": "RP", "type": "REAL", "description": "The parallel resistance value used in the calculation."}, {"name": "RS", "type": "REAL", "description": "The series resistance value used in the calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated sensor intensity value.", "fields": []}}
{"title": "Calculate Day of the Week", "description": "DAY_OF_WEEK week from the date of receipt\nIDATE.\nMonday = 1 .. Sunday = 7 The calculation is done in accordance with\nISO8601.", "type": "FUNCTION", "name": "DAY_OF_WEEK", "input": [{"name": "IDATE", "type": "DATE", "description": "The input date for which the day of the week is to be calculated."}], "output": [{"name": "DAY_OF_WEEK", "type": "INT", "description": "An integer representing the day of the week, where 1 corresponds to Sunday."}], "in/out": [], "return_value": {"type": "INT", "description": "The day of the week as an integer.", "fields": []}}
{"title": "Compute Complex Hyperbolic Cosine", "description": "CCOSH calculates the hyperbolic cosine of a complex number", "type": "FUNCTION", "name": "CCOSH", "input": [{"name": "X", "type": "COMPLEX", "description": "A complex number for which the hyperbolic cosine is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The hyperbolic cosine of the input complex number.", "fields": [{"name": "re", "type": "real", "description": "The real part of the hyperbolic cosine."}, {"name": "im", "type": "real", "description": "The imaginary part of the hyperbolic cosine."}]}}
{"title": "Real to String Formatting Function", "description": "REAL_TO_STRF converts a REAL value to a string with a fxed number of\ndecimal N. At the conversion entirely in a normal number format XXX.NNN\nis converted. At the conversion IN is rounded to N digits after the decimal\npoint and then converted into a String to the format XXX.NNN. When N =\n0, the REAL number is rounded to 0 digits after the decimal point and the\nresult is passed as an integer without a point and decimal places. If the\nnumber IN is less than, as with N decimal places can be captured, a zero is\npassed. The decimal places are always flled up to N digits with zeros. The\nmaximum string length is 20 digits. The D input determines which charac￾ter represents the decimal point.", "type": "FUNCTION", "name": "REAL_TO_STRF", "input": [{"name": "IN", "type": "REAL", "description": "The real number to be converted to a string."}, {"name": "N", "type": "INT", "description": "The number of decimal places to round the real number to. Must be limited to the range 0..7."}, {"name": "D", "type": "STRING[1]", "description": "The character to be used as the decimal separator."}], "output": [{"name": "REAL_TO_STRF", "type": "string", "description": "The resulting string representation of the real number."}], "in/out": [], "return_value": {"type": "string", "description": "The string representation of the real number after conversion and formatting."}}
{"title": "Toggle Function Block", "description": "TOGGLE is a edge-triggered Toggle Flip -Flop with asynchronous reset \ninput. The TOGGLE Flip Flop invertes output Q on a rising edge of CLK. The \noutput changes on each rising edge of CLK his condition.\n 18. Signal Generators", "type": "FUNCTION_BLOCK", "name": "TOGGLE", "input": [{"name": "CLK", "type": "BOOL", "description": "Clock input signal used for toggling the output state."}, {"name": "rst", "type": "BOOL", "description": "Reset input signal that sets the output Q to false when high."}], "output": [{"name": "Q", "type": "BOOL", "description": "Current state of the output signal, toggled based on the CLK input."}], "in/out": [], "return_value": null}
{"title": "Cyclic Redundancy Check (CRC) Generator", "description": "CRC_GEN generates a CRC check sum of an arbitrarily large array of Bytes.\nWhen the function is called a Pointer is passed on the processed array and\nits size in bytes. In CoDeSys the call reads: CRC_GEN(ADR(array),\nSIZEOF(Array),...), where array is the name of the processed array. ADR is\na standard function, the Pointer the array is determined and SIZEOF is a\nstandard function, which determines the size of the array. The polynomial\ncan be any polynomials up to a maximum of 32 bits in length. A polynomi￾al X³ + X² + 1 is represented by 101 (1*X³ + 1*X² + 0+X¹ + 1*X⁰). The\nmost signifcant bit, in this case 1*X³ is not specifed in the polynomial, be￾cause it is always one. It can process up polynomials to X³² (CRC 32). By\nthe value INIT, the CR can be passed a starting value. Usually are here are\n0000 and FFFF. The appropriate start value is the standard in the litera￾ture, \"Direct Initial Value\". The input XOR_OUT determines with which bit\nsequence with the checksum at the end of XOR is associated with. The in￾puts and REV_IN REV_OUT set the bit sequence of data. If REV_IN = TRUE,\neach byte with LSB beginning is processed, if REV_IN = FALSE with MSB is\nstarted. REV_OUT = TRUE turns the bit corresponding sequence to the\nchecksum. The module requires a minimum length of the processed data\nof 4 bytes, and is limited up only by the maximum array size. \nThe CRC further down in the following table provides detailed information\non common CRC's and the setup data for CRC_GEN. Due to the number of\npossible and even common CRC's, it is not possible for us to show a com￾plete list.\nFor further research, the website http://regregex.bbcmicro.net/crc-cata￾logue.htm is recommended. \nOnline test calculations are possible for the following Java Tool:\nhttp://zorc.breitbandkatze.de/crc.html \nCommon CRC'S AND polynomials:\nCRC PL PN [Hex] INIT [Hex] REV\nIN\nREV\nOU\nT\nXOUT [Hex]\nCRC-3/ROHC 3 3 7 T T 0\nCRC-4/ITU 4 3 0 T T 0\nCRC-5/EPC 5 9 9 F F 0\nCRC-5/ITU 5 15 0 T T 0\nCRC-5/USB 5 5 1F T T 1F\nCRC-6/DARC 6 19 0 T F 0\nCRC-6/ITU 6 3 0 T T 0\nCRC-7 7 9 0 F F 0\nCRC-7/ROHC 7 4F 7F T T 0\nCRC-8 8 7 0 F F 0\nCRC-8/DARC 8 39 0 T T 0\nCRC-8/I-CODE 8 1D FD F F 0\nCRC-8/ITU 8 7 0 F F 55\nCRC-8/MAXIM 8 31 0 T T 0\nCRC-8/ROHC 8 7 FF T T 0\nCRC-8/WCDMA 8 9B 0 T T 0\nCRC-10 10 233 0 F F 0\nCRC-11 11 385 1A F F 0\nCRC-12/3GPP 12 80F 0 F T 0\nCRC-12/DECT 12 80F 0 F F 0\nCRC-14/DARC 14 805 0 T T 0\nCRC-15 15 4599 0 F F 0\nCRC-16/LHA 16 8005 0 T T 0\nCRC-16/CCITT-AUG 16 1021 1D0F F F 0\nCRC-16/BUYPASS 16 8005 0 F F 0\nCRC-16/CCITT-FALSE 16 1021 FFFF F F 0\nCRC-16/DDS 16 8005 800D F F 0\nCRC-16/DECT-R 16 589 0 F F 1\nCRC-16/DECT-X 16 589 0 F F 0\nCRC-16/DNP 16 3D65 0 T T FFFF\nCRC-16/EN13757 16 3D65 0 F F FFFF\nCRC-16/GENIBUS 16 1021 FFFF F F FFFF\nCRC-16/MAXIM 16 8005 0 T T FFFF\nCRC-16/MCRF4XX 16 1021 FFFF T T 0\nCRC-16/RIELLO 16 1021 B2AA T T 0\nCRC-16/T10-DIF 16 8BB7 0 F F 0\nCRC-16/TELEDISK 16 A097 0 F F 0\nCRC-16/USB 16 8005 FFFF T T FFFF\nCRC-16/CCITT-TRUE 16 1021 0 T T 0\nCRC-16/MODBUS 16 8005 FFFF T T 0\nCRC-16/X-25 16 1021 FFFF T T FFFF\nCRC-16/XMODEM 16 1021 0 F F 0\nCRC-24/OPENPGP 24 864CFB B704CE F F 0\nCRC-24/FLEXRAY-A 24 5D6DCB FEDCBA F F 0\nCRC-24/FLEXRAY-B 24 5D6DCB ABCDEF F F 0\nCRC-32/PKZIP 32 04C11DB7 FFFFFFFF T T FFFFFFFF\nCRC-32/BZIP2 32 04C11DB7 FFFFFFFF F F FFFFFFFF\nCRC-32/CASTAGNOLI 32 1EDC6F41 FFFFFFFF T T FFFFFFFF\nCRC-32/D 32 A833982B FFFFFFFF T T FFFFFFFF\nCRC-32/MPEG2 32 04C11DB7 FFFFFFFF F F 0\nCRC-32/POSIX 32 04C11DB7 0 F F FFFFFFFF\nCRC-32/Q 32 814141AB 0 F F 0\nCRC-32/JAM 32 04C11DB7 FFFFFFFF T T 0\nCRC-32/XFER 32 AF 0 F F 0", "type": "FUNCTION", "name": "CRC_GEN", "input": [{"name": "PT", "type": "POINTER TO ARRAY[0..32000] OF BYTE", "description": "Pointer to the input byte array that needs CRC generation."}, {"name": "SIZE", "type": "INT", "description": "Size of the input byte array, must be at least 4 bytes."}, {"name": "PL", "type": "INT", "description": "Polynomial degree which defines the CRC configuration."}, {"name": "PN", "type": "DWORD", "description": "Polynomial value used for CRC calculation."}, {"name": "INIT", "type": "DWORD", "description": "Initial value for the CRC calculation."}, {"name": "REV_IN", "type": "BOOL", "description": "Flag indicating whether to reverse the input bytes before processing."}, {"name": "REV_OUT", "type": "BOOL", "description": "Flag indicating whether to reverse the output CRC value."}, {"name": "XOR_OUT", "type": "DWORD", "description": "Value to XOR with the final CRC result."}], "output": [{"name": "CRC_GEN", "type": "DWORD", "description": "The resulting CRC value after processing the input byte array."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Returns the calculated CRC value.", "fields": []}}
{"title": "Convert Hours to Time", "description": "HOUR_TO_TIME calculates a time value (TIME) from the input\nvalue in hours as REAL.", "type": "FUNCTION", "name": "HOUR_TO_TIME", "input": [{"name": "IN", "type": "REAL", "description": "The input value representing time in hours."}], "output": [], "in/out": [], "return_value": {"type": "TIME", "description": "The converted time in the TIME format.", "fields": []}}
{"title": "Random Number Generation Function", "description": "HOUR_TO_TIME calculates a time value (TIME) from the input\nvalue in hours as REAL.", "type": "FUNCTION", "name": "RDM2", "input": [{"name": "last", "type": "INT", "description": "An integer input used to generate the random number."}, {"name": "low", "type": "INT", "description": "The lower bound of the range for the random number generation."}, {"name": "high", "type": "INT", "description": "The upper bound of the range for the random number generation."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The generated random integer within the specified range from 'low' to 'high'."}}
{"title": "SINC Function", "description": "SINC calculates the sine Kardinalis or the gap function.\nMit SINC(0) = 1.", "type": "FUNCTION", "name": "SINC", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the sine calculation is to be performed."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the sine calculation, or 1.0 if the input value is zero."}}
{"title": "Complex Arc Sine Function", "description": "CASIN calculates the arc sine of a complex number\nThe range of values of the result is between [-/2,+/2 ] For the imagina￾ry part.", "type": "FUNCTION", "name": "CASIN", "input": [{"name": "X", "type": "complex", "description": "Input variable of type complex, representing the complex number for which the arc sine will be calculated."}], "output": [{"name": "CASIN", "type": "complex", "description": "Output variable of type complex, representing the arc sine of the input complex number X."}], "in/out": [], "return_value": {"type": "complex", "description": "The resulting complex number from the computation of the arc sine.", "fields": [{"name": "re", "type": "real", "description": "The real part of the resulting complex number."}, {"name": "im", "type": "real", "description": "The imaginary part of the resulting complex number."}]}}
{"title": "Bit Load Function", "description": "BIT_LOAD_B copies the bit at VAL to the bit in the position N in byte IN.\nThe least signifcant bit B0 is described by the position 0.", "type": "FUNCTION", "name": "BIT_LOAD_B", "input": [{"name": "IN", "type": "BYTE", "description": "The input BYTE value that will be modified."}, {"name": "VAL", "type": "BOOL", "description": "A boolean flag that determines whether to set or clear the bit at the specified position."}, {"name": "POS", "type": "INT", "description": "The position of the bit in the BYTE that needs to be set or cleared."}], "output": [{"name": "BIT_LOAD_B", "type": "BYTE", "description": "The modified BYTE after the bit operation."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The value of the modified BYTE after the operation.", "fields": []}}
{"title": "CLK_PULSE Function Block", "description": "CLK_PULSE generates a defned number of clock pulses with a program￾mable duty cycle. PT defnes the duty cycle and N is the number of gene￾rated pulses. WIth a reset input RST, the generator can be restarted at\nany time. The output CNT counts the pulses generated and RUN = TRUE\nindicates that the generator currently generate pulses. An input value N =\n0 generates an infnite pulse series, the maximum number of pulses is li￾mited to 32767.\nThe following example shows an application of CLK_PULSE for the produc￾tion of 7 pulses with a duty cycle of 100 ms.\nThe trace recording, shows how the RESET (green) is inactive and thus\nRUN (red) is active. The generator generates then 7 pulses (blue), as spe￾cifed at the input N. The output CNT counts from 1 on the frst pulse to 7\nby the last pulse. After the end of the sequence RUN is inactive again and\nthe cycle is complete until it is started by a new reset.", "type": "FUNCTION_BLOCK", "name": "CLK_PULSE", "input": [{"name": "PT", "type": "TIME", "description": "The time period for generating each pulse."}, {"name": "N", "type": "INT", "description": "The number of pulses to generate. A value of 0 means continuous pulses."}, {"name": "RST", "type": "BOOL", "description": "A reset flag to initialize the pulse generation process."}], "output": [{"name": "Q", "type": "BOOL", "description": "Indicates when a pulse is generated (TRUE during a pulse)."}, {"name": "CNT", "type": "INT", "description": "Counts the number of pulses generated."}, {"name": "RUN", "type": "BOOL", "description": "Indicates if pulse generation is currently running."}], "in/out": [], "return_value": {}}
{"title": "D_TRIG Function Block", "description": "D_TRIG triggers on any change in the DWORD-input IN. If the input \nvalue has changed, the output Q for a PLC cycle is set to TRUE and the \noutput X indicates how much has changed in the IN input. The input and \noutput are of type DWORD. The input can also process WORD and BYTE \ntypes. With output X it should be noted that DWORD is unsigned and \ntherefore a change of -1 at the input is not -1, but the number 2^32-2 at \nthe output. With the standard function DWORD_TO_INT the output X can \nbe converted to an integer, which displays also negative changes correctly.\nThe following example shows the application of D_TRIG when the input\nchanges value from 5 to 2:", "type": "FUNCTION_BLOCK", "name": "D_TRIG", "input": [{"name": "in", "type": "DWORD", "description": "Current input value to be monitored."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output flag indicating whether the input has changed since the last scan."}, {"name": "X", "type": "DWORD", "description": "Output value that represents the difference between the current input and the last input."}], "in/out": [], "return_value": null}
{"title": "Binary to Byte Conversion", "description": "BIN_TO_BYTE converts a binary encoded string in a BYTE va￾lue. There, this method only binary characters are '0 'and '1' is interpre￾ted, others in BIN occurring characters are ignored.", "type": "FUNCTION", "name": "BIN_TO_BYTE", "input": [{"name": "BIN", "type": "STRING(12)", "description": "A binary string consisting of '0's and '1's with a maximum length of 12 characters."}], "output": [{"name": "BIN_TO_BYTE", "type": "BYTE", "description": "The resulting byte value obtained from the binary string."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The byte value that represents the input binary string.", "fields": []}}
{"title": "Convert Direction to Degrees", "description": "DIR_TO_DEG converts a NNE direction in the form to degrees. It will be up\nto 3 points evaluated, corresponding to a resolution of 22.5°. The output is\ninteger. The input must be in capital letters and East must be marked with\nO or E. The string NO is converted to 45°. L specifes the used language,\nfor detailed information see data type CONSTANTS_LANGUAGE.\nThe cardinal points are: 0° = North, 90° = East, 180° = South, 270° =\nWest. The conversion is done according to the following table:\nN 0° NNO, NNE 23° NO 45° ONO, ENE 68°\nO 90° OSO, ESE 113° SO, SE 135° SSO, SSE 158°\nS 180° SSW 203° SW 225° WSW 248°\nW 270° WNW 293° NW 315° NNW 338°", "type": "FUNCTION", "name": "DIR_TO_DEG", "input": [{"name": "DIR", "type": "STRING[3]", "description": "A string representation of the direction, limited to three characters."}, {"name": "L", "type": "INT", "description": "An integer indicating the language option, used for direction localization."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The degree representation of the input direction calculated as per the language-specific mapping.", "fields": []}}
{"title": "Character Replacement Function", "description": "REPLACE_CHARS replaces all the characters STR in String SRC with the\ncharacters at the same place in REP.\nexample: REPLACE_CHARS('abc123', '0123456789', ABCDEFGHIJ') = 'ab￾cABC'", "type": "FUNCTION", "name": "REPLACE_CHARS", "input": [{"name": "STR", "type": "STRING", "description": "The string in which the replacement will occur."}, {"name": "SRC", "type": "STRING", "description": "The substring to be replaced in STR."}, {"name": "REP", "type": "STRING", "description": "The substring that will replace occurrences of SRC."}], "output": [{"name": "REPLACE_CHARS", "type": "STRING", "description": "The resulting string after replacement operations."}], "in/out": [], "return_value": {"type": "string", "description": "The modified string after replacing characters according to the defined rules."}}
{"title": "Filter Dynamics with Time Integration", "description": "FILTER_DW is a flter of the frst degree for 32-bit DWORD data. The main\napplication is the fltering of sensor signals for noise reduction. The basic\nfunctionality of a flter of the frst degree can be found in the module\nFT_PT1.", "type": "FUNCTION_BLOCK", "name": "FILTER_DW", "input": [{"name": "X", "type": "DWORD", "description": "Input value to be filtered."}, {"name": "T", "type": "TIME", "description": "Time interval over which the integration is computed."}], "output": [{"name": "Y", "type": "DWORD", "description": "The filtered output value."}], "in/out": [], "return_value": {}}
{"title": "Input Control Function for ISC", "description": "ISC_CTRL tests whether a sign IN is a control character, if IN is a controll\ncharacter, the function returns TRUE, if not the function returns FALSE.\nControl characters are all characters with code < 32 or 127.", "type": "FUNCTION", "name": "ISC_CTRL", "input": [{"name": "IN", "type": "BYTE", "description": "A byte input value that will be evaluated by the function."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the input IN is less than 32 or equal to 127; otherwise, returns FALSE."}}
{"title": "First-order Transfer Function with Time Constant", "description": "ISC_CTRL tests whether a sign IN is a control character, if IN is a controll\ncharacter, the function returns TRUE, if not the function returns FALSE.\nControl characters are all characters with code < 32 or 127.", "type": "FUNCTION_BLOCK", "name": "FT_PT1", "input": [{"name": "in", "type": "REAL", "description": "The input signal for the transfer function."}, {"name": "T", "type": "TIME", "description": "The time constant for the transfer function."}, {"name": "K", "type": "REAL", "description": "The gain factor applied to the input signal. Default value is 1.0."}], "output": [{"name": "out", "type": "REAL", "description": "The output signal of the transfer function."}], "in/out": [], "return_value": null}
{"title": "METER Function Block", "description": "METER is a meter, the two independent inputs (M1 and M2) are added up\nover time. The counting is controlled the inputs I1 and I2. With the reset\ninput RST the counter can be reset at any time. The value of M1 is added\nto the output value per second as long as I1 is TRUE analogous the value\nof M2 is added per second to output value if I2 is TRUE. If I1 and I2 TRUE,\nthe value of M1 + M2 is added per seconds once to the output. The input\nD Splits the output MX. Thus i.e. watt-hours can be counted instead of\nwatt-seconds. The module uses internally the OSCAT specifc data type\nREAL2 which allows a resolution of 15 digits. This the module can capture\nsmallest consumption levels at the inputs of M1 and M2 with short cycle ti￾mes and add them up to high overall values at the output MX. The resolu￾tion of the block can be determined as follows. MX is defned as I/O and\nmust be placed on an external variable of type REAL. The external variable\ncan be declared as retentive and/or persistent in order to obtain the value\nin case of power failure.\nMX/10^15 corresponds to the minimum resolution at the inputs M1 and\nM2.", "type": "FUNCTION_BLOCK", "name": "METER", "input": [{"name": "M1", "type": "REAL", "description": "First measurement input."}, {"name": "M2", "type": "REAL", "description": "Second measurement input."}, {"name": "I1", "type": "BOOL", "description": "Boolean indicator for the first measurement."}, {"name": "I2", "type": "BOOL", "description": "Boolean indicator for the second measurement."}, {"name": "D", "type": "REAL", "description": "Divisor used for calculations, defaults to 1.0."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to initialize measured values."}], "output": [{"name": "MX", "type": "REAL", "description": "Current output value reflecting the consumption measurement."}], "in/out": [], "return_value": null}
{"title": "Convert Degrees to Radians with Modulo Operation", "description": "RAD function converts an angle value from degrees to radians. Taking\ninto account that the DEG will not be greater than 360. If DEG is greater\nthan 360, 360 is to be subtracted as long as DEG is again between 0-360\n°.\nRAD(0) = 0 RAD(180) = π\nRAD(360) = 0 RAD(540) = π", "type": "FUNCTION", "name": "RAD", "input": [{"name": "DEG", "type": "REAL", "description": "Degrees as input variable."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated radians value, constrained to be within the range [0, 2PI]."}}
{"title": "Replace All Occurrences of a Substring", "description": "REPLACE_ALL replaces all occurring strings SRC in the string STR with REP.\nAn empty string SRC gives no results.", "type": "FUNCTION", "name": "REPLACE_ALL", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The original string in which occurrences of the source substring will be replaced."}, {"name": "src", "type": "STRING[STRING_LENGTH]", "description": "The substring that needs to be replaced in the original string."}, {"name": "rep", "type": "STRING[STRING_LENGTH]", "description": "The substring that will replace each occurrence of the source substring."}], "output": [{"name": "REPLACE_ALL", "type": "string", "description": "The modified string after all occurrences of the source substring have been replaced."}], "in/out": [], "return_value": {"type": "string", "description": "The final string resulting from the replacement of all occurrences."}}
{"title": "Fractional Part Calculation", "description": "FRACT(3.14) results 0.14.\nFor X greater than or less than +/- 2.14 * 10^9 Fract always provides a\nzero return. As the resolution of a 32bit REAL is a maximum of 8 digits,\nfrom numbers larger or smaller than +/- 2.14 * 10^9 no fractional part can\nbe determined, because this part can also not be stored in a REAL varia￾ble.", "type": "FUNCTION", "name": "FRACT", "input": [{"name": "x", "type": "REAL", "description": "The real number from which the fractional part is to be calculated."}], "output": [{"name": "FRACT", "type": "REAL", "description": "The calculated fractional part of the input number, or 0 if the absolute value of the input number is greater than or equal to 2 billion."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the fractional component of the input real number."}}
{"title": "Complex Conjugate Function", "description": "CCON calculated the conjugation of a complex number\nCCON.RE = X.RE\nCCON.IM = -X.IM", "type": "FUNCTION", "name": "CCON", "input": [{"name": "X", "type": "COMPLEX", "description": "The input complex number for which the conjugate is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The complex conjugate of the input complex number.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the complex conjugate."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the complex conjugate, which is the negation of the input's imaginary part."}]}}
{"title": "Find First Non-Numeric Character", "description": "FINDB_NONUM STR searches from right to left and returns\nthe last position which is not a number.\nNumbers are the letters \"0..9\" and \".\"", "type": "FUNCTION", "name": "FINDB_NONUM", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The string in which to search for a non-numeric character."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The position of the first non-numeric character found in the string. Returns 0 if no non-numeric character is found.", "fields": []}}
{"title": "Scale a Value between Two Ranges", "description": "SCALE_D scales an input value DWORD and calculates an output value in\nREAL. The input value X is limited here to I_LO and I_HI. SCALE_D (IN, 0,\n8191, 0, 100) scales an input with 14 bit resolution to the output 0..100.\nSCALE_D can also be negative and have a negative slope work at output\nvalues, and the values I_LO and I_HI must always be specifed that ILO <\nI_HI is.", "type": "FUNCTION", "name": "SCALE_D", "input": [{"name": "X", "type": "DWORD", "description": "The input value to be scaled."}, {"name": "I_LO", "type": "DWORD", "description": "The lower limit of the input range."}, {"name": "I_HI", "type": "DWORD", "description": "The upper limit of the input range."}, {"name": "O_LO", "type": "REAL", "description": "The lower limit of the output range."}, {"name": "O_HI", "type": "REAL", "description": "The upper limit of the output range."}], "output": [{"name": "SCALE_D", "type": "REAL", "description": "The scaled output value based on the input range and output range."}], "in/out": [], "return_value": {"type": "REAL", "description": "The function returns the scaled value."}}
{"title": "1D Timer Function Block", "description": "SCALE_D scales an input value DWORD and calculates an output value in\nREAL. The input value X is limited here to I_LO and I_HI. SCALE_D (IN, 0,\n8191, 0, 100) scales an input with 14 bit resolution to the output 0..100.\nSCALE_D can also be negative and have a negative slope work at output\nvalues, and the values I_LO and I_HI must always be specifed that ILO <\nI_HI is.", "type": "FUNCTION_BLOCK", "name": "TP_1D", "input": [{"name": "IN", "type": "BOOL", "description": "A boolean input signal that starts the timing process when true."}, {"name": "PT1", "type": "TIME", "description": "The time duration that determines how long the output Q remains true after the input IN is activated."}, {"name": "PTD", "type": "TIME", "description": "The delay time which controls when output W is activated after the input has been processed."}, {"name": "RST", "type": "BOOL", "description": "A boolean reset input that, when true, resets the outputs and internal states."}], "output": [{"name": "Q", "type": "BOOL", "description": "The boolean output indicating the active state based on the input and time conditions."}, {"name": "W", "type": "BOOL", "description": "The boolean output indicating the delayed state which activates after the PTD time if conditions are met."}], "in/out": [], "return_value": null}
{"title": "UTC to Local Time Conversion", "description": "UTC_TO_LTIME calculates from the universal time at\ninput UTC the local time (LOCAL_DT), with automatic daylight saving time\nif DST_ENABLE is set to True. If DST_ENABLE is FALSE, the local time is cal￾culated without daylight saving.\nThis function module requires UTC at the input, which is normally provided\nby the PLC and can be read by a routine of the manufacturer. \nThe following example an application for a WAGO 750-841 CPU is shown.\nThe reading of the internal clock is done by the manufacturer SYSRTCGET￾TIME routine. The PLC clock must be in this case set to UTC.", "type": "FUNCTION", "name": "UTC_TO_LTIME", "input": [{"name": "UTC", "type": "DT", "description": "The UTC date and time to be converted."}, {"name": "DST_ENABLE", "type": "BOOL", "description": "A boolean flag indicating whether daylight saving time adjustments should be applied."}, {"name": "TIME_ZONE_OFFSET", "type": "INT", "description": "The time zone offset in minutes to be applied to the UTC time."}], "output": [{"name": "UTC_TO_LTIME", "type": "DT", "description": "The converted local time in date and time format."}], "in/out": [], "return_value": {"type": "DT", "description": "The function returns the local time corresponding to the input UTC time after applying the necessary adjustments for the time zone and DST.", "fields": []}}
{"title": "Convert BCD to Integer", "description": "BCDC_TO_INT converts a BCD coded input BYTE in an integer value.", "type": "FUNCTION", "name": "BCDC_TO_INT", "input": [{"name": "IN", "type": "BYTE", "description": "A BYTE input representing the BCD value to be converted."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The resulting integer value derived from the given BCD input."}}
{"title": "Temperature Conversion from Kelvin to Celsius", "description": "K_TO_C converts a temperature reading from Kelvin in Celsius.", "type": "FUNCTION", "name": "K_TO_C", "input": [{"name": "Kelvin", "type": "REAL", "description": "The temperature value in Kelvin that needs to be converted to Celsius."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The converted temperature value in Celsius.", "fields": []}}
{"title": "TONOF Function Block", "description": "TONOF creates a ON delay T1 and an OFF delay T2\nThe rising edge of the input signal IN is delayed by T1 and the falling edge\nof IN is delayed by T2.", "type": "FUNCTION_BLOCK", "name": "TONOF", "input": [{"name": "IN", "type": "BOOL", "description": "The boolean input signal that triggers the timer."}, {"name": "T_ON", "type": "TIME", "description": "The time duration for which the output remains active when the input is true."}, {"name": "T_OFF", "type": "TIME", "description": "The time duration for which the output remains inactive when the input is false."}], "output": [{"name": "Q", "type": "BOOL", "description": "The boolean output signal indicating the state after applying the timing logic."}], "in/out": [], "return_value": null}
{"title": "AOUT1 Function Specification", "description": "TONOF creates a ON delay T1 and an OFF delay T2\nThe rising edge of the input signal IN is delayed by T1 and the falling edge\nof IN is delayed by T2.", "type": "FUNCTION", "name": "AOUT1", "input": [{"name": "in", "type": "REAL", "description": "The input real value that will be processed to compute the output."}, {"name": "Bit_0", "type": "INT", "description": "The starting bit position for the output value. This is a constant input."}, {"name": "Bit_N", "type": "INT", "description": "The ending bit position for the output value, defaulting to 31."}, {"name": "sign", "type": "INT", "description": "The sign bit indicator, defaulting to 255."}, {"name": "low", "type": "REAL", "description": "The minimum value that input is limited to."}, {"name": "high", "type": "REAL", "description": "The maximum value available, defaulting to 10.0."}], "output": [{"name": "AOUT1", "type": "DWORD", "description": "The calculated DWORD output value based on the processed input."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Returns the calculated DWORD output value."}}
{"title": "Buffer to String Conversion", "description": "BUFFER_TO_STRING (ADR (Array),\nSIZEOF (ARRAY), START, STOP), ARRAY is the name of the array. ADR() is a\nstandard function which identifes the pointer to the array and SIZEOF() is\na standard function, which determines the size of the array. The function\nreturns the string copied from the bufer as STRING. This type of proces￾sing arrays is very efcient because no additional memory is required and\nno surrender values must be copied.", "type": "FUNCTION", "name": "BUFFER_TO_STRING", "input": [{"name": "PT", "type": "POINTER TO ARRAY [0..32767] OF BYTE", "description": "A pointer to the byte array that contains the data to be converted to a string."}, {"name": "SIZE", "type": "UINT", "description": "The total size of the byte array pointed to by PT."}, {"name": "START", "type": "UINT", "description": "The starting index in the byte array from which to begin the conversion."}, {"name": "STOP", "type": "UINT", "description": "The stopping index in the byte array at which to end the conversion."}], "output": [{"name": "string", "type": "string", "description": "The resulting string obtained from the specified range of the byte buffer."}], "in/out": [], "return_value": {"type": "string", "description": "The final string after converting the bytes from the buffer.", "fields": []}}
{"title": "Find Last Numeric Character in String", "description": "FINDB_NUM searches STR from right to left and returns the\nlast position that is a number.\nNumbers are the letters \"0..9\" and \".\"", "type": "FUNCTION", "name": "FINDB_NUM", "input": [{"name": "str", "type": "STRING", "description": "Input variable of type STRING with a specified length.", "fields": []}], "output": [{"name": "FINDB_NUM", "type": "INT", "description": "The position of the last numeric character or period in the input string, or 0 if none exists.", "fields": []}], "in/out": [], "return_value": {"type": "INT", "description": "The return value indicates the position of the last numeric character or period found in the string.", "fields": []}}
{"title": "STAIR2 Function Block", "description": "FINDB_NUM searches STR from right to left and returns the\nlast position that is a number.\nNumbers are the letters \"0..9\" and \".\"", "type": "FUNCTION_BLOCK", "name": "STAIR2", "input": [{"name": "X", "type": "REAL", "description": "The input real value that needs to be rounded."}, {"name": "D", "type": "REAL", "description": "The step size for the rounding operation. Must be a positive real number to perform the stair-step calculation."}], "output": [{"name": "Y", "type": "REAL", "description": "The output real value after applying the stair-step rounding logic based on inputs X and D."}], "in/out": [], "return_value": null}
{"title": "String to DWORD Conversion Function", "description": "FSTRING_TO_DWORD converts a formatted string to a 32bit Value. It sup￾ports following input formats:\n2#0101 (binary), 8#345 (octal), 16#2a33 (hexadecimal) and 234 (deci￾mal).", "type": "FUNCTION", "name": "FSTRING_TO_DWORD", "input": [{"name": "IN", "type": "STRING[40]", "description": "The input string which can represent a number in binary, octal, hexadecimal, or decimal format."}], "output": [{"name": "FSTRING_TO_DWORD", "type": "DWORD", "description": "The DWORD representation of the input string after conversion from its specified format."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Returns the converted DWORD value from the input string.", "fields": []}}
{"title": "Average Calculation Function Block", "description": "FT_AVG calculates a moving average over each of\nthe last N values. By the input RST, the stored values can be deleted. N is\ndefned from 0 .. 32. N = 0 means that the output signal = input signal. N\n= 5 is the average over the last 5 values. The average is calculated over a\nmaximum of 32 values. With input E can be control when the input is read.\nThis allows a simple way to connect a sample and a hold module, such as\nSH_1 with FT_AVG can be linked. The frst call to FT_AVG the bufer load\nthe input signal to avoid that a Ramp-up takes place. \nThe following example reads SH_1 once a second the input value Signal_In\nand passes these values once per second to FT_AVG, which then forms out\nof the last 8 values the mean value.", "type": "FUNCTION_BLOCK", "name": "FT_AVG", "input": [{"name": "IN", "type": "REAL", "description": "The input real value to be averaged."}, {"name": "E", "type": "BOOL", "description": "Enable signal to control the calculation of the average, defaults to TRUE."}, {"name": "N", "type": "INT", "description": "The number of cycles for which the average is calculated, limited to a maximum of 32."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to initialize the buffer with the actual input value instead of zero."}], "output": [{"name": "AVG", "type": "REAL", "description": "The computed average of the input values over the specified cycles."}], "in/out": [], "return_value": null}
{"title": "Calculation of Solar Times", "description": "SUN_TIME is a astro timer. It calculates sunrise and \nsunset for any day, defned by the input UTC. In addition to sunrise and \nsunset, the time of the solar azimuth (daily peak in the south) and the \nsolar angle above the horizon in the azimuth is calculated. This SUN_TIME \nwill work regardless of the site all the time is calculated in UTC (Universal \nTime) and can again be converted to local time as needed. In addition, to \nthe times of sunrise and sunset, the module also calculates the angle of \nthe sun above the horizon SUN_DECLINATION. SUN_TIME uses a complex \nalgorithm to minimize the loading of a PLC as low as possible, the values \nshould be calculated with SUN_TIME only once per day. SUN_TIME is used \nfor the control of blinds, in order to pull up just before sunrise and enjoy in \nthe bedroom the twilight. Other applications are include controlling \nirrigation in horticulture to using the sunrise and sunset or even for \ntracking solar panels. Further calculations of Sun's position is provided by \nthe module SUN_POS. SUN_TIME is only in latitudes between 65°S and \n65°North is available. The output MIDDAY passes, at what time the sun is \nthe south and SUN_DECLINATION stating the angle above the horizon in \ndegrees.", "type": "FUNCTION_BLOCK", "name": "SUN_TIME", "input": [{"name": "LATITUDE", "type": "REAL", "description": "Latitude of geographical position in degrees."}, {"name": "LONGITUDE", "type": "REAL", "description": "Longitude of geographical position in degrees."}, {"name": "UTC", "type": "DATE", "description": "World time in UTC format."}, {"name": "H", "type": "REAL", "description": "Height above horizon for sunrise, default value is -0.83333333333."}], "output": [{"name": "MIDDAY", "type": "TOD", "description": "Astrological midday in hours when sun stands at south direction."}, {"name": "SUN_RISE", "type": "TOD", "description": "Sunrise time for the current day in local time."}, {"name": "SUN_SET", "type": "TOD", "description": "Sunset time for the current day in local time."}, {"name": "SUN_DECLINATION", "type": "REAL", "description": "Sun declination above horizon at midday in degrees."}], "in/out": [], "return_value": {}}
{"title": "Convert Byte to UML Representation", "description": "TO_UML converts individual characters of the character set to greater than\n127 in a combination of two letters. It is here the extended ASCII character\nset ISO 8859-1 (Latin1).\nIt will be converted the following characters:\nÄ >> Ae ä >> ae Ö >> Oe ö >> oe Ü >> Ue ü >> ue\nß >> ss\nAll other characters are returned as a string with the character IN.", "type": "FUNCTION", "name": "TO_UML", "input": [{"name": "IN", "type": "BYTE", "description": "A BYTE input that represents a character in a specific encoding."}], "output": [{"name": "TO_UML", "type": "string", "description": "The UML representation of the input byte, transformed according to predefined rules."}], "in/out": [], "return_value": {"type": "string", "description": "The resulting UML string representation of the input BYTE."}}
{"title": "Calculate Days in Year", "description": "DAYS_IN_YEAR function calculates the number of days in the current\nyear.", "type": "FUNCTION", "name": "DAYS_IN_YEAR", "input": [{"name": "IDATE", "type": "DATE", "description": "The date for which the number of days in the year needs to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The number of days in the year corresponding to the given date (365 or 366)."}}
{"title": "Scale Input Values with Offset", "description": "DAYS_IN_YEAR function calculates the number of days in the current\nyear.", "type": "FUNCTION", "name": "SCALE_X2", "input": [{"name": "IN1", "type": "BOOL", "description": "First boolean selector for input selection."}, {"name": "IN2", "type": "BOOL", "description": "Second boolean selector for input selection."}, {"name": "K", "type": "REAL", "description": "Scaling factor applied to the selected inputs."}, {"name": "O", "type": "REAL", "description": "Offset added to the result after scaling."}, {"name": "IN1_MIN", "type": "REAL", "description": "Minimum value for input 1 when selected."}, {"name": "IN1_MAX", "type": "REAL", "description": "Maximum value for input 1 when selected. Default is 1000.0.", "fields": []}, {"name": "IN2_MIN", "type": "REAL", "description": "Minimum value for input 2 when selected."}, {"name": "IN2_MAX", "type": "REAL", "description": "Maximum value for input 2 when selected. Default is 1000.0.", "fields": []}], "output": [{"name": "SCALE_X2", "type": "REAL", "description": "The resultant value after scaling and applying the offset."}], "in/out": [], "return_value": {"type": "REAL", "description": "The final calculated value after processing the input parameters.", "fields": []}}
{"title": "RMP Next Function Block", "description": "_RMP_NEXT follows at the output OUT to the input signal IN with the in TR\nand TF defned rising or falling fanks. Unlike RMP_SOFT the fank of\nRMP_NEXT runs until it underrun or overrun the endpoint and is therefore\nsuitable for control tasks. Changing the value of IN so a rising ramp with\nTR or a falling fank with TF starts at the output OUT until the value of OUT\nhas overrun or underrun the IN. The output then remains at this value. The\noutputs of UP and DN shows just whether a rising or a falling edge are\ncreated. The output DIR indicates the direction of change at IN, if IN is not\nchanged, the output remains at the last state. The lock time TL determi￾nes the delay time between the direction reversal.\nThe following graph shows the waveform at OUT when changing the input\nsignal at IN:", "type": "FUNCTION_BLOCK", "name": "_RMP_NEXT", "input": [{"name": "E", "type": "BOOL", "description": "Enable/disable input, with initial value set to TRUE."}, {"name": "IN", "type": "BYTE", "description": "Current input value for the ramp control."}, {"name": "TR", "type": "TIME", "description": "Time duration for ramping state when moving upwards."}, {"name": "TF", "type": "TIME", "description": "Time duration for ramping state when moving downwards."}, {"name": "TL", "type": "TIME", "description": "Lock time duration for the ramp."}], "output": [{"name": "DIR", "type": "BOOL", "description": "Indicates the direction of ramping; upwards if TRUE."}, {"name": "UP", "type": "BOOL", "description": "Output indicating if the ramp is moving upwards."}, {"name": "DN", "type": "BOOL", "description": "Output indicating if the ramp is moving downwards."}], "in/out": [{"name": "OUT", "type": "BYTE", "description": "Current output value that can be modified by the function block."}], "return_value": null}
{"title": "FF_RSE Function Block", "description": "FF_RSE an edge-triggered RS fip-fop. The output Q is set by a rising edge\nof CS and cleared by a rising edge on CR. If both edges (CS and CR) rise at\nthe same time, the output is set to FALSE. An asynchronous reset input\nRST sets the output at any time to FALSE.", "type": "FUNCTION_BLOCK", "name": "FF_RSE", "input": [{"name": "CS", "type": "BOOL", "description": "Clock signal input, triggers a transition on the rising edge."}, {"name": "CR", "type": "BOOL", "description": "Reset signal input, sets the output Q to FALSE on the rising edge."}, {"name": "RST", "type": "BOOL", "description": "Asynchronous reset signal to set output Q to FALSE immediately."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output signal representing the state of the flip-flop (TRUE or FALSE)."}], "in/out": [], "return_value": null}
{"title": "Dead Band Calculation Function", "description": "DEAD_BAND is a linear transfer function with dead zone. The function mo￾ves the positive part of the curve to -L and the negative part of the curve\nby +L. DEAD_BAND is used to flter a quantization noise and other noise\ncomponents from a signal. DEAD_BAND, for example, is used in control\nsystems in order to prevent that the controller permanently switches in\nsmall increments, while the actuator is overstressed and worn out.\nDEAD_BAND = X - SGN(X)*L if ABS(X)> L if ABS(X) > L \nDEAD_BAND = 0 if ABS(X) <= L", "type": "FUNCTION", "name": "DEAD_BAND", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the dead band is calculated."}, {"name": "L", "type": "REAL", "description": "The limit value used to determine the dead band thresholds."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated dead band value based on the input conditions."}}
{"title": "Inverse Hyperbolic Cosine Calculation", "description": "ACOSH calculates the arcus hyperbolic cosine of the following formula:", "type": "FUNCTION", "name": "ACOSH", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the inverse hyperbolic cosine is to be calculated. This value must be greater than or equal to 1."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the inverse hyperbolic cosine calculation.", "fields": []}}
{"title": "Ceiling Function", "description": "CEIL function returns the smallest integer value greater or equal than\nX.", "type": "FUNCTION", "name": "CEIL", "input": [{"name": "X", "type": "REAL", "description": "A real number input for which the ceiling value is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The ceiling value of the input real number X, representing the smallest integer greater than or equal to X."}}
{"title": "Time to DWORD Conversion with Offset and Debugging", "description": "T_PLC_US returns the current internal PLC time in microseconds. This has\nnothing to do with a possibly existing clock (Real Time Module), but is the\ninternal Timer of a PLC that is used as a time reference. \nThe source code of the module has the following characteristics:\nFUNCTION T_PLC_US : DWORD\nVAR CONSTANT\nDEBUG : BOOL := FALSE;\nN : INT := 0;\nOFFSET := 0;\nEND_VAR\nVAR\nTEMP : DWORD := 1;\nEND_VAR\nT_PLC_US := TIME_TO_DWORD(TIME())*1000;\nIF DEBUG THEN\nT_PLC_US := SHL(T_PLC_US,N) OR SHL(TEMP,N)-1 + OFFSET;\nEND_IF;\nIn normal operation, the module reads the function TIME() the internal\nTimer of the PLC. Since the internal Timer of the PLC works according to\nIEC standard with 1 millisecond resolution, the read value is multiplied by\n1000 to deliver the value in micro-seconds back. This function was created\nfor compatibility reasons in that way, to provide microseconds timer for\ncontrols, that has a resolution no better than milliseconds, which can then\nbe used in other modules. If the existing PLC supports microseconds, this\nfunction can easily be adjusted only at this point and the accuracy chan￾ges by this simple patch for all the modules that call this feature. The soft￾ware remains portable and future proof. Already, virtually all PLC control￾lers support a resolution in microseconds. This will however not be read\nusing standard routines, but provided vendor specifc and non-standard.\nThe module T_PLC_US provides so an appropriate interface to these ven￾dor-specifc timers. \nAnother feature of T_PLC_US is a Debug Mode, which allows to produce\nthe overfow of the internal PLC Timers and test the software developed\nright shure. The internal Timer of any PLC has, independent of manufac￾turer and type of implementation, after a fxed time an overfow. That\nmeans that it is running against FF..FFFF (highest value of the correspon￾ding type can be stored) and then starts again at 000..0000. At standard\nPLC Timer is the overfow time 2^32 -1 milliseconds, which is about 49.71\ndays. Since this Timer is implemented in a hardware, it initial value can\nnot be set, so that after starting the PLC it always starts at 0 and runs up\nto the maximum value. After reaching the maximum value, the infamous\nTimer Overfow arises, which causes fatal consequences in the application\nsoftware , but can only be tested extremely difcult. \nT_PLC_US ofers several ways to test the overfow and time-dependent\nsoftware. With the constant DEBUG, the test mode is switched on and\nthen, using the constants N and ofset , starts the timer at a certain level,\nthus specifcally the overfow can be tested without waiting the 49. Ofset\ndefnces a value which is added to the value of the internal Timer . With\nthe constant N is determined by how many bits of the internal Timer Value\nis shifted to the left, while the lower N bits are flled with 1. With N thus\nthe speed of the internal Timers can be increased by factors of 2,4,8,16\nand so on. \nT_PLC_US thus ofers all possibilities to test time-dependent software, both\nfor the problem of overfow, and for very slow time-dependent functions.\nThe constant DEBUG, N and OFFSET were intentionally not implemented\nas inputs of the function to avoid accidental misuse.", "type": "FUNCTION", "name": "T_PLC_US", "input": [{"name": "debug", "type": "BOOL", "description": "Flag indicating whether debug mode is active."}, {"name": "N", "type": "INT", "description": "Number of bits to shift in the conversion process."}, {"name": "offset", "type": "DWORD", "description": "Offset to apply to the converted time value."}], "output": [{"name": "T_PLC_US", "type": "DWORD", "description": "The resulting DWORD value derived from the time conversion."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Returns the converted time value as a DWORD."}}
{"title": "Beta Function Calculation", "description": "BETA computes the Euler Beta function.", "type": "FUNCTION", "name": "BETA", "input": [{"name": "X", "type": "REAL", "description": "A real number input representing the first parameter for the beta function calculation."}, {"name": "Y", "type": "REAL", "description": "A real number input representing the second parameter for the beta function calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the beta function calculation, which is a real number."}}
{"title": "Fibonacci Function", "description": "FIB calculate the Fibonacci number The Fibonacci number is defned as fol￾lows:\nFIB(0) = 0, FIB(1) = 1, FIB(2) = 1, FIB(3) = 2, FIB(4) = 3, FIB(5) = 5 .....\nThe Fibonacci number of X is equal to the sum of the Fibonacci numbers of\nX-1 and X-2. The function can compute the Fibonacci numbers up to 46, if\nX < 0 or greater than 46, the function returns -1.", "type": "FUNCTION", "name": "FIB", "input": [{"name": "X", "type": "INT", "description": "An integer input for which the Fibonacci number needs to be calculated."}], "output": [{"name": "FIB", "type": "DINT", "description": "The calculated Fibonacci number, or -1 for invalid input."}], "in/out": [], "return_value": {"type": "DINT", "description": "The final result of the Fibonacci calculation.", "fields": []}}
{"title": "TMIN Function Block", "description": "TMIN ensures that the output pulse Q is at least PT is set to TRUE, even if\nthe input pulse at IN is shorter than PT. otherwise the output Q follows the\ninput IN.", "type": "FUNCTION_BLOCK", "name": "TMIN", "input": [{"name": "IN", "type": "BOOL", "description": "A boolean input signal that influences the output state."}, {"name": "PT", "type": "TIME", "description": "The time period for which the input signal should be considered."}], "output": [{"name": "Q", "type": "BOOL", "description": "The boolean output signal indicating the current state based on the input and timer."}], "in/out": [], "return_value": null}
{"title": "Calculate Area of an Ellipse", "description": "ELLIPSE_A calculates the area of an ellipse that is defned by the radii R1\nand R2.", "type": "FUNCTION", "name": "ELLIPSE_A", "input": [{"name": "R1", "type": "REAL", "description": "The length of the semi-major axis of the ellipse."}, {"name": "R2", "type": "REAL", "description": "The length of the semi-minor axis of the ellipse."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated area of the ellipse.", "fields": []}}
{"title": "Rate of Motion Profile (RMP)", "description": "_RMP_W Is an 16-bit ramp generator. The ramp is generated in an external￾ly declared variable. The ramp is rising when DIR = TRUE and falling if DIR\n= FALSE. Reaching a fnal value of the ramp, the generator remains at this\nvalue. With the input E the ramp can be stopped at any time, when E =\nTRUE the ramp runs. The input TR shows the time which is needed to cy￾cle through 0-65535 or the other way around.", "type": "FUNCTION_BLOCK", "name": "_RMP_W", "input": [{"name": "DIR", "type": "BOOL", "description": "Indicates the direction of the ramp. True for one direction and false for the opposite."}, {"name": "E", "type": "BOOL", "description": "Enable signal for the ramp calculation. Default value is TRUE."}, {"name": "TR", "type": "TIME", "description": "Time interval used for calculating the ramp step."}], "output": [{"name": "RMP", "type": "WORD", "description": "The calculated ramp value constrained between 0 and 65535."}], "in/out": [], "return_value": null}
{"title": "Get Element from String List", "description": "LIST_GET delivers the item at the position POS from a list. The list consists\nof Strings (elements) that begin with the separation character SEP. The\nfrst element of the list has the position 1.", "type": "FUNCTION", "name": "LIST_GET", "input": [{"name": "SEP", "type": "BYTE", "description": "The separator used to delimit elements in the input string list."}, {"name": "POS", "type": "INT", "description": "The position of the element to be retrieved from the list (0-based index)."}], "output": [{"name": "LIST_GET", "type": "string", "description": "The output string containing the retrieved element from the input list based on the specified position."}], "in/out": [{"name": "LIST", "type": "STRING(LIST_LENGTH)", "description": "The input/output string list from which the element will be retrieved."}], "return_value": {"type": "string", "description": "Returns the string representation of the element at the specified position in the list."}}
{"title": "Lambert W Function Calculation", "description": "LAMBERT_W function is defned for x > = -1/e. When the value is be￾low the range the is result -1000. The range of LAMBERT_W function is >=\n-1.", "type": "FUNCTION", "name": "LAMBERT_W", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the Lambert W function is to be calculated."}], "output": [{"name": "LAMBERT_W", "type": "REAL", "description": "The calculated Lambert W value. Returns -1000.0 for invalid inputs and 0 for an input of 0."}], "in/out": [], "return_value": {"type": "REAL", "description": "The return value of the Lambert W function computation.", "fields": []}}
{"title": "Convert Seconds to TIME", "description": "SECOND_TO_TIME calculates a value (TIME) from the input\nvalue in seconds as a REAL.", "type": "FUNCTION", "name": "SECOND_TO_TIME", "input": [{"name": "IN", "type": "REAL", "description": "The input value representing time in seconds that needs to be converted to TIME."}], "output": [{"name": "SECOND_TO_TIME", "type": "TIME", "description": "The output time value converted from the input seconds into the TIME format."}], "in/out": [], "return_value": {"type": "TIME", "description": "Returns the converted TIME value."}}
{"title": "String Trimming Function", "description": "TRIM function removes all spaces from STR.", "type": "FUNCTION", "name": "TRIM", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string from which leading spaces need to be removed."}], "output": [{"name": "TRIM", "type": "string", "description": "The output string after leading spaces have been stripped away."}], "in/out": [], "return_value": {"type": "string", "description": "The trimmed string that results from the removal of leading spaces.", "fields": []}}
{"title": "Convert Weekday Integer to String Representation", "description": "WEEKDAY_TO_STRING converts a weekday in the corresponding string.\nThe input WDAY indicates the corresponding day of the week: 1 = Monday\nand 7 = Sunday. The input LANG chooses the language: 1 = English and 2\n= German. LANG = 0 used as Default the language specifed in the Global\nSetup variable LANGUAGE_DEFAULT. [fzy] The input LX sets the length of\nthe string to be generated: 0 = full month name, 3 = 3-letter abbreviation,\nall other values at the input LX are undefned. \nThe strings produced by the module, and the supported languages are de￾fned in the Global Constants and can be expanded and changed. \nWEEKDAY_TO_STRING(1,0,0) = ' Monday ' \ndependent on the global constant LANGUAGE_DEFAULT\nWEEKDAY_TO_STRING(1,2,0) = ' Monday ' \nWEEKDAY_TO_STRING(1,0,2) = ' Mon ' \n 14. Memory Modules", "type": "FUNCTION", "name": "WEEKDAY_TO_STRING", "input": [{"name": "WDAY", "type": "INT", "description": "An integer representing the weekday. Valid values are from 1 to 7."}, {"name": "LANG", "type": "INT", "description": "An integer representing the language choice. If set to 0, the default language is used."}, {"name": "LX", "type": "INT", "description": "An integer that specifies the language format. 0 for standard, 2 for an alternative format."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "Returns the string representation of the weekday in the specified language.", "fields": []}}
{"title": "Manual Control Function Block", "description": "WEEKDAY_TO_STRING converts a weekday in the corresponding string.\nThe input WDAY indicates the corresponding day of the week: 1 = Monday\nand 7 = Sunday. The input LANG chooses the language: 1 = English and 2\n= German. LANG = 0 used as Default the language specifed in the Global\nSetup variable LANGUAGE_DEFAULT. [fzy] The input LX sets the length of\nthe string to be generated: 0 = full month name, 3 = 3-letter abbreviation,\nall other values at the input LX are undefned. \nThe strings produced by the module, and the supported languages are de￾fned in the Global Constants and can be expanded and changed. \nWEEKDAY_TO_STRING(1,0,0) = ' Monday ' \ndependent on the global constant LANGUAGE_DEFAULT\nWEEKDAY_TO_STRING(1,2,0) = ' Monday ' \nWEEKDAY_TO_STRING(1,0,2) = ' Mon ' \n 14. Memory Modules", "type": "FUNCTION_BLOCK", "name": "MANUAL_2", "input": [{"name": "IN", "type": "BOOL", "description": "Input signal to the function block indicating the manual input state."}, {"name": "ENA", "type": "BOOL", "description": "Enable signal to activate the function block."}, {"name": "ON", "type": "BOOL", "description": "Signal indicating a request to turn the output ON."}, {"name": "OFF", "type": "BOOL", "description": "Signal indicating a request to turn the output OFF."}, {"name": "MAN", "type": "BOOL", "description": "Manual control input signal when neither ON nor OFF is active."}], "output": [{"name": "Q", "type": "BOOL", "description": "Current output state of the function block."}, {"name": "STATUS", "type": "BYTE", "description": "Status code representing the current state of processing."}], "in/out": [], "return_value": null}
{"title": "Complex Sine Function", "description": "WEEKDAY_TO_STRING converts a weekday in the corresponding string.\nThe input WDAY indicates the corresponding day of the week: 1 = Monday\nand 7 = Sunday. The input LANG chooses the language: 1 = English and 2\n= German. LANG = 0 used as Default the language specifed in the Global\nSetup variable LANGUAGE_DEFAULT. [fzy] The input LX sets the length of\nthe string to be generated: 0 = full month name, 3 = 3-letter abbreviation,\nall other values at the input LX are undefned. \nThe strings produced by the module, and the supported languages are de￾fned in the Global Constants and can be expanded and changed. \nWEEKDAY_TO_STRING(1,0,0) = ' Monday ' \ndependent on the global constant LANGUAGE_DEFAULT\nWEEKDAY_TO_STRING(1,2,0) = ' Monday ' \nWEEKDAY_TO_STRING(1,0,2) = ' Mon ' \n 14. Memory Modules", "type": "FUNCTION", "name": "CSIN", "input": [{"name": "X", "type": "complex", "description": "A complex number input for which the sine is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The sine of the complex input X, returned as a complex number.", "fields": [{"name": "re", "type": "real", "description": "The real part of the sine result."}, {"name": "im", "type": "real", "description": "The imaginary part of the sine result."}]}}
{"title": "Timer Counter Function Block", "description": "TC_MS determines the last cycle time, that is the time since the last call of\nthe module has passed. The time comes in milliseconds.", "type": "FUNCTION_BLOCK", "name": "TC_MS", "input": [], "output": [{"name": "TC", "type": "DWORD", "description": "The calculated time difference in milliseconds between the current timer value and the last timer value."}], "in/out": [], "return_value": null}
{"title": "HYST_1 Function Block", "description": "TC_MS determines the last cycle time, that is the time since the last call of\nthe module has passed. The time comes in milliseconds.", "type": "FUNCTION_BLOCK", "name": "HYST_1", "input": [{"name": "In", "type": "REAL", "description": "The input value to be evaluated against the threshold limits."}, {"name": "high", "type": "REAL", "description": "The upper threshold for the hysteresis comparison."}, {"name": "low", "type": "REAL", "description": "The lower threshold for the hysteresis comparison."}], "output": [{"name": "Q", "type": "BOOL", "description": "Boolean output indicating if the input is above the high threshold."}, {"name": "win", "type": "BOOL", "description": "Boolean output indicating whether the input is within the hysteresis window."}], "in/out": [], "return_value": {}}
{"title": "Convert Real Number to Fraction", "description": "REAL_TO_FRAC converts a foating point number (REAL) in a fraction. The\nfunction returns the data type is a FRACTION of the structure with 2 va￾lues. With the input X, the maximum size of the counter can be specifed.\nData type FRACTION:\n*.NUMERATOR : INT (Numerator of the fraction)\n*.DENOMINATOR : INT (Denominator of the fraction)", "type": "FUNCTION", "name": "REAL_TO_FRAC", "input": [{"name": "X", "type": "REAL", "description": "The real number to be converted into a fraction."}, {"name": "N", "type": "INT", "description": "The maximum allowed size of the denominator."}], "output": [{"name": "NUMERATOR", "type": "DINT", "description": "The calculated numerator of the resulting fraction."}, {"name": "DENOMINATOR", "type": "DINT", "description": "The calculated denominator of the resulting fraction."}], "in/out": [], "return_value": {"type": "FRACTION", "description": "The fraction representation of the given real number containing numerator and denominator.", "fields": [{"name": "NUMERATOR", "type": "DINT", "description": "The numerator value of the fraction."}, {"name": "DENOMINATOR", "type": "DINT", "description": "The denominator value of the fraction."}]}}
{"title": "Meter Status Function Block", "description": "METER_STAT calculates the consumption of the current day, week, month\nand year and shows the value of the last corresponding period. The accu￾mulated consumption value is at the IN input, while at the DI input is app￾lied the current date. With the RST input, the counter can be reset at any\ntime. For ease of storage in the persistent and retentive memory, the out￾puts are defned as I / O.\nThe following example shows the application of METER_STAT with the mo￾dule METER:", "type": "FUNCTION_BLOCK", "name": "METER_STAT", "input": [{"name": "IN", "type": "REAL", "description": "The input value measured by the meter."}, {"name": "DI", "type": "DATE", "description": "The current date corresponding to the measurement."}, {"name": "RST", "type": "BOOL", "description": "A boolean flag to indicate whether to reset the current measurements."}], "output": [], "in/out": [{"name": "Last_Day", "type": "REAL", "description": "The value of the last day measurement."}, {"name": "Current_Day", "type": "REAL", "description": "The value of the current day measurement."}, {"name": "Last_Week", "type": "REAL", "description": "The value of the last week measurement."}, {"name": "Current_Week", "type": "REAL", "description": "The value of the current week measurement."}, {"name": "Last_Month", "type": "REAL", "description": "The value of the last month measurement."}, {"name": "Current_Month", "type": "REAL", "description": "The value of the current month measurement."}, {"name": "Last_Year", "type": "REAL", "description": "The value of the last year measurement."}, {"name": "Current_Year", "type": "REAL", "description": "The value of the current year measurement."}], "return_value": null}
{"title": "Ramp Generator Function Block", "description": "RMP_W is a ramp generator with 16-bit (2 bytes) resolution. The ramp of\n0.. 65535 is divided into a maximum of 65536 steps and run in a time of\nPT once complete. An enable signal E switches the ramp generator on or\nof. An asynchronous reset sets each time the output to 0, and a pulse at\nthe Set input sets the output to 65535. With the UD input, the direction UP\n(UD = TRUE) or DOWN (UD = FALSE) is defned. The output of BUSY =\nTRUE indicates that a ramp is active. BUSY = FALSE means the output is\nstable. The outputs HIGH and LOW gets TRUE, the output OUT reaches the\nlower or upper limit (0 and 65535).\nAt setting of PT is to be noted that a PLC with 5 ms cycle time needs\n65536*5 = 327 seconds for a ramp. If the PT is the time defned shorter\nthan the cycle time 65536, the edge is translated in correspondingly lar￾ger steps. The ramp is constructed in this case with less than 256 steps\nper cycle. PT may be T#0s, then the output switched between minimum\nand maximum value back and forth.\nFor a detailed description, see the module RMP_B. The function is absolu￾tely identical except that the output OUT 8-bit wide instead of 16 bit.\n 19. Signal processing", "type": "FUNCTION_BLOCK", "name": "RMP_W", "input": [{"name": "SET", "type": "BOOL", "description": "Control signal to set the ramp output to its maximum value."}, {"name": "PT", "type": "TIME", "description": "Time duration for which the ramp should be executed."}, {"name": "E", "type": "BOOL", "description": "Enable signal for the ramp operation; when false, the ramp is disabled."}, {"name": "UP", "type": "BOOL", "description": "Direction control for the ramp; true for upward ramping, false for downward."}, {"name": "RST", "type": "BOOL", "description": "Control signal to reset the ramp output to zero."}], "output": [{"name": "out", "type": "WORD", "description": "Current output value of the ramp generator."}, {"name": "busy", "type": "BOOL", "description": "Indicates whether the ramp generator is currently active."}, {"name": "high", "type": "BOOL", "description": "Indicates if the output is at its maximum value."}, {"name": "low", "type": "BOOL", "description": "Indicates if the output is at its minimum value."}], "in/out": [], "return_value": null}
{"title": "Trimming Leading and Trailing Spaces from a String", "description": "TRIME function removes spaces at the beginning and the end of STR.\nSpaces within the string are ignored, even if they occur repeatedly.", "type": "FUNCTION", "name": "TRIME", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string that needs to be trimmed."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The trimmed version of the input string, with leading and trailing spaces removed."}}
{"title": "Complex Arc Tangent Function", "description": "CATAN calculates the arc tangent of a complex number\nThe range of values of the result is between [-/2,+/2 ] For the imagina￾ry part.", "type": "FUNCTION", "name": "CATAN", "input": [{"name": "X", "type": "complex", "description": "Input variable of type complex."}], "output": [{"name": "CATAN", "type": "complex", "description": "The result of the arc tangent calculation, returned as a complex number."}], "in/out": [], "return_value": {"type": "complex", "description": "The complex result representing the arc tangent of the input complex number.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the arc tangent result."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the arc tangent result."}]}}
{"title": "TUNE2 Function Block", "description": "CATAN calculates the arc tangent of a complex number\nThe range of values of the result is between [-/2,+/2 ] For the imagina￾ry part.", "type": "FUNCTION_BLOCK", "name": "TUNE2", "input": [{"name": "SET", "type": "BOOL", "description": "Indicator to set the output to SET_val."}, {"name": "SU", "type": "BOOL", "description": "Signal to initiate a slow step up operation."}, {"name": "SD", "type": "BOOL", "description": "Signal to initiate a slow step down operation."}, {"name": "FU", "type": "BOOL", "description": "Signal to initiate a fast step up operation."}, {"name": "FD", "type": "BOOL", "description": "Signal to initiate a fast step down operation."}, {"name": "RST", "type": "BOOL", "description": "Indicator to reset the output to RST_val."}, {"name": "SS", "type": "REAL", "description": "The amount to be added or subtracted during each slow step operation."}, {"name": "FS", "type": "REAL", "description": "The amount to be added or subtracted during each fast step operation."}, {"name": "Limit_L", "type": "REAL", "description": "The lower limit for the output."}, {"name": "LIMIT_H", "type": "REAL", "description": "The upper limit for the output."}, {"name": "RST_val", "type": "REAL", "description": "The value to assign to Y when the reset is triggered."}, {"name": "SET_val", "type": "REAL", "description": "The value to assign to Y when the set operation is triggered."}, {"name": "TR", "type": "TIME", "description": "The time duration for the ramp operation."}, {"name": "S1", "type": "REAL", "description": "The speed factor used for slow movements."}, {"name": "S2", "type": "REAL", "description": "The speed factor used for fast movements."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value after processing commands."}], "in/out": [], "return_value": {}}
{"title": "Hyperbolic Sine Function", "description": "SINH calculates the sinus Hyperbolic according the following formula:", "type": "FUNCTION", "name": "SINH", "input": [{"name": "X", "type": "REAL", "description": "The real number input for which the hyperbolic sine is to be calculated."}], "output": [{"name": "SINH", "type": "REAL", "description": "The calculated hyperbolic sine of the input value X."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the hyperbolic sine calculation."}}
{"title": "Delay Block", "description": "SINH calculates the sinus Hyperbolic according the following formula:", "type": "FUNCTION_BLOCK", "name": "DELAY_4", "input": [{"name": "in", "type": "REAL", "description": "The input signal to be delayed."}], "output": [{"name": "out1", "type": "REAL", "description": "The first delayed output of the input signal."}, {"name": "out2", "type": "REAL", "description": "The second delayed output of the input signal."}, {"name": "out3", "type": "REAL", "description": "The third delayed output of the input signal."}, {"name": "out4", "type": "REAL", "description": "The fourth delayed output of the input signal."}], "in/out": [], "return_value": {}}
{"title": "Energy Calculation Function Block", "description": "ENERGY in diferent, in practice common units of\nenergy. Normally, only the input to be converted is occupied and the re￾maining inputs remain free. However, if several inputs loaded with values,\nthe values of all inputs are converted accordingly and then summed.\n1 J = 1 Ws (Watt * Seconds) = 1 Nm (Newton * meters)\n1 C = 4,1868 J = 1,163 * 10 -3 Wh (watt * hours) \n1 Wh = 3,6 * 103 J = 860 C", "type": "FUNCTION_BLOCK", "name": "ENERGY", "input": [{"name": "J", "type": "REAL", "description": "Energy in Joules."}, {"name": "C", "type": "REAL", "description": "Capacity in a specific energy unit."}, {"name": "Wh", "type": "REAL", "description": "Energy in watt-hours."}], "output": [{"name": "YJ", "type": "REAL", "description": "Calculated energy in Joules after conversion."}, {"name": "YC", "type": "REAL", "description": "Energy in a calculated unit based on YJ."}, {"name": "YWh", "type": "REAL", "description": "Converted energy from YJ to watt-hours."}], "in/out": [], "return_value": null}
{"title": "Uppercase String Conversion", "description": "ENERGY in diferent, in practice common units of\nenergy. Normally, only the input to be converted is occupied and the re￾maining inputs remain free. However, if several inputs loaded with values,\nthe values of all inputs are converted accordingly and then summed.\n1 J = 1 Ws (Watt * Seconds) = 1 Nm (Newton * meters)\n1 C = 4,1868 J = 1,163 * 10 -3 Wh (watt * hours) \n1 Wh = 3,6 * 103 J = 860 C", "type": "FUNCTION", "name": "UPPERCASE", "input": [{"name": "str", "type": "STRING", "description": "The input string that needs to be converted to uppercase."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The converted uppercase string.", "fields": []}}
{"title": "Dead Band Filter Function Block", "description": "DEAD_BAND_A is a self adapting linear transfer function with dead zone.\nThe function moves the positive part of the curve to -L and the negative\npart of the curve by +L. DEAD_BAND_A is used to flter the noise com￾ponents at the origin of a signal. DEAD_BAND_A, for example, used in con￾trol systems in order to prevent that the controller permanently switches\nin small increments, while the actuator is overstressed and worn out.\nThe size L is calculated by fltering the HF cpmponents of the input signal\nX using a low pass with time constant T and the dead zone L calculated\nfrom the amplitude of the HF portion. The sensitivity of the device can be\nchanged via the parameter KL. KL is predefned to 1 and can be unconnec￾ted. Reasonable values for KL are between 1 - 5.\nL = HF_Amplitude(efective) *KL.\nSo that the module will remain stable even under extreme operating con￾ditions, the input LM is limited by of the maximum value of L.\nDEAD_BAND = X - SGN(X)*L if ABS(X)> L if ABS(X) > L \nDEAD_BAND = 0 if ABS(X) <= L", "type": "FUNCTION_BLOCK", "name": "DEAD_BAND_A", "input": [{"name": "X", "type": "REAL", "description": "The input signal to be filtered."}, {"name": "T", "type": "TIME", "description": "The time constant for the filtering process."}, {"name": "KL", "type": "REAL", "description": "A scaling factor for the dead band, default value is 1.0."}, {"name": "LM", "type": "REAL", "description": "The maximum limit for the dead band's width."}], "output": [{"name": "Y", "type": "REAL", "description": "The processed output signal after applying dead band filtering."}, {"name": "L", "type": "REAL", "description": "The computed width of the dead band, representing stability."}], "in/out": [], "return_value": null}
{"title": "Calculate Area of a Circle", "description": "CIRCLE_A calculates the area of a circle segment with the angle AX and ra￾dius RX. If the angle is set AX = 360 so the circle area is calculated.", "type": "FUNCTION", "name": "CIRCLE_A", "input": [{"name": "rx", "type": "REAL", "description": "The radius of the circle."}, {"name": "ax", "type": "REAL", "description": "A constant multiplier factor that influences the area calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated area of the circle based on the provided radius and constant factor."}}
{"title": "Count Manager", "description": "COUNT_DR is a DWORD (32-bit) counter with counts from 0 to MX and\nthen begins again at 0. The counter can, using two edge-triggered inputs\nUP and DN, both forward and backward counting. when reaching a fnal\nvalue 0 or MX it counts again at 0 or MX. The STEP input sets the incre￾ment value of the counter. With a TRUE at input SET the counter is set to\npresent value at the IN input. A reset input RST resets the counter at any\ntime to 0.\nSET IN UP DN STEP RST CNT\nReset - - - - - 1 0\nSet 1 N - - - 0 N\nup 0 - ↑ 0 N 0 CNT + N\ndown 0 - 0 ↑ N 0 CNT - N\nIf the independent inputs UP and DN with CLK and a control input UP/DN\nshould be replaced, id can be done using two AND gates at the inputs:", "type": "FUNCTION_BLOCK", "name": "COUNT_DR", "input": [{"name": "SET", "type": "BOOL", "description": "Signal to initialize the count to the input value."}, {"name": "IN", "type": "DWORD", "description": "Input value used to set the count when 'SET' is true."}, {"name": "UP", "type": "BOOL", "description": "Signal to increment the count."}, {"name": "DN", "type": "BOOL", "description": "Signal to decrement the count."}, {"name": "STEP", "type": "DWORD", "description": "Amount to increment or decrement the count, defaulted to 1.", "fields": []}, {"name": "MX", "type": "DWORD", "description": "Maximum value for the count, defaulted to 16#FFFFFFFF.", "fields": []}, {"name": "RST", "type": "BOOL", "description": "Signal to reset the count to zero."}], "output": [{"name": "CNT", "type": "DWORD", "description": "Current value of the count."}], "in/out": [], "return_value": null}
{"title": "Complex Number Set Function", "description": "CSET generated from the two input components RE and IM is a complex\nnumber of type COMPLEX.", "type": "FUNCTION", "name": "CSET", "input": [{"name": "RE", "type": "REAL", "description": "The real part of the complex number."}, {"name": "IM", "type": "REAL", "description": "The imaginary part of the complex number."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The complex number consisting of the provided real and imaginary parts.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the complex number."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the complex number."}]}}
{"title": "Retrieve Element from List", "description": "LIST_RETRIEVE passes the item at the position POS from a list and deletes\nthe corresponding item in the list. The list consists of Strings (elements)\nthat begin with the separation character SEP. The frst element of the list\nis at position 1. The function returns an empty string if no element is at\nthe position POS.", "type": "FUNCTION", "name": "LIST_RETRIEVE", "input": [{"name": "SEP", "type": "BYTE", "description": "The byte value representing the separator used to delimit elements in the list."}, {"name": "POS", "type": "INT", "description": "The position of the element to retrieve from the list, where the first element is at position 1."}], "output": [], "in/out": [{"name": "LIST", "type": "STRING(LIST_LENGTH)", "description": "The list from which an element will be retrieved. This is both the input list and will be updated during the operation."}], "return_value": {"type": "string", "description": "The retrieved element from the list. If the position is not greater than 0, the function returns an empty string."}}
{"title": "Binomial Coefficient Calculation", "description": "BINOM calculates the binominal coefcient N over K for integer N and K.", "type": "FUNCTION", "name": "BINOM", "input": [{"name": "N", "type": "INT", "description": "The total number of elements from which the selection is made."}, {"name": "K", "type": "INT", "description": "The number of elements to choose from the total elements."}], "output": [], "in/out": [], "return_value": {"type": "DINT", "description": "The computed binomial coefficient value.", "fields": []}}
{"title": "Convert Byte to Lowercase", "description": "TO_LOWER converts individual characters to lowercase. During conversion,\nthe Global Setup EXTENDED_ASCII constant is considered. If\nEXTENDED_ASCII = TRUE, all characters of the extended ASCII character\nset to be considered in accordance with ISO 8859-1.\nThe following Table discusses the conversion code:\nCode EXTENDED_ASCII = TRUE EXTENDED_ASCII = FALSE\n0..64 0..64 0..64\n65..90 97..122 97..122\n91..191 91..191 91..191\n192..214 224..246 192..214\n215 215 215\n216..222 248..254 216..254\n223..255 223..255 223..255", "type": "FUNCTION", "name": "TO_LOWER", "input": [{"name": "IN", "type": "BYTE", "description": "The input byte to be converted to lowercase."}], "output": [{"name": "TO_LOWER", "type": "BYTE", "description": "The lowercase representation of the input byte."}], "in/out": [], "return_value": {"type": "BYTE", "description": "Returns the converted lowercase byte if applicable, otherwise returns the input byte.", "fields": []}}
{"title": "Maximum of Three Real Numbers", "description": "TO_LOWER converts individual characters to lowercase. During conversion,\nthe Global Setup EXTENDED_ASCII constant is considered. If\nEXTENDED_ASCII = TRUE, all characters of the extended ASCII character\nset to be considered in accordance with ISO 8859-1.\nThe following Table discusses the conversion code:\nCode EXTENDED_ASCII = TRUE EXTENDED_ASCII = FALSE\n0..64 0..64 0..64\n65..90 97..122 97..122\n91..191 91..191 91..191\n192..214 224..246 192..214\n215 215 215\n216..222 248..254 216..254\n223..255 223..255 223..255", "type": "FUNCTION", "name": "MAX3", "input": [{"name": "in1", "type": "REAL", "description": "The first real number input."}, {"name": "in2", "type": "REAL", "description": "The second real number input."}, {"name": "in3", "type": "REAL", "description": "The third real number input."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The maximum value among the three input real numbers."}}
{"title": "Proportional-Integral Controller Function Block", "description": "FT_PIW can used together with the modules CTRL_IN and CTRL_OUT to\nbuild complex controllers.", "type": "FUNCTION_BLOCK", "name": "FT_PIW", "input": [{"name": "IN", "type": "REAL", "description": "The input value to be controlled."}, {"name": "KP", "type": "REAL", "description": "The proportional gain for the controller.", "fields": []}, {"name": "KI", "type": "REAL", "description": "The integral gain for the controller.", "fields": []}, {"name": "LIM_L", "type": "REAL", "description": "The lower limit for the output.", "fields": []}, {"name": "LIM_H", "type": "REAL", "description": "The upper limit for the output.", "fields": []}, {"name": "RST", "type": "BOOL", "description": "Reset signal for the integrator.", "fields": []}], "output": [{"name": "Y", "type": "REAL", "description": "The output value of the controller.", "fields": []}, {"name": "LIM", "type": "BOOL", "description": "Indicator that output is at limit.", "fields": []}], "in/out": [], "return_value": {}}
{"title": "Scale Function", "description": "SCALE multiplies the input X with K, and adds the ofset O. The calculated\nvalue will be limited to the values of MN and MX and the result is passed\nto output.\nSCALE = LIMIT(MN, X * K + O, MX)", "type": "FUNCTION", "name": "SCALE", "input": [{"name": "X", "type": "REAL", "description": "The input value that will be scaled."}, {"name": "K", "type": "REAL", "description": "The scaling factor applied to the input value."}, {"name": "O", "type": "REAL", "description": "The offset to be added to the scaled input value."}, {"name": "MX", "type": "REAL", "description": "The maximum limit for the scaled value."}, {"name": "MN", "type": "REAL", "description": "The minimum limit for the scaled value."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The scaled value limited between MN and MX."}}
{"title": "Check if All Characters are Present", "description": "IS_CC tests whether the string in STR only the in STR listed characters are\nincluded. If another character is found the function returns FALSE.", "type": "FUNCTION", "name": "IS_CC", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The input string to be checked against the comparison string."}, {"name": "cmp", "type": "STRING(STRING_LENGTH)", "description": "The comparison string containing characters to look for in the input string."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the input string contains all characters from the comparison string in the specified portion; otherwise, returns FALSE."}}
{"title": "Exponentiation Function", "description": "EXPN calculates the exponential value of X^N for integer N. EXPN is espe￾cifcally written for PLC without Floating Point Unit and is about 30 times\nfaster than the IEC standard function EXPT(). Note the special case of the\n0^0 defned mathematically as a 1 and is not a 0. \nEXPN(10,-2) = 0.01 EXPN(1.5,2) = 2.25\nEXPN(0,0) = 1", "type": "FUNCTION", "name": "EXPN", "input": [{"name": "X", "type": "REAL", "description": "The base value which is a real number."}, {"name": "N", "type": "INT", "description": "The exponent value which is an integer. It can be positive or negative."}], "output": [{"name": "EXPN", "type": "REAL", "description": "The result of the calculation, representing X raised to the power of N."}], "in/out": [], "return_value": {"type": "REAL", "description": "The real number result of the exponentiation."}}
{"title": "Cross Product of Two Vectors", "description": "EXPN calculates the exponential value of X^N for integer N. EXPN is espe￾cifcally written for PLC without Floating Point Unit and is about 30 times\nfaster than the IEC standard function EXPT(). Note the special case of the\n0^0 defned mathematically as a 1 and is not a 0. \nEXPN(10,-2) = 0.01 EXPN(1.5,2) = 2.25\nEXPN(0,0) = 1", "type": "FUNCTION", "name": "V3_XPRO", "input": [{"name": "A", "type": "Vector_3", "description": "The first input vector for the cross product operation."}, {"name": "B", "type": "Vector_3", "description": "The second input vector for the cross product operation."}], "output": [], "in/out": [], "return_value": {"type": "vector_3", "description": "The resulting vector that is the cross product of vectors A and B.", "fields": [{"name": "X", "type": "REAL", "description": "The x-component of the resulting cross product vector."}, {"name": "Y", "type": "REAL", "description": "The y-component of the resulting cross product vector."}, {"name": "Z", "type": "REAL", "description": "The z-component of the resulting cross product vector."}]}}
{"title": "Convert Gray Code to Byte", "description": "GRAY_TO_BYTE converts a Gray-coded value (IN) in a byte.", "type": "FUNCTION", "name": "GRAY_TO_BYTE", "input": [{"name": "IN", "type": "BYTE", "description": "A BYTE value representing the Gray code to be converted."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "The binary representation of the input Gray code after conversion."}}
{"title": "4-bit Shift Register with Set, Reset, and Clock Functionality", "description": "GRAY_TO_BYTE converts a Gray-coded value (IN) in a byte.", "type": "FUNCTION_BLOCK", "name": "SHR_4E", "input": [{"name": "SET", "type": "BOOL", "description": "Input signal to set the shift register."}, {"name": "D0", "type": "BOOL", "description": "Data input for the shift register."}, {"name": "CLK", "type": "BOOL", "description": "Clock input signal to trigger the shifting operation."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to reset the shift register outputs."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output representing the least significant bit of the shift register."}, {"name": "Q1", "type": "BOOL", "description": "Output representing the second least significant bit of the shift register."}, {"name": "Q2", "type": "BOOL", "description": "Output representing the second most significant bit of the shift register."}, {"name": "Q3", "type": "BOOL", "description": "Output representing the most significant bit of the shift register."}], "in/out": [], "return_value": null}
{"title": "Pressure Conversion Function Block", "description": "PRESSURE converts diferent, in practice common units, for\npressure. Normally, only the input to be converted is occupied and the re￾maining inputs remain free. However, if several inputs loaded with values,\nthe values of all inputs are converted accordingly and then summed.\n1 MWS = 1 meter of water = 0.0980665 Bar\n1 Torr = 1 mm Hg = 0.133322 bar = 101325/760 Pa\n1 ATT = 1 kp / cm ² = 0.980665 bar\n1 ATM = 1.01325 Bar\n1 PA = 1 N / m²\n1 BAR = 105 Pa", "type": "FUNCTION_BLOCK", "name": "PRESSURE", "input": [{"name": "mws", "type": "REAL", "description": "Pressure in millimeters of water column."}, {"name": "torr", "type": "REAL", "description": "Pressure in torr."}, {"name": "att", "type": "REAL", "description": "Pressure in technical atmospheres."}, {"name": "atm", "type": "REAL", "description": "Pressure in standard atmospheres."}, {"name": "pa", "type": "REAL", "description": "Pressure in pascals."}, {"name": "bar", "type": "REAL", "description": "Pressure in bar."}], "output": [{"name": "Ymws", "type": "REAL", "description": "Converted pressure in millimeters of water column."}, {"name": "Ytorr", "type": "REAL", "description": "Converted pressure in torr."}, {"name": "Yatt", "type": "REAL", "description": "Converted pressure in technical atmospheres."}, {"name": "Yatm", "type": "REAL", "description": "Converted pressure in standard atmospheres."}, {"name": "Ypa", "type": "REAL", "description": "Converted pressure in pascals."}, {"name": "Ybar", "type": "REAL", "description": "Converted pressure in bar."}], "in/out": [], "return_value": null}
{"title": "Array Sorting Function", "description": "_ARRAY_SORT(ADR(Array), SI￾ZEOF(Array)), where array is the name of the array to be manipulated.\nADR() is a standard function which identifes the pointer to the array and\nSIZEOF() is a standard function, which determines the size of the array.\nThe function only returns TRUE. The array specifed by the pointer is mani￾pulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "_ARRAY_SORT", "input": [{"name": "PT", "type": "POINTER TO ARRAY[1..32000] OF REAL", "description": "A pointer to the array of real numbers to be sorted."}, {"name": "SIZE", "type": "UINT", "description": "The size of the array."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Indicates whether the sorting was successful or not."}}
{"title": "Minimum of Three Real Numbers", "description": "_ARRAY_SORT(ADR(Array), SI￾ZEOF(Array)), where array is the name of the array to be manipulated.\nADR() is a standard function which identifes the pointer to the array and\nSIZEOF() is a standard function, which determines the size of the array.\nThe function only returns TRUE. The array specifed by the pointer is mani￾pulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "MIN3", "input": [{"name": "in1", "type": "REAL", "description": "The first real number input."}, {"name": "in2", "type": "REAL", "description": "The second real number input."}, {"name": "in3", "type": "REAL", "description": "The third real number input."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The minimum value among the three input real numbers."}}
{"title": "Convert String to Month Integer", "description": "FSTRING_TO_MONTH determines from a string containing a month name\nor abbreviation the value of the month. The function can handle both the\nmonth names and abbreviations as input as well as a number of the\nmonth.\nFSTRING_TO_MONTH('Januar',2) = 1\nFSTRING_TO_MONTH('Jan',2) = 1\nFSTRING_TO_MONTH('11',0) = 11\nThe input LANG selects the used language, 0 = the default in the Setup , 1\n= English .... more info about the language settings, see the chapter Data\nTypes.", "type": "FUNCTION", "name": "FSTRING_TO_MONTH", "input": [{"name": "MTH", "type": "STRING(20)", "description": "A string representing the month to be converted."}, {"name": "LANG", "type": "INT", "description": "An integer representing the language setting. Use 0 for default language, or a specific language index."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "Returns the integer representation of the month (1-12), or the integer value of the string if no match is found."}}
{"title": "Increment Function", "description": "FSTRING_TO_MONTH determines from a string containing a month name\nor abbreviation the value of the month. The function can handle both the\nmonth names and abbreviations as input as well as a number of the\nmonth.\nFSTRING_TO_MONTH('Januar',2) = 1\nFSTRING_TO_MONTH('Jan',2) = 1\nFSTRING_TO_MONTH('11',0) = 11\nThe input LANG selects the used language, 0 = the default in the Setup , 1\n= English .... more info about the language settings, see the chapter Data\nTypes.", "type": "FUNCTION", "name": "INC1", "input": [{"name": "X", "type": "INT", "description": "The integer value to be incremented."}, {"name": "N", "type": "INT", "description": "The limit value that determines the behavior of the increment."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The result of the increment operation, which will be either X + 1 or 0 if X is greater than or equal to N - 1."}}
{"title": "Trim String Function", "description": "FSTRING_TO_MONTH determines from a string containing a month name\nor abbreviation the value of the month. The function can handle both the\nmonth names and abbreviations as input as well as a number of the\nmonth.\nFSTRING_TO_MONTH('Januar',2) = 1\nFSTRING_TO_MONTH('Jan',2) = 1\nFSTRING_TO_MONTH('11',0) = 11\nThe input LANG selects the used language, 0 = the default in the Setup , 1\n= English .... more info about the language settings, see the chapter Data\nTypes.", "type": "FUNCTION", "name": "TRIM1", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string that needs to be trimmed of spaces."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The trimmed string with no leading, trailing, or consecutive spaces."}}
{"title": "FIFO Buffer Implementation", "description": "FSTRING_TO_MONTH determines from a string containing a month name\nor abbreviation the value of the month. The function can handle both the\nmonth names and abbreviations as input as well as a number of the\nmonth.\nFSTRING_TO_MONTH('Januar',2) = 1\nFSTRING_TO_MONTH('Jan',2) = 1\nFSTRING_TO_MONTH('11',0) = 11\nThe input LANG selects the used language, 0 = the default in the Setup , 1\n= English .... more info about the language settings, see the chapter Data\nTypes.", "type": "FUNCTION_BLOCK", "name": "FIFO_32", "input": [{"name": "Din", "type": "DWORD", "description": "The data input to be written to the FIFO."}, {"name": "E", "type": "BOOL", "description": "Enable signal, when TRUE allows reading and writing operations."}, {"name": "RD", "type": "BOOL", "description": "Read signal, when TRUE initiates a read operation from the FIFO."}, {"name": "WD", "type": "BOOL", "description": "Write signal, when TRUE initiates a write operation to the FIFO."}, {"name": "RST", "type": "BOOL", "description": "Reset signal, when TRUE resets the FIFO state."}], "output": [{"name": "Dout", "type": "DWORD", "description": "The data output read from the FIFO."}, {"name": "EMPTY", "type": "BOOL", "description": "Status indicator, TRUE if the FIFO is empty."}, {"name": "FULL", "type": "BOOL", "description": "Status indicator, TRUE if the FIFO is full."}], "in/out": [], "return_value": null}
{"title": "Convert Frequency to Angular Frequency", "description": "F_TO_OM calculates the angular frequency omega of the frequency in Hz", "type": "FUNCTION", "name": "F_TO_OM", "input": [{"name": "F", "type": "REAL", "description": "The frequency value in Hertz to be converted to angular frequency."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The converted angular frequency in radians per second.", "fields": []}}
{"title": "Moving Average Filter", "description": "FILTER_MAV_W is a flter with moving average. The flter with moving ave￾rage (also Moving Average Filter called) the average of N successive rea￾dings is output as an average. \nY:= (X0 + X1 + … + Xn-1) / N\nX0 is the value of X in the current cycle, X1 is the value in the previous cy￾cle, etc. The number of values over which the average has to be calcula￾ted is specifed at the input N. The range of values of N is between 1 and\n32", "type": "FUNCTION_BLOCK", "name": "FILTER_MAV_W", "input": [{"name": "X", "type": "WORD", "description": "Input variable which is a word value to be averaged."}, {"name": "N", "type": "UINT", "description": "Input variable that specifies the number of samples to average. It is limited to a maximum of 32."}, {"name": "RST", "type": "BOOL", "description": "Reset variable that initializes the moving average calculation when set to TRUE."}], "output": [{"name": "Y", "type": "WORD", "description": "Output variable which holds the current average value."}], "in/out": [], "return_value": null}
{"title": "Polynomial Interpolation Calculation", "description": "POLYNOM_INT interpolates a number of pairs of values with a polynomial\nof N times degree. The number of pairs is PTS, and N is the number of\npairs of values (PTS). Any characteristic is described by a maximum of 5\ncoordinate-values (X, Y) and internally described by a polynomial. The de￾fnition of the coordinate values is passed in an array which describes the\ncharacteristic with individual X, Y describes value pairs. The value pairs\nmust be sorted by the x_value. If an X value is queried outside the descri￾bed range by value-apairs, so that is calculated according to the determi￾ned polygon. It is noted, that here can occur oscillations above and below\nthe area of defnition by a polynomial of higher degree , and calculated va￾lues mostly are not useful in this area. Before the application of a polyno￾mial it is essential for this purpose to read the basics, for example, in Wiki￾pedia. To keep the number of defnition points fexible, at the input PTS is\ngiven the number of points. The possible score is in the range from 3 to 5,\nwherein each individual dot is shown with X-and Y-value. A Polynomial with\nmore than 5 points leads to an increased tendency to oscillate and is for\nthis reason refused. \nThe following example shows the defnition for the array XY and some va￾lues:\nVAR\n EXAMPLE : ARRAY[1..5,0..1] := -10,-0.53, 10,0.53, 100,88.3, 200,122.2;\nEND_VAR\nfor the above defnition, the following results are valid:\nPOLYNOM_INT(0, example, 4) = -1.397069;\nPOLYNOM_INT(30.0, example, 4) = 11.4257;\nPOLYNOM_INT(66.41, example, 4) = 47.74527;\nPOLYNOM_INT(800.0, example, 4) = -19617.94;\nWhen the results of the example is clearly seen that the value of\n-19617.94 for the input X = 800 makes no sense, since it is outside the\ndefned range of -10 to +200.\n The following trace recording shows the variation of output to input. Here,\nclearly, the overshoot of the polygon with respect to a linear interpolation\ncan be seen. Green = input X, Red = linear interpolation, Blue = polynomi￾al interpolation. \n 10. Geometric Functions", "type": "FUNCTION", "name": "POLYNOM_INT", "input": [{"name": "X", "type": "REAL", "description": "The point at which the polynomial value is to be calculated."}, {"name": "XY", "type": "ARRAY[1..5, 0..1] OF REAL", "description": "A two-dimensional array containing the data points for polynomial interpolation, where each element corresponds to an (x, y) coordinate."}, {"name": "Pts", "type": "INT", "description": "The number of data points provided in the 'XY' array, limited to a maximum of 5."}], "output": [{"name": "POLYNOM_INT", "type": "REAL", "description": "The calculated value of the polynomial at the point 'X'."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the polynomial interpolation at the specified point 'X'."}}
{"title": "Capitalize String", "description": "POLYNOM_INT interpolates a number of pairs of values with a polynomial\nof N times degree. The number of pairs is PTS, and N is the number of\npairs of values (PTS). Any characteristic is described by a maximum of 5\ncoordinate-values (X, Y) and internally described by a polynomial. The de￾fnition of the coordinate values is passed in an array which describes the\ncharacteristic with individual X, Y describes value pairs. The value pairs\nmust be sorted by the x_value. If an X value is queried outside the descri￾bed range by value-apairs, so that is calculated according to the determi￾ned polygon. It is noted, that here can occur oscillations above and below\nthe area of defnition by a polynomial of higher degree , and calculated va￾lues mostly are not useful in this area. Before the application of a polyno￾mial it is essential for this purpose to read the basics, for example, in Wiki￾pedia. To keep the number of defnition points fexible, at the input PTS is\ngiven the number of points. The possible score is in the range from 3 to 5,\nwherein each individual dot is shown with X-and Y-value. A Polynomial with\nmore than 5 points leads to an increased tendency to oscillate and is for\nthis reason refused. \nThe following example shows the defnition for the array XY and some va￾lues:\nVAR\n EXAMPLE : ARRAY[1..5,0..1] := -10,-0.53, 10,0.53, 100,88.3, 200,122.2;\nEND_VAR\nfor the above defnition, the following results are valid:\nPOLYNOM_INT(0, example, 4) = -1.397069;\nPOLYNOM_INT(30.0, example, 4) = 11.4257;\nPOLYNOM_INT(66.41, example, 4) = 47.74527;\nPOLYNOM_INT(800.0, example, 4) = -19617.94;\nWhen the results of the example is clearly seen that the value of\n-19617.94 for the input X = 800 makes no sense, since it is outside the\ndefned range of -10 to +200.\n The following trace recording shows the variation of output to input. Here,\nclearly, the overshoot of the polygon with respect to a linear interpolation\ncan be seen. Green = input X, Red = linear interpolation, Blue = polynomi￾al interpolation. \n 10. Geometric Functions", "type": "FUNCTION", "name": "CAPITALIZE", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The input string that needs to be capitalized."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The capitalized version of the input string."}}
{"title": "MESSAGE_4R Function Block", "description": "POLYNOM_INT interpolates a number of pairs of values with a polynomial\nof N times degree. The number of pairs is PTS, and N is the number of\npairs of values (PTS). Any characteristic is described by a maximum of 5\ncoordinate-values (X, Y) and internally described by a polynomial. The de￾fnition of the coordinate values is passed in an array which describes the\ncharacteristic with individual X, Y describes value pairs. The value pairs\nmust be sorted by the x_value. If an X value is queried outside the descri￾bed range by value-apairs, so that is calculated according to the determi￾ned polygon. It is noted, that here can occur oscillations above and below\nthe area of defnition by a polynomial of higher degree , and calculated va￾lues mostly are not useful in this area. Before the application of a polyno￾mial it is essential for this purpose to read the basics, for example, in Wiki￾pedia. To keep the number of defnition points fexible, at the input PTS is\ngiven the number of points. The possible score is in the range from 3 to 5,\nwherein each individual dot is shown with X-and Y-value. A Polynomial with\nmore than 5 points leads to an increased tendency to oscillate and is for\nthis reason refused. \nThe following example shows the defnition for the array XY and some va￾lues:\nVAR\n EXAMPLE : ARRAY[1..5,0..1] := -10,-0.53, 10,0.53, 100,88.3, 200,122.2;\nEND_VAR\nfor the above defnition, the following results are valid:\nPOLYNOM_INT(0, example, 4) = -1.397069;\nPOLYNOM_INT(30.0, example, 4) = 11.4257;\nPOLYNOM_INT(66.41, example, 4) = 47.74527;\nPOLYNOM_INT(800.0, example, 4) = -19617.94;\nWhen the results of the example is clearly seen that the value of\n-19617.94 for the input X = 800 makes no sense, since it is outside the\ndefned range of -10 to +200.\n The following trace recording shows the variation of output to input. Here,\nclearly, the overshoot of the polygon with respect to a linear interpolation\ncan be seen. Green = input X, Red = linear interpolation, Blue = polynomi￾al interpolation. \n 10. Geometric Functions", "type": "FUNCTION_BLOCK", "name": "MESSAGE_4R", "input": [{"name": "M0", "type": "STRING(STRING_LENGTH)", "description": "First message string."}, {"name": "M1", "type": "STRING(STRING_LENGTH)", "description": "Second message string."}, {"name": "M2", "type": "STRING(STRING_LENGTH)", "description": "Third message string."}, {"name": "M3", "type": "STRING(STRING_LENGTH)", "description": "Fourth message string."}, {"name": "MM", "type": "INT", "description": "Increment value for the message counter. Default is 3."}, {"name": "ENQ", "type": "BOOL", "description": "Enable signal for the message selection process. Default is TRUE."}, {"name": "CLK", "type": "BOOL", "description": "Clock signal used for timing the message selection process. Default is TRUE."}, {"name": "T1", "type": "TIME", "description": "Time interval for the timer. Default is 3 seconds."}], "output": [{"name": "MX", "type": "STRING(STRING_LENGTH)", "description": "Selected message string based on the current counter value."}, {"name": "MN", "type": "INT", "description": "Current message counter value."}, {"name": "TR", "type": "BOOL", "description": "Trigger signal indicating that a new message has been selected."}], "in/out": [], "return_value": null}
{"title": "Hysteresis Control Function Block", "description": "HYST is a standard Hysteresis module, its function depends on the input\nvalues ON and OFF.\nIs ON > OFF then the output TRUE if IN > ON and is FALSE when IN < OFF.\nIs ON < OFF then the output TRUE if IN < ON and is FALSE when IN > OFF.\nThe output WIN is TRUE if IN is between ON and OFF, is IN is out of range\nON - OFF WIN gets FALSE.", "type": "FUNCTION_BLOCK", "name": "HYST", "input": [{"name": "In", "type": "REAL", "description": "The input value to be evaluated against the hysteresis thresholds."}, {"name": "ON", "type": "REAL", "description": "The upper threshold value for the hysteresis control."}, {"name": "OFF", "type": "REAL", "description": "The lower threshold value for the hysteresis control."}], "output": [{"name": "Q", "type": "BOOL", "description": "The output boolean indicating the active state based on hysteresis logic."}, {"name": "win", "type": "BOOL", "description": "A boolean output that indicates if the input is within the hysteresis range."}], "in/out": [], "return_value": {}}
{"title": "Negation Function", "description": "NEGX returns the negated input value (-x).", "type": "FUNCTION", "name": "NEGX", "input": [{"name": "X", "type": "REAL", "description": "Input parameter which is a real number to be negated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The negated value of the input X.", "fields": []}}
{"title": "ONTIME Function Block", "description": "ONTIME is an hour meter. It is summed up the entire time that the signal\nIN was since the last RESET to TRUE. Additionally, the number of the total\non/of cycles is determined. The output values are of type UDINT. With the\ninput RST, the output values will be reset at any time. The output values\nare not stored in variables of the module, but are applied externally atta￾ched and connected over IO (Pointer). This has the distinct advantage that\nas desired by the user the variables can be determined as RETAIN or PER￾SISTENT. It is thus possible to store old operating hours and restore it la￾ter, for example, at CPU change.\nThe declaration of the variables at the inputs SECONDS and CYCLES must\nbe of type UDINT and can either be created as a VAR, VAR RETAIN or VAR\nRETAIN PERSISTENT.\nThe declaration of the variables for the operating time and cycles must be\nUDINT type and can be alternatively RETAIN or PERSISTENT.\nVAR RETAIN PERSISTENT\nBetriebszeit_in_Sekunden: UDINT;\nCycles: UDINT;\nEND_VAR\nThe following table explains, RETAIN and PERSISTENT:\nType variables Retain and Persistent retain their value during download,\nonline change and reset. In a cold reset or reset source, lose these varia-\nbles the values. The user can save, but the values in the fle system or\nnetwork, and to restore itself, eg after changing the CPU.", "type": "FUNCTION_BLOCK", "name": "ONTIME", "input": [{"name": "IN", "type": "BOOL", "description": "This input signal indicates whether the timing should be active."}, {"name": "RST", "type": "BOOL", "description": "This input signal resets the SECONDS and CYCLES outputs."}], "output": [{"name": "SECONDS", "type": "UDINT", "description": "The total elapsed time in seconds."}, {"name": "CYCLES", "type": "UDINT", "description": "The total count of active cycles."}], "in/out": [], "return_value": null}
{"title": "Sign Function", "description": "SIGN_I returns TRUE if the input value is negative. The input\nvalues are of type DINT.", "type": "FUNCTION", "name": "SIGN_I", "input": [{"name": "IN", "type": "DINT", "description": "A 32-bit signed integer input whose sign is to be checked."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "A boolean value indicating the sign of the input integer. Returns true if the sign bit is set (input is negative), otherwise returns false."}}
{"title": "Alarm Monitoring Block", "description": "SIGN_I returns TRUE if the input value is negative. The input\nvalues are of type DINT.", "type": "FUNCTION_BLOCK", "name": "ALARM_2", "input": [{"name": "X", "type": "REAL", "description": "The input value that is being monitored."}, {"name": "LO_1", "type": "REAL", "description": "The lower threshold for the first alarm."}, {"name": "HI_1", "type": "REAL", "description": "The upper threshold for the first alarm."}, {"name": "LO_2", "type": "REAL", "description": "The lower threshold for the second alarm."}, {"name": "HI_2", "type": "REAL", "description": "The upper threshold for the second alarm."}, {"name": "HYS", "type": "REAL", "description": "The hysteresis value applied to determine alarm state changes."}], "output": [{"name": "Q1_LO", "type": "BOOL", "description": "Output indicating if the first low alarm is triggered."}, {"name": "Q1_HI", "type": "BOOL", "description": "Output indicating if the first high alarm is triggered."}, {"name": "Q2_LO", "type": "BOOL", "description": "Output indicating if the second low alarm is triggered."}, {"name": "Q2_HI", "type": "BOOL", "description": "Output indicating if the second high alarm is triggered."}], "in/out": [], "return_value": null}
{"title": "Complex Inverse Function", "description": "CINV calculated the reciprocal of a complex number, CINV = 1/X", "type": "FUNCTION", "name": "CINV", "input": [{"name": "X", "type": "COMPLEX", "description": "Input variable of type complex representing the complex number for which the inverse is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The inverse of the input complex number.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the inverse complex number."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the inverse complex number."}]}}
{"title": "Calculate Volume of a Cone", "description": "CONE_V calculated the volume of a cone with the radius RX and height HX.", "type": "FUNCTION", "name": "CONE_V", "input": [{"name": "rx", "type": "REAL", "description": "The radius of the cone's base."}, {"name": "hx", "type": "REAL", "description": "The height of the cone."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated volume of the cone."}}
{"title": "Convert Hour to Time of Day", "description": "HOUR_TO_TOD calculate a time of day (TIMEOFDAY) from the\ninput value in hours as REAL.", "type": "FUNCTION", "name": "HOUR_TO_TOD", "input": [{"name": "IN", "type": "REAL", "description": "The input time in hours that needs to be converted to Time of Day."}], "output": [], "in/out": [], "return_value": {"type": "TOD", "description": "Returns the equivalent Time of Day representation of the input hours.", "fields": []}}
{"title": "BYTE_To_STRH", "description": "BYTE_TO_STRH converts a byte into a fxed-length STRING. The output\nstring is exactly two characters long and is the hexadecimal notation of\nthe value of IN. The output string consists of the characters '0 '.. '9' and\n'A' .. 'F'. The least signifcant sign is right in the STRING.", "type": "FUNCTION", "name": "BYTE_TO_STRH", "input": [{"name": "IN", "type": "BYTE", "description": "The BYTE input variable to be converted into a hexadecimal string."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The resulting string representation of the input BYTE in hexadecimal format.", "fields": []}}
{"title": "Minute Calculation from Time of Day", "description": "MINUTE function extracts the current minute of the day.", "type": "FUNCTION", "name": "MINUTE", "input": [{"name": "itod", "type": "TOD", "description": "The Time of Day input from which the minute value will be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The calculated minute value derived from the given Time of Day input."}}
{"title": "ESR Monitoring Function Block", "description": "MINUTE function extracts the current minute of the day.", "type": "FUNCTION_BLOCK", "name": "ESR_MON_X8", "input": [{"name": "s0", "type": "BYTE", "description": "First status input byte."}, {"name": "s1", "type": "BYTE", "description": "Second status input byte."}, {"name": "s2", "type": "BYTE", "description": "Third status input byte."}, {"name": "s3", "type": "BYTE", "description": "Fourth status input byte."}, {"name": "s4", "type": "BYTE", "description": "Fifth status input byte."}, {"name": "s5", "type": "BYTE", "description": "Sixth status input byte."}, {"name": "s6", "type": "BYTE", "description": "Seventh status input byte."}, {"name": "s7", "type": "BYTE", "description": "Eighth status input byte."}, {"name": "DT_in", "type": "DT", "description": "DateTime input parameter."}, {"name": "Mode", "type": "BYTE", "description": "Mode of operation, default is 3."}, {"name": "a0", "type": "STRING[10]", "description": "Additional string input for status s0."}, {"name": "a1", "type": "STRING[10]", "description": "Additional string input for status s1."}, {"name": "a2", "type": "STRING[10]", "description": "Additional string input for status s2."}, {"name": "a3", "type": "STRING[10]", "description": "Additional string input for status s3."}, {"name": "a4", "type": "STRING[10]", "description": "Additional string input for status s4."}, {"name": "a5", "type": "STRING[10]", "description": "Additional string input for status s5."}, {"name": "a6", "type": "STRING[10]", "description": "Additional string input for status s6."}, {"name": "a7", "type": "STRING[10]", "description": "Additional string input for status s7."}], "output": [{"name": "ESR_Flag", "type": "BOOL", "description": "Flag indicating if any status input has changed and an output was updated."}], "in/out": [{"name": "ESR_Out", "type": "ARRAY[0..3] OF esr_data", "description": "Output array that stores the converted status based on inputs."}], "return_value": null}
{"title": "Sigmoid Function", "description": "SIGMOID = 1 / (1 + EXP(-X))\nThe Sigmoid is often used as activation function. By its behavior the\nSigmoid is qualifed for soft switching transitions.\nThe following chart illustrates the progress of the Sigmoid :", "type": "FUNCTION", "name": "SIGMOID", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the sigmoid function is to be calculated."}], "output": [{"name": "SIGMOID", "type": "REAL", "description": "The output of the sigmoid function calculated based on the input value X."}], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated sigmoid value based on the input X, returning 1.0, 0.0, or the computed value based on the sigmoid formula.", "fields": []}}
{"title": "String Mirror Function", "description": "MIRROR reads the string STR reverse and passes the characters in reverse\norder.", "type": "FUNCTION", "name": "MIRROR", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The input string that needs to be mirrored."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The mirrored version of the input string."}}
{"title": "Hexadecimal to DWORD Converter", "description": "HEX_TO_DWORD converts a hexadecimal string in a DWORD\nvalue. Here only hexadecimal characters '0'..'9', 'a..f' and 'A'.. 'F' are inter￾preted, others occurring in HEX characters are ignored.", "type": "FUNCTION", "name": "HEX_TO_DWORD", "input": [{"name": "Hex", "type": "STRING", "description": "A hexadecimal string input with a maximum length of 20 characters."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The DWORD value that results from converting the hexadecimal input string.", "fields": []}}
{"title": "TMAX Function Block", "description": "TMAX limits the duration of the output pulse to the time PT. The output Q\nfollows the input IN, as long as the TRUE time of IN is shorter than PT. If IN\nis longer than PT to TRUE, the output pulse is shortened. Whenever an\noutput changes by a timeout to FALSE, the output Z is set to TRUE for a\ncycle.", "type": "FUNCTION_BLOCK", "name": "TMAX", "input": [{"name": "IN", "type": "BOOL", "description": "Input boolean signal that triggers the function block."}, {"name": "PT", "type": "TIME", "description": "Time duration that the input signal must be TRUE for in order to reset the output."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output signal that indicates whether the function block is active or not."}, {"name": "Z", "type": "BOOL", "description": "Output signal that indicates that the timing condition has been satisfied, i.e., the input was TRUE for the specified duration."}], "in/out": [], "return_value": null}
{"title": "Convert BYTE to STRING Representation", "description": "BYTE_TO_STRB convert a byte into a fxed-length STRING. The output\nstring is exactly 8 characters long and is the bitwise notation of the value\nof IN. The output string consists of the characters '0 'and '1'. The least si￾gnifcant bit is right in the STRING. If a STRING is required with less than 8\ncharacters, it can be truncated with the standard function RIGHT () accor￾dingly. The call RIGHT(BYTE_TO_STRB (X),4) results in a STRING with four\ncharacters that correspond to the content of the lowest 4 bits of X.", "type": "FUNCTION", "name": "BYTE_TO_STRB", "input": [{"name": "IN", "type": "BYTE", "description": "The BYTE value to be converted into a string."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The string representation of the byte input, consisting of 8 characters representing each bit.", "fields": []}}
{"title": "AGDF Function Implementation", "description": "AGDF calculates the inverse Gundermann function.\nThe calculation is done using the formula:", "type": "FUNCTION", "name": "AGDF", "input": [{"name": "X", "type": "REAL", "description": "The input real value for which the AGDF function will compute the result."}], "output": [{"name": "AGDF", "type": "REAL", "description": "The output result of the AGDF function, which is the computed natural logarithm value."}], "in/out": [], "return_value": {"type": "REAL", "description": "The return value of the AGDF function is a REAL number representing the natural logarithm of the specified computation."}}
{"title": "PT1 Differentiator Function Block", "description": "AGDF calculates the inverse Gundermann function.\nThe calculation is done using the formula:", "type": "FUNCTION_BLOCK", "name": "FT_PDT1", "input": [{"name": "IN", "type": "REAL", "description": "The input signal to be processed."}, {"name": "KP", "type": "REAL", "description": "The proportional gain factor, default value is 1.0."}, {"name": "TV", "type": "REAL", "description": "The time constant for the differentiator, default value is 1.0."}, {"name": "T1", "type": "REAL", "description": "The time constant for the PT1 filter, default value is 1.0."}], "output": [{"name": "Y", "type": "REAL", "description": "The output of the function block, which is the combined result of the processed input."}], "in/out": [], "return_value": {}}
{"title": "OSCAT_VERSION Function", "description": "OSCAT_VERSION iprovides if IN = FALSE the current version number as\nDWORD. If IN is set to TRUE then the release date of the current version as\na DWORD is returned.", "type": "FUNCTION", "name": "OSCAT_VERSION", "input": [{"name": "IN", "type": "BOOL", "description": "A boolean input parameter that determines which version number to return."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The DWORD value representing the OSCAT version based on the input parameter.", "fields": []}}
{"title": "Convert BYTE to Range", "description": "BYTE_TO_RANGE convert a BYTE value to a REAL. An input value of 0 cor￾responds to the REAL value of LOW and an input value of 255 corresponds\nto the input value of HIGH.\nTo convert a BYTE value of 0 .255 to a percent of 0 .100 the module is cal￾led, as follows:\nBYTE_TO_RANGE (X,0,100)", "type": "FUNCTION", "name": "BYTE_TO_RANGE", "input": [{"name": "X", "type": "BYTE", "description": "The BYTE value to be converted, which should be in the range of 0 to 255."}, {"name": "low", "type": "REAL", "description": "The lower boundary of the desired range."}, {"name": "high", "type": "REAL", "description": "The upper boundary of the desired range."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The scaled value in the range defined by low and high based on the input BYTE value.", "fields": []}}
{"title": "String to Weekday Conversion", "description": "FSTRING_TO_WEEKDAY decodes a weekday in the form 'MO' to an integer,\n1 = MO ... 7 = Sun. For the analysis the frst two letters of the string WDAY\nare evaluated, all others are ignored. If the string contains spaces they will\nbe removed. The days of the week can be present in both upper-or lower￾case. Since the function evaluates only the frst two characters, the week￾days may also be spelled out (Monday) format.\nMo = 1; Di, Tu = 2; We, Mi = 3; Th, Do = 4; Fr = 5; Sa = 6; So, Su = 7\nAs an alternative form, the weekday can be specifed as number 1..7.\nLANG specifes the used language, 1 = English, 2 = German, 0 = defned\ndefault language in the Setup.", "type": "FUNCTION", "name": "FSTRING_TO_WEEKDAY", "input": [{"name": "WDAY", "type": "STRING[20]", "description": "A string representation of the weekday to be converted."}, {"name": "LANG", "type": "INT", "description": "An integer representing the language index to be used for weekday conversion. 0 refers to the default language."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "An integer representing the corresponding weekday (1 to 7) if a match is found, otherwise the result of STRING_TO_INT on WDAY."}}
{"title": "Convert Two Words to a DWORD", "description": "DWORD_OF_WORD creates from 2 separate WORDS W0 und W1 a\nDWORD.\nA DWORD is composed as follows: W1-W0.", "type": "FUNCTION", "name": "DWORD_OF_WORD", "input": [{"name": "W1", "type": "WORD", "description": "The first 16-bit WORD value to be converted and shifted."}, {"name": "W0", "type": "WORD", "description": "The second 16-bit WORD value to be combined with the first."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The resulting 32-bit DWORD value formed by combining W1 and W0.", "fields": []}}
{"title": "ESR Monitor Block", "description": "DWORD_OF_WORD creates from 2 separate WORDS W0 und W1 a\nDWORD.\nA DWORD is composed as follows: W1-W0.", "type": "FUNCTION_BLOCK", "name": "ESR_MON_B8", "input": [{"name": "s0", "type": "BOOL", "description": "Boolean input 0 for state monitoring."}, {"name": "s1", "type": "BOOL", "description": "Boolean input 1 for state monitoring."}, {"name": "s2", "type": "BOOL", "description": "Boolean input 2 for state monitoring."}, {"name": "s3", "type": "BOOL", "description": "Boolean input 3 for state monitoring."}, {"name": "s4", "type": "BOOL", "description": "Boolean input 4 for state monitoring."}, {"name": "s5", "type": "BOOL", "description": "Boolean input 5 for state monitoring."}, {"name": "s6", "type": "BOOL", "description": "Boolean input 6 for state monitoring."}, {"name": "s7", "type": "BOOL", "description": "Boolean input 7 for state monitoring."}, {"name": "DT_in", "type": "DT", "description": "Data time input to be associated with the monitored states."}, {"name": "a0", "type": "STRING[10]", "description": "String address for input 0."}, {"name": "a1", "type": "STRING[10]", "description": "String address for input 1."}, {"name": "a2", "type": "STRING[10]", "description": "String address for input 2."}, {"name": "a3", "type": "STRING[10]", "description": "String address for input 3."}, {"name": "a4", "type": "STRING[10]", "description": "String address for input 4."}, {"name": "a5", "type": "STRING[10]", "description": "String address for input 5."}, {"name": "a6", "type": "STRING[10]", "description": "String address for input 6."}, {"name": "a7", "type": "STRING[10]", "description": "String address for input 7."}], "output": [{"name": "ESR_Flag", "type": "BOOL", "description": "Flag indicating if any input state has changed."}], "in/out": [{"name": "ESR_Out", "type": "ARRAY[0..3] OF esr_data", "description": "Array of output data structures that hold information about the changes in the inputs."}], "return_value": null}
{"title": "Click Edge Detection and Counting Function Block", "description": "CLICK_DEC decodes multiple keystrokes and signals to diferent outputs\nthe number of pulses. An input signal without falling edge within TC is is￾sued at Q0 and remains TRUE until IN goes on FALSE. A pulse followed by\na TRUE is output to Q1 and so on. Is a pulse registered within TC which is\nfollowed by the state FALSE, then TRUE appear at the corresponding out￾put for a PLC cycle.", "type": "FUNCTION_BLOCK", "name": "CLICK_DEC", "input": [{"name": "IN", "type": "BOOL", "description": "Boolean input signal that triggers edge detection."}, {"name": "TC", "type": "TIME", "description": "Time constant used for timing operations within the block."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal activated when the count is zero."}, {"name": "Q1", "type": "BOOL", "description": "Output signal activated when the count is one."}, {"name": "Q2", "type": "BOOL", "description": "Output signal activated when the count is two."}, {"name": "Q3", "type": "BOOL", "description": "Output signal activated when the count is three."}], "in/out": [], "return_value": null}
{"title": "Find Character in String", "description": "FIND_CHAR searches the string STR starting at position POS and returns\nthe position at which the frst character is not a control character. Control\ncharacters are all characters whose value is less than 32 or 127. In exami￾ning the Global Setup EXTENDED_ASCII constant is considered. If EXTEN￾DED_ASCII = TRUE the extended ASCII character-set to be considered in\naccordance with ISO 8859-1. Umlauts like Ä, Ö, Ü are considered only if\nthe global constant EXTENDED_ASCII = TRUE. If EXTENDED_ASCII = FAL￾SE characters of the extended character set with a value > 127 interpre￾ted as control characters.", "type": "FUNCTION", "name": "FIND_CHAR", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The string in which to search for the character."}, {"name": "pos", "type": "INT", "description": "The starting position in the string from which to begin the search."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The index of the found character if it meets the criteria; otherwise, 0.", "fields": []}}
{"title": "Trend Detection Function Block", "description": "TREND_DW monitors the input X and time at the output Q to see if X incre￾ases (Q = TRUE) or X decrease (Q = FALSE). If X does not change, Q re￾mains at its last value. If X increases, the output TU gets for one cycle to\nTRUE and at the output D the result X - LAST_X is displayed. If X is less\nthan LAST_X so TD gets TRUE for one cycle and the output D is LAST_X - X\npassed. LAST_X is an internal value of the module and is the value of X in\nthe last cycle.", "type": "FUNCTION_BLOCK", "name": "TREND_DW", "input": [{"name": "X", "type": "DWORD", "description": "The input value to be monitored for trend detection."}], "output": [{"name": "Q", "type": "BOOL", "description": "Indicates whether the input value 'X' has changed."}, {"name": "TU", "type": "BOOL", "description": "True if an upward trend is detected (X has increased)."}, {"name": "TD", "type": "BOOL", "description": "True if a downward trend is detected (X has decreased)."}, {"name": "D", "type": "DWORD", "description": "The difference in value between the current and last input value."}], "in/out": [], "return_value": null}
{"title": "PID Controller Function Block", "description": "CTRL_PI is a PI controller with dynamic anti-wind-up and manual control in￾put. The PI controller operates according to the formula:\nY = KP * DIFF + KI * INTEG(DIFF) + OFFSET\nwhere DIFF = SET_POINT - ACTUAL\nIn manual mode (manual = TRUE) is: Y = MANUAL_IN+ OFFSET\nACT is the measured value for the controlled system and set the setpoint\nfor the controller. The input values of LH and LL limit Output value Y. With\nRST the internal integrator may be set to 0 any time. The output LIM si￾gnals that the controller has reached the limit of LL or LH. The PI controller\nis free running and uses the trapezoidal rule to calculate the integrator for\nthe highest accuracy and optimal speed. The Default Values of the input\nparameters are predefned as follows: KP = 1, KI = 1, LIMIT_L = -1000 and\nLIMIT_H = +1000. With the input SUP a noise reduction is set, the value on\ninput SUP determines at which control diference the controller turns on.\nWith SUP is avoided that the output of the controller varies continously.\nThe value at the input SUP should be in dimension that it suppresses the\nnoise of the controlled system and the sensors. If the input to SUP is set to\n0.1, the controller is only at deviations greater than 0.1 active. At the out￾put DIFF the measured and through a Noise Filter (DEAD_BAND) fltered\ncontrol deviation is available. DIFF is normally not required in a controlled\nsystem but can be used to infuence the control parameters. The input\nOFS is added as the last value to output, and is used to compensate main￾ly of noise, whose efect can be estimated on the loop. \nThe controller works with a dynamic air- Up that prevents that the integra￾tor, when reaching a output limit and further deviation, continues to run\nunlimited and afects the properties usually negative. In the introduction\nchapter of the control technology, more details can be found on anti-wind￾up. \nThe following graph illustrates the internal structure of the controller:", "type": "FUNCTION_BLOCK", "name": "CTRL_PI", "input": [{"name": "ACT", "type": "REAL", "description": "The actual value to be used in the PID control."}, {"name": "SET", "type": "REAL", "description": "The desired setpoint value for the PID control."}, {"name": "SUP", "type": "REAL", "description": "The reference value for supervision purposes."}, {"name": "OFS", "type": "REAL", "description": "Offset value to adjust the output signal."}, {"name": "M_I", "type": "REAL", "description": "Manual input value for the controller."}, {"name": "MAN", "type": "BOOL", "description": "Manual mode switch; if true, the controller uses manual input."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to reset the controller operation."}, {"name": "KP", "type": "REAL", "description": "Proportional gain factor for the PID controller.", "fields": null}, {"name": "KI", "type": "REAL", "description": "Integral gain factor for the PID controller.", "fields": null}, {"name": "LL", "type": "REAL", "description": "Lower limit for the output value.", "fields": null}, {"name": "LH", "type": "REAL", "description": "Upper limit for the output value.", "fields": null}], "output": [{"name": "Y", "type": "REAL", "description": "The output value generated by the PID controller."}, {"name": "DIFF", "type": "REAL", "description": "The difference between the setpoint and actual value."}, {"name": "LIM", "type": "BOOL", "description": "Flag indicating whether the output is within the limits."}], "in/out": [], "return_value": null}
{"title": "Convert Byte to Uppercase", "description": "TO_UPPER converts some characters to uppercase. During conversion, the\nGlobal Setup EXTENDED_ASCII constant is considered. If EXTENDED_ASCII\n= TRUE, all characters of the extended ASCII character set to be conside￾red in accordance with ISO 8859-1.\nThe following Table discusses the conversion code:\nCode EXTENDED_ASCII = TRUE EXTENDED_ASCII = FALSE\n0..64 0..64 0..64\n65..90 97..122 97..122\n91..191 91..191 91..191\n192..214 224..246 192..214\n215 215 215\n216..222 248..254 216..254\n223..255 223..255 223..255", "type": "FUNCTION", "name": "TO_UPPER", "input": [{"name": "IN", "type": "BYTE", "description": "The BYTE value to be converted to uppercase."}], "output": [{"name": "TO_UPPER", "type": "BYTE", "description": "The uppercase equivalent of the input BYTE, or the original input if no conversion is applicable."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The result of the uppercase conversion for the input BYTE.", "fields": []}}
{"title": "Mixing Two Real Values", "description": "MIX provides at the output a mixed ratio M value, mixed from values A and\nB. The input M passes the proportion of B in the range 0..1.\nMIX = (M-1)*A + M*B", "type": "FUNCTION", "name": "MIX", "input": [{"name": "A", "type": "REAL", "description": "The first real value to be mixed."}, {"name": "B", "type": "REAL", "description": "The second real value to be mixed."}, {"name": "M", "type": "REAL", "description": "The mixing factor, which determines the weight of each input value in the final result."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the mixing operation, calculated as (1.0 - M) * A + M * B."}}
{"title": "Convert DWORD to String", "description": "DWORD_TO_STRB converts a DWORD, Word or byte in a STRING of fxed\nlength. The output string is exactly 32 characters long and is the bitwise\nnotation of the value of IN. The output string consists of the characters '0\n'and '1'. The least signifcant bit is left in the string. DWORD_TO_STRB can\nhandle input formats, Byte, Word and DWORD types. The output is inde￾pendent of the input type is always a STRING of 32 characters. If a shorter\nstring is needed, it can be cut with the standard function RIGHT() accor-\ndingly. The call RIGHT(DWORD_TO_STRB(X),8) results to a string of 8 cha￾racters to the contents of the lower bytes of X.", "type": "FUNCTION", "name": "DWORD_TO_STRB", "input": [{"name": "IN", "type": "DWORD", "description": "The input DWORD value that needs to be converted to a string."}], "output": [{"name": "DWORD_TO_STRB", "type": "string", "description": "The output string representation of the input DWORD value, containing binary characters."}], "in/out": [], "return_value": {"type": "string", "description": "The resulting binary string derived from the input DWORD.", "fields": []}}
{"title": "Fahrenheit to Celsius Conversion", "description": "F_TO_C converts a temperature reading from Fahrenheit in Celsius.", "type": "FUNCTION", "name": "F_TO_C", "input": [{"name": "fahrenheit", "type": "REAL", "description": "The temperature value in Fahrenheit that needs to be converted to Celsius."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The converted temperature value in Celsius.", "fields": []}}
{"title": "Hysteresis Control Logic", "description": "F_TO_C converts a temperature reading from Fahrenheit in Celsius.", "type": "FUNCTION_BLOCK", "name": "HYST_2", "input": [{"name": "IN", "type": "REAL", "description": "The input value to be evaluated against the hysteresis conditions."}, {"name": "VAL", "type": "REAL", "description": "The reference value from which hysteresis is calculated."}, {"name": "HYS", "type": "REAL", "description": "The amount of hysteresis used to determine the output states."}], "output": [{"name": "Q", "type": "BOOL", "description": "The boolean output indicating if the input is above the upper hysteresis threshold."}, {"name": "WIN", "type": "BOOL", "description": "The boolean output indicating if the input is within the hysteresis window."}], "in/out": [], "return_value": {}}
{"title": "Decimal String to Integer Conversion", "description": "DEC_TO_INT converts a decimal encoded string into a byte\nvalue. Here only decimal characters '0 '.. '9' and '-' are interpreted, others\nin DEC occurring characters are ignored .", "type": "FUNCTION", "name": "DEC_TO_INT", "input": [{"name": "DEC", "type": "STRING[10]", "description": "The input decimal string to be converted to an integer."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The integer value resulting from the conversion of the input decimal string.", "fields": []}}
{"title": "Analog Input Processing", "description": "DEC_TO_INT converts a decimal encoded string into a byte\nvalue. Here only decimal characters '0 '.. '9' and '-' are interpreted, others\nin DEC occurring characters are ignored .", "type": "FUNCTION_BLOCK", "name": "AIN1", "input": [{"name": "in", "type": "DWORD", "description": "The input value that needs to be processed."}, {"name": "sign_bit", "type": "INT", "description": "The position of the sign bit in the input value, defaulting to 255."}, {"name": "error_bit", "type": "INT", "description": "The position of the error bit in the input value, defaulting to 255."}, {"name": "error_code_en", "type": "BOOL", "description": "A boolean flag enabling error code checking."}, {"name": "error_code", "type": "DWORD", "description": "The error code to compare against the input value."}, {"name": "overflow_bit", "type": "INT", "description": "The position of the overflow bit in the input value, defaulting to 255."}, {"name": "overflow_code_en", "type": "BOOL", "description": "A boolean flag enabling overflow code checking."}, {"name": "overflow_code", "type": "DWORD", "description": "The overflow code to compare against the input value."}, {"name": "Bit_0", "type": "INT", "description": "The starting bit position for the processing."}, {"name": "Bit_N", "type": "INT", "description": "The maximum bit position for processing, defaulting to 31."}, {"name": "out_min", "type": "REAL", "description": "The minimum output value after conversion."}, {"name": "out_max", "type": "REAL", "description": "The maximum output value after conversion, defaulting to 10.0."}, {"name": "code_min", "type": "DWORD", "description": "The minimum allowable code value for valid input."}, {"name": "code_max", "type": "DWORD", "description": "The maximum allowable code value for valid input, defaulting to 16#FFFFFFFF."}, {"name": "error_output", "type": "REAL", "description": "Output value when an error condition is detected."}, {"name": "overflow_output", "type": "REAL", "description": "Output value when an overflow condition is detected, defaulting to 10.0."}], "output": [{"name": "out", "type": "REAL", "description": "The processed output value after conversion."}, {"name": "sign", "type": "BOOL", "description": "Indicator of the sign of the output value."}, {"name": "error", "type": "BOOL", "description": "Flag indicating whether an error condition was detected."}, {"name": "overflow", "type": "BOOL", "description": "Flag indicating whether an overflow condition was detected."}], "in/out": [], "return_value": null}
{"title": "Find Position of Substring", "description": "FINDP searches in a string STR starting at position POS for a string SRC. If\nSRC found in the string so the position of the frst character of SRC in STR\nis returned. If the string starting at position POS is not found, an 0 is retur￾ned. If an empty string is specifed as the search string, the module deli￾vers the result 0.", "type": "FUNCTION", "name": "FINDP", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The string in which to search for the substring."}, {"name": "src", "type": "STRING[STRING_LENGTH]", "description": "The substring that is being searched for in the main string."}, {"name": "pos", "type": "INT", "description": "The position from which to start searching in the main string."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The position of the first occurrence of the substring; returns 0 if the substring is not found.", "fields": []}}
{"title": "Scheduler Function Block", "description": "SCHEDULER is used to call time dependent program parts. For example,\ncomplex calculations that are needed only rarely, can be called at fxed in￾tervals. The outputs Q? of the module will be active only for one cycle and\nrelease the execution of the program part. The setup time T? specify at\nwhich intervals the outputs are enabled. SCHEDULER checks per CPU cy￾cle only one output, so that in maximum one output per cycle can be acti￾ve. In the extreme case when all call times T? are T#0s, in each cycle one\noutput should be set, so that frst Q0, then Q1, etc. to Q3 are set and then\nagain to start Q0. The call times can therefore up to 3 CPU cycles and dif￾fer from the predetermined value T? .", "type": "FUNCTION_BLOCK", "name": "SCHEDULER", "input": [{"name": "E0", "type": "BOOL", "description": "Input event signal for output Q0."}, {"name": "E1", "type": "BOOL", "description": "Input event signal for output Q1."}, {"name": "E2", "type": "BOOL", "description": "Input event signal for output Q2."}, {"name": "E3", "type": "BOOL", "description": "Input event signal for output Q3."}, {"name": "T0", "type": "TIME", "description": "The time interval for activating output Q0."}, {"name": "T1", "type": "TIME", "description": "The time interval for activating output Q1."}, {"name": "T2", "type": "TIME", "description": "The time interval for activating output Q2."}, {"name": "T3", "type": "TIME", "description": "The time interval for activating output Q3."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal indicating the status of E0 after T0 has elapsed."}, {"name": "Q1", "type": "BOOL", "description": "Output signal indicating the status of E1 after T1 has elapsed."}, {"name": "Q2", "type": "BOOL", "description": "Output signal indicating the status of E2 after T2 has elapsed."}, {"name": "Q3", "type": "BOOL", "description": "Output signal indicating the status of E3 after T3 has elapsed."}], "in/out": [], "return_value": {}}
{"title": "Circle Calculation Function", "description": "CIRCLE_C calculates the arc length of an arc with the angle AX and radius\nRX. If the angle is set AX = 360 so the circumference is calculated.", "type": "FUNCTION", "name": "CIRCLE_C", "input": [{"name": "Rx", "type": "REAL", "description": "The radius of the circle."}, {"name": "Ax", "type": "REAL", "description": "The axis factor used in the calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed value from the formula that involves the radius and axis factor."}}
{"title": "8-bit Shift Register Function Block", "description": "CIRCLE_C calculates the arc length of an arc with the angle AX and radius\nRX. If the angle is set AX = 360 so the circumference is calculated.", "type": "FUNCTION_BLOCK", "name": "SHR_8PLE", "input": [{"name": "Din", "type": "BOOL", "description": "Input data bit to be shifted into the register."}, {"name": "Dload", "type": "BYTE", "description": "Byte value to load into the register when load signal is active."}, {"name": "CLK", "type": "BOOL", "description": "Clock signal which triggers the shifting operation."}, {"name": "UP", "type": "BOOL", "description": "Direction of shift; TRUE for shift up, FALSE for shift down."}, {"name": "load", "type": "BOOL", "description": "Signal to load Dload value into the register."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to clear the register."}], "output": [{"name": "DOut", "type": "BOOL", "description": "Output data bit, represents the bit shifted out of the register."}], "in/out": [], "return_value": null}
{"title": "Convert WORD to Range", "description": "WORD_TO_RANGE converts a WORD value to a REAL value. An input value\nof 0 corresponds to the real value of LOW and an input value of 65535 cor￾responds to the input value of HIGH.\nTo convert a WORD value of 0..65535 in a percentage of 0..100, the modu￾le is called as follows:\nWORD_TO_RANGE(X,100,0)\n 20. Sensors", "type": "FUNCTION", "name": "WORD_TO_RANGE", "input": [{"name": "X", "type": "WORD", "description": "The WORD value to be converted into the specified range."}, {"name": "low", "type": "REAL", "description": "The lower bound of the range to which the WORD value will be mapped."}, {"name": "high", "type": "REAL", "description": "The upper bound of the range to which the WORD value will be mapped."}], "output": [{"name": "WORD_TO_RANGE", "type": "REAL", "description": "The resulting REAL value after mapping the WORD input into the specified range."}], "in/out": [], "return_value": {"type": "REAL", "description": "The mapped REAL value based on the input WORD and specified range.", "fields": []}}
{"title": "Range to Word Conversion", "description": "RANGE_TO_WORD converts a REAL value to a WORD value. An input value\nof X corresponds to the value of LOW is converted it into an output value\nof 0 and an input value X that corresponds to HIGH is converted to an out￾put value of 65535. The X input is limited to the range from LOW to HIGH,\nan overfow of the output WORD therefore can not happen.", "type": "FUNCTION", "name": "RANGE_TO_WORD", "input": [{"name": "X", "type": "REAL", "description": "The input real number that needs to be converted."}, {"name": "low", "type": "REAL", "description": "The lower limit for the range."}, {"name": "high", "type": "REAL", "description": "The upper limit for the range."}], "output": [], "in/out": [], "return_value": {"type": "WORD", "description": "The word representation of the normalized input value.", "fields": []}}
{"title": "Conversion from BFT to MS", "description": "BFT_TO_MS calculete wind speeds on the Beaufort scale in meters per se￾cond.\nThe calculation is done using the formula:\nBFT_TO_MS = 0.836m/s * B^3/2", "type": "FUNCTION", "name": "BFT_TO_MS", "input": [{"name": "BFT", "type": "INT", "description": "An integer value representing BFT to be converted to MS."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The converted MS value calculated as BFT raised to the power of 1.5 multiplied by 0.836."}}
{"title": "Convert String to Lowercase", "description": "LOWERCASE converts the String STR to lower case. During\nconversion, the Global Setup EXTENDED_ASCII constant is considered. If\nEXTENDED_ASCII = TRUE extended ASCII character set are evaluated ac￾cording to ISO 8859-1. Umlauts like Ä, Ö, Ü are considered only if the glo￾bal constant EXTENDED_ASCII = TRUE. A detailed description of the code\nchange is found in the function TO_LOWER.", "type": "FUNCTION", "name": "LOWERCASE", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string that needs to be converted to lowercase."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "The lowercase version of the input string.", "fields": []}}
{"title": "Buffer Comparison Function", "description": "BUFFER_COMP checks whether the content of the array PT2\noccurs in the array PT1 from position START. If PT2 is found in PT1, so the\nfunction returns the position in PT1, starting from 0. If PT2 is not found in\nPT1, -1 is returned. BUFFER_COMP can also be used for comparison of two\nequally sized arrays.\nWhen called, a Pointer to the array and its size in bytes is passed to the\nfunction. In CoDeSys the call reads: BUFFER_COMP(ADR(BUF1),\nSIZEOF(BUF1), ADR(BUF2), SIZEOF(BUF2)), where BUF1 and BUF2 are the\nnames of the arrays to be manipulated. ADR() is a standard function which\nindentifes the Pointer to the array and SIZEOF() is a standard function,\nwhich determines the size of the array. The function only returns TRUE.\nThe array specifed by the Pointer is manipulated directly in memory. This\ntype of processing arrays is very efcient because no additional memory\nis required and no surrender values must be copied.", "type": "FUNCTION", "name": "BUFFER_COMP", "input": [{"name": "PT1", "type": "POINTER TO ARRAY [0..32767] OF BYTE", "description": "Pointer to the first byte array where the search will be performed."}, {"name": "SIZE1", "type": "INT", "description": "The size of the first byte array (PT1)."}, {"name": "PT2", "type": "POINTER TO ARRAY [0..32767] OF BYTE", "description": "Pointer to the second byte array which will be searched within the first byte array."}, {"name": "SIZE2", "type": "INT", "description": "The size of the second byte array (PT2)."}, {"name": "START", "type": "INT", "description": "The starting index in the first byte array (PT1) from which the search will be initiated."}], "output": [{"name": "BUFFER_COMP", "type": "INT", "description": "Returns the index of the first match in the first byte array (PT1), or -1 if no match was found."}], "in/out": [], "return_value": {"type": "INT", "description": "The return value indicates the position of the first occurrence of the second byte array in the first byte array.", "fields": []}}
{"title": "Gamma Function Calculation", "description": "GAMMA calculates the gamma function after approximation\nof NEMES.\nThe gamma function can be used for Integer X as replacement for the Fa￾culty.", "type": "FUNCTION", "name": "GAMMA", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the Gamma function is to be calculated."}], "output": [{"name": "GAMMA", "type": "REAL", "description": "The computed Gamma value based on the input X."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the Gamma function calculation.", "fields": []}}
{"title": "Normalize a 3D Vector", "description": "GAMMA calculates the gamma function after approximation\nof NEMES.\nThe gamma function can be used for Integer X as replacement for the Fa￾culty.", "type": "FUNCTION", "name": "V3_NORM", "input": [{"name": "A", "type": "Vector_3", "description": "The input 3D vector that needs to be normalized."}], "output": [{"name": "V3_NORM", "type": "vector_3", "description": "The normalized 3D vector as the output."}], "in/out": [], "return_value": {"type": "vector_3", "description": "The normalized form of the input vector.", "fields": []}}
{"title": "Convert Bytes to DWORD", "description": "DWORD_OF_BYTE creates from 4 individual bytes (B0 .. B3) a DWORD.\nA DWORD is composed as follows: B3-B2-B1-B0.", "type": "FUNCTION", "name": "DWORD_OF_BYTE", "input": [{"name": "B3", "type": "BYTE", "description": "The highest byte of the DWORD."}, {"name": "B2", "type": "BYTE", "description": "The second highest byte of the DWORD."}, {"name": "B1", "type": "BYTE", "description": "The third byte of the DWORD."}, {"name": "B0", "type": "BYTE", "description": "The lowest byte of the DWORD."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The combined DWORD value generated from the four input BYTE values."}}
{"title": "Vector Subtraction Function", "description": "DWORD_OF_BYTE creates from 4 individual bytes (B0 .. B3) a DWORD.\nA DWORD is composed as follows: B3-B2-B1-B0.", "type": "FUNCTION", "name": "V3_SUB", "input": [{"name": "A", "type": "Vector_3", "description": "The first input vector from which the second vector will be subtracted."}, {"name": "B", "type": "Vector_3", "description": "The second input vector that will be subtracted from the first vector."}], "output": [], "in/out": [], "return_value": {"type": "vector_3", "description": "The resultant vector after subtracting vector B from vector A.", "fields": [{"name": "X", "type": "REAL", "description": "The X component of the resultant vector, calculated as A.X - B.X."}, {"name": "Y", "type": "REAL", "description": "The Y component of the resultant vector, calculated as A.Y - B.Y."}, {"name": "Z", "type": "REAL", "description": "The Z component of the resultant vector, calculated as A.Z - B.Z."}]}}
{"title": "Count Substring Occurrences", "description": "DWORD_OF_BYTE creates from 4 individual bytes (B0 .. B3) a DWORD.\nA DWORD is composed as follows: B3-B2-B1-B0.", "type": "FUNCTION", "name": "COUNT_SUBSTRING", "input": [{"name": "SEARCH", "type": "STRING", "description": "The substring to search for within the main string."}, {"name": "STR", "type": "STRING", "description": "The main string in which substring occurrences will be counted."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The total number of occurrences of the substring within the main string."}}
{"title": "Complex Number Multiplication", "description": "CMUL Multiplies two complex numbers X and Y.", "type": "FUNCTION", "name": "CMUL", "input": [{"name": "X", "type": "COMPLEX", "description": "The first complex number to be multiplied."}, {"name": "Y", "type": "COMPLEX", "description": "The second complex number to be multiplied."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The result of multiplying the two complex numbers.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the resulting complex number."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the resulting complex number."}]}}
{"title": "Simple Signal Handler Function Block", "description": "SH is a Sample and Hold module. It saves on each rising edge of CLK, the\ninput signal IN at the output OUT. After each update of TRIG OUT is TRUE\nfor one cycle. \nThe following", "type": "FUNCTION_BLOCK", "name": "SH", "input": [{"name": "in", "type": "REAL", "description": "Input Real Variable that receives the signal to be processed."}, {"name": "CLK", "type": "BOOL", "description": "Clock Input Variable that triggers the processing of the input signal."}], "output": [{"name": "out", "type": "REAL", "description": "Output Real Variable that reflects the captured input value when triggered."}, {"name": "trig", "type": "BOOL", "description": "Output BOOL Variable that indicates whether the input has been captured or not."}], "in/out": [], "return_value": null}
{"title": "Set Time of Day (TOD)", "description": "SET_TOD calculates a time of day (TOD) from the input va￾lues, hours, minutes and seconds.", "type": "FUNCTION", "name": "SET_TOD", "input": [{"name": "hour", "type": "INT", "description": "The hour component of the time, ranging from 0 to 23."}, {"name": "minute", "type": "INT", "description": "The minute component of the time, ranging from 0 to 59."}, {"name": "second", "type": "REAL", "description": "The second component of the time, which can include a fractional part for milliseconds."}], "output": [], "in/out": [], "return_value": {"type": "TOD", "description": "Returns the time of day value calculated from the input parameters.", "fields": []}}
{"title": "Function to Convert Frequency to Period Time", "description": "F_TO_PT converts a frequency value of Hz in the corresponding period.", "type": "FUNCTION", "name": "F_TO_PT", "input": [{"name": "F", "type": "REAL", "description": "The input frequency in Hertz."}], "output": [], "in/out": [], "return_value": {"type": "TIME", "description": "The calculated period time corresponding to the given frequency.", "fields": []}}
{"title": "Selection of Valid Inputs from Three Inputs", "description": "F_TO_PT converts a frequency value of Hz in the corresponding period.", "type": "FUNCTION_BLOCK", "name": "SEL2_OF_3", "input": [{"name": "IN1", "type": "REAL", "description": "The first input value."}, {"name": "IN2", "type": "REAL", "description": "The second input value."}, {"name": "IN3", "type": "REAL", "description": "The third input value."}, {"name": "D", "type": "REAL", "description": "The tolerance value to determine the validity of inputs."}], "output": [{"name": "Y", "type": "REAL", "description": "The calculated average of the selected valid input values."}, {"name": "W", "type": "INT", "description": "Indicator of which inputs were valid (0 for all, 1 for IN2 and IN3, 2 for IN3 and IN1, 3 for IN1 and IN2, 4 for none)."}, {"name": "E", "type": "BOOL", "description": "Error flag indicating if no valid input combinations were found."}], "in/out": [], "return_value": null}
{"title": "Calculate Stair Value", "description": "STAIR follows the input signal X with a step function. The \nheight of the steps is given by D. If X = 0, then the output directly follows \nthe input signal. STAIR is not suitable for fltering of input signals, because \nif the input fuctuates by a step , the output switches between two \nadjacent values back and forth. For this purpose we recommend the use of \nStair2 that works with a Hysteresis and avoids unstable conditions.\nThe following example illustrates the operation of STAIR:", "type": "FUNCTION", "name": "STAIR", "input": [{"name": "X", "type": "REAL", "description": "The value from which the stair calculation is derived."}, {"name": "D", "type": "REAL", "description": "The step size used for the stair calculation. Should be greater than zero for the operation to apply."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated stair value based on the inputs.", "fields": []}}
{"title": "Complex Hyperbolic Sine Function", "description": "CSINH calculates the hyperbolic sine of a complex number", "type": "FUNCTION", "name": "CSINH", "input": [{"name": "X", "type": "COMPLEX", "description": "A complex number for which the hyperbolic sine is to be calculated."}], "output": [{"name": "CSINH", "type": "complex", "description": "The complex hyperbolic sine of the input complex number."}], "in/out": [], "return_value": {"type": "complex", "description": "The calculated complex hyperbolic sine value.", "fields": [{"name": "re", "type": "float", "description": "The real part of the complex hyperbolic sine."}, {"name": "im", "type": "float", "description": "The imaginary part of the complex hyperbolic sine."}]}}
{"title": "Convert DWORD to REAL", "description": "DW_TO_REAL copies the bit pattern of a DWORD (IN) to a REAL. These bits\nare copied without regard to their meaning. The function REAL_TO_DW is\nthe inverse so that the conversion of REAL_TO_DW and then DW_TO_REAL\nresult in the output value. The IEC standard DWORD_TO_REAL function\nconverts the value of the DWORD to a REAL value.", "type": "FUNCTION", "name": "DW_TO_REAL", "input": [{"name": "X", "type": "DWORD", "description": "The DWORD input variable that needs to be converted to REAL."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The REAL value obtained from the conversion of the input DWORD.", "fields": []}}
{"title": "Array Initialization Function", "description": "_ARRAY_INIT initializes an arbitrary array of REAL with an in￾itial value. When called, a pointer to the array and its size in bytes is\ntransferred to the function. Under CoDeSys the call reads:\n_ARRAY_INIT(ADR(Array), SIZEOF(Array), INIT), where array is the name of\nthe array to be manipulated. ADR() is a standard function which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. The function only returns TRUE. The array spe￾cifed by the pointer is manipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "_ARRAY_INIT", "input": [{"name": "pt", "type": "POINTER TO ARRAY [0..32000] OF REAL", "description": "A pointer to the array that needs to be initialized."}, {"name": "size", "type": "UINT", "description": "The size of the array to be initialized."}, {"name": "init", "type": "REAL", "description": "The initial value to set for each element of the array."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the array initialization was successful."}}
{"title": "Message Generation Based on Alarm Status", "description": "_ARRAY_INIT initializes an arbitrary array of REAL with an in￾itial value. When called, a pointer to the array and its size in bytes is\ntransferred to the function. Under CoDeSys the call reads:\n_ARRAY_INIT(ADR(Array), SIZEOF(Array), INIT), where array is the name of\nthe array to be manipulated. ADR() is a standard function which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. The function only returns TRUE. The array spe￾cifed by the pointer is manipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION_BLOCK", "name": "MESSAGE_8", "input": [{"name": "IN1", "type": "BOOL", "description": "Indicates the presence of alarm 1."}, {"name": "IN2", "type": "BOOL", "description": "Indicates the presence of alarm 2."}, {"name": "IN3", "type": "BOOL", "description": "Indicates the presence of alarm 3."}, {"name": "IN4", "type": "BOOL", "description": "Indicates the presence of alarm 4."}, {"name": "IN5", "type": "BOOL", "description": "Indicates the presence of alarm 5."}, {"name": "IN6", "type": "BOOL", "description": "Indicates the presence of alarm 6."}, {"name": "IN7", "type": "BOOL", "description": "Indicates the presence of alarm 7."}, {"name": "IN8", "type": "BOOL", "description": "Indicates the presence of alarm 8."}, {"name": "S1", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 1."}, {"name": "S2", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 2."}, {"name": "S3", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 3."}, {"name": "S4", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 4."}, {"name": "S5", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 5."}, {"name": "S6", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 6."}, {"name": "S7", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 7."}, {"name": "S8", "type": "STRING[STRING_LENGTH]", "description": "Message to display for alarm 8."}], "output": [{"name": "M", "type": "STRING[STRING_LENGTH]", "description": "The output message based on the current alarm status."}], "in/out": [], "return_value": {}}
{"title": "Flip-Flop Dynamic Reset and Set", "description": "FF_DRE is a edge-triggered D-Flip-Flop with Asynchronous Set and Reset\ninput. A rising edge at CLK stores the input D to output Q. A TRUE on the\nSET or RST input resets or clears the output Q at any time regardless of\nCLK. The reset input has priority over the input set. If both are active\n(TRUE) are reset is processed and SET is ignored.", "type": "FUNCTION_BLOCK", "name": "FF_DRE", "input": [{"name": "SET", "type": "BOOL", "description": "Input to set the output Q to high."}, {"name": "D", "type": "BOOL", "description": "Data input that determines the value of output Q when CLK is high."}, {"name": "CLK", "type": "BOOL", "description": "Clock input that triggers the update of output Q on its rising edge."}, {"name": "RST", "type": "BOOL", "description": "Input to reset the output Q."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output that represents the state of the flip-flop."}], "in/out": [], "return_value": null}
{"title": "Ramping Soft Signal Control", "description": "RMP_SOFT smooths the ramp of an input signal VAL. The signal Out follows\nthe input signal VAL, where increase time as well as fall time can be limi￾ted by PT_ON and PT_OFF . The rise time and fall time of the ramps are de￾fned by setup parameter in the module RMP_SOFT. The setup time PT_ON\nspecifes how long the ramp takes of 0..255. A ramp that is limited by the\nVAL, is accordingly shorter. PT_OFF defnes accordingly the falling ramp. If\nthe input IN is set to FALSE, VAL corresponds to a value of 0, so by swit￾ching the input IN between 0 and VAL it can be switched.", "type": "FUNCTION_BLOCK", "name": "RMP_SOFT", "input": [{"name": "IN", "type": "BOOL", "description": "Boolean input that triggers the ramping action."}, {"name": "VAL", "type": "BYTE", "description": "The target value to ramp towards."}, {"name": "PT_ON", "type": "TIME", "description": "The ramping time when increasing the output value."}, {"name": "PT_OFF", "type": "TIME", "description": "The ramping time when decreasing the output value."}], "output": [{"name": "OUT", "type": "BYTE", "description": "The output value that gets ramped up or down based on the input conditions."}], "in/out": [], "return_value": null}
{"title": "Tangent Over X Function", "description": "TANC TANC function calculates the following formula:\nwith TANC(0) = 1.", "type": "FUNCTION", "name": "TANC", "input": [{"name": "X", "type": "REAL", "description": "The input real number which the tangent is computed from."}], "output": [{"name": "TANC", "type": "REAL", "description": "The output real number resulting from the computation of TAN(X) / X or 1.0 if X is zero."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the tangent function divided by the input value, or 1.0 if the input is zero."}}
{"title": "Integer to BCD Conversion", "description": "INT_TO_BCDC converts the input value IN to a BCD coded output value.", "type": "FUNCTION", "name": "INT_TO_BCDC", "input": [{"name": "IN", "type": "INT", "description": "The integer value to be converted into BCD format."}], "output": [{"name": "BYTE", "type": "BYTE", "description": "The BCD representation of the input integer."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The result of the BCD conversion as a byte."}}
{"title": "Filter Waveform", "description": "FILTER_WAV is a flter with a weighted average. (Also called FIR flter) the\nflter with a weighted average of individual values in the bufer are evalua￾ted with diferent weights.\nY:= X0 * W0 + X1 * W1 + ….+ X15 * W15\nX0 is the value of X in the current cycle, X1 is the value in the previous cy￾cle, etc. The factors W are passed as the input array W. In applying the FIR\nflter hast to be ensured that appropriate factors are used for weighting.\nThe application makes sense only if these factors are determined by ap￾propriate methods or design software.", "type": "FUNCTION_BLOCK", "name": "FILTER_WAV", "input": [{"name": "X", "type": "REAL", "description": "The input sample value to be filtered."}, {"name": "W", "type": "ARRAY[0..15] OF REAL", "description": "An array of weights corresponding to the samples in the buffer."}, {"name": "RST", "type": "BOOL", "description": "A reset signal that initializes the buffer if set to TRUE."}], "output": [{"name": "Y", "type": "REAL", "description": "The output result representing the weighted average of the buffered samples."}], "in/out": [], "return_value": null}
{"title": "Retrieve Last Element from a List", "description": "LIST_RETRIEVE_LAST passes the last item from a list and deletes the corre￾sponding item in the list. The list consists of Strings (elements) that begin\nwith the separation character SEP.", "type": "FUNCTION", "name": "LIST_RETRIEVE_LAST", "input": [{"name": "SEP", "type": "BYTE", "description": "The byte value used as a separator in the list."}], "output": [{"name": "LIST_RETRIEVE_LAST", "type": "string", "description": "The substring extracted from the list after the last occurrence of the separator."}], "in/out": [{"name": "LIST", "type": "STRING[LENGTH := LIST_LENGTH]", "description": "The input-output list of characters from which the last element is to be retrieved. This list will be modified to terminate at the last separator."}], "return_value": {"type": "string", "description": "Returns the last element in the list found after the last separator."}}
{"title": "Check if Character is Lowercase", "description": "ISC_LOWER tests whether a sign IN is a lowercase letter, If IN is a lower\ncase the function returns TRUE, else the function returns FALSE. In exami￾ning the Global Setup EXTENDED_ASCII constant is considered. If EXTEN￾DED_ASCII = TRUE the extended ASCII character-set to be considered in\naccordance with ISO 8859-1.\nThe following Table discusses the character codes:\nCode EXTENDED_ASCII = TRUE EXTENDED_ASCII = FASLE\n0..96, 123..223, 247, 255 FALSE FALSE\n97..122 TRUE TRUE\n224..246 TRUE FALSE\n248..254 TRUE FALSE", "type": "FUNCTION", "name": "ISC_LOWER", "input": [{"name": "IN", "type": "BYTE", "description": "Input variable representing the ASCII value of a character."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the input corresponds to a lowercase ASCII character, otherwise returns FALSE."}}
{"title": "PID Control Function Block", "description": "CTRL_PID is a PID controller with dynamic anti-wind up and manual control\ninput. The PID controller operates according to the formula: \nY = KP * (DIFF + 1/Tn * INTEG(DIFF) + TV *DERIV(DIFF)) + OFFSET\nwhere DIFF = SET_POINT - ACTUAL\nIn manual mode (manual = TRUE) is: Y = MANUAL_IN+ OFFSET\nACT is the measured value for the controlled system and SET is the set￾point for the controller. The input values of LH and LL limit the output va￾lue Y. With RST, the internal integrator will always set to 0. The output LIM\nsignals that the controller has reached the limit of LL or LH. The PID con￾troller operates free-running and uses the trapezoidal rule to calculate\nwith highest accuracy and optimal speed. The default values of the input\nparameters are predefned as follows: KP = 1, TN = 1, TV = 1, LIMIT_L =\n-1000 and LIMIT_H = +1000. With the input SUP a noise reduction is set,\nthe value on input SUP determines at which control diference, the control￾ler turns on. With SUP is avoided that the output of the controller wob￾bles. The value at the input SUP should be in dimension that it suppresses\nthe noise of the controlled system and the sensors. If the input to SUP is\nset to 0.1, the controller is only at deviations greater than 0.1 active. The\nouput DIFF passes the measured and through a noise flter (DEAD_BAND)\nfltered control deviation. DIFF is normally not required in a controlled sys￾tem but can be used to infuence the control parameters. The input OFS is\nadded as the last value to output, and is used to compensate mainly of\nnoise, whose efect can be estimated on the loop. \nThe controller works with a dynamic air- Up that prevents that the integra￾tor, when reaching a output limit and further deviation, continues to run\nunlimited and afects the properties usually negative. In the introduction\nchapter of the control technology, more details can be found on anti-wind￾up. \nThe control parameters are given in the form of KP, TN and TV, and if the￾re are parameters KP, KI and KD they can be converted using the following\nformula:\nTN = KP/KI und TV = KD/KP\nThe following graph illustrates the internal structure of the controller:\nIn the following example, a PID controller is shown whose SET_POINT is ge￾nerated by module TUNE2 using buttons. Output DIFF is passedto a modu￾le PARSET2 which changes the parameters KP, TN, and TV depending on\nthe deviation at the output of DIFF.", "type": "FUNCTION_BLOCK", "name": "CTRL_PID", "input": [{"name": "ACT", "type": "REAL", "description": "The actual value from the process being controlled."}, {"name": "SET", "type": "REAL", "description": "The desired setpoint for the process variable."}, {"name": "SUP", "type": "REAL", "description": "A supplementary input for additional control."}, {"name": "OFS", "type": "REAL", "description": "Offset value for the controller output."}, {"name": "M_I", "type": "REAL", "description": "Manual input value for control when in manual mode."}, {"name": "MAN", "type": "BOOL", "description": "Manual control flag; when true, overrides the automatic control."}, {"name": "RST", "type": "BOOL", "description": "Reset flag for the PID controller."}, {"name": "KP", "type": "REAL", "description": "Proportional gain of the PID controller.", "default": "1.0"}, {"name": "TN", "type": "REAL", "description": "Integral time constant of the PID controller.", "default": "1.0"}, {"name": "TV", "type": "REAL", "description": "Derivative time constant of the PID controller.", "default": "1.0"}, {"name": "LL", "type": "REAL", "description": "Lower limit for the controller output.", "default": "-1000.0"}, {"name": "LH", "type": "REAL", "description": "Upper limit for the controller output.", "default": "1000.0"}], "output": [{"name": "Y", "type": "REAL", "description": "Output value of the PID controller."}, {"name": "DIFF", "type": "REAL", "description": "Difference between setpoint and actual value."}, {"name": "LIM", "type": "BOOL", "description": "Indicator whether the output is within defined limits."}], "in/out": [], "return_value": null}
{"title": "Signal Function Block", "description": "SIGNAL generates an output signal Q that corresponds to the bit pattern in\nSIG. This is Bitpattern is passed in TS long steps. By diferent bit patterns\nin SIG, various output signals are generated. If the input IN connected to\nTRUE, the module begins to put on output Q in accordance with the SIG\nprovided Bitpattern . By adapting the Bitpattern diferent output signals\nare generated. A Pattern of 10101010, generates an output signal with\n50% Duty Cycle and a frequency that is 1/2*S. A Pattern 11110000 by con￾trast, generates an output signal of 50% and a frequency of 1/8*TS. The\nstart of an output signal is random. The Bit sequence starts at any bit\nwhen the input IN goes to TRUE. If at the input TS no time given then the\nmodule internally uses a default of 1024ms per cycle (a cycle is the cycle\nof all 8 bits of a sequence). Typical applications for SIGNAL is the signal ge￾neration for sirens or signal lamps. \nThe following graph illustrates the functioning of signal for\nSIG = 2#1111_0000:", "type": "FUNCTION_BLOCK", "name": "SIGNAL", "input": [{"name": "IN", "type": "BOOL", "description": "A boolean input indicating whether an alarm is present."}, {"name": "SIG", "type": "BYTE", "description": "A byte input representing a signal value that will be combined with the calculated step."}, {"name": "TS", "type": "TIME", "description": "A time input to determine the interval for the step calculation."}], "output": [{"name": "Q", "type": "BOOL", "description": "A boolean output indicating the result of the signal processing."}], "in/out": [], "return_value": null}
{"title": "FIFO 16-Element Queue", "description": "SIGNAL generates an output signal Q that corresponds to the bit pattern in\nSIG. This is Bitpattern is passed in TS long steps. By diferent bit patterns\nin SIG, various output signals are generated. If the input IN connected to\nTRUE, the module begins to put on output Q in accordance with the SIG\nprovided Bitpattern . By adapting the Bitpattern diferent output signals\nare generated. A Pattern of 10101010, generates an output signal with\n50% Duty Cycle and a frequency that is 1/2*S. A Pattern 11110000 by con￾trast, generates an output signal of 50% and a frequency of 1/8*TS. The\nstart of an output signal is random. The Bit sequence starts at any bit\nwhen the input IN goes to TRUE. If at the input TS no time given then the\nmodule internally uses a default of 1024ms per cycle (a cycle is the cycle\nof all 8 bits of a sequence). Typical applications for SIGNAL is the signal ge￾neration for sirens or signal lamps. \nThe following graph illustrates the functioning of signal for\nSIG = 2#1111_0000:", "type": "FUNCTION_BLOCK", "name": "FIFO_16", "input": [{"name": "Din", "type": "DWORD", "description": "The data input that will be stored in the FIFO queue."}, {"name": "E", "type": "BOOL", "description": "Enable input for the FIFO operations. When TRUE, the operation proceeds."}, {"name": "RD", "type": "BOOL", "description": "Read command input. When TRUE, it indicates a read operation should occur."}, {"name": "WD", "type": "BOOL", "description": "Write command input. When TRUE, it indicates a write operation should occur."}, {"name": "RST", "type": "BOOL", "description": "Reset input. When TRUE, it resets the FIFO queue to its initial state."}], "output": [{"name": "Dout", "type": "DWORD", "description": "The data output from the FIFO queue when a read operation is performed."}, {"name": "EMPTY", "type": "BOOL", "description": "Indicates whether the FIFO queue is empty. TRUE if empty, FALSE otherwise."}, {"name": "FULL", "type": "BOOL", "description": "Indicates whether the FIFO queue is full. TRUE if full, FALSE otherwise."}], "in/out": [], "return_value": null}
{"title": "Scale Byte Function", "description": "SCALE_B scales an input value BYTE and calculates an output value in\nREAL. The input value X is limited here to I_LO and I_HI. SCALE_D (IN, 0,\n255, 0, 100) scales an input with 8-bit resolution on the output 0..100.", "type": "FUNCTION", "name": "SCALE_B", "input": [{"name": "X", "type": "BYTE", "description": "The input byte value to be scaled."}, {"name": "I_LO", "type": "BYTE", "description": "The lower limit of the input range."}, {"name": "I_HI", "type": "BYTE", "description": "The upper limit of the input range."}, {"name": "O_LO", "type": "REAL", "description": "The lower limit of the output range."}, {"name": "O_HI", "type": "REAL", "description": "The upper limit of the output range."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The scaled output value based on the input range and output limits."}}
{"title": "Select 8 Function Block", "description": "SCALE_B scales an input value BYTE and calculates an output value in\nREAL. The input value X is limited here to I_LO and I_HI. SCALE_D (IN, 0,\n255, 0, 100) scales an input with 8-bit resolution on the output 0..100.", "type": "FUNCTION_BLOCK", "name": "SELECT_8", "input": [{"name": "E", "type": "BOOL", "description": "Enable input for the function block."}, {"name": "SET", "type": "BOOL", "description": "Sets the state variable to the value of IN when TRUE."}, {"name": "IN", "type": "BYTE", "description": "Input value used to set the state variable."}, {"name": "UP", "type": "BOOL", "description": "Increment the state variable when TRUE and the last UP was FALSE."}, {"name": "DN", "type": "BOOL", "description": "Decrement the state variable when TRUE and the last DN was FALSE."}, {"name": "RST", "type": "BOOL", "description": "Resets the state variable to 0 when TRUE."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal for state 0."}, {"name": "Q1", "type": "BOOL", "description": "Output signal for state 1."}, {"name": "Q2", "type": "BOOL", "description": "Output signal for state 2."}, {"name": "Q3", "type": "BOOL", "description": "Output signal for state 3."}, {"name": "Q4", "type": "BOOL", "description": "Output signal for state 4."}, {"name": "Q5", "type": "BOOL", "description": "Output signal for state 5."}, {"name": "Q6", "type": "BOOL", "description": "Output signal for state 6."}, {"name": "Q7", "type": "BOOL", "description": "Output signal for state 7."}, {"name": "STATE", "type": "INT", "description": "Current state of the selection (0-7)."}], "in/out": [], "return_value": null}
{"title": "Sample Time Trigger Function Block", "description": "SCALE_B scales an input value BYTE and calculates an output value in\nREAL. The input value X is limited here to I_LO and I_HI. SCALE_D (IN, 0,\n255, 0, 100) scales an input with 8-bit resolution on the output 0..100.", "type": "FUNCTION_BLOCK", "name": "SH_1", "input": [{"name": "in", "type": "REAL", "description": "The input value to be output when the trigger condition is met."}, {"name": "PT", "type": "TIME", "description": "The time period that must elapse before the output is updated."}], "output": [{"name": "out", "type": "REAL", "description": "The output value that reflects the input when the trigger condition is met."}, {"name": "Trig", "type": "BOOL", "description": "A boolean flag that indicates whether the output has been updated."}], "in/out": [], "return_value": null}
{"title": "FT_Profile Function Block", "description": "SCALE_B scales an input value BYTE and calculates an output value in\nREAL. The input value X is limited here to I_LO and I_HI. SCALE_D (IN, 0,\n255, 0, 100) scales an input with 8-bit resolution on the output 0..100.", "type": "FUNCTION_BLOCK", "name": "FT_Profile", "input": [{"name": "K", "type": "REAL", "description": "The gain factor applied to the output value, with a default value of 1.0."}, {"name": "O", "type": "REAL", "description": "The offset added to the output value."}, {"name": "M", "type": "REAL", "description": "A multiplier applied to the time intervals, with a default value of 1.0."}, {"name": "E", "type": "BOOL", "description": "A boolean signal to start the profile generation."}, {"name": "value_0", "type": "REAL", "description": "The initial value at time_0."}, {"name": "time_1", "type": "TIME", "description": "The time at which value_1 is reached."}, {"name": "value_1", "type": "REAL", "description": "The value corresponding to time_1."}, {"name": "time_2", "type": "TIME", "description": "The time at which value_2 is reached."}, {"name": "value_2", "type": "REAL", "description": "The value corresponding to time_2."}, {"name": "time_3", "type": "TIME", "description": "The time at which value_3 is reached."}, {"name": "value_3", "type": "REAL", "description": "The value corresponding to time_3."}, {"name": "time_10", "type": "TIME", "description": "The time at which value_10 is reached."}, {"name": "value_10", "type": "REAL", "description": "The value corresponding to time_10."}, {"name": "time_11", "type": "TIME", "description": "The time at which value_11 is reached."}, {"name": "value_11", "type": "REAL", "description": "The value corresponding to time_11."}, {"name": "time_12", "type": "TIME", "description": "The time at which value_12 is reached."}, {"name": "value_12", "type": "REAL", "description": "The value corresponding to time_12."}, {"name": "time_13", "type": "TIME", "description": "The time at which value_13 is reached."}, {"name": "value_13", "type": "REAL", "description": "The value corresponding to time_13."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value calculated from the interpolation and adjusted by K and O."}, {"name": "RUN", "type": "BOOL", "description": "A boolean indicating whether the function block is currently running or not."}, {"name": "ET", "type": "TIME", "description": "Elapsed time since the start of the profile generation."}], "in/out": [], "return_value": null}
{"title": "PID Controller Function Block", "description": "FT_PID is a PID controller of the following formula works:\nY = KP * ( IN + 1/TN * INTEG(IN) + TV *DERIV(IN))\nThe control parameters are given in the form of KP, TN and TV, and if the￾re are parameters KP, KI and KD they can be converted using the following\nformula:\nTN = KP/KI und TV = KD/KP\nThe input values ILIM_H and ILIM_L limit the working area of the internal\nintegrator. With RST, the internal integrator will always set to 0. The out￾put LIM signals that the integrator runs one of the limits or ILIM_L ILIM_H.\nThe PI controller is free running and uses the trapezoidal rule to calculate\nthe integrator for the highest accuracy and optimal speed. The default va￾lues of the input parameters are predefned as follows: KP = 1, TN = 1s,\nTV = 1s, ILIM_L =-1E38 and ILIM_H = +1 E38.\n Anti Wind-Up: Control modules with Integrator tend to the so-called Wind￾Up Efect. A Wind-Up means that the integrator module continuously run\nagain because, for example, the control signal Y is at a limit and the sys￾tem can not compensate the deviation, which then leads to subsequent\ntransition into the control range until a long and time-consuming dismant￾ling of the integrator value and the scheme only respond delayed. Since\nthe integrator is only necessary to compensate the deviation for all other\ncontrol units, and the range of the integrator should be limited with the\nvalues of ILIM. The Integrator then reaches a limit and stops remaining at\nthe last valid value. For other wind- Up Action, the Integrator can be con￾trolled with the input IEN = FALSE any time separately, the Integrator only\nruns when IEN = TRUE. \nThe following graph illustrates the internal structure of the controller:\nFT_PD can be used in conjunction with the modules CTRL_IN and\nCTRL_OUT to establish a PD controller.", "type": "FUNCTION_BLOCK", "name": "FT_PID", "input": [{"name": "IN", "type": "REAL", "description": "The input value to the PID controller."}, {"name": "KP", "type": "REAL", "description": "Proportional gain coefficient."}, {"name": "TN", "type": "REAL", "description": "Integral time constant."}, {"name": "TV", "type": "REAL", "description": "Derivative time constant."}, {"name": "ILIM_L", "type": "REAL", "description": "Lower limit for the integrator output."}, {"name": "ILIM_H", "type": "REAL", "description": "Upper limit for the integrator output."}, {"name": "IEN", "type": "BOOL", "description": "Enable flag for the integrator."}, {"name": "RST", "type": "BOOL", "description": "Reset flag for the integrator."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value of the PID controller."}, {"name": "LIM", "type": "BOOL", "description": "Flag indicating whether the integrator has hit its limits."}], "in/out": [], "return_value": null}
{"title": "Complex Tangent Function", "description": "CTAN calculates the tangent of a complex number", "type": "FUNCTION", "name": "CTAN", "input": [{"name": "X", "type": "complex", "description": "A complex number for which the tangent is to be calculated."}], "output": [{"name": "CTAN", "type": "complex", "description": "The complex tangent of the input number X."}], "in/out": [], "return_value": {"type": "complex", "description": "The return value is the complex tangent of the input complex number X.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the complex tangent result."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the complex tangent result."}]}}
{"title": "Calculate Square Root of a Complex Number", "description": "CSQRT calculates the square root of a complex number", "type": "FUNCTION", "name": "CSQRT", "input": [{"name": "X", "type": "complex", "description": "The complex number for which the square root needs to be calculated."}], "output": [{"name": "CSQRT", "type": "complex", "description": "The computed square root of the input complex number."}], "in/out": [], "return_value": {"type": "complex", "description": "The square root of the input complex number returned by the function.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the square root of the complex number."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the square root of the complex number."}]}}
{"title": "Convert Time of Day to Seconds", "description": "SECOND extracts the seconds portion of the day", "type": "FUNCTION", "name": "SECOND", "input": [{"name": "itod", "type": "TOD", "description": "The input time of day value that needs to be converted to seconds."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The output value represents the time in seconds converted from the input TOD."}}
{"title": "Event Status Report (ESR) Monitoring", "description": "SECOND extracts the seconds portion of the day", "type": "FUNCTION_BLOCK", "name": "ESR_MON_R4", "input": [{"name": "R0", "type": "REAL", "description": "First real input value."}, {"name": "R1", "type": "REAL", "description": "Second real input value."}, {"name": "R2", "type": "REAL", "description": "Third real input value."}, {"name": "R3", "type": "REAL", "description": "Fourth real input value."}, {"name": "DT_in", "type": "DT", "description": "Input data type for the event report."}, {"name": "a0", "type": "STRING(10)", "description": "Address associated with R0."}, {"name": "a1", "type": "STRING(10)", "description": "Address associated with R1."}, {"name": "a2", "type": "STRING(10)", "description": "Address associated with R2."}, {"name": "a3", "type": "STRING(10)", "description": "Address associated with R3."}, {"name": "s0", "type": "REAL", "description": "State value 0."}, {"name": "s1", "type": "REAL", "description": "State value 1."}, {"name": "s2", "type": "REAL", "description": "State value 2."}, {"name": "s3", "type": "REAL", "description": "State value 3."}], "output": [{"name": "ESR_Flag", "type": "BOOL", "description": "Indicates whether any input has changed and a new event status report has been generated."}], "in/out": [{"name": "ESR_Out", "type": "ARRAY[0..3] OF esr_data", "description": "Array that contains the event status report data."}], "return_value": null}
{"title": "Convert Kilometers per Hour to Meters per Second", "description": "KMH_TO_MS converts value to a speed of kilomter per Hour in meters per\nsecond. KMH_TO_MS := KMH / 3.6", "type": "FUNCTION", "name": "KMH_TO_MS", "input": [{"name": "kmh", "type": "REAL", "description": "The speed value in kilometers per hour to be converted."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The equivalent speed value in meters per second after conversion."}}
{"title": "Driver Function Block", "description": "KMH_TO_MS converts value to a speed of kilomter per Hour in meters per\nsecond. KMH_TO_MS := KMH / 3.6", "type": "FUNCTION_BLOCK", "name": "DRIVER_1", "input": [{"name": "Toggle_Mode", "type": "BOOL", "description": "A boolean input that determines whether the output Q should toggle its state."}, {"name": "Timeout", "type": "TIME", "description": "The duration after which the output will reset, if applicable."}, {"name": "SET", "type": "BOOL", "description": "A boolean input to set the output Q to TRUE."}, {"name": "IN", "type": "BOOL", "description": "A boolean input to indicate the control state; it may trigger toggling of the output Q."}, {"name": "RST", "type": "BOOL", "description": "A boolean input to reset the output Q to FALSE."}], "output": [{"name": "Q", "type": "BOOL", "description": "The output signal that indicates the state of the driver."}], "in/out": [], "return_value": null}
{"title": "Convert DWORD to Hexadecimal String", "description": "DWORD_TO_STRH converts a DWORD, Word or byte in a STRING of fxed\nlength. The output string is exactly 8 characters long and is the hexadeci￾mal notation of the value of IN. The output string consists of the charac￾ters '0 '.. '1' and 'A '.. 'F'. The least signifcant hexadecimal character is\nright in the string. DWORD_TO_STRH can process input as byte, word and\nDWORD types. The output is independent of the input type is always a\nSTRING of 32 characters. If a shorter string is needed, it can be cut with\nthe standard function RIGHT() accordingly. The call\nRIGHT(DWORD_TO_STRH(X),4) results to a string of 4 characters to the\ncontents of the lower 2 bytes of X.", "type": "FUNCTION", "name": "DWORD_TO_STRH", "input": [{"name": "IN", "type": "DWORD", "description": "The input DWORD value that needs to be converted to a hexadecimal string."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "A string representation of the hexadecimal value of the input DWORD, consisting of 8 hex characters.", "fields": []}}
{"title": "Refraction Calculation", "description": "REFRACTION calculates the atmospheric refraction outside the atmosphe￾re and celestial bodies. A celestial body appears by the refraction of light\nin the atmosphere by the refraction higher above the horizon than he ac￾tually is. The refraction is 0 at the zenith (at 12:00 noon) and increases\nmuch close to the horizon. At 0° (the horizon), the refraction is -0.59° and\n10° above the horizon, it is 0.09°. The refraction is needed to calculated\norbits of celestial bodies and to correct satellite so that they match with\nobservation. The module calculates an average value for the pressure of\n1010mBar and 10° C. When the sun is actually at 0°, so exactly in the ho￾rizon, it appears above the horizon because of refraction at 0.59 degrees .\nThe visible sun position is the actual (astronomical) sun position H + the\nrefraction of the sun. The refraction angle is also calculated below the ho￾rizon ELEV < - 2°, so that below the horizon always the refraction is added\nto the astronomical refraction angle, so as the distance to the sun can be\ncalculated correctly at any time. For astronomical angle < -1.9 ° is the re￾fraction remains constant at 0.744 degrees.", "type": "FUNCTION", "name": "REFRACTION", "input": [{"name": "ELEV", "type": "REAL", "description": "The elevation in degrees which will be used in the refraction calculation."}], "output": [{"name": "REFRACTION", "type": "REAL", "description": "The calculated refraction value based on the input elevation."}], "in/out": [], "return_value": {"type": "REAL", "description": "The output value representing the refraction calculated from the given elevation."}}
{"title": "Astronomical Units Conversion", "description": "ASTRO converts various distance units commonly used in \nastronomy. Normally, only the input to be converted is occupied and the \nremaining inputs remain free. However, if several inputs loaded with \nvalues, the values of all inputs are converted accordingly and then \nsummed.\n1 AE = 149,597870 * 109 m\n1 PC = 206265 AE\n1 LJ = 9,460530 * 1015 m = 63240 AE = 0,30659 PC", "type": "FUNCTION_BLOCK", "name": "ASTRO", "input": [{"name": "m", "type": "REAL", "description": "Distance in meters (SI base unit)."}, {"name": "AE", "type": "REAL", "description": "Distance in astronomical units, where 1 AE = 149,597,870 meters."}, {"name": "PC", "type": "REAL", "description": "Distance in parsecs, where 1 parsec = 206265 AE."}, {"name": "LJ", "type": "REAL", "description": "Distance in light years, where 1 light year = 63240 AE."}], "output": [{"name": "Ym", "type": "REAL", "description": "Converted distance in meters based on input parameters."}, {"name": "YAE", "type": "REAL", "description": "Converted distance in astronomical units."}, {"name": "YPC", "type": "REAL", "description": "Converted distance in parsecs."}, {"name": "YLJ", "type": "REAL", "description": "Converted distance in light years."}], "in/out": [], "return_value": null}
{"title": "Degree Conversion Function", "description": "DEG(π) = 180 Grad, DEG(3π) = 180 Grad\nDEG(0) = 0 Grad, DEG(2π) = 0 Grad", "type": "FUNCTION", "name": "DEG", "input": [{"name": "rad", "type": "REAL", "description": "The angle in radians to be converted to degrees."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The angle in degrees, constrained to be between 0 and 360 degrees.", "fields": []}}
{"title": "Leap Year Calculation", "description": "LEAP_OF_DATE tests whether the input date is in a leap year.\nThe function calculates whether a date falls within a leap year and returns\nTRUE if necessary. The test is valid for the time window from 1970 to\n2099. In the year 2100 a leap year is indicated although this is not one.\nHowever, since the range of dates according to IEC61131-3 extends only\nto the year 2106 this correction will be omitted.", "type": "FUNCTION", "name": "LEAP_OF_DATE", "input": [{"name": "idate", "type": "DATE", "description": "The date to check for leap year status."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "True if the year of the given date is a leap year, otherwise false."}}
{"title": "Bit Toggle Function", "description": "BIT_TOGGLE_DW inverts a specifed bit at IN.\nBIT_TOGGLE_DW(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_DW(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION", "name": "BIT_TOGGLE_DW", "input": [{"name": "IN", "type": "DWORD", "description": "The input DWORD value where the bit will be toggled."}, {"name": "POS", "type": "INT", "description": "The position of the bit to be toggled, starting from 0 for the least significant bit."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The resulting DWORD value after the specified bit has been toggled.", "fields": []}}
{"title": "Interlock Control Logic", "description": "BIT_TOGGLE_DW inverts a specifed bit at IN.\nBIT_TOGGLE_DW(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_DW(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION_BLOCK", "name": "INTERLOCK_4", "input": [{"name": "I0", "type": "BOOL", "description": "Input signal 0, a boolean value indicating one of the interlock conditions."}, {"name": "I1", "type": "BOOL", "description": "Input signal 1, a boolean value indicating one of the interlock conditions."}, {"name": "I2", "type": "BOOL", "description": "Input signal 2, a boolean value indicating one of the interlock conditions."}, {"name": "I3", "type": "BOOL", "description": "Input signal 3, a boolean value indicating one of the interlock conditions."}, {"name": "E", "type": "BOOL", "description": "Enable signal, a boolean value that activates the interlock processing when true."}, {"name": "MODE", "type": "INT", "description": "Mode selector, an integer value that determines the operation behavior of the interlock logic."}], "output": [{"name": "OUT", "type": "BYTE", "description": "Output byte that represents the processed input signals based on the selected mode."}, {"name": "TP", "type": "BOOL", "description": "Transition signal, a boolean value that indicates if there is a change in the output state compared to the previous cycle."}], "in/out": [], "return_value": null}
{"title": "Random Number Generation Function", "description": "RDM calculates a pseudo- random number. This is the PLC's internal Timer\nread and converted into a pseudo-random number. Because RDM's is writ￾ten as a function and not as a function module, it can not save data bet￾ween 2 calls and should therefore be used with caution. RDM is only called\nonce per cycle, it produces reasonable good results. But when it is repea￾tedly called within a cycle, it delivers the same number, most likely becau￾se of the PLC timer is still on the same value. If the function is repeatedly\nused within a cycle, so it must be passed with each call a diferent number\nof starts (LAST). It shall be called only once per cycle, is sufcient to call\nRDM(0). As a starting number for each call, the last calculated number of\nRDM can be used. Supplied by RDM random numbers between 0 and 1,\nwhich does not contain 1 (0 <=random number < 1)", "type": "FUNCTION", "name": "RDM", "input": [{"name": "last", "type": "REAL", "description": "The upper limit for the generated random number, constrained between 0.0 and 1.0."}], "output": [{"name": "RDM", "type": "REAL", "description": "The generated pseudo-random number, calculated based on the input 'last' and the current PLC time."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the random number generation function, which is a pseudo-random value based on internal calculations and input parameters."}}
{"title": "Byte Swapping Function", "description": "SWAP_BYTE exchanges the High and Low Bytes in a WORD.", "type": "FUNCTION", "name": "SWAP_BYTE", "input": [{"name": "IN", "type": "WORD", "description": "The input WORD that will undergo byte swapping."}], "output": [], "in/out": [], "return_value": {"type": "WORD", "description": "The result of the byte-swapped input WORD.", "fields": []}}
{"title": "Bit Generator Function Block", "description": "GEN_BIT is a fully programmable pattern generator. At the inputs in0 .. IN7\nare the bit patterns at the input CLK in each case as a DWORD and passed\nby each clock pulse to the outputs Q0 .. Q3 starting from bit 0 of ascen￾ding. After the frst clock pulse at the input CLK the output Q0 has bit 0 of\nIN0 , at Q1 is bit 0 of In1 ... on Q7 is bit 0 of IN3. After the next clock pulse\nat the CLK input, the bit 1 of the inputs IN is passed to the outputs Q and\nso on, until the sequence is completed. The input STEPS determines how\nmany bits of the input DWORDS be passed to the outputs. The input REP\ndetermines how often this sequence is repeated. If the input set to 0, the\nsequence is repeated continuously. An asynchronous reset can always re￾set the sequencer. The outputs CNT and RUN indicate which bit is current￾ly passed to the output and whether the sequencer is running, or the se￾quence (RUN inactive) has fnished. After the sequences have expired the\nlast bit patterns remains on the outputs available until a reset restarts the\ngenerator.", "type": "FUNCTION_BLOCK", "name": "GEN_BIT", "input": [{"name": "in0", "type": "DWORD", "description": "First input DWORD value for bit shifting."}, {"name": "in1", "type": "DWORD", "description": "Second input DWORD value for bit shifting."}, {"name": "in2", "type": "DWORD", "description": "Third input DWORD value for bit shifting."}, {"name": "in3", "type": "DWORD", "description": "Fourth input DWORD value for bit shifting."}, {"name": "clk", "type": "BOOL", "description": "Clock signal to trigger the operation."}, {"name": "steps", "type": "INT", "description": "Number of steps to process before resetting."}, {"name": "rep", "type": "INT", "description": "Number of times to repeat the operation; 0 for continuous operation."}, {"name": "rst", "type": "BOOL", "description": "Reset signal to initialize the block."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output for the least significant bit of in0."}, {"name": "Q1", "type": "BOOL", "description": "Output for the least significant bit of in1."}, {"name": "Q2", "type": "BOOL", "description": "Output for the least significant bit of in2."}, {"name": "Q3", "type": "BOOL", "description": "Output for the least significant bit of in3."}, {"name": "cnt", "type": "INT", "description": "Current step count in the operation."}, {"name": "run", "type": "BOOL", "description": "Indicates if the block is currently running."}], "in/out": [], "return_value": null}
{"title": "TON Timer Function Block", "description": "GEN_BIT is a fully programmable pattern generator. At the inputs in0 .. IN7\nare the bit patterns at the input CLK in each case as a DWORD and passed\nby each clock pulse to the outputs Q0 .. Q3 starting from bit 0 of ascen￾ding. After the frst clock pulse at the input CLK the output Q0 has bit 0 of\nIN0 , at Q1 is bit 0 of In1 ... on Q7 is bit 0 of IN3. After the next clock pulse\nat the CLK input, the bit 1 of the inputs IN is passed to the outputs Q and\nso on, until the sequence is completed. The input STEPS determines how\nmany bits of the input DWORDS be passed to the outputs. The input REP\ndetermines how often this sequence is repeated. If the input set to 0, the\nsequence is repeated continuously. An asynchronous reset can always re￾set the sequencer. The outputs CNT and RUN indicate which bit is current￾ly passed to the output and whether the sequencer is running, or the se￾quence (RUN inactive) has fnished. After the sequences have expired the\nlast bit patterns remains on the outputs available until a reset restarts the\ngenerator.", "type": "FUNCTION_BLOCK", "name": "TOF_1", "input": [{"name": "IN", "type": "BOOL", "description": "Input signal to start the timer."}, {"name": "PT", "type": "TIME", "description": "Preset time duration for the timer."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to clear the output."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output signal indicating the state of the timer."}], "in/out": [], "return_value": null}
{"title": "Trend Function Block", "description": "TREND monitors the input X and time at the output Q to see if X increases\n(Q = TRUE) or X decrease (Q = FALSE). If X does not change, Q remains at\nits last value. If X increases, the output TU gets for one cycle to TRUE and\nat the output D the result X - LAST_X is displayed. If X is less than LAST_X\nso TD gets TRUE for one cycle and the output D is LAST_X - X passed.\nLAST_X is an internal value of the module and is the value of X in the last\ncycle.", "type": "FUNCTION_BLOCK", "name": "TREND", "input": [{"name": "X", "type": "REAL", "description": "Input variable representing the current value being monitored."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output indicating whether the input variable 'X' has changed (increased or decreased)."}, {"name": "TU", "type": "BOOL", "description": "Output indicating if 'X' is greater than the last recorded value."}, {"name": "TD", "type": "BOOL", "description": "Output indicating if 'X' is less than the last recorded value."}, {"name": "D", "type": "REAL", "description": "Output representing the difference between the current value 'X' and the last value."}], "in/out": [], "return_value": null}
{"title": "Scale Input Values by a Factor", "description": "TREND monitors the input X and time at the output Q to see if X increases\n(Q = TRUE) or X decrease (Q = FALSE). If X does not change, Q remains at\nits last value. If X increases, the output TU gets for one cycle to TRUE and\nat the output D the result X - LAST_X is displayed. If X is less than LAST_X\nso TD gets TRUE for one cycle and the output D is LAST_X - X passed.\nLAST_X is an internal value of the module and is the value of X in the last\ncycle.", "type": "FUNCTION", "name": "SCALE_X4", "input": [{"name": "IN1", "type": "BOOL", "description": "First Boolean input to select between IN1_MIN and IN1_MAX."}, {"name": "IN2", "type": "BOOL", "description": "Second Boolean input to select between IN2_MIN and IN2_MAX."}, {"name": "IN3", "type": "BOOL", "description": "Third Boolean input to select between IN3_MIN and IN3_MAX."}, {"name": "IN4", "type": "BOOL", "description": "Fourth Boolean input to select between IN4_MIN and IN4_MAX."}, {"name": "K", "type": "REAL", "description": "Scaling factor applied to the sum of inputs."}, {"name": "O", "type": "REAL", "description": "Offset added to the scaled sum."}, {"name": "IN1_MIN", "type": "REAL", "description": "Minimum value for IN1 when the corresponding input is true."}, {"name": "IN1_MAX", "type": "REAL", "description": "Maximum value for IN1 when the corresponding input is false."}, {"name": "IN2_MIN", "type": "REAL", "description": "Minimum value for IN2 when the corresponding input is true."}, {"name": "IN2_MAX", "type": "REAL", "description": "Maximum value for IN2 when the corresponding input is false."}, {"name": "IN3_MIN", "type": "REAL", "description": "Minimum value for IN3 when the corresponding input is true."}, {"name": "IN3_MAX", "type": "REAL", "description": "Maximum value for IN3 when the corresponding input is false."}, {"name": "IN4_MIN", "type": "REAL", "description": "Minimum value for IN4 when the corresponding input is true."}, {"name": "IN4_MAX", "type": "REAL", "description": "Maximum value for IN4 when the corresponding input is false."}], "output": [{"name": "SCALE_X4", "type": "REAL", "description": "The result of the scaled sum of the selected input values."}], "in/out": [], "return_value": {"type": "REAL", "description": "The final computed value after scaling the sum and adding the offset."}}
{"title": "Extract Second from Date and Time", "description": "SECOND_OF_DT extracts the second from a current DT value.\nSECOND_OF_DT(DT#2008-6-6-10:22:20) = 20", "type": "FUNCTION", "name": "SECOND_OF_DT", "input": [{"name": "XDT", "type": "DT", "description": "The date and time value from which the second component will be extracted."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "An integer representing the second component extracted from the input date and time.", "fields": []}}
{"title": "Bit Toggle Function", "description": "BIT_TOGGLE_B inverts a specifed bit at IN.\nBIT_TOGGLE_W(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_W(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION", "name": "BIT_TOGGLE_B", "input": [{"name": "IN", "type": "BYTE", "description": "The input BYTE value whose bit is to be toggled."}, {"name": "POS", "type": "INT", "description": "The position of the bit to be toggled, where 0 represents the least significant bit."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "The resulting BYTE value after toggling the specified bit.", "fields": []}}
{"title": "Scale Function for B2 Inputs", "description": "BIT_TOGGLE_B inverts a specifed bit at IN.\nBIT_TOGGLE_W(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_W(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION", "name": "SCALE_B2", "input": [{"name": "in1", "type": "BYTE", "description": "First input value to be scaled."}, {"name": "in2", "type": "BYTE", "description": "Second input value to be scaled."}, {"name": "K", "type": "REAL", "description": "Scaling factor applied to the combined inputs."}, {"name": "O", "type": "REAL", "description": "Offset added to the result after scaling."}, {"name": "in1_min", "type": "REAL", "description": "Minimum value for the first input used in scaling."}, {"name": "in1_max", "type": "REAL", "description": "Maximum value for the first input used in scaling. Defaults to 1000.0."}, {"name": "in2_min", "type": "REAL", "description": "Minimum value for the second input used in scaling."}, {"name": "in2_max", "type": "REAL", "description": "Maximum value for the second input used in scaling. Defaults to 1000.0."}], "output": [{"name": "SCALE_B2", "type": "REAL", "description": "The scaled output value calculated from the input parameters."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the scaling operation applied to the inputs.", "fields": []}}
{"title": "Bitwise Shift Left Function", "description": "BIT_TOGGLE_B inverts a specifed bit at IN.\nBIT_TOGGLE_W(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_W(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION", "name": "SHL1", "input": [{"name": "IN", "type": "DWORD", "description": "The input value that will be shifted."}, {"name": "N", "type": "INT", "description": "The number of positions to shift the input value to the left."}], "output": [{"name": "SHL1", "type": "DWORD", "description": "The result of the left shift operation applied to the input value."}], "in/out": [], "return_value": {"type": "DWORD", "description": "The final computed value after applying bitwise operations.", "fields": []}}
{"title": "FT_TN16 Function Block", "description": "BIT_TOGGLE_B inverts a specifed bit at IN.\nBIT_TOGGLE_W(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_W(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION_BLOCK", "name": "FT_TN16", "input": [{"name": "in", "type": "REAL", "description": "The real input value to be processed."}, {"name": "T", "type": "TIME", "description": "The time duration that influences the input processing frequency."}], "output": [{"name": "out", "type": "REAL", "description": "The output value from the circular array of input values."}, {"name": "trig", "type": "BOOL", "description": "A boolean flag that indicates whether a new value has been output."}], "in/out": [], "return_value": null}
{"title": "Calculate Angle Between Two Vectors", "description": "BIT_TOGGLE_B inverts a specifed bit at IN.\nBIT_TOGGLE_W(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_W(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION", "name": "V3_ANG", "input": [{"name": "A", "type": "Vector_3", "description": "The first input vector for angle calculation."}, {"name": "B", "type": "Vector_3", "description": "The second input vector for angle calculation."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The angle in radians between vectors A and B.", "fields": []}}
{"title": "Calculate Minimum Value in an Array", "description": "ARRAY_MIN calculates the minimum value of any array of\nREAL. When called the function passed a Pointer to the array and its size\nin bytes. Under CoDeSys the call reads: ARRAY_MIN(ADR(Array),\nSIZEOF(Array)), where array is the name of the array to be manipulated.\nADR() is a standard function, which identifes the pointer to the array and\nSIZEOF() is a standard function, which determines the size of the array. In\norder to determine the maximum, the array referenced by the pointer is\nscanned directly in memory. The function ARRAY _ MIN does not change\nthe contents of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_MIN", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "Pointer to the array of real numbers from which the minimum value will be computed."}, {"name": "size", "type": "UINT", "description": "The size of the array indicating the number of elements to be considered for the minimum calculation."}], "output": [{"name": "array_min", "type": "REAL", "description": "The minimum value found in the specified array of real numbers."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the minimum value found within the input array."}}
{"title": "Sign Function", "description": "SIGN_R function returns TRUE if the input value is negative. The input\nvalues are of type REAL.", "type": "FUNCTION", "name": "SIGN_R", "input": [{"name": "in", "type": "REAL", "description": "The real number input for which the sign is to be determined."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "The return value indicating the sign of the input number. TRUE if negative, FALSE otherwise."}}
{"title": "Complex Polar Calculator", "description": "CPOL produces a complex number in polar form. The input values of L and\nA specify the length (radius) and the angle.", "type": "FUNCTION", "name": "CPOL", "input": [{"name": "L", "type": "REAL", "description": "The magnitude of the complex number in polar coordinates."}, {"name": "A", "type": "REAL", "description": "The angle (in radians) of the complex number in polar coordinates."}], "output": [{"name": "CPOL", "type": "complex", "description": "A complex number represented with a real part and an imaginary part."}], "in/out": [], "return_value": {"type": "complex", "description": "The result of the conversion from polar to rectangular form for the complex number.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the complex number."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the complex number."}]}}
{"title": "String Lowercase Check", "description": "IS_LOWER tests whether the string STR only lowercase letters are inclu￾ded. If anything other than a small letter found the function returns FALSE.\nIf in STR are only lowercase letters included, the function returns TRUE. In\nexamining the Global Setup EXTENDED_ASCII constant is considered. If\nEXTENDED_ASCII = TRUE the extended ASCII character-set to be conside-\nred in accordance with ISO 8859-1. Umlauts like Ä, Ö, Ü are considered\nonly if the global constant EXTENDED_ASCII = TRUE.", "type": "FUNCTION", "name": "IS_LOWER", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string that needs to be checked for lowercase characters."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns true if all characters in the string are lowercase; otherwise, false.", "fields": []}}
{"title": "Temperature Calculation from NTC Resistance", "description": "TEMP_NTC\nInput RES: REAL (measured resistance in ohms)\nRN: REAL (resistance of the sensor at 25°C)\nB: REAL (specifcation of the sensor)\nOutput REAL (measured temperature)\nTEMP_NTC calculates from the measured resistance and the parameters of\nthe sensor, the measured temperature. RN is the resistance of the sensor\nat 25°C, and B depends on the sensor and the specifcation of the sensor.\nThe module calculates the temperature according to the following formu￾la:", "type": "FUNCTION", "name": "TEMP_NTC", "input": [{"name": "RES", "type": "REAL", "description": "The resistance value of the NTC thermistor."}, {"name": "RN", "type": "REAL", "description": "The nominal resistance of the thermistor at a reference temperature."}, {"name": "B", "type": "REAL", "description": "The material constant used in the calculation for the NTC thermistor."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated temperature in degrees Celsius based on the thermistor resistance.", "fields": []}}
{"title": "Increment Function", "description": "INC adds to the input X the Value D and ensures that the output INC is not\ndoes not exceed the value of M. If the result from the addition of X and D\nis greater than M, then it starts again at 0. The feature is especially useful\nwhen addressing arrays and bufers. Even the positioning of absolute en￾coders it can be used. INC can be used to decrementieren with a negative\nD, while INC will ensure that the result is not below zero. If subtract 1 from\nzero INC starts again at M.\nINC: = X + D, because D can take the maximum value M.\nIf INC > M so INC starts again at 0.\nIf INC < 0 so INC starts again at M", "type": "FUNCTION", "name": "INC", "input": [{"name": "X", "type": "INT", "description": "The initial integer value to be incremented."}, {"name": "D", "type": "INT", "description": "The increment value that will be added to X."}, {"name": "M", "type": "INT", "description": "The modulus value used for wrapping the result."}], "output": [{"name": "INC", "type": "INT", "description": "The resulting value after incrementing X by D and applying modulo M."}], "in/out": [], "return_value": {"type": "INT", "description": "The final computed increment value.", "fields": []}}
{"title": "Bit Load Function", "description": "INC adds to the input X the Value D and ensures that the output INC is not\ndoes not exceed the value of M. If the result from the addition of X and D\nis greater than M, then it starts again at 0. The feature is especially useful\nwhen addressing arrays and bufers. Even the positioning of absolute en￾coders it can be used. INC can be used to decrementieren with a negative\nD, while INC will ensure that the result is not below zero. If subtract 1 from\nzero INC starts again at M.\nINC: = X + D, because D can take the maximum value M.\nIf INC > M so INC starts again at 0.\nIf INC < 0 so INC starts again at M", "type": "FUNCTION", "name": "BIT_LOAD_W2", "input": [{"name": "I", "type": "WORD", "description": "The input word to be manipulated."}, {"name": "D", "type": "BOOL", "description": "Control signal that determines the bit loading operation; TRUE for right operations, FALSE for left operations."}, {"name": "P", "type": "INT", "description": "The number of positions to shift or rotate the word."}, {"name": "N", "type": "INT", "description": "Specifies the number of positions for loading bits."}], "output": [{"name": "BIT_LOAD_W2", "type": "WORD", "description": "The result of the bit manipulation operation on the input word."}], "in/out": [], "return_value": {"type": "WORD", "description": "The manipulated word after applying the specified bit operations."}}
{"title": "BIT_LOAD_DW Function", "description": "BIT_LOAD_DW copies the VAL bit at the input to the bit in position N in\nDWORD IN. The least signifcant bit B0 is described by the position 0.", "type": "FUNCTION", "name": "BIT_LOAD_DW", "input": [{"name": "IN", "type": "DWORD", "description": "The input DWORD value to be manipulated."}, {"name": "VAL", "type": "BOOL", "description": "A boolean flag that determines whether to set (TRUE) or clear (FALSE) a bit in the input DWORD."}, {"name": "POS", "type": "INT", "description": "The position of the bit in the DWORD to be manipulated, where 0 is the least significant bit."}], "output": [{"name": "BIT_LOAD_DW", "type": "DWORD", "description": "The resulting DWORD after the bit manipulation operation has been applied."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Returns the modified DWORD after adjusting the specified bit according to the VAL parameter.", "fields": []}}
{"title": "Hexadecimal String Validation", "description": "IS_HEX tests whether the string STR contains only hexadecimal characters\nare. If another character is found the function returns FALSE. If in STR are\nonly hexadecimal characters included, the function returns TRUE. The he￾xadecimal character are characters with the decimal code 0..9, a..f. and\nA..F.", "type": "FUNCTION", "name": "IS_HEX", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string that needs to be validated as a hexadecimal string."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Indicates whether the input string is a valid hexadecimal string. Returns TRUE if all characters are hexadecimal, otherwise FALSE."}}
{"title": "Date Period Check", "description": "IS_HEX tests whether the string STR contains only hexadecimal characters\nare. If another character is found the function returns FALSE. If in STR are\nonly hexadecimal characters included, the function returns TRUE. The he￾xadecimal character are characters with the decimal code 0..9, a..f. and\nA..F.", "type": "FUNCTION", "name": "PERIOD2", "input": [{"name": "DP", "type": "ARRAY[0..3, 0..1] OF DATE", "description": "An array containing pairs of dates that define specific periods."}, {"name": "DX", "type": "DATE", "description": "A single date to check against the periods defined in the DP array."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "A boolean value indicating whether the date DX is within any of the defined date periods in DP.", "fields": []}}
{"title": "Manual Control Logic Function", "description": "MANUAL can override an input signal IN with TRUE or FALSE.\nIN ON OFF Q\n0 0 0 0\n1 0 0 1\n- - 1 0 Manual operation position OFF\n- 1 0 1 Manual operation position ON\nThe typical use of MANUAL by means of a switch with 3 positions (OFF,\nAUTO, ON) where the connections are OFF at OFF and On at On and AUTO\nof the switch remains open.\nThe following diagram shows the possible connection of a switch with 3\npositions:", "type": "FUNCTION", "name": "ManualControlLogic", "input": [{"name": "IN", "type": "BOOL", "description": "Input signal indicating the current state. This signal is involved in the logical operation."}, {"name": "ON", "type": "BOOL", "description": "Input signal that, when TRUE, contributes to activating the manual control."}, {"name": "OFF", "type": "BOOL", "description": "Input signal that, when TRUE, deactivates the manual control."}], "output": [{"name": "MANUAL", "type": "BOOL", "description": "Output of the function indicating the state of the manual control, TRUE if the manual control is active."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns the state of the MANUAL control determined by the logical conditions of the input parameters."}}
{"title": "FT_TN8 Function Block", "description": "MANUAL can override an input signal IN with TRUE or FALSE.\nIN ON OFF Q\n0 0 0 0\n1 0 0 1\n- - 1 0 Manual operation position OFF\n- 1 0 1 Manual operation position ON\nThe typical use of MANUAL by means of a switch with 3 positions (OFF,\nAUTO, ON) where the connections are OFF at OFF and On at On and AUTO\nof the switch remains open.\nThe following diagram shows the possible connection of a switch with 3\npositions:", "type": "FUNCTION_BLOCK", "name": "FT_TN8", "input": [{"name": "in", "type": "REAL", "description": "The real input value that will be processed by the function block."}, {"name": "T", "type": "TIME", "description": "The time interval that determines how frequently the input is sampled."}], "output": [{"name": "out", "type": "REAL", "description": "The real output value which corresponds to the last sampled input."}, {"name": "trig", "type": "BOOL", "description": "A boolean output that indicates if the input was processed and the output was updated."}], "in/out": [], "return_value": null}
{"title": "Hyperbolic Tangent Function (TANH)", "description": "TANH calculates the Tangent Hyperbolic according to the following \nformula:", "type": "FUNCTION", "name": "TANH", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the hyperbolic tangent is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The hyperbolic tangent of the input value X."}}
{"title": "Bit Load Word Function", "description": "BIT_LOAD_W copies the bit at input VAL to the bit in position N in WORD\nIN. The least signifcant bit B0 is described by the position 0.", "type": "FUNCTION", "name": "BIT_LOAD_W", "input": [{"name": "IN", "type": "WORD", "description": "The input WORD to be modified."}, {"name": "VAL", "type": "BOOL", "description": "Boolean value indicating whether to set or clear the bit."}, {"name": "POS", "type": "INT", "description": "The position of the bit to be set or cleared."}], "output": [{"name": "BIT_LOAD_W", "type": "WORD", "description": "The modified WORD after the bit operation."}], "in/out": [], "return_value": {"type": "WORD", "description": "The resulting WORD after the function's bit manipulation."}}
{"title": "Calculate the Magnitude of a 3D Vector", "description": "BIT_LOAD_W copies the bit at input VAL to the bit in position N in WORD\nIN. The least signifcant bit B0 is described by the position 0.", "type": "FUNCTION", "name": "V3_ABS", "input": [{"name": "A", "type": "ARRAY[1..3] OF REAL", "description": "An array representing a 3D vector, containing three REAL values corresponding to the x, y, and z components of the vector."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed magnitude of the 3D vector A.", "fields": []}}
{"title": "Linear Interpolation Function", "description": "BIT_LOAD_W copies the bit at input VAL to the bit in position N in WORD\nIN. The least signifcant bit B0 is described by the position 0.", "type": "FUNCTION", "name": "F_LIN2", "input": [{"name": "X", "type": "REAL", "description": "The independent variable for which the interpolation is calculated."}, {"name": "X1", "type": "REAL", "description": "The X coordinate of the first point."}, {"name": "Y1", "type": "REAL", "description": "The Y coordinate of the first point."}, {"name": "X2", "type": "REAL", "description": "The X coordinate of the second point."}, {"name": "Y2", "type": "REAL", "description": "The Y coordinate of the second point."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The interpolated Y value corresponding to the input X value.", "fields": []}}
{"title": "Flow Control Function Block", "description": "FLOW_CONTROL switches a valve at the output Q when the input IN =\nTRUE. In addition, the valve can also be switched via the input RE. REQ =\nTRUE turns the valve on for the time T_AUTO and will be locked for the\ntime T_DELAY. after the time T_DELAY the valve can be turned on again on\nREQ. During this lock period T_DELAY the valve may be controlled by the\ninput IN. An ESR compatible status output STATUS indicates the status of\nthe module. Both the REQ and IN can only switch the output Q when the\ninput ENQ is set to True.\nStatus = 100 Ready\nStatus = 101 Valve on by a TRUE at IN\nStatus = 102 Valve on by a TRUE at REQ\nStatus = 103 Reset is executed\nThe diagram illustrates the structure of inferential FLOW_CONTROL:", "type": "FUNCTION_BLOCK", "name": "FLOW_CONTROL", "input": [{"name": "IN", "type": "BOOL", "description": "Input boolean signal that influences the flow control."}, {"name": "REQ", "type": "BOOL", "description": "Request boolean signal that triggers the timing and operations."}, {"name": "ENQ", "type": "BOOL", "description": "Enquiry boolean signal that enables or disables certain operations."}, {"name": "RST", "type": "BOOL", "description": "Reset signal that clears the state of the function block."}, {"name": "T_AUTO", "type": "TIME", "description": "The automatic timing duration for the timer, defaulting to 60 minutes."}, {"name": "T_DELAY", "type": "TIME", "description": "The delay duration applied after the automatic timing, defaulting to 1380 minutes."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output boolean signal that indicates the state of the flow control."}, {"name": "STATUS", "type": "BYTE", "description": "Status code reflecting the current state of the function block."}], "in/out": [], "return_value": null}
{"title": "Combine Two Bytes into a Word", "description": "WORD_OF_BYTE composes a Word of 2 separate bytes B0 and B1.", "type": "FUNCTION", "name": "WORD_OF_BYTE", "input": [{"name": "B1", "type": "BYTE", "description": "The first byte to be combined, which will be shifted left by 8 bits."}, {"name": "B0", "type": "BYTE", "description": "The second byte to be combined, which will remain in its original position."}], "output": [], "in/out": [], "return_value": {"type": "WORD", "description": "The resulting WORD obtained by combining B1 and B0."}}
{"title": "Window Function", "description": "WINDOW function tests whether the input value is within the limits de￾fned by the LOW and HIGH.\nWINDOW is exactly TRUE if IN < HIGH and IN > LOW.", "type": "FUNCTION", "name": "WINDOW", "input": [{"name": "low", "type": "REAL", "description": "The lower boundary of the input range."}, {"name": "in", "type": "REAL", "description": "The input value to be evaluated."}, {"name": "high", "type": "REAL", "description": "The upper boundary of the input range."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns true if the input value is within the specified range, false otherwise."}}
{"title": "Hyperbolic Arcsine Calculation", "description": "ASINH calculate the arc hyperbolic sine by the formula:", "type": "FUNCTION", "name": "ASINH", "input": [{"name": "X", "type": "REAL", "description": "A real number input for which the hyperbolic arcsine is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed hyperbolic arcsine of the input value X."}}
{"title": "Cosh Function", "description": "COSH calculates the hyperbolic cosine using the formula:", "type": "FUNCTION", "name": "COSH", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the hyperbolic cosine is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The hyperbolic cosine of the input value X, computed as (1.0 / T + T) * 0.5 where T is equal to EXP(X)."}}
{"title": "Mid Value Calculation", "description": "COSH calculates the hyperbolic cosine using the formula:", "type": "FUNCTION", "name": "MID3", "input": [{"name": "IN1", "type": "REAL", "description": "The first input real number."}, {"name": "IN2", "type": "REAL", "description": "The second input real number."}, {"name": "IN3", "type": "REAL", "description": "The third input real number."}], "output": [{"name": "MID3", "type": "REAL", "description": "The calculated mid value, which is the second largest of the three input numbers."}], "in/out": [], "return_value": {"type": "REAL", "description": "The return value represents the mid value of the three inputs."}}
{"title": "Absolute Value Function for REAL2", "description": "COSH calculates the hyperbolic cosine using the formula:", "type": "FUNCTION", "name": "R2_ABS", "input": [{"name": "X", "type": "REAL2", "description": "Input parameter of type REAL2 containing the values to compute the absolute value from."}], "output": [], "in/out": [], "return_value": {"type": "REAL2", "description": "The output result of type REAL2 that holds the absolute values of the input's components.", "fields": [{"name": "RX", "type": "REAL", "description": "The absolute value of the RX component of the input REAL2."}, {"name": "R1", "type": "REAL", "description": "The absolute value of the R1 component of the input REAL2."}]}}
{"title": "Leap Year Determination Function", "description": "LEAP_YEAR tests if the input year is a leap year and passs\nTRUE if true. The test is valid for the time window from 1970 to 2099. In\nthe year 2100 a leap year is indicated although this is not one. However,\nsince the range of dates according to IEC61131-3 extends only to the year\n2106 this correction will be omitted.", "type": "FUNCTION", "name": "LEAP_YEAR", "input": [{"name": "yr", "type": "INT", "description": "The year for which the leap year status is to be determined."}], "output": [{"name": "LEAP_YEAR", "type": "BOOL", "description": "Returns TRUE if the year is a leap year, FALSE otherwise."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Indicates whether the year is a leap year."}}
{"title": "Convert Real to DWORD", "description": "REAL_TO_DW copies the bit pattern of a REAL (IN) in a DWORD. These bits\nare copied without regard to their meaning. The function REAL_TO_DW is\nthe inverse so that the conversion of REAL_TO_DW and then DW_TO_REAL\nresult in the output value. The IEC standard function REAL_TO_DWORD\nconverts the REAL value to a fxed numerical value and is rounded at the\nlowest point of the DWORD.", "type": "FUNCTION", "name": "REAL_TO_DW", "input": [{"name": "X", "type": "REAL", "description": "Input variable of type REAL that needs to be converted to DWORD."}], "output": [{"name": "REAL_TO_DW", "type": "DWORD", "description": "The DWORD representation of the input REAL value."}], "in/out": [], "return_value": {"type": "DWORD", "description": "The result of the conversion from REAL to DWORD."}}
{"title": "B_TRIG Function Block", "description": "B_TRIG generates after a change of edge on the CLK\ninput an output pulse for exactly one PLC cycle. In contrast to the two\nstandard modules R_TRIG and F_TRIG that produce only at falling or rising\nedge of a pulse, B_TRIG generates at falling and rising edge of an output\npulse.", "type": "FUNCTION_BLOCK", "name": "B_TRIG", "input": [{"name": "CLK", "type": "BOOL", "description": "Input variable that represents the clock signal."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output variable that reflects the state triggered by the input clock signal."}], "in/out": [], "return_value": null}
{"title": "Gauss cumulative distribution function", "description": "GAUSSCD calculated the distribution function for normal dis￾tribution using the following formula:\nThe normal distribution is the density function normally distributed ran￾dom variables. With the parameters U = 0 and SI = 1, it follows the stan￾dard normal distribution. The distribution function ( Cumulative Distributi￾on Function ).", "type": "FUNCTION", "name": "GAUSSCD", "input": [{"name": "X", "type": "REAL", "description": "The value at which to evaluate the cumulative distribution function."}, {"name": "U", "type": "REAL", "description": "The mean value of the Gaussian distribution."}, {"name": "SI", "type": "REAL", "description": "The standard deviation of the Gaussian distribution."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The cumulative probability for the Gaussian distribution at the given value X.", "fields": []}}
{"title": "Find Non-Numeric Character", "description": "FIND_NONUM searches STR from the starting position POS\nfrom left to right and returns the frst position which is not a number.\nNumbers are the letters \"0..9\" and \".\"", "type": "FUNCTION", "name": "FIND_NONUM", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The input string to be searched for non-numeric characters."}, {"name": "pos", "type": "INT", "description": "The position in the string from which to start the search."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The index of the first non-numeric character found in the string, or 0 if there are no non-numeric characters.", "fields": []}}
{"title": "Float to Real Conversion Function", "description": "FLOAT_TO_REAL converts a string- foating point number into a data type\nREAL. While the conversion characters \".\" or ',' interpreted as a comma\nand 'E' or 'e' as the separator of the exponent. The characters '-\n0123456789' are evaluated and others in FLT occurring characters are\nignored.", "type": "FUNCTION", "name": "FLOAT_TO_REAL", "input": [{"name": "FLT", "type": "STRING[20]", "description": "The string input representing a floating-point number to be converted."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The converted real number value from the input string.", "fields": []}}
{"title": "Conversion from SDT to TOD", "description": "SDT_TO_TOD produces a time of day of a structured date-time value.", "type": "FUNCTION", "name": "SDT_TO_TOD", "input": [{"name": "DTI", "type": "SDT", "description": "The input parameter of type SDT that contains the hours, minutes, seconds, and milliseconds to be converted."}], "output": [], "in/out": [], "return_value": {"type": "TOD", "description": "The converted time of day in milliseconds as a DWORD.", "fields": []}}
{"title": "First-Order Proportional-Derivative Controller", "description": "FT_PD is a PD controller, the following formula works:\nY = KP * (IN + DERIV(IN))\nFT_PD can be used in conjunction with the modules CTRL_IN and\nCTRL_OUT to establish a PD controller.\nThe following graph illustrates the internal structure of the controller:", "type": "FUNCTION_BLOCK", "name": "FT_PD", "input": [{"name": "IN", "type": "REAL", "description": "The input signal to be controlled."}, {"name": "KP", "type": "REAL", "description": "The proportional gain constant, default value is 1.0."}, {"name": "TV", "type": "REAL", "description": "The time constant for the derivative action, default value is 1.0."}], "output": [{"name": "Y", "type": "REAL", "description": "The output of the PD controller based on the input signal and its derivative."}], "in/out": [], "return_value": null}
{"title": "Hexadecimal to Byte Conversion", "description": "HEX_TO_BYTE in a BYTE value.\nHere only hexadecimal characters '0'..'9', 'a..f' and 'A'.. 'F' are interpreted,\nothers occurring in HEX characters are ignored.", "type": "FUNCTION", "name": "HEX_TO_BYTE", "input": [{"name": "HEX", "type": "STRING(5)", "description": "A string representing the hexadecimal value to be converted to a byte."}], "output": [{"name": "HEX_TO_BYTE", "type": "BYTE", "description": "The resulting byte value obtained from the conversion of the hexadecimal string."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The output byte value derived from the hexadecimal input string."}}
{"title": "Fade Function Block", "description": "FADE is used to switch between 2 inputs IN1 and IN2 with a soft transition.\nThe switching time is specifed as TF. An asynchronous reset (RST) resets\nthe module without delay to IN1 if F = FALSE or IN2 when F = TRUE. A\nswitching operation is triggered by a change in the value of R. Then it\nswitches within the time TF between the two inputs. The switchover will\nmix the two entrances during the changeover. At the beginning of swit￾ching at the output are at 0% of the new value and 100% of the old value\npasssed. after half the transfer time (TF/2) the output has 50% each of the\ntwo input values (Y = in1* 0.5 + in2 * 0.5). after the time TF is then the\nnew output value to 100% available.\nDuring the switching of the output Y is:\nY = TU/TF * IN1 + (1 - TU/TF) * IN2.\nTU is the time elapsed since the start of the switchover.\nSince the output of FADE is dynamically calculated, the device can also be\nused to switch dynamic signals. The switch is divided into up to 65,535\nsteps, which can be limited by the cycle time of the PLC. A PLC with a cy￾cle time of 10ms and a TF of a second is only in 1s/10ms = 100 steps to\nchange channels.", "type": "FUNCTION_BLOCK", "name": "FADE", "input": [{"name": "IN1", "type": "REAL", "description": "The starting value for the fade effect."}, {"name": "IN2", "type": "REAL", "description": "The target value for the fade effect."}, {"name": "F", "type": "BOOL", "description": "A boolean flag that indicates whether the fade operation should be active."}, {"name": "TF", "type": "TIME", "description": "The duration of the fade effect."}, {"name": "rst", "type": "BOOL", "description": "A reset signal that initializes the ramp module and stops the fade effect."}], "output": [{"name": "Y", "type": "REAL", "description": "The output value after applying the fade effect between IN1 and IN2."}], "in/out": [], "return_value": null}
{"title": "Decimal Rounding Function", "description": "ROUND rounds the input value IN to N digits. Follows the last\ndigit a digit greater than 5 the last digit is rounded up. ROUND internally\nuses the standard function TRUNC() which converts the input value to an\nINTEGER type DINT. This may come as an overfow because DINT can store\nin maximum +/-2.14*10^9. The range of ROUND is therefore limited to +/-\n2.14 * 10^9.", "type": "FUNCTION", "name": "ROUND", "input": [{"name": "in", "type": "REAL", "description": "The real number to be rounded."}, {"name": "N", "type": "INT", "description": "The number of decimal places to round to, limited between 0 and 8."}], "output": [{"name": "ROUND", "type": "REAL", "description": "The rounded real number."}], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the rounding operation.", "fields": []}}
{"title": "Pulse Width Modulation Control", "description": "PWM_PW is a pulse width modulated frequency generator. The generator\ngenerates a fxed frequency F with a duty cycle (TON / TOFF) which can\nbemodulated (set) by the input PW. The input passes the time before the\nsignal remains TRUE.", "type": "FUNCTION_BLOCK", "name": "PWM_PW", "input": [{"name": "F", "type": "REAL", "description": "The frequency of the PWM signal in Hertz."}, {"name": "PW", "type": "TIME", "description": "The duration of the pulse width."}], "output": [{"name": "Q", "type": "BOOL", "description": "The output Boolean signal representing the PWM signal."}], "in/out": [], "return_value": null}
{"title": "Calculate Days Delta", "description": "DAYS_DELTA calculates the diference between two data in\ndays.", "type": "FUNCTION", "name": "DAYS_DELTA", "input": [{"name": "date_1", "type": "DATE", "description": "The first date for comparison."}, {"name": "date_2", "type": "DATE", "description": "The second date for comparison."}], "output": [], "in/out": [], "return_value": {"type": "DINT", "description": "The difference in days between date_1 and date_2.", "fields": []}}
{"title": "Calculate the Absolute Value of a Complex Number", "description": "CABS calculates the length of the vector of a complex number The absolu￾te value is also module or Magnitude mentioned.\nCABS = SQRT(X.RE² + X.IM²)", "type": "FUNCTION", "name": "CABS", "input": [{"name": "X", "type": "COMPLEX", "description": "A complex number whose absolute value is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The absolute value of the complex number X.", "fields": []}}
{"title": "Calculate Angle in 3D Space", "description": "CABS calculates the length of the vector of a complex number The absolu￾te value is also module or Magnitude mentioned.\nCABS = SQRT(X.RE² + X.IM²)", "type": "FUNCTION", "name": "V3_XANG", "input": [{"name": "A", "type": "Vector_3", "description": "A 3D vector from which the angle is to be calculated.", "fields": [{"name": "X", "type": "REAL", "description": "The X component of the vector."}, {"name": "Y", "type": "REAL", "description": "The Y component of the vector."}, {"name": "Z", "type": "REAL", "description": "The Z component of the vector."}]}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The angle in radians calculated from the 3D vector.", "fields": []}}
{"title": "Cauchy Distribution Calculation", "description": "CAUCHYCD calculated the distribution function after Cauchy.", "type": "FUNCTION", "name": "CAUCHYCD", "input": [{"name": "X", "type": "REAL", "description": "A real number representing the first parameter of the Cauchy distribution."}, {"name": "T", "type": "REAL", "description": "A real number representing the second parameter of the Cauchy distribution."}, {"name": "U", "type": "REAL", "description": "A real number representing the scale parameter of the Cauchy distribution."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated value of the Cauchy distribution based on the inputs X, T, and U."}}
{"title": "Compute Inverse Hyperbolic Cosine of a Complex Number", "description": "CACOSH calculates the arc hyperbolic cosine of a complex number\n[fzy] The range of values of the result is between [-  ,+  ] For the imagi￾nary part.", "type": "FUNCTION", "name": "CACOSH", "input": [{"name": "X", "type": "COMPLEX", "description": "Input variable representing a complex number for which the inverse hyperbolic cosine will be calculated."}], "output": [{"name": "CACOSH", "type": "complex", "description": "The result of the inverse hyperbolic cosine of the input complex number."}], "in/out": [], "return_value": {"type": "complex", "description": "Returns the complex result of the inverse hyperbolic cosine function.", "fields": []}}
{"title": "Calculate Days in Month", "description": "DAYS_IN_MONTH function calculates the number of days in the current\nmonth.", "type": "FUNCTION", "name": "DAYS_IN_MONTH", "input": [{"name": "IDATE", "type": "DATE", "description": "The input date for which the number of days in the month needs to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The number of days in the month corresponding to the provided date.", "fields": []}}
{"title": "Control Output Function Block", "description": "CTRL_OUT adds to the CI input the value of OFFSET and returns the result\nto Y if MANUAL = FALSE. If MANUAL is TRUE at output Y the input value of\nMAN_IN + OFFSET is issued. Y is always limited to the boundaries defned\nby LIM_L and LIM_H. If Y reaches one of the limits, then the output LIM is\nTRUE. CTRL_OUT can be used to build own rule modules.\nBlock diagram of CTRL_OUT:", "type": "FUNCTION_BLOCK", "name": "CTRL_OUT", "input": [{"name": "CI", "type": "REAL", "description": "Input signal value used for output calculation."}, {"name": "OFFSET", "type": "REAL", "description": "Value to be added to the output signal."}, {"name": "MAN_IN", "type": "REAL", "description": "Manual input value to be used if manual mode is activated."}, {"name": "LIM_L", "type": "REAL", "description": "Lower limit for the output signal."}, {"name": "LIM_H", "type": "REAL", "description": "Upper limit for the output signal."}, {"name": "MANUAL", "type": "BOOL", "description": "Flag to indicate whether to use manual input."}], "output": [{"name": "Y", "type": "REAL", "description": "The calculated output value after applying offset and limits."}, {"name": "LIM", "type": "BOOL", "description": "Flag indicating if the output is within the defined limits."}], "in/out": [], "return_value": null}
{"title": "Sequence Control Block", "description": "CTRL_OUT adds to the CI input the value of OFFSET and returns the result\nto Y if MANUAL = FALSE. If MANUAL is TRUE at output Y the input value of\nMAN_IN + OFFSET is issued. Y is always limited to the boundaries defned\nby LIM_L and LIM_H. If Y reaches one of the limits, then the output LIM is\nTRUE. CTRL_OUT can be used to build own rule modules.\nBlock diagram of CTRL_OUT:", "type": "FUNCTION_BLOCK", "name": "SEQUENCE_64", "input": [{"name": "START", "type": "BOOL", "description": "A boolean signal to start the sequence."}, {"name": "SMAX", "type": "INT", "description": "The maximum state index for the sequence."}, {"name": "PROG", "type": "ARRAY[0..63] OF TIME", "description": "An array containing timing intervals for each state in the sequence."}, {"name": "RST", "type": "BOOL", "description": "A boolean signal to reset the sequence state."}], "output": [{"name": "STATE", "type": "INT", "description": "The current state of the sequence, initialized to -1."}, {"name": "TRIG", "type": "BOOL", "description": "A trigger signal that indicates when a state transition has occurred."}], "in/out": [], "return_value": {}}
{"title": "Ramp Function Block (RMP_B)", "description": "RMP_B is a ramp generator with 8 bits (1 byte) resolution. The ramp of\n0..255 is divided into a maximum of 255 steps and go through, in a time\nof PT once complete. An enable signal E switches the ramp generator on\nor of. An asynchronous reset sets each time the output to 0, and a pulse\nat the SET input sets the output to 255. With a UD input, the direction\nOPEN (UD = TRUE) or down (UD = FALSE) is set. The output of BUSY =\nTRUE indicates that a ramp is active. BUSY = FALSE means the output is\nstable. The outputs HIGH and LOW are TRUE, if the output OUT reaches\nthe lower or upper limit (0 and 255).\nAt setting of PT has to be noted, that a PLC with 5ms cycle time needs\n256*5 = 1275 milliseconds for a ramp. If the time PT is made shorter than\nthe cycle time multiplied by 256, the edge is translated in correspondingly\nlarger steps. The ramp is constructed in this case with less than 256 steps\nper cycle. PT may be T#0s, then the output switched between minimum\nand maximum value back and forth.\nThe following example shows an application of RMP_B. The outputs HIGH\nand LOW triggers both NTSC (X4, X5) 1 second delayed, and switch with\nthe RS Flip Flop (X6) the UP input of the Ramps generators in order. The\nresult is a ramp of 5 seconds, followed by an break of 1 second and then\nthe reverse gradient of 5 seconds and then a break of 1 second. In the\nTrace the history of the signals can be seen. \nTiming diagram for Up / Down Ramp:\nAnother example shows the use of a sawtooth RMP_B.\nTiming diagram for sawtooth:", "type": "FUNCTION_BLOCK", "name": "RMP_B", "input": [{"name": "SET", "type": "BOOL", "description": "A boolean indicating if the ramp should be set to its maximum value."}, {"name": "PT", "type": "TIME", "description": "The time duration over which the ramp should occur."}, {"name": "E", "type": "BOOL", "description": "Enable input that allows the ramp operation to process; defaults to TRUE."}, {"name": "UP", "type": "BOOL", "description": "A boolean that determines the direction of the ramp; if TRUE, the ramp will increase, if FALSE, it will decrease."}, {"name": "RST", "type": "BOOL", "description": "A boolean that, when set, resets the output value to zero."}], "output": [{"name": "OUT", "type": "BYTE", "description": "The current value of the ramp output."}, {"name": "BUSY", "type": "BOOL", "description": "Indicates if the function block is currently busy processing the ramp operation."}, {"name": "HIGH", "type": "BOOL", "description": "Indicates if the output is currently at its maximum value (255)."}, {"name": "LOW", "type": "BOOL", "description": "Indicates if the output is currently at its minimum value (0)."}], "in/out": [], "return_value": null}
{"title": "FindB Function", "description": "FINDB searched for the presence of STR2 in STR1 and returns\nthe last position of STR2 in STR1.\nIf STR2 is not found, a 0 is returned.", "type": "FUNCTION", "name": "FindB", "input": [{"name": "str1", "type": "STRING(STRING_LENGTH)", "description": "The main string in which the search for the substring will be conducted."}, {"name": "str2", "type": "STRING(STRING_LENGTH)", "description": "The substring that is being searched for in 'str1'."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The position of the last occurrence of 'str2' in 'str1'. Returns 0 if 'str2' is not found.", "fields": []}}
{"title": "Determine Daylight Saving Time", "description": "FINDB searched for the presence of STR2 in STR1 and returns\nthe last position of STR2 in STR1.\nIf STR2 is not found, a 0 is returned.", "type": "FUNCTION", "name": "DST", "input": [{"name": "UTC", "type": "DT", "description": "The date and time in UTC format that needs to be evaluated for Daylight Saving Time."}], "output": [{"name": "DST", "type": "BOOL", "description": "Returns TRUE if the given UTC date and time is within the Daylight Saving Time period, otherwise FALSE."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Indicates whether the input date is within Daylight Saving Time.", "fields": []}}
{"title": "FF_D4E Function Block", "description": "FINDB searched for the presence of STR2 in STR1 and returns\nthe last position of STR2 in STR1.\nIf STR2 is not found, a 0 is returned.", "type": "FUNCTION_BLOCK", "name": "FF_D4E", "input": [{"name": "D0", "type": "BOOL", "description": "Input boolean signal that sets output Q0."}, {"name": "D1", "type": "BOOL", "description": "Input boolean signal that sets output Q1."}, {"name": "D2", "type": "BOOL", "description": "Input boolean signal that sets output Q2."}, {"name": "D3", "type": "BOOL", "description": "Input boolean signal that sets output Q3."}, {"name": "CLK", "type": "BOOL", "description": "Clock signal that triggers the setting of outputs."}, {"name": "RST", "type": "BOOL", "description": "Reset signal that clears all outputs."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output boolean signal representing the state set by D0."}, {"name": "Q1", "type": "BOOL", "description": "Output boolean signal representing the state set by D1."}, {"name": "Q2", "type": "BOOL", "description": "Output boolean signal representing the state set by D2."}, {"name": "Q3", "type": "BOOL", "description": "Output boolean signal representing the state set by D3."}], "in/out": [], "return_value": null}
{"title": "Calculate Angle from Vector", "description": "FINDB searched for the presence of STR2 in STR1 and returns\nthe last position of STR2 in STR1.\nIf STR2 is not found, a 0 is returned.", "type": "FUNCTION", "name": "V3_YANG", "input": [{"name": "A", "type": "Vector_3", "description": "A 3-dimensional vector for which the angle will be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed angle in radians based on the Y component of the vector.", "fields": []}}
{"title": "Convert Minutes to Time", "description": "MINUTE_TO_TIME calculates a time value (TIME) from the in￾put in minutes as REAL.", "type": "FUNCTION", "name": "MINUTE_TO_TIME", "input": [{"name": "IN", "type": "REAL", "description": "The input parameter representing the time in minutes to be converted."}], "output": [{"name": "MINUTE_TO_TIME", "type": "TIME", "description": "The output time value calculated from the input minutes."}], "in/out": [], "return_value": {"type": "TIME", "description": "The resulting time value after conversion from minutes.", "fields": []}}
{"title": "Complex Cosine Function", "description": "CCOS calculates the cosine of a complex number", "type": "FUNCTION", "name": "CCOS", "input": [{"name": "X", "type": "COMPLEX", "description": "A complex number for which the cosine is to be calculated."}], "output": [{"name": "CCOS", "type": "complex", "description": "The cosine of the input complex number."}], "in/out": [], "return_value": {"type": "complex", "description": "The result of the cosine calculation.", "fields": []}}
{"title": "Multiplexer Function", "description": "CCOS calculates the cosine of a complex number", "type": "FUNCTION", "name": "MUX_R4", "input": [{"name": "IN0", "type": "REAL", "description": "The first input value."}, {"name": "IN1", "type": "REAL", "description": "The second input value."}, {"name": "IN2", "type": "REAL", "description": "The third input value."}, {"name": "IN3", "type": "REAL", "description": "The fourth input value."}, {"name": "A0", "type": "BOOL", "description": "The first boolean selection input."}, {"name": "A1", "type": "BOOL", "description": "The second boolean selection input."}], "output": [{"name": "MUX_R4", "type": "REAL", "description": "The output value selected based on the input and selection parameters."}], "in/out": [], "return_value": {"type": "REAL", "description": "The selected output value based on the multiplexer logic."}}
{"title": "IS_ALPHA Function", "description": "IS_ALPHA tests whether the string STR contains only letters. If an incorrect,\nnon-alphanumeric character is found the function returns FALSE. If only letters\nare included in STR is the result of TRUE. Letters are the characters A..Z and\na..z. In examining the Global Setup EXTENDED_ASCII constant is considered. If\nEXTENDED_ASCII = TRUE the extended ASCII character-set to be considered in\naccordance with ISO 8859-1. Umlauts like Ä, Ö, Ü are considered only if the glo￾bal constant EXTENDED_ASCII = TRUE.", "type": "FUNCTION", "name": "IS_ALPHA", "input": [{"name": "str", "type": "STRING", "description": "The input string to be checked for alphabetic characters. It is defined with a specified maximum length.", "fields": []}], "output": [{"name": "IS_ALPHA", "type": "BOOL", "description": "A boolean value indicating whether the string consists solely of alphabetic characters.", "fields": []}], "in/out": [], "return_value": {"type": "BOOL", "description": "The return value of the function, indicating the result of the alphabet check.", "fields": []}}
{"title": "SRAMP Function Block", "description": "SRAMP generates an output signal which is is limited by the adjustable pa￾rameters. The output follows the input signal and is limited by maximum\nspeed (VU_MAX and VD_MAX), upper and lower limit (LIMIT_LOW and LI￾MIT_HIGH), and maximum acceleration (A_UP and A_DN). SRAMP is used to\ndrive motors, for example. The output V passes the current speed of the\noutput.\nIn following diagram, the internal process of SRAMP is shown. A ramp ge￾nerator X2, sets the speed of the output change, and a second ramp gene￾rator X3 controls the output.\nThe Trace Recording shows an example of SRAMP. The input (green) increa￾ses from 0 to 20 and then immediately to 10 while the output increases\nwith the maximum acceleration to maximum speed. Then is shown that\nthe Input during the course may change. In this example, it slowed down\nin time, so that the output stops exactly at 10. After reaching the end va￾lue 10 of the input switches to -3 and the output Y follows accordingly. \nThe input values for A_UP and VU_MAX must be specifed with a positive\nsign, A_DN and VD_MAX need a negative sign.", "type": "FUNCTION_BLOCK", "name": "SRAMP", "input": [{"name": "X", "type": "REAL", "description": "The target value that the output 'Y' should reach."}, {"name": "A_UP", "type": "REAL", "description": "The acceleration rate when ramping up towards the target value."}, {"name": "A_DN", "type": "REAL", "description": "The deceleration rate when ramping down away from the target value."}, {"name": "VU_MAX", "type": "REAL", "description": "The maximum speed limit when ramping up."}, {"name": "VD_MAX", "type": "REAL", "description": "The maximum speed limit when ramping down."}, {"name": "LIMIT_HIGH", "type": "REAL", "description": "The upper limit for the output 'Y'."}, {"name": "LIMIT_LOW", "type": "REAL", "description": "The lower limit for the output 'Y'."}, {"name": "RST", "type": "BOOL", "description": "A boolean reset signal. If true, it resets the internal states."}], "output": [{"name": "Y", "type": "REAL", "description": "The current output value of the function block, which is ramped towards 'X'."}, {"name": "V", "type": "REAL", "description": "The current speed of the ramping operation, determining how quickly 'Y' approaches 'X'."}], "in/out": [], "return_value": null}
{"title": "Mathematical Expression Evaluator", "description": "EXEC calculates mathematic expressions and results a string.\nThe expression can only be a simple expression with an operator and wi￾thout brackets. For errors, such as a divide by zero EXEC provides the re￾turn string 'ERROR'.\nThe valid operators are: +, - *, /, ^, SIN, COS, TAN, SQRT.\nREAL as numbers and integer numbers are allowed.", "type": "FUNCTION", "name": "EXEC", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string representing the mathematical expression to be evaluated."}], "output": [{"name": "EXEC", "type": "STRING", "description": "The result of the evaluated mathematical expression as a string."}], "in/out": [], "return_value": {"type": "string", "description": "The result or error message returned after evaluating the expression.", "fields": []}}
{"title": "Calculate Ellipse Circumference", "description": "ELLIPSE_C calculates the circumference of an ellipse that is defned by the\nradii R1 and R2.", "type": "FUNCTION", "name": "ELLIPSE_C", "input": [{"name": "R1", "type": "REAL", "description": "The length of the semi-major axis of the ellipse."}, {"name": "R2", "type": "REAL", "description": "The length of the semi-minor axis of the ellipse."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed circumference of the ellipse.", "fields": []}}
{"title": "Speed Conversion Function Block", "description": "SPEED converts various common units in the units for speed.\nNormally, only the input to be converted is occupied and the remaining in-\nputs remain free. However, if several inputs loaded with values, the values\nof all inputs are converted accordingly and then summed.\n1 ms = meters / second = 3.6 km / h\n1 kmh = kilometers / hour = 1 / 3, 6 m / s\n1 knot = knot = 1 nautical mile / hour = 0.5144 m / s\nMh = 1 mile per hour = 0.44704 m / s", "type": "FUNCTION_BLOCK", "name": "SPEED", "input": [{"name": "ms", "type": "REAL", "description": "Speed in meters per second (m/s)"}, {"name": "kmh", "type": "REAL", "description": "Speed in kilometers per hour (km/h)"}, {"name": "kn", "type": "REAL", "description": "Speed in knots (kn)"}, {"name": "mh", "type": "REAL", "description": "Speed in miles per hour (mh)"}], "output": [{"name": "Yms", "type": "REAL", "description": "Converted speed in meters per second (m/s)"}, {"name": "Ykmh", "type": "REAL", "description": "Converted speed in kilometers per hour (km/h)"}, {"name": "Ykn", "type": "REAL", "description": "Converted speed in knots (kn)"}, {"name": "Ymh", "type": "REAL", "description": "Converted speed in miles per hour (mh)"}], "in/out": [], "return_value": null}
{"title": "Exponential Function Base 10 Calculation", "description": "SPEED converts various common units in the units for speed.\nNormally, only the input to be converted is occupied and the remaining in-\nputs remain free. However, if several inputs loaded with values, the values\nof all inputs are converted accordingly and then summed.\n1 ms = meters / second = 3.6 km / h\n1 kmh = kilometers / hour = 1 / 3, 6 m / s\n1 knot = knot = 1 nautical mile / hour = 0.5144 m / s\nMh = 1 mile per hour = 0.44704 m / s", "type": "FUNCTION", "name": "EXP10", "input": [{"name": "X", "type": "REAL", "description": "A real number input for which the base 10 exponential is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The output is the result of the base 10 exponential function for the input X."}}
{"title": "Integral Function Block", "description": "SPEED converts various common units in the units for speed.\nNormally, only the input to be converted is occupied and the remaining in-\nputs remain free. However, if several inputs loaded with values, the values\nof all inputs are converted accordingly and then summed.\n1 ms = meters / second = 3.6 km / h\n1 kmh = kilometers / hour = 1 / 3, 6 m / s\n1 knot = knot = 1 nautical mile / hour = 0.5144 m / s\nMh = 1 mile per hour = 0.44704 m / s", "type": "FUNCTION_BLOCK", "name": "FT_INT2", "input": [{"name": "IN", "type": "REAL", "description": "The real input value to be integrated."}, {"name": "K", "type": "REAL", "description": "A scaling factor for the integration process. Default is 1.0."}, {"name": "RUN", "type": "BOOL", "description": "Boolean flag indicating whether the integration should be performed. Default is TRUE."}, {"name": "RST", "type": "BOOL", "description": "Boolean flag to reset the integration process when TRUE."}, {"name": "OUT_MIN", "type": "REAL", "description": "The minimum limit for the output value. Default is -1E+38."}, {"name": "OUT_MAX", "type": "REAL", "description": "The maximum limit for the output value. Default is 1E+38."}], "output": [{"name": "OUT", "type": "REAL", "description": "The result of the integration process."}, {"name": "LIM", "type": "BOOL", "description": "Boolean flag indicating whether the output value is within the specified limits."}], "in/out": [], "return_value": null}
{"title": "Latch Function Block", "description": "LTCH is a transparent storage element ( Latch ). As long as L is true, Q fol￾lows the input D and the falling edge of L stores the output Q the current\ninput signal to D. With the asynchronous reset input of the Latch will be\ndeleted at any time regardless of L.", "type": "FUNCTION_BLOCK", "name": "LTCH", "input": [{"name": "D", "type": "BOOL", "description": "The data input that is transferred to the output Q when the latch is transparent."}, {"name": "L", "type": "BOOL", "description": "The latch control input that determines whether the latch is transparent."}, {"name": "RST", "type": "BOOL", "description": "The asynchronous reset input that forces the output Q to FALSE."}], "output": [{"name": "Q", "type": "BOOL", "description": "The output of the latch that reflects the state based on the inputs D and L."}], "in/out": [], "return_value": {}}
{"title": "Binary to DWORD Conversion", "description": "BIN_TO_DWORD converts a binary encoded string in a BYTE\nvalue. There, this method only binary characters are '0 'and '1' is interpre￾ted, others in BIN occurring characters are ignored.", "type": "FUNCTION", "name": "BIN_TO_DWORD", "input": [{"name": "BIN", "type": "STRING(40)", "description": "A binary string of length up to 40 characters, consisting of '0's and '1's, representing the binary number to be converted."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The resulting DWORD value obtained from the binary string conversion.", "fields": []}}
{"title": "Timed Pulse Generator", "description": "TP_X is a multiple triggerable pulse generator. In contrast to the standard\nmodule TP this template can be triggered multiple times and thus the out￾put pulse can be extended. The output Q remains after the last trigger\nevent (rising edge of IN) at ON, for the period of PT. While Q is true, by a\nfurther edge at the IN the Timer can be triggered again and the output\npulse can be extended. In contrast to TOF, at TP_X the time PT is measu￾red as of the last rising edge, regardless of how long IN remains at TRUE.\nThis means that the output Q, after the time PT, is measured from the last\nrising edge of IN moves to FALSE, even when the input IN is TRUE. \nTiming of TP_X:\n 16. Logic Modules", "type": "FUNCTION_BLOCK", "name": "TP_X", "input": [{"name": "IN", "type": "BOOL", "description": "Boolean input for the triggering signal. A rising edge on this signal will start the pulse."}, {"name": "PT", "type": "TIME", "description": "Time duration for which the output Q will remain true after a rising edge is detected."}], "output": [{"name": "Q", "type": "BOOL", "description": "Boolean output that indicates whether the pulse is currently active."}, {"name": "ET", "type": "TIME", "description": "Elapsed time since the pulse was activated."}], "in/out": [], "return_value": null}
{"title": "Timing Function Block", "description": "M_T measures the time how long IN was TRUE. PT is the time from the \nrising edge of signal IN to the falling edge of the IN signal. The Output ET \npasses the elapsed time since the last rising edge to falling edge. As long \nas the input signal is FALSE, ET = 0. M_T requires a rising edge to trigger \nthe measurement. If at the frst call IN is already TRUE, it is not seen as a \nrising edge. For more examples, see the description of M_TX. With TRUE at \nthe input RST, the outputs can always be reset to 0. If ET reaches the \nvalue of TMAX, automatically a reset is generated in the module to reset \nall outputs to 0. TMAX is internally assigned with default value of T#10d \nand normally can be unconnected.", "type": "FUNCTION_BLOCK", "name": "M_T", "input": [{"name": "IN", "type": "BOOL", "description": "A boolean input that, when true, starts the timing measurement."}, {"name": "TMAX", "type": "TIME", "description": "The maximum allowable elapsed time that can be measured. Defaults to 14400 minutes."}, {"name": "RST", "type": "BOOL", "description": "A boolean input to reset the elapsed time measurements."}], "output": [{"name": "PT", "type": "TIME", "description": "The previous time value recorded before the reset or input changes."}, {"name": "ET", "type": "TIME", "description": "The elapsed time measured from the rising edge of the input signal."}], "in/out": [], "return_value": null}
{"title": "Buffer Search Function", "description": "BUFFER_SEARCH (ADR (Array), SIZEOF (ARRAY),\nSTR, POS, IGN), where ARRAY is the name of the array. ADR() is a standard\nfunction which identifes the pointer to the array and SIZEOF() is a stan￾dard function, which determines the size of the array. The function returns\nthe string copied from the bufer as STRING. This type of processing arrays\nis very efcient because no additional memory is required and no surren￾der values must be copied. If IGN = TRUE both upper- and lowercase let￾ters are found as a match, while STR must be present in uppercase letters.\nIf IGN = FALSE case sensitive is searched.", "type": "FUNCTION", "name": "BUFFER_SEARCH", "input": [{"name": "PT", "type": "POINTER TO ARRAY[0..32767] OF BYTE", "description": "A pointer to the array of bytes that represents the buffer to be searched."}, {"name": "SIZE", "type": "INT", "description": "The size of the buffer, indicating how many bytes can be considered for the search."}, {"name": "STR", "type": "STRING", "description": "The string to search for in the buffer."}, {"name": "POS", "type": "INT", "description": "The starting position in the buffer from which to begin the search."}, {"name": "IGN", "type": "BOOL", "description": "A boolean flag indicating whether the search should be case-insensitive (true) or case-sensitive (false)."}], "output": [{"name": "BUFFER_SEARCH", "type": "INT", "description": "The position at which the substring is found within the buffer, or -1 if the substring is not found."}], "in/out": [], "return_value": {"type": "INT", "description": "The function returns the index of the first occurrence of the substring in the buffer or -1 if not found."}}
{"title": "Buffer Insert Function", "description": "_BUFFER_INSERT copies a string in any array of Byte and mo￾ves the rest of the array to the length of the string. The string is stored\nfrom any position POS in the bufer. The frst element in the array has the\nposition number 0. When called, a pointer to the array and its size in bytes\nis passed to the function. Under CoDeSys the call reads:\n_BUFFER_INSERT(ADR(Array), SIZEOF(Array)), where array is the name of\nthe array to be manipulated. ADR() is a standard function which identifes\nthe pointer to the array and SIZEOF() is a standard function, which deter￾mines the size of the array. The function returns the string copied from the\nbufer as STRING. The array specifed by the pointer is manipulated direct￾ly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "_BUFFER_INSERT", "input": [{"name": "STR", "type": "STRING[STRING_LENGTH]", "description": "The string to be inserted into the buffer."}, {"name": "POS", "type": "INT", "description": "The position in the buffer where the string will be inserted."}, {"name": "PT", "type": "POINTER TO ARRAY[0..32767] OF BYTE", "description": "A pointer to the buffer array where the string will be inserted."}, {"name": "SIZE", "type": "UINT", "description": "The size of the buffer."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "The next position in the buffer after the inserted string."}}
{"title": "Output Calculation Function", "description": "AOUT is confgured by setup parameters and calculates the input\nvalues (IN) to accordingly, so that after the module AOUT is a digital value\navailable at the output of the D/A converter generates a value that is the\nREAL value IN matches. Furthermore, the module can insert a Sign- Bit\nanywhere if the D/A converter need a Sign- Bit. By double-clicking on the\nmodule, several setup variables can be defned. Bits defne how many Bits\nthe D/A converter can handle. For a 12 bit converter, this value is 12. Then\nonly the bits 0 - 11 are scored. Sign defnes whether a sign bit is needed\nand where to place in the source DWORD. Sign = 255 means that no sign\nbit is needed, and 15 means Bit 15 in the DWORD contains the sign. LOW\nand HIGH defne the smallest and highest input value. If a Sign-Bit is def￾ned ( SIGN< 255), then LOW and HIGH must be positive. Without Sign-Bit\nthey can be either positive or negative.", "type": "FUNCTION", "name": "AOUT", "input": [{"name": "in", "type": "REAL", "description": "The input real number to be processed."}, {"name": "Bits", "type": "BYTE", "description": "The number of bits to be used in the output calculation."}, {"name": "sign", "type": "BYTE", "description": "The sign bit, defaults to 255 if not specified."}, {"name": "low", "type": "REAL", "description": "The lower limit for the input value."}, {"name": "high", "type": "REAL", "description": "The upper limit for the input value, defaults to 10.0 if not specified."}], "output": [{"name": "Aout", "type": "DWORD", "description": "The calculated 32-bit output value based on the processed input."}], "in/out": [], "return_value": {"type": "DWORD", "description": "The final computed output value.", "fields": []}}
{"title": "Check if a String is Alphanumeric", "description": "IS_ALNUM test if in the string STR are only letters or numbers. If an incor￾rect, non-alphanumeric character is found the function returns FALSE. STR\ncontains only letters or numbers, the result is TRUE. Letters are the cha￾racters A..Z and a..Z, and numbers are the signs 0..9. In examining the\nGlobal Setup constant EXTENDED_ASCII is considered. If EXTENDED_ASCII\n= TRUE the extended ASCII character-set to be considered in accordance\nwith ISO 8859-1. Umlauts like Ä, Ö, Ü are considered only if the global con￾stant EXTENDED_ASCII = TRUE.", "type": "FUNCTION", "name": "IS_ALNUM", "input": [{"name": "str", "type": "STRING(STRING_LENGTH)", "description": "The input string to be checked for alphanumeric characters."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns true if the string is alphanumeric and not empty; otherwise returns false."}}
{"title": "Extract Byte from String at Position", "description": "CODE determines the numerical code for a character at the position POS\nin STR. Is CODE called with a position with less than 1 or greater than the\nlength of STR, 0 is returned.", "type": "FUNCTION", "name": "ExtractByteFromString", "input": [{"name": "STR", "type": "STRING[STRING_LENGTH]", "description": "The input string from which the byte will be extracted."}, {"name": "POS", "type": "INT", "description": "The position in the string from which to extract the byte. Must be between 1 and the length of the string."}], "output": [{"name": "CODE", "type": "BYTE", "description": "The byte extracted from the string at the specified position, or 0 if the position is invalid."}], "in/out": [], "return_value": {"type": "BYTE", "description": "Returns the byte extracted from the string at the specified position, or 0 if the position is out of bounds."}}
{"title": "GEN_SQR Function Block", "description": "GEN_SQR is a sqare wave generator with programmable period, adjustable\namplitude and signal ofset and duty cycle DC ( Duty Cycle ). A special\nfeature is a adjustable delay so that with multiple generators overlapping\nsignals can be generated.\nThe following", "type": "FUNCTION_BLOCK", "name": "GEN_SQR", "input": [{"name": "PT", "type": "TIME", "description": "The period time for the square wave generation."}, {"name": "AM", "type": "REAL", "description": "The amplitude of the output signal. Default is 1.0."}, {"name": "OS", "type": "REAL", "description": "The offset value added to the output signal."}, {"name": "DC", "type": "REAL", "description": "The duty cycle of the square wave. Default is 0.5."}, {"name": "DL", "type": "REAL", "description": "The dead time. This is used to control the timing of the edges in the output signal."}], "output": [{"name": "Q", "type": "BOOL", "description": "A boolean output indicating the current state of the square wave signal."}, {"name": "Out", "type": "REAL", "description": "The generated output value of the square wave signal."}], "in/out": [], "return_value": null}
{"title": "Bar Graph Function Block", "description": "BAR_GRAPH is a level Detector, which activates depending on the input\nvalue an output. The threshold for the LOW and HIGH Outputs can be set\nby the setup variables TRIGGER_LOW and TRIGGER_HIGH. LOW is TRUE if\nX is less than TRIGGER_LOW and HIGH is true if X is greater or equal than\nTRIGGER_HIGH. If the setup variables ALARM_LOW and / or ALARM_HIGH\nset to TRUE, the output ALARM set to TRUE if the value will be lower than\nTRIGGER_LOW or exceed of TRIGGER_HIGH , and the output LOW or HIGH\nand ALARM remains TRUE until the input RST is TRUE and the alarm is re￾seted. The outputs Q1 to Q6 divide the area between between\nTRIGGER_LOW and TRIGGER_HIGH in seven equal areas. If the setup varia￾ble LOG_SCALE is set, the area between TRIGGER_LOW and\nTRIGGER_HIGH is divided logarithmically. \nThe output Status is an ESR compliant output and forwards states and\nalarms to ESR components.\nStatus\n110 Input is between Trigger_Low and Trigger_High.\n111 Input lower than Trigger_Low , Output LOW is TRUE\n112 Input higher than Trigger_High , Output HIGH is TRUE.\n1 Input lower than Trigger_low and Alarm_Lowis TRUE\n2 Input higher than Trigger_high and Alarm_High is TRUE\nThe following example shows a signal characteristic of n Bar_Graph:", "type": "FUNCTION_BLOCK", "name": "BAR_GRAPH", "input": [{"name": "X", "type": "REAL", "description": "The current value to be evaluated against the trigger thresholds."}, {"name": "rst", "type": "BOOL", "description": "Reset signal to clear alarms and output states."}, {"name": "trigger_Low", "type": "REAL", "description": "The lower threshold for triggering the alarm and bar graph outputs."}, {"name": "trigger_High", "type": "REAL", "description": "The upper threshold for triggering the alarm and bar graph outputs."}, {"name": "Alarm_low", "type": "BOOL", "description": "Indicates if a low alarm is enabled."}, {"name": "Alarm_high", "type": "BOOL", "description": "Indicates if a high alarm is enabled."}, {"name": "log_scale", "type": "BOOL", "description": "Indicates if a logarithmic scale should be applied to the graph representation."}], "output": [{"name": "LOW", "type": "BOOL", "description": "Indicates if the value is below the low trigger threshold."}, {"name": "Q1", "type": "BOOL", "description": "Status of the first bar in the graph."}, {"name": "Q2", "type": "BOOL", "description": "Status of the second bar in the graph."}, {"name": "Q3", "type": "BOOL", "description": "Status of the third bar in the graph."}, {"name": "Q4", "type": "BOOL", "description": "Status of the fourth bar in the graph."}, {"name": "Q5", "type": "BOOL", "description": "Status of the fifth bar in the graph."}, {"name": "Q6", "type": "BOOL", "description": "Status of the sixth bar in the graph."}, {"name": "HIGH", "type": "BOOL", "description": "Indicates if the value is above the high trigger threshold."}, {"name": "Alarm", "type": "BOOL", "description": "Indicates if any alarm condition has been triggered."}, {"name": "Status", "type": "BYTE", "description": "Current status code indicating the state of the evaluation."}], "in/out": [], "return_value": null}
{"title": "Leap Year Day Check", "description": "LEAP_DAY function checks if the input date is a leap or a 29th Februa￾ry. The test is valid for the time window from 1970 to 2099. In the year\n2100 a leap year indicated although this is not one. However, since the\nrange of dates according to IEC61131-3 extends only to the year 2106 this\ncorrection will be omitted.", "type": "FUNCTION", "name": "LEAP_DAY", "input": [{"name": "IDATE", "type": "DATE", "description": "The date to be checked for leap day."}], "output": [{"name": "LEAP_DAY", "type": "BOOL", "description": "A boolean value indicating whether the input date is a leap day."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns true if the date is February 29th, otherwise false."}}
{"title": "JD2000 Function", "description": "LEAP_DAY function checks if the input date is a leap or a 29th Februa￾ry. The test is valid for the time window from 1970 to 2099. In the year\n2100 a leap year indicated although this is not one. However, since the\nrange of dates according to IEC61131-3 extends only to the year 2106 this\ncorrection will be omitted.", "type": "FUNCTION", "name": "JD2000", "input": [{"name": "DTI", "type": "TIME", "description": "The input time value to be converted to Julian Date format."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The computed Julian Date corresponding to the input TIME value.", "fields": []}}
{"title": "Filter Function Block", "description": "FILTER_I is a flter of the frst degree for 16-bit INT data. The main applica￾tion is the fltering of sensor signals for noise reduction. The basic functio￾nality of a flter of the frst degree can be found in the module FT_PT1.", "type": "FUNCTION_BLOCK", "name": "FILTER_I", "input": [{"name": "X", "type": "INT", "description": "An integer input value to be filtered."}, {"name": "T", "type": "TIME", "description": "A time duration used to control the filtering process."}], "output": [{"name": "Y", "type": "INT", "description": "The filtered output value computed from the input."}], "in/out": [], "return_value": null}
{"title": "Complex Hyperbolic Cotangent Function", "description": "CATANH calculates the arc hyperbolic tangent of a complex number\nThe range of values of the result is between [- /2,+/2 ] for the imagina￾ry part.", "type": "FUNCTION", "name": "CATANH", "input": [{"name": "X", "type": "complex", "description": "A complex number for which the hyperbolic cotangent is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The result of the hyperbolic cotangent operation, returned as a complex number.", "fields": [{"name": "re", "type": "REAL", "description": "The real part of the hyperbolic cotangent result."}, {"name": "im", "type": "REAL", "description": "The imaginary part of the hyperbolic cotangent result."}]}}
{"title": "Character to String Conversion", "description": "CHR_TO_STRING forms a ASCII characters from a byte and returns it as a\none-character string.", "type": "FUNCTION", "name": "CHR_TO_STRING", "input": [{"name": "C", "type": "BYTE", "description": "The byte value representing a character that needs to be converted to a string."}], "output": [], "in/out": [], "return_value": {"type": "string", "description": "Returns the string representation of the input character, properly null-terminated."}}
{"title": "String to Byte Conversion", "description": "FSTRING_TO_BYTE converts a formatted string into a byte value. It sup￾ports following input formats:\n2#0101 (binary), 8#345 (octal), 16#2a33 (hexadecimal) and 234 (deci￾mal).", "type": "FUNCTION", "name": "FSTRING_TO_BYTE", "input": [{"name": "IN", "type": "STRING[12]", "description": "A string representation of a number, which can be in binary, octal, hexadecimal, or decimal format."}], "output": [{"name": "FSTRING_TO_BYTE", "type": "BYTE", "description": "The byte value converted from the input string representation."}], "in/out": [], "return_value": {"type": "BYTE", "description": "The byte result of the conversion based on the provided input string."}}
{"title": "PWM_DC Function Block", "description": "PWM_DC is a Duty - cycle modulated frequency generator. The generator\ngenerates a fxed frequency F with a duty cycle (TON / TOFF) which can be\nmodulated (adjusted) by the input DC. A value of 0.5 at the input DC ge￾nerates a duty cycle of 50%. \nThe following image shows an output signal with a duty - cycle 2 / 1, which\ncorresponds to a DC (ratio) of 0.67.", "type": "FUNCTION_BLOCK", "name": "PWM_DC", "input": [{"name": "F", "type": "REAL", "description": "The frequency of the PWM signal in Hz."}, {"name": "DC", "type": "REAL", "description": "The duty cycle of the PWM signal, specified as a fraction (0.0 to 1.0)."}], "output": [{"name": "Q", "type": "BOOL", "description": "The output state of the PWM signal, where TRUE indicates the pulse is active."}], "in/out": [], "return_value": null}
{"title": "Set Date and Time", "description": "SET_DT calculates a time-date value (DATE_TIME) from the\ninput values, day, month, year, hour, minute and seconds.", "type": "FUNCTION", "name": "SET_DT", "input": [{"name": "year", "type": "INT", "description": "The year to be set."}, {"name": "month", "type": "INT", "description": "The month to be set, ranging from 1 to 12."}, {"name": "day", "type": "INT", "description": "The day of the month to be set."}, {"name": "hour", "type": "INT", "description": "The hour of the day to be set, ranging from 0 to 23."}, {"name": "minute", "type": "INT", "description": "The minute of the hour to be set, ranging from 0 to 59."}, {"name": "second", "type": "INT", "description": "The second of the minute to be set, ranging from 0 to 59."}], "output": [], "in/out": [], "return_value": {"type": "DT", "description": "The date and time represented as a DWORD.", "fields": []}}
{"title": "Clock Divider Function Block", "description": "CLK_DIV is a divider module and devides the input si￾gnal CLK into 8 levels each divided by 2, so that at the output Q0 is half\nthe frequency of the input CLK with 50% duty cycle available. The output\nQ1 is the halved frequency of Q0 available and so on, until at Q7 the input\nfrequency is divided by 256. A reset input RST sets asynchronous all out￾puts to FALSE. CLK is allowed to make only one cycle to TRUE, if CLK does\nnot this, CLK musst provided over TP_R.\n The following example is a test circuit with a start signal via ENI / ENO\nrealized functionality. Figure 2 shows a corresponding trace recording of\nthe circuit:", "type": "FUNCTION_BLOCK", "name": "CLK_DIV", "input": [{"name": "clk", "type": "BOOL", "description": "The clock input signal used to increment the counter."}, {"name": "rst", "type": "BOOL", "description": "The reset input signal that initializes the counter and output states."}], "output": [{"name": "Q0", "type": "BOOL", "description": "The first output bit representing the least significant bit of the counter."}, {"name": "Q1", "type": "BOOL", "description": "The second output bit of the counter."}, {"name": "Q2", "type": "BOOL", "description": "The third output bit of the counter."}, {"name": "Q3", "type": "BOOL", "description": "The fourth output bit of the counter."}, {"name": "Q4", "type": "BOOL", "description": "The fifth output bit of the counter."}, {"name": "Q5", "type": "BOOL", "description": "The sixth output bit of the counter."}, {"name": "Q6", "type": "BOOL", "description": "The seventh output bit of the counter."}, {"name": "Q7", "type": "BOOL", "description": "The eighth output bit representing the most significant bit of the counter."}], "in/out": [], "return_value": null}
{"title": "Buffer Initialization Function", "description": "_BUFFER_INIT initializes any array of Byte with value INIT.\nWhen called, a pointer to the array and its size in bytes is passed to the\nfunction. Under CoDeSys the call reads: _BUFFER_INIT(ADR(Array), SI￾ZEOF(Array), INIT), where array is the name of the array to be manipula￾ted. ADR() is a standard function which identifes the pointer to the array\nand SIZEOF() is a standard function, which determines the size of the ar￾ray. The function only returns TRUE. The array specifed by the pointer is\nmanipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "_BUFFER_INIT", "input": [{"name": "PT", "type": "POINTER TO BYTE", "description": "Pointer to the buffer that needs to be initialized."}, {"name": "SIZE", "type": "UINT", "description": "The size in bytes of the buffer to be initialized."}, {"name": "INIT", "type": "BYTE", "description": "The byte value with which to initialize the buffer."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE upon successful initialization of the buffer."}}
{"title": "Real2 Addition Function", "description": "_BUFFER_INIT initializes any array of Byte with value INIT.\nWhen called, a pointer to the array and its size in bytes is passed to the\nfunction. Under CoDeSys the call reads: _BUFFER_INIT(ADR(Array), SI￾ZEOF(Array), INIT), where array is the name of the array to be manipula￾ted. ADR() is a standard function which identifes the pointer to the array\nand SIZEOF() is a standard function, which determines the size of the ar￾ray. The function only returns TRUE. The array specifed by the pointer is\nmanipulated directly in memory. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "R2_ADD", "input": [{"name": "X", "type": "Real2", "description": "A derived type that contains two real numbers, RX and R1."}, {"name": "Y", "type": "REAL", "description": "A real number that will be added to the components of the Real2 input."}], "output": [{"name": "R2_ADD", "type": "REAL2", "description": "The output structure of type Real2 containing the results of the addition operations."}], "in/out": [], "return_value": {"type": "REAL2", "description": "The resulting Real2 structure after performing the addition.", "fields": [{"name": "RX", "type": "REAL", "description": "The result of adding Y, X.R1, and X.RX."}, {"name": "R1", "type": "REAL", "description": "The result of computing temp minus RX, plus Y, and X.R1."}]}}
{"title": "Langevin Function", "description": "LANGEVIN Function is very similarto sigmoid function, but more\nslowly approaching the limits. In contrast to the sigmoid are the values at\n-1 and +1. The Langevin function is mainly at CPUs without foating point\nunit much faster than the Sigmoid function.\nThe following chart shows the progress of the Langevin function:", "type": "FUNCTION", "name": "LANGEVIN", "input": [{"name": "X", "type": "REAL", "description": "Input parameter representing a real number."}], "output": [{"name": "LANGEVIN", "type": "REAL", "description": "The calculated Langevin value based on the input parameter X."}], "in/out": [], "return_value": {"type": "REAL", "description": "Returns the Langevin value, which is a real number calculated based on the input X."}}
{"title": "Find Maximum Value in an Array", "description": "ARRAY_MAX(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the maximum, the array refe￾renced by the pointer is scanned directly in memory. The function\nARRAY_MAX does not change the content of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_MAX", "input": [{"name": "pt", "type": "ARRAY[0..32000] OF REAL", "description": "A pointer to an array of real numbers from which the maximum value is to be found."}, {"name": "size", "type": "UINT", "description": "The number of elements in the array."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The maximum value found in the array.", "fields": []}}
{"title": "Selective Output Block for Three Inputs", "description": "ARRAY_MAX(ADR(Array), SIZEOF(Array)), where array is the name of the\narray to be manipulated. ADR() is a standard function which identifes the\npointer to the array and SIZEOF() is a standard function, which determines\nthe size of the array. In order to determine the maximum, the array refe￾renced by the pointer is scanned directly in memory. The function\nARRAY_MAX does not change the content of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION_BLOCK", "name": "SEL2_OF_3B", "input": [{"name": "IN1", "type": "BOOL", "description": "First boolean input."}, {"name": "IN2", "type": "BOOL", "description": "Second boolean input."}, {"name": "IN3", "type": "BOOL", "description": "Third boolean input."}, {"name": "TD", "type": "TIME", "description": "Time duration for the delay timer."}], "output": [{"name": "Q", "type": "BOOL", "description": "Output boolean indicating the result of the OR logic on the inputs."}, {"name": "W", "type": "BOOL", "description": "Output boolean representing the state of the timer output."}], "in/out": [], "return_value": null}
{"title": "Insert into List Function", "description": "LIST_INSERT puts an element at the position POS in a list. The list consists\nof Strings (elements) that begin with the separation character SEP. The\nfrst element of the list is at position 1. If a position greater than the last\nelement of the list is given, empty elements are added to the list until INS\nis at its normal position at the end of the list. If POS = 0, the new element\nwill be placed to the top of the list.", "type": "FUNCTION", "name": "LIST_INSERT", "input": [{"name": "SEP", "type": "BYTE", "description": "The separator byte used to tokenize the list."}, {"name": "POS", "type": "INT", "description": "The position in the list where the new string should be inserted."}, {"name": "INS", "type": "STRING(LIST_LENGTH)", "description": "The string that will be inserted into the list."}], "output": [], "in/out": [{"name": "LIST", "type": "STRING(LIST_LENGTH)", "description": "The list into which the string will be inserted."}], "return_value": {"type": "BOOL", "description": "Returns TRUE if the string was successfully inserted, otherwise FALSE."}}
{"title": "Convert Octal String to Byte", "description": "OCT_TO_BYTE converts an octal encoded string into a byte\nvalue. Only the octal characters are '0 '..'7' are interpreted, others in HEX\noccurring characters are ignored.", "type": "FUNCTION", "name": "OCT_TO_BYTE", "input": [{"name": "OCT", "type": "STRING[10]", "description": "An octal string consisting of up to 10 characters representing values in the octal numeral system."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "The resulting byte value obtained from converting the octal string.", "fields": []}}
{"title": "AIN Function for Analog Input Conversion", "description": "AIN\nfunction is confgured by setup parameters and calculates the output va￾lues of the A/D converter according to, so that after the AIN module a\nREAL value is available, which corresponds to the real measured value.\nFurthermore, the module can extract and convert a Sign- Bit at any point.\nBy double-clicking on the module, several setup variables can be defned.\nBits defnes how many bits of the input DWORD to be processed. For a 12\nbit converter, this value is 12. Then only the bits 0 - 11 are scored. Sign\ndefnes whether a sign bit is present and where it is found in the input\nword. Sign = 255 means that no sign bit is present and 15 means that bit\n15 in the DWORD contains the sign. The default value for SIGN is 255.\nLOW and HIGH defne the smallest and largest output value. If a Sign- Bit\nis defned ( SIGN < 255), then LOW and HIGH must be positive. Without\nSign- Bit they can be either positive or negative.", "type": "FUNCTION", "name": "AIN", "input": [{"name": "in", "type": "DWORD", "description": "The digital input value to be converted."}, {"name": "Bits", "type": "BYTE", "description": "The number of bits that represent the valid portion of the digital input."}, {"name": "sign", "type": "BYTE", "description": "The position of the sign bit in the input value; defaults to 255 indicating no sign bit."}, {"name": "low", "type": "REAL", "description": "The lower limit of the output range."}, {"name": "high", "type": "REAL", "description": "The upper limit of the output range; defaults to 10.0."}], "output": [{"name": "AIN", "type": "REAL", "description": "The converted real value based on the input and specified parameters."}], "in/out": [], "return_value": {"type": "REAL", "description": "The resulting real value after conversion from the digital input."}}
{"title": "Calculate Sun Midday Time", "description": "SUN_MIDDAY calculates at what time the sun is exactly in the \nsouth, depending on the date . The calculation is done in UTC (Universal \nTime).", "type": "FUNCTION", "name": "SUN_MIDDAY", "input": [{"name": "LON", "type": "REAL", "description": "The longitude in degrees for which the noon time is to be calculated."}, {"name": "UTC", "type": "DATE", "description": "The UTC date based on which the midday time will be computed."}], "output": [{"name": "SUN_MIDDAY", "type": "TOD", "description": "The calculated time of day representing the sun midday for the specified location."}], "in/out": [], "return_value": {"type": "TOD", "description": "The resulting time of day after adjusting for the calculated offset from standard noon.", "fields": []}}
{"title": "Sign Function (SGN)", "description": "SGN calculates the Signum of X. \nSGN = +1 if X > 0\nSGN = 0 if X = 0\nSGN = -1 if X < 0", "type": "FUNCTION", "name": "SGN", "input": [{"name": "X", "type": "REAL", "description": "The real number for which the sign is to be determined."}], "output": [{"name": "SGN", "type": "INT", "description": "The sign of the input number, which will be 1, -1, or 0."}], "in/out": [], "return_value": {"type": "INT", "description": "Returns the sign of the input number as an integer value.", "fields": []}}
{"title": "Scalar Multiplication of a 3D Vector", "description": "SGN calculates the Signum of X. \nSGN = +1 if X > 0\nSGN = 0 if X = 0\nSGN = -1 if X < 0", "type": "FUNCTION", "name": "V3_SMUL", "input": [{"name": "A", "type": "Vector_3", "description": "The 3-dimensional vector that is to be multiplied by the scalar.", "fields": [{"name": "X", "type": "REAL", "description": "The x-component of the vector."}, {"name": "Y", "type": "REAL", "description": "The y-component of the vector."}, {"name": "Z", "type": "REAL", "description": "The z-component of the vector."}]}, {"name": "M", "type": "REAL", "description": "The scalar multiplier to be applied to each component of the vector."}], "output": [{"name": "V3_SMUL", "type": "Vector_3", "description": "The resulting vector after multiplication by the scalar.", "fields": [{"name": "X", "type": "REAL", "description": "The x-component of the resulting vector."}, {"name": "Y", "type": "REAL", "description": "The y-component of the resulting vector."}, {"name": "Z", "type": "REAL", "description": "The z-component of the resulting vector."}]}], "in/out": [], "return_value": {"type": "Vector_3", "description": "The resulting vector formed by multiplying each component of the input vector by the scalar.", "fields": [{"name": "X", "type": "REAL", "description": "The x-component of the resulting vector."}, {"name": "Y", "type": "REAL", "description": "The y-component of the resulting vector."}, {"name": "Z", "type": "REAL", "description": "The z-component of the resulting vector."}]}}
{"title": "Convert Omega to Frequency", "description": "OM_TO_F calculates the frequency in Hz of the angular frequency Omega.", "type": "FUNCTION", "name": "OM_TO_F", "input": [{"name": "OM", "type": "REAL", "description": "The input value representing Omega (angular velocity) in real number format."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The function returns the computed frequency as a real number value.", "fields": []}}
{"title": "DT Simulation Function Block", "description": "DT_SIMU simulates on output DTS a date value that starts with the initial\nvalue of START and continues with the speed SPEED. If SPEED intthe input\nvalue not used, the device operates with the internal standard value 1.0\nand the DTS output is running forward at 1 second/second. With the input\nSPEED at the output DTS an arbitrarily fast or slow clock can be simulated.\nThe module can be used in the simulation environment to simulate an RTC\nand also adjust the speed of the RTC for testing. If the input SPEED = 0,\nthe output DTS at each PLC cycle is further increased by a second.", "type": "FUNCTION_BLOCK", "name": "DT_SIMU", "input": [{"name": "START", "type": "DT", "description": "The starting date and time value for the simulation."}, {"name": "SPEED", "type": "REAL", "description": "The speed factor that modifies the time increment, with a default value of 1.0."}], "output": [{"name": "DTS", "type": "DT", "description": "The updated date and time value after applying the simulation logic."}], "in/out": [], "return_value": null}
{"title": "Standard Deviation Calculation", "description": "ARRAY_SDV calculates the standard deviation (Standard De￾viation) value of an arbitrary array of REAL. When called a pointer to the\narray and its size in bytes is passed to the function. Under CoDeSys the\ncall reads: ARRAY_SDV(ADR(Array), SIZEOF(Array)), where array is the\nname of the array to be manipulated. ADR() is a standard function, which\nidentifes the pointer to the array and SIZEOF() is a standard function,\nwhich determines the size of the array. In order to determine the maxi￾mum, the array referenced by the pointer is scanned directly in memory.\nThe function ARRAY_SDV does not change the contents of the array. \nThis type of processing arrays is very efcient because no additional me￾mory is required and no surrender values must be copied.", "type": "FUNCTION", "name": "ARRAY_SDV", "input": [{"name": "pt", "type": "POINTER TO ARRAY[0..32000] OF REAL", "description": "A pointer to an array of real numbers whose standard deviation is to be calculated."}, {"name": "size", "type": "UINT", "description": "The size of the array, indicating the number of elements in the input array."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated standard deviation of the input array of real numbers."}}
{"title": "Temperature Conversion", "description": "TEMPERATURE converts diferent, in practice common used units for\ntemperature. Normally, only the input to be converted is occupied and the\nremaining inputs remain free. However, if several inputs loaded with va￾lues, the values of all inputs are converted accordingly and then summed.\n1 K = 273.15 °C\n1 °C = 273.15 K\n1 °F = °C * 1.8 + 32\n1 Re = °C * 0.8\n1 Ra = K * 1.8\n23. Control Modules", "type": "FUNCTION_BLOCK", "name": "TEMPERATURE", "input": [{"name": "K", "type": "REAL", "description": "Input temperature in Kelvin."}, {"name": "C", "type": "REAL", "description": "Celsius conversion base value, initialized to -273.15."}, {"name": "F", "type": "REAL", "description": "Fahrenheit conversion base value, initialized to -459.67."}, {"name": "Re", "type": "REAL", "description": "Réaumur conversion base value, initialized to -218.52."}, {"name": "Ra", "type": "REAL", "description": "Rankine value to be converted."}], "output": [{"name": "YK", "type": "REAL", "description": "Converted temperature in Kelvin."}, {"name": "YC", "type": "REAL", "description": "Converted temperature in Celsius."}, {"name": "YF", "type": "REAL", "description": "Converted temperature in Fahrenheit."}, {"name": "YRe", "type": "REAL", "description": "Converted temperature in Réaumur."}, {"name": "YRa", "type": "REAL", "description": "Converted temperature in Rankine."}], "in/out": [], "return_value": null}
{"title": "Calculate the Inverse Hyperbolic Cotangent", "description": "ACOTH calculates the arc cotangent hyperbolic with following formula:", "type": "FUNCTION", "name": "ACOTH", "input": [{"name": "X", "type": "REAL", "description": "The input value for which the inverse hyperbolic cotangent is to be calculated."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated inverse hyperbolic cotangent of the input value X."}}
{"title": "Extract Specific Word from DWORD", "description": "WORD_OF_DWORD extracts a word (W0 .. W1) from a DWORD.\n 17. Latches, Flip-Flop and Shift Register", "type": "FUNCTION", "name": "WORD_OF_DWORD", "input": [{"name": "in", "type": "DWORD", "description": "The input DWORD from which the WORD will be extracted."}, {"name": "N", "type": "BYTE", "description": "The index of the WORD to extract from the DWORD, where N specifies which 16-bit segment to retrieve."}], "output": [{"name": "WORD_OF_DWORD", "type": "WORD", "description": "The output WORD extracted from the input DWORD at the specified index N."}], "in/out": [], "return_value": {"type": "WORD", "description": "The extracted 16-bit unsigned integer (WORD) from the input DWORD.", "fields": []}}
{"title": "Interlock Function Block", "description": "INTERLOCK has 2 inputs I1 and I2 which passes to each of the\noutputs Q1 and Q2. Q1 and Q2, however, are interlocked so that only one\noutput is set to TRUE. The time TL sets a dead time between the two out￾puts. An output can only be true if the other output was at least for the\ntime TL FALSE.\nI1 I2 Q1 Q2\n0 0 0 0\n0 1 0 1\n1 0 1 0\n1 1 0 0", "type": "FUNCTION_BLOCK", "name": "INTERLOCK", "input": [{"name": "I1", "type": "BOOL", "description": "First input signal."}, {"name": "I2", "type": "BOOL", "description": "Second input signal."}, {"name": "TL", "type": "TIME", "description": "Time delay for the interlock mechanism."}], "output": [{"name": "Q1", "type": "BOOL", "description": "Output signal 1, reflects the state of I1 considering the delay of I2."}, {"name": "Q2", "type": "BOOL", "description": "Output signal 2, reflects the state of I2 considering the delay of I1."}], "in/out": [], "return_value": null}
{"title": "PID Controller Function Block", "description": "FT_PIDW is a PID controller with Anti Wind- Up Hold works according to the\nfollowing formula: \nY = KP * ( IN + 1/TN * INTEG(IN) + TV *DERIV(IN))\nThe control parameters are given in the form of KP, TN and TV, and if the￾re are parameters KP, KI and KD they can be converted using the following\nformula:\nTN = KP/KI und TV = KD/KP\nThe input values LIM_H and LIM_L limit the range of the output Y. With\nRST, the internal Integrator can always be set to 0. The output LIM indica￾tes that the Output Y runs to one of the limits LIM_L orL IM_H. The PI con￾troller is free running and uses the trapezoidal rule to calculate the inte￾grator for the highest accuracy and optimal speed. The default values of\nthe input parameters are predefned as follows: KP = 1, TN = 1s, TV = 1s,\nILIM_L =-1E38 and ILIM_H = +1 E38.\n Anti Wind-Up: Control modules with Integrator tend to the so-called Wind￾Up Efect. A Wind-Up means that the integrator module continuously run\nagain because, for example, the control signal Y is at a limit and the sys￾tem can not compensate the deviation, which then leads to subsequent\ntransition into the control range until a long and time-consuming dismant￾ling of the integrator value and the scheme only respond delayed. Since\nthe integrator is only necessary to compensate the deviation for all other\ncontrol units, and the range of the integrator should be limited with the\nvalues of ILIM.\nThe module FT_PIDW has a so-called Wind-Up-Hold which freezes the inte￾grator after reaching for an output limit (LIM_L, LIM_H) on the last value\nand thus a Wind-Up prevents. \nThe following graph illustrates the internal structure of the controller:\nFT_PD can be used in conjunction with the modules CTRL_IN and\nCTRL_OUT to establish a PD controller.", "type": "FUNCTION_BLOCK", "name": "FT_PIDW", "input": [{"name": "IN", "type": "REAL", "description": "The input process variable that the PID controller will process."}, {"name": "KP", "type": "REAL", "description": "The proportional gain of the PID controller, defaults to 1.0."}, {"name": "TN", "type": "REAL", "description": "The integral time constant of the PID controller, defaults to 1.0."}, {"name": "TV", "type": "REAL", "description": "The derivative time constant of the PID controller, defaults to 1.0."}, {"name": "LIM_L", "type": "REAL", "description": "The lower limit for the output, defaults to -1E+38."}, {"name": "LIM_H", "type": "REAL", "description": "The upper limit for the output, defaults to 1E+38."}, {"name": "RST", "type": "BOOL", "description": "A reset flag that when true resets the integral component of the controller."}], "output": [{"name": "Y", "type": "REAL", "description": "The calculated control output of the PID controller."}, {"name": "LIM", "type": "BOOL", "description": "A flag indicating whether the output is within the defined limits."}], "in/out": [], "return_value": null}
{"title": "Date and Time Formatting Function", "description": "DT_TO_STRF converts a DATETIME value into a formated string. At the in￾put DTI the convertible DATETIME value appears and with the string FMT\nthe appropriate output format is determined. The input LANG determines\nthe language to be used (0 = LANGUAGE_DEFAULT, 1 = English and 2 =\nGerman). The language settings are made in the relevant paragraph of\nthe global constants and can be adapted or modifed. In addition to the\ndate and time at the input of MS also milliseconds can be processed. \nThe generated string matches the string FMT where in the string all cha￾racters '#' followed by a capital letter are replaced with the corresponding\nvalue. The following table defnes the format characters:\n#A 4 digit year number (2008)\n#B 2-digit year number, eg (08)\n#C Month 1-2 digits (1,12)\n#D Month 2 digits (1, 12)\n#E Month 3 letters (Jan)\n#F Months written out (January)\n#G Day 1 or 2 digits (1, 31)\n#H Day 2-digit (01, 31)\n#I Week as a number (1 = Monday, 7 = Sunday)\n#J Week 2 letters (Mo)\n#K Week written out (Monday)\n#L AM or PM in American date formats\n#M Hour in 24 hour format 1-2 digits (0, 23)\n#N Hour in 24 hour format 2 digits (00, 23)\n#O Hours in 12 hours Format 1 - 2 digits (1, 12)\n# P Hour in 12 hour format 2 digits (01, 12)\n#Q Minutes 1-2 digits (0, 59)\n#R Minutes 2 digits (00, 59)\n#S Seconds 1-2 digits (0, 59)\n#T Seconds 2 digits (00, 59)\n#U Milliseconds 1-3 digits (0, 999)\n#V Milliseconds 3 digits (000, 999)\n#W Day 2 digits but pre-padded with blank (' a' .. '31 ')\n#X Month 2 digits but pre- padded with blank (' 1' .. '12 ')", "type": "FUNCTION", "name": "DT_TO_STRF", "input": [{"name": "DTI", "type": "TIME_DT", "description": "Date and Time Input representing the DateTime value to format."}, {"name": "MS", "type": "INT", "description": "Additional Integer Input specifying milliseconds."}, {"name": "FMT", "type": "STRING", "description": "Format String Input that defines the desired output format for the DateTime."}, {"name": "LANG", "type": "INT", "description": "Language Input that specifies the language for formatting the output."}], "output": [{"name": "DT_TO_STRF", "type": "string", "description": "Formatted string representation of the DateTime based on the input format and language."}], "in/out": [], "return_value": {"type": "string", "description": "The formatted string output of the function.", "fields": []}}
{"title": "Random Duty Cycle Generator", "description": "GEN_RDM is a random signal generator. It generates the output OUT a\nnew value in PT intervals. The output Q is TRUE for one cycle when the\noutput OUT has changed. The input AM and OS set the amplitude and the\nofset for the output OUT. If the inputs OS and AM are not connected, then\nthe default values are 0 and .\nThe following example shows a trace recording of the input values PT =\n100ms, AM = 10 and OS = 5. The output values generated every 100 ms\nin the range of 0 .. 10.", "type": "FUNCTION_BLOCK", "name": "GEN_RDM", "input": [{"name": "PT", "type": "TIME", "description": "The time period for the duty cycle generation."}, {"name": "AM", "type": "REAL", "description": "The amplitude factor that scales the random signal, default value is 1."}, {"name": "OS", "type": "REAL", "description": "The offset added to the generated random signal."}], "output": [{"name": "Q", "type": "BOOL", "description": "A boolean output indicating whether the output signal is active."}, {"name": "Out", "type": "REAL", "description": "The generated output signal based on the random duty cycle."}], "in/out": [], "return_value": null}
{"title": "String Truncation and Padding Function", "description": "FIX creates a string of fxed length N. The string STR at the input is trunca￾ted to the length N respective flled with the fll character C. If the string\nSTR is shorter than the length L to be created, will the string be flled de￾pending on M, with the fll character C. If M = 0, the padding at the end of\nthe string is appended, if M = 1, the padding is attached the beginning\nand when M = 2, the string is centered between fll character. If the num￾ber of the necessary padding is odd and if M = 2, the fll at the end has a\nfll character more than at the beginning. The FIX function evaluates the\nGlobal Setup string_length constant and limits the maximum length L of\nthe string to string_length.", "type": "FUNCTION", "name": "FIX", "input": [{"name": "str", "type": "STRING[STRING_LENGTH]", "description": "The input string that needs to be modified."}, {"name": "L", "type": "INT", "description": "The length to which the string should be truncated or padded."}, {"name": "C", "type": "BYTE", "description": "The character used for padding the string."}, {"name": "M", "type": "INT", "description": "The mode for string modification: 1 for left truncate/pad, 2 for center pad."}], "output": [{"name": "FIX", "type": "string", "description": "The modified string after truncation and/or padding."}], "in/out": [], "return_value": {"type": "string", "description": "Returns the modified string after performing the specified operations."}}
{"title": "Hour Extraction from DateTime", "description": "HOUR_OF_DT extracts the hour from a current DT value.\nHOUR_OF_DT(DT#2008-6-6-10:22:20) = 10", "type": "FUNCTION", "name": "HOUR_OF_DT", "input": [{"name": "XDT", "type": "DT", "description": "A DateTime value from which the hour will be extracted."}], "output": [], "in/out": [], "return_value": {"type": "INT", "description": "An integer representing the hour part of the given DateTime value, in the range of 0 to 23."}}
{"title": "Bit Load Function", "description": "HOUR_OF_DT extracts the hour from a current DT value.\nHOUR_OF_DT(DT#2008-6-6-10:22:20) = 10", "type": "FUNCTION", "name": "BIT_LOAD_B2", "input": [{"name": "I", "type": "BYTE", "description": "The BYTE value to manipulate."}, {"name": "D", "type": "BOOL", "description": "Condition to determine which operation to perform."}, {"name": "P", "type": "INT", "description": "The number of bit positions to shift in the operations."}, {"name": "N", "type": "INT", "description": "The number of bits to be loaded or shifted."}], "output": [{"name": "BIT_LOAD_B2", "type": "BYTE", "description": "The resulting BYTE value after performing the bitwise operations."}], "in/out": [], "return_value": {"type": "BYTE", "description": "Computed BYTE value after bit manipulation based on inputs.", "fields": []}}
{"title": "Finite Time Derivative Calculation", "description": "FT_DERIV is a D-link, or LZI-transfer element, which has a diferentiating\ntransfer behavior. At the output of FT_DERIV the derivative is over time T\nin seconds. When the input signal increases in one second from 3 to 4\nthen the output 1 * K (K *  X /  T = 1 * (4-3) / 1 = 1\nIn other words, the derivative of the input signal, the instantaneous slope\nof the input signal. With the input RUN the FT_DERIV can be enabled or di￾sabled. FT_DERIV works internally in microseconds and fulfll also the re￾quirements of very fast PLC controller with cycle times under a millise￾cond.\nStructure diagram:", "type": "FUNCTION_BLOCK", "name": "FT_DERIV", "input": [{"name": "in", "type": "REAL", "description": "Current input value to be differentiated."}, {"name": "K", "type": "REAL", "description": "Scaling factor for the derivative calculation, default is 1.0."}, {"name": "run", "type": "BOOL", "description": "Boolean to indicate if the calculation should be performed, default is TRUE."}], "output": [{"name": "out", "type": "REAL", "description": "Calculated derivative value based on the input."}], "in/out": [], "return_value": null}
{"title": "Calculate Volume of a Sphere", "description": "SPHERE_V calculates the volume of a sphere with a radius of RX.", "type": "FUNCTION", "name": "SPHERE_V", "input": [{"name": "rx", "type": "REAL", "description": "The radius of the sphere."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated volume of the sphere."}}
{"title": "Sample High-Low Average Calculation", "description": "SPHERE_V calculates the volume of a sphere with a radius of RX.", "type": "FUNCTION_BLOCK", "name": "SH_2", "input": [{"name": "in", "type": "REAL", "description": "The input value to be sampled for calculations."}, {"name": "PT", "type": "TIME", "description": "The time period for triggering the sample calculations."}, {"name": "N", "type": "INT", "description": "The number of samples to consider for the average and high/low calculations. Default value is 16."}, {"name": "disc", "type": "INT", "description": "The disc value used in determining the sampling range."}], "output": [{"name": "out", "type": "REAL", "description": "The most recent input value that has been sampled."}, {"name": "trig", "type": "BOOL", "description": "Indicates whether the sampling trigger has occurred."}, {"name": "avg", "type": "REAL", "description": "The average value computed from the sampled inputs."}, {"name": "high", "type": "REAL", "description": "The highest value among the sampled inputs."}, {"name": "low", "type": "REAL", "description": "The lowest value among the sampled inputs."}], "in/out": [], "return_value": null}
{"title": "SH_T Function Block", "description": "SH_T is a transparent Sample and Hold module. The input signal is provi￾ded at the output, as long as E is TRUE. With a falling edge of E, the value\nstored in the output OUT and will stay here until E return TRUE, and thus is\nswitched back to OUT. \nThe following example illustrates the operation of SH_T", "type": "FUNCTION_BLOCK", "name": "SH_T", "input": [{"name": "IN", "type": "REAL", "description": "The input value that will be passed to the output when enabled."}, {"name": "E", "type": "BOOL", "description": "The enable signal that determines whether the input is passed to the output."}], "output": [{"name": "OUT", "type": "REAL", "description": "The output value that reflects the input value when enabled."}], "in/out": [], "return_value": null}
{"title": "Bitwise Load with Rotation", "description": "SH_T is a transparent Sample and Hold module. The input signal is provi￾ded at the output, as long as E is TRUE. With a falling edge of E, the value\nstored in the output OUT and will stay here until E return TRUE, and thus is\nswitched back to OUT. \nThe following example illustrates the operation of SH_T", "type": "FUNCTION", "name": "BIT_LOAD_DW2", "input": [{"name": "I", "type": "DWORD", "description": "The input DWORD value to be manipulated."}, {"name": "D", "type": "BOOL", "description": "A boolean flag to determine the operation mode: TRUE for rotation left, FALSE for mask application."}, {"name": "P", "type": "INT", "description": "The number of bit positions to rotate or shift."}, {"name": "N", "type": "INT", "description": "The number of bits to be shifted left or right from the maximum DWORD value."}], "output": [{"name": "BIT_LOAD_DW2", "type": "DWORD", "description": "The resulting DWORD value after the bitwise load operation."}], "in/out": [], "return_value": {"type": "DWORD", "description": "The value obtained from the bit manipulation operations, as specified by the input parameters."}}
{"title": "Dead Zone Function", "description": "DEAD_ZONE is a linear transfer function with dead zone. The output equals \nthe input signal when the absolute value of the input is greater than L.\nDEAD_ZONE = X if ABS(X) > L \nDEAD_ZONE = 0 if ABS(X) <= L", "type": "FUNCTION", "name": "DEAD_ZONE", "input": [{"name": "X", "type": "REAL", "description": "Input variable X of type REAL which is evaluated against the threshold L."}, {"name": "L", "type": "REAL", "description": "Input variable L of type REAL which serves as the threshold for the dead zone."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the dead zone calculation, which is either the value of X if |X| > L or 0.0 if |X| <= L."}}
{"title": "Time Check Function", "description": "DEAD_ZONE is a linear transfer function with dead zone. The output equals \nthe input signal when the absolute value of the input is greater than L.\nDEAD_ZONE = X if ABS(X) > L \nDEAD_ZONE = 0 if ABS(X) <= L", "type": "FUNCTION", "name": "TIMECHECK", "input": [{"name": "TD", "type": "TOD", "description": "The time of day to check against the range."}, {"name": "START", "type": "TOD", "description": "The start time of the range."}, {"name": "STOP", "type": "TOD", "description": "The stop time of the range."}], "output": [{"name": "TIMECHECK", "type": "BOOL", "description": "Returns TRUE if TD falls within the time range; otherwise, returns FALSE."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Indicates the result of the time check operation.", "fields": []}}
{"title": "GDF Function Calculation", "description": "GDF calculate the Gundermann function.\nThe calculation is done using the formula:\nThe result of GDF is between -π/2 and + π/2\nGDF(0) = 0", "type": "FUNCTION", "name": "GDF", "input": [{"name": "X", "type": "REAL", "description": "Input parameter representing a real number which will influence the output based on defined conditions."}], "output": [{"name": "GDF", "type": "REAL", "description": "Output parameter which is a real number calculated based on the value of the input parameter X."}], "in/out": [], "return_value": {"type": "REAL", "description": "The calculated result based on the input parameter X according to specific conditional logic."}}
{"title": "Flow Meter Function Block", "description": "FLOW_METER determines the fow rate per unit of\ntime and count quantities. FLOW_METER determines the fow rate from the\ninput VX and E. The module supports two operating modes are determined\nby the variable setup PULSE_MODE. If PULSE_MODE = TRUE is the volume\nfow and the amount determined by is added at each rising edge at E, the\nvalue of VX upon itself. If the PULSE_MODE = FALSE the input VX is inter￾preted as fow per unit time and is added up as long as E = TRUE. Using\nthe input RST, the internal counter can be always set to zero. X and Y are\nexternal to be declared variables and can be declared retentive / perma￾nent to be permanent in case of power failure. The module provides the\ninstantaneous fow value F as the Real in accordance to the unit connec￾ted to VX. If a value at VX is applied eg. in liters / hour so is the measured\nvalue at the output F in l / h. The output F is set at the constant intervals\nUPDATE_TIME. The outputs X and Y make up the over time accumulated\nmeasure values where X in REAL represent in the decimal point and Y in\nUDINT the integer part. A count of 234.111234 is represented by 0.111234\nat X and a value of 234 at Y. If for count only a REAL is used then the reso￾lution (for Real to IEEE32), is only 7-8 position . The above described me￾thod can provide more than 9 digits before the decimal point (2^32-1) and\nat least 7 digits after the decimal point. Since in this case X is always\nsmaller than 1, Y can be used for output without decimal places. The two\nvariables X and Y must be declared external and can, as the following ex￾ample, also be secured against power failure.", "type": "FUNCTION_BLOCK", "name": "FLOW_METER", "input": [{"name": "VX", "type": "REAL", "description": "Input velocity for flow calculation."}, {"name": "E", "type": "BOOL", "description": "Enable signal for the flow measurement."}, {"name": "RST", "type": "BOOL", "description": "Reset signal to initialize flow measurement parameters."}, {"name": "PULSE_MODE", "type": "BOOL", "description": "Flag to indicate if the flow meter is operating in pulse mode."}, {"name": "UPDATE_TIME", "type": "TIME", "description": "Time interval for updating flow calculation. Default is 1 second."}], "output": [{"name": "F", "type": "REAL", "description": "Calculated flow rate based on input parameters."}], "in/out": [{"name": "X", "type": "REAL", "description": "Current flow measurement value."}, {"name": "Y", "type": "UDINT", "description": "Counter for flow measurements, incremented based on calculated results."}], "return_value": null}
{"title": "Complex Addition Function", "description": "CADD adds two complex numbers X and Y.", "type": "FUNCTION", "name": "CADD", "input": [{"name": "X", "type": "complex", "description": "The first complex number to be added."}, {"name": "Y", "type": "complex", "description": "The second complex number to be added."}], "output": [], "in/out": [], "return_value": {"type": "complex", "description": "The resulting complex number obtained from the addition of X and Y.", "fields": [{"name": "re", "type": "real", "description": "The real part of the resulting complex number."}, {"name": "im", "type": "real", "description": "The imaginary part of the resulting complex number."}]}}
{"title": "Calculate Circle Segment Area", "description": "CIRCLE_SEG calculates the area of a\ncircle segment is enclosed by a Sektantli￾nie and the circle.", "type": "FUNCTION", "name": "CIRCLE_SEG", "input": [{"name": "RX", "type": "REAL", "description": "The radius of the circle."}, {"name": "HX", "type": "REAL", "description": "The height of the circle segment."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The area of the circle segment calculated using the provided radius and height."}}
{"title": "Power Calculation Function", "description": "F_POWER = A * X^N)\nF_Power calculate the power function according to the equation F_POWER\n= A * Xn .", "type": "FUNCTION", "name": "F_POWER", "input": [{"name": "a", "type": "REAL", "description": "The coefficient to multiply with the result of the exponentiation."}, {"name": "x", "type": "REAL", "description": "The base value which will be raised to the power of n."}, {"name": "n", "type": "REAL", "description": "The exponent value to which the base x will be raised."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The result of the calculation, which is the coefficient multiplied by the base raised to the exponent.", "fields": []}}
{"title": "Polynomial Evaluation Function", "description": "F_POLY calculates a polynomial of 7th degree.\nF_POLY = C[0] + C[1] * X^1 + C[2] * X^2 + ...C[7] * X^7", "type": "FUNCTION", "name": "F_POLY", "input": [{"name": "X", "type": "REAL", "description": "The input value at which the polynomial is to be evaluated."}, {"name": "C", "type": "ARRAY[0..7] OF REAL", "description": "An array of coefficients for the polynomial, where each index corresponds to the coefficient for X to the power of the index."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The resulting value of the polynomial evaluated at X."}}
{"title": "Calculate Beginning of Year Date", "description": "YEAR_BEGIN calculate the date of the frst January for the year Y.", "type": "FUNCTION", "name": "YEAR_BEGIN", "input": [{"name": "y", "type": "INT", "description": "The year for which to calculate the beginning date."}], "output": [{"name": "YEAR_BEGIN", "type": "DATE", "description": "The date representing the beginning of the specified year."}], "in/out": [], "return_value": {"type": "DATE", "description": "The calculated beginning date of the year based on the provided input year."}}
{"title": "Easter Date Calculation", "description": "EASTER calculates for a given year, the date of Easter Sun￾day. Most religious holidays have a fxed distance from Easter, so that in\nthe case that Easter is known for a year, these holidays can also be deter￾mined easily. EASTER is also used in the module HOLIDAY to calculate holi￾days.", "type": "FUNCTION", "name": "EASTER", "input": [{"name": "year", "type": "INT", "description": "The year for which the Easter date should be calculated, provided as an integer."}], "output": [{"name": "EASTER", "type": "DATE", "description": "The calculated date of Easter Sunday for the specified year."}], "in/out": [], "return_value": {"type": "DATE", "description": "The calculated date of Easter Sunday for the year input.", "fields": []}}
{"title": "Multiplexer Function", "description": "EASTER calculates for a given year, the date of Easter Sun￾day. Most religious holidays have a fxed distance from Easter, so that in\nthe case that Easter is known for a year, these holidays can also be deter￾mined easily. EASTER is also used in the module HOLIDAY to calculate holi￾days.", "type": "FUNCTION", "name": "MUX_R2", "input": [{"name": "IN0", "type": "REAL", "description": "First input value to be selected from."}, {"name": "IN1", "type": "REAL", "description": "Second input value to be selected from."}, {"name": "A", "type": "BOOL", "description": "Boolean selector that determines which input value to return."}], "output": [], "in/out": [], "return_value": {"type": "REAL", "description": "The selected input value based on the condition provided by 'A'."}}
{"title": "Toggle Bit in Word", "description": "BIT_TOGGLE_W inverts a specifed bit POS at IN.\nBIT_TOGGLE_W(2#0000_1111, 2) = 2#0000_1011\nBIT_TOGGLE_W(2#0000_1111, 7) = 2#1000_1111", "type": "FUNCTION", "name": "BIT_TOGGLE_W", "input": [{"name": "IN", "type": "WORD", "description": "The WORD input value whose specific bit is to be toggled."}, {"name": "POS", "type": "INT", "description": "The position of the bit to be toggled, where 0 represents the least significant bit."}], "output": [], "in/out": [], "return_value": {"type": "WORD", "description": "The resulting WORD after toggling the specified bit.", "fields": []}}
{"title": "Read and Compute Data with Bit Manipulation", "description": "RDMDW charges pseudo - random number with 32 bits in length in the for￾mat DWORD. This is the PLC's internal timer that is read and is transferred\ninto a pseudo random number. Since RDMDW as a function and was not\nwritten as a function module, it can not save data between 2 calls and\nshould therefore be used with caution. If RDMDW called only once per cy￾cle, it produces reasonable good results. But when it is repeatedly called\nwithin a cycle, it delivers the same number, most likely because of the PLC\ntimer is still on the same value. If the function is repeatedly used within a\ncycle, so it must be passed with each call a diferent number of starts\n(LAST). If it be called only once per cycle, it is sufcient to call RDMDW(0).\nAs a starting number for each call, the last number accounted by RDMDW\nbe used. That result from RDMDW is a random 32-bit wide bit pattern.", "type": "FUNCTION", "name": "RDMDW", "input": [{"name": "last", "type": "DWORD", "description": "The DWORD value used for bit counting and subsequent mathematical operations."}], "output": [{"name": "RDMDW", "type": "DWORD", "description": "The resulting DWORD after applying bit manipulation and mathematical computations based on the input value."}], "in/out": [], "return_value": {"type": "DWORD", "description": "The final computed DWORD value returned from the function."}}
