FUNCTION_BLOCK CALENDAR_CALC
VAR_INPUT
    SPE : BOOL;
    H : REAL := -0.83333333333;
END_VAR

VAR_IN_OUT
    XCAL : CALENDAR;
    HOLIDAYS : ARRAY[0..29] OF HOLIDAY_DATA;
END_VAR

VAR
    last : DT;
    last_day : DINT;
    holy : HOLIDAY;
    sun : SUN_TIME;
    last_hour : INT;
    utod : TOD;
    pos : SUN_POS;
    plast : DT;
END_VAR

VAR_TEMP
    dtemp : DINT;
    tmp : INT;
END_VAR
IF xcal.UTC <> last THEN
	(* run once per second *)
	(* update utc last calculated  *)
	last := XCAL.UTC;
	utod := DT_TO_TOD(xcal.UTC);

	(* calculate ltc from utc *)
	XCAL.LOCAL_DT := UTC_TO_LTIME(XCAL.UTC, XCAL.DST_EN, XCAL.OFFSET);
	XCAL.LOCAL_DATE := DT_TO_DATE(XCAL.LOCAL_DT);
	XCAL.LOCAL_TOD := DT_TO_TOD(XCAL.LOCAL_DT);
	dtemp := DAY_OF_DATE(XCAL.LOCAL_DATE);
	xcal.night := XCAL.LOCAL_TOD < XCAL.SUN_RISE OR XCAL.LOCAL_TOD > XCAL.SUN_SET;

	(* run once per hour *)
	tmp := HOUR(xcal.LOCAL_TOD);
	IF  tmp <> last_hour THEN
		XCAL.DST_ON := DST(XCAL.UTC) AND xcal.DST_EN;
		last_hour := tmp;
	END_IF;

	(* run once per day *)
	IF dtemp <> last_day THEN
		last_day := dtemp;
		(* a new day has started, recalculate daily events *)
		XCAL.YEAR := YEAR_OF_DATE(XCAL.LOCAL_DATE);
		XCAL.MONTH := MONTH_OF_DATE(XCAL.LOCAL_DATE);
		XCAL.DAY := DAY_OF_MONTH(XCAL.LOCAL_DATE);
		XCAL.WEEKDAY := DAY_OF_WEEK(XCAL.LOCAL_DATE);
		HOLY(date_in := XCAL.LOCAL_DATE, LANGU := xcal.LANGUAGE, HOLIDAYS := HOLIDAYS);
		XCAL.HOLIDAY := HOLY.Y;
		XCAL.HOLY_NAME := HOLY.NAME;
		sun(latitude := XCAL.LATITUDE, longitude := xcal.LONGITUDE, utc := DT_TO_DATE(xcal.UTC), H := H);
		XCAL.SUN_RISE := DINT_TO_TOD(TOD_TO_DINT(sun.sun_rise) + XCAL.OFFSET * 60000 + SEL(XCAL.DST_ON,DINT#0,3600000));
		XCAL.SUN_SET := DINT_TO_TOD(TOD_TO_DINT(sun.sun_set) + XCAL.OFFSET * 60000 + SEL(XCAL.DST_ON,DINT#0,3600000));
		XCAL.SUN_MIDDAY := DINT_TO_TOD(TOD_TO_DINT(sun.MIDDAY) + XCAL.OFFSET * 60000 + SEL(XCAL.DST_ON,DINT#0,3600000));
		XCAL.SUN_HEIGTH := sun.sun_declination;
		XCAL.WORK_WEEK := WORK_WEEK(XCAL.LOCAL_DATE);
	END_IF;

	(* calculate the suns position every 10 seconds when SPE = TRUE *)
	IF SPE AND xcal.UTC -  plast >= t#25s THEN
		plast := last;
		pos(latitude := xcal.LATITUDE, longitude := xcal.LONGITUDE, utc := xcal.UTC);
		xcal.SUN_HOR := pos.B;
		xcal.SUN_VER := pos.HR;
	END_IF;
END_IF;



(* revision history

hm 23. oct. 2008	rev 1.0
	original version

hm	8. feb. 2009	rev 1.1
	night was calculated wrong
	added sun position data

hm	10. mar. 2009	rev 1.2
	added work_week, sun_midday, sun_heigth
	sun_position will only be calculated evey 25 seconds
	dst will only become true when dst_en = true

hm	23. jan 2010	rev 1.3
	sun_rise, sun_set and sun_midday are now calculated in local time

hm	18. jan. 2011	rev 1.4
	added input holidays to specify local holidays
	changed call for function sun_time

hm	2. feb. 2011	rev 1.5
	added input H to specify twilight

hm	6. apr. 2011	rev 1.6
	night was calculated wrong

HM 3. Feb 2021    rev 1.7
   chaged LDT >> LOCAL_DT, LDATE >> LOCAL_DT, LTOD >> LOCAL_TOD

*)
END_FUNCTION_BLOCK
