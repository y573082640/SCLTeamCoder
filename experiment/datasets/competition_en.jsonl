{"title": "Special Stack", "description": "Write a function block FB that implements a special stack feature that removes the minimum value from the stack during the pop operation.\n1. Push operation: When a new element is pushed, first check if the stack is full. If the stack is full, do nothing. Otherwise, add it to the top of the stack array and update the top position.\n2. Pop operation: When performing a pop operation, first check if the stack is empty. If the stack is empty, do nothing. Otherwise, remove the minimum value from the stack and return the value of that element, while updating the top position. Status codes:\n16#0000: Execution of FB without error\n16#8A04: The stack is full\n16#8A05: The stack is empty", "type": "FUNCTION_BLOCK", "name": "StackMin", "input": [{"name": "push", "type": "Bool", "description": "Push operation, add an element to the stack if it is not full"}, {"name": "pop", "type": "Bool", "description": "Pop operation, remove the minimum value element from the stack and return its value if the stack is not empty"}, {"name": "reset", "type": "Bool", "description": "Reset operation, the top position of the stack will be reset"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "item", "type": "Int", "description": "The value used to push into the stack or to return from the stack"}, {"name": "stack", "type": "Array[0..3] of Int", "description": "The array used as the stack"}]}
{"title": "Find Maximum and Minimum Values", "description": "Write a function FC that can accept a variable-length array of integers as input and return the maximum and minimum values in the array along with their positions in the array.\n\nExample:\nAssuming the input array is array[1..5]=[5, 10, 2, 25, 1], the function should return the maximum value 25, the minimum value 1, the position of the maximum value 4, and the position of the minimum value 5.", "type": "FUNCTION", "name": "SearchMinMax_DInt", "input": [{"name": "values", "type": "Array[*] of DInt", "description": "The array to be searched"}], "output": [{"name": "minValue", "type": "DInt", "description": "The minimum value in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "The position of the minimum value in the array"}, {"name": "maxValue", "type": "DInt", "description": "The maximum value in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "The position of the maximum value in the array"}]}
{"title": "Multi-Pump Switching Control System", "description": "In an industrial water supply system, there are 5 pumps, each of which can be controlled independently. The system needs to support both manual and automatic operating modes.\nBased on the value of the mode variable, switch to the corresponding operating mode.\nIn manual mode, control the start and stop of the selected pump based on the value of pumpGroup[1..5].selection.\nIn automatic mode, compare the priority of each pump, and automatically select the 3 pumps with higher priority for water supply according to the method of three in use and two on standby.", "type": "FUNCTION_BLOCK", "name": "MultiPumpCtrl", "input": [{"name": "mode", "type": "Bool", "description": "FALSE: Manual mode\nTRUE: Automatic mode"}, {"name": "start", "type": "Bool", "description": "Start button, used to start the manually selected or automatically selected pump"}, {"name": "stop", "type": "Bool", "description": "Stop button, used to stop all pumps"}], "in/out": [{"name": "pumpGroup", "type": "Array[1..5] of Struct", "description": "Pump group control structure", "fields": {"priority": {"type": "Int", "description": "Represents the priority of each pump, the higher the value, the higher the priority"}, "selection": {"type": "Bool", "description": "Whether the pump is selected in manual mode, TRUE=selected"}, "RunComd": {"type": "Bool", "description": "Pump run command, TRUE=run, FALSE=stop"}}}]}
{"title": "Calculate the Day of the Year", "description": "In some automated systems, it may be necessary to calculate the day of the year based on the current date. This can be used for tracking production cycles, maintenance schedules, or other situations that require date information.\nControl Requirements:\nThe system needs to receive date input, including year, month, and day.\nBased on the input date, calculate and output the day of the year.\nConsidering that the number of days in February may vary each year (28 days in a leap year, 29 days in a non-leap year), the system needs to be able to identify leap years and calculate accordingly.\nThe output result should be an integer representing the day of the year.\nIf the input date is invalid (such as February 30th, April 31st, etc.), the system should output an error status and error code.\nNotes:\n1. The input year (Year) must be between 1000 and 3000 (inclusive), otherwise output an error status with error=true and an error code status=16#8001. If the input month (Month) is invalid, output an error status with error=true and an error code status=16#8002. If the input day (Day) is invalid, output an error status with error=true and an error code status=16#8003.\n2. The result of the calculation is output through DayOfYear.", "type": "FUNCTION_BLOCK", "name": "FB_CalculateDayOfYear", "input": [{"name": "Year", "type": "Int", "description": "Year input"}, {"name": "Month", "type": "Int", "description": "Month input"}, {"name": "Day", "type": "Int", "description": "Day input"}], "output": [{"name": "DayOfYear", "type": "Int", "description": "Output the day of the year"}, {"name": "error", "type": "Bool", "description": "Error status indicator\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "Multiple Data Type Selection Sort", "description": "Write a function block FB to implement an ascending order selection sort algorithm. This function block should accept an array of variable length and data types (including Sint, Int, DInt, LInt, Real, LReal, USint, UInt, UDInt, ULint) and write the sorted results back to the original array.\nBased on the program execution results, output the corresponding error status and status code:\n16#0000: No error occurred when executing FB\n16#8A01: The queue seq is not an array type", "type": "FUNCTION_BLOCK", "name": "SelectSort", "input": [{"name": "exe", "type": "Bool", "description": "Start sorting"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred\nTRUE: Error occurred while executing FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "seq", "type": "Variant", "description": "Array to be sorted"}]}
{"title": "Random Number", "description": "Write a function FC that generates a random integer within a specified range using the PLC's clock value.\nIf the specified range is incorrect or there is an error reading the system time, an error status and error code are output.\n\nStatus codes:\n16#0000: Execution of FC without error\n16#8200: Specified range is incorrect: minValue is greater than maxValue\n16#8600: Error reading system time", "type": "FUNCTION", "name": "RandomRange_DInt", "input": [{"name": "minValue", "type": "DInt", "description": "The minimum value of the random number range"}, {"name": "maxValue", "type": "DInt", "description": "The maximum value of the random number range"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FC"}, {"name": "status", "type": "Word", "description": "Status code"}], "return_value": [{"type": "DInt", "description": "The generated random number"}]}
{"title": "Analog Batch Processing", "description": "In industrial automation applications, analog signals usually need to be converted into specific engineering units or ranges. Write a PLC program that can batch read analog input signals and convert them to specified range. The program receives an array of analog value inputs analogValues and an array for channel settings and conversion outputs channels, with the actual total number of channels specified by the input parameter count, starting from the first element of the array. Each channel is started for conversion by enable, and the conversion is performed according to different rules based on the measuringMode. \nWhen measuringMode=0, it is a non-temperature measurement mode: \nThis mode also needs to be converted based on the polarity bipolar, when bipolar=0, it is unipolar, then the analog input value analogValues from 0 to 27648 is linearly mapped to the lower limit loLIM to the upper limit hiLIM of the output value outputFile; when bipolar=1, it is bipolar, then the analog input value analogValues from -27648 to 27648 is linearly mapped to the lower limit loLIM to the upper limit hiLIM of the output value outputFile. \nWhen measuringMode=1, it is a standard temperature measurement mode: \nIn this mode, the output value outputFile is one-tenth of the analog input value analogValues. \nWhen measuringMode=2, it is a climatic temperature measurement mode: \nIn this mode, the output value outputFile is one-hundredth of the analog input value analogValues. \nThe program also requires checking the correctness of the input parameters: \nIf measuringMode is a value other than 0, 1, 2, then retVal=16#8001, and no conversion is performed for this channel; \nIf hiLIM is less than or equal to loLIM, then retVal=16#8002, and no conversion is performed for this channel.", "type": "FUNCTION_BLOCK", "name": "AIConvert", "input": [{"name": "count", "type": "DInt", "description": "Number of channels to be converted"}], "in/out": [{"name": "analogValues", "type": "Array[*] of Int", "description": "Array of analog values for each channel input"}, {"name": "channels", "type": "Array[*] of Struct", "description": "Settings and converted output values for each channel", "fields": [{"name": "enable", "type": "Bool", "description": "Enable conversion for this channel"}, {"name": "hiLIM", "type": "Real", "description": "Upper limit"}, {"name": "loLIM", "type": "Real", "description": "Lower limit"}, {"name": "bipolar", "type": "Bool", "description": "FALSE: Unipolar\nTRUE: Bipolar"}, {"name": "measuringMode", "type": "Int", "description": "0: Non-temperature measurement\n1: Standard temperature measurement\n2: Climatic temperature measurement"}, {"name": "retVal", "type": "Word", "description": "Status information"}, {"name": "outputValue", "type": "Real", "description": "Converted output value"}]}]}
{"title": "Decompose a 16-bit binary number into four 4-bit binary numbers", "description": "In some data processing and communication applications, it is necessary to decompose a 16-bit binary number into four independent 4-bit binary numbers. For example, such decomposition operations may be required during data encoding, decoding, or data exchange with external systems.\nControl requirements:\nThe system needs to receive a 16-bit binary number InputWord as input.\nDecompose the input 16-bit binary number into four 4-bit binary numbers, corresponding to the lowest to the highest bits of the input number.\nOutput these four 4-bit binary numbers to independent variables Byte0~Byte3.\nAt the same time, calculate the average of the non-zero variables among these four variables Byte0~Byte3 and output it to average.\nFor example, if InputWord=16#1203, then Byte0=3, Byte1=0, Byte2=2, Byte3=1, and the average value average=(1+2+3)/3", "type": "FUNCTION_BLOCK", "name": "FB_SplitWordIntoBytes", "input": [{"name": "InputWord", "type": "Word", "description": "16-bit binary number input"}], "output": [{"name": "Byte0", "type": "Byte", "description": "The lowest 4-bit binary number output"}, {"name": "Byte1", "type": "Byte", "description": "The second lowest 4-bit binary number output"}, {"name": "Byte2", "type": "Byte", "description": "The second highest 4-bit binary number output"}, {"name": "Byte3", "type": "Byte", "description": "The highest 4-bit binary number output"}, {"name": "average", "type": "Real", "description": "The average of non-zero bytes among the four bytes"}]}
{"title": "Sorting", "description": "Write a function block FB that implements an optional ascending or descending sorting feature. This function block should accept a variable-length array of integers (with a maximum length of 1000 elements) and a parameter indicating the sorting direction (ascending or descending), and write the sorted results back to the original array. If the array elements exceed 1000 or are less than or equal to 1, the function block should output an error status and an error code. Status codes:\n16#0000: Execution of FB without error\n16#8200: The array has less than or equal to 1 element\n16#8201: The array has more than 1000 elements", "type": "FUNCTION_BLOCK", "name": "ShellSort_DInt", "input": [{"name": "sortDirection", "type": "Bool", "description": "When FALSE, it indicates ascending order; when TRUE, it indicates descending order"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "The array to be sorted"}]}
{"title": "Calculate Moving Average", "description": "Write a function block FB that calculates and updates a moving arithmetic mean. The moving arithmetic mean is a method of averaging over consecutive data points, where each new data point replaces the oldest data point, and then the average is recalculated.\n\n1. When cyclicExecution is TRUE, a new data value is automatically read and the moving average average is updated every scan cycle.\n2. Provide an external trigger signal trigger, which reads a new data value and updates the moving average upon each rising edge.\n3. Provide a reset function reset, which resets the moving average calculation when the reset signal is TRUE. If the window size is less than 1 or greater than 100, output an error status and status code.\n\nThe status parameter indicates the execution status of the program:\n- 16#0000: Execution successful\n- 16#8200: Window length setting error, please set a value between 1 and 100.", "type": "FUNCTION_BLOCK", "name": "FloatingAverage", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "When TRUE, periodic reading is performed, and trigger has no effect"}, {"name": "trigger", "type": "Bool", "description": "External trigger signal, reads value upon each rising edge"}, {"name": "value", "type": "LReal", "description": "Newly read data value"}, {"name": "windowSize", "type": "Int", "description": "The window size for the moving average, which must be between 1 and 100"}, {"name": "reset", "type": "Bool", "description": "Reset signal, resets the moving average calculation when TRUE"}], "output": [{"name": "average", "type": "LReal", "description": "The moving average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached TRUE: Maximum window width has been reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "Automated Filling Line Control", "description": "An automated filling line responsible for cleaning, filling, capping, and packaging bottles. Each step of the production line is controlled by PLC and triggered by signals from sensors and operators.\nControl requirements:\nWhen the sensor bottleSensor detects a bottle, it triggers the start of the cleaning pump and continues to work.\nAfter cleaning is completed, the operator operates the button cleaningConfirmButton to trigger the cleaning completion signal, automatically starting the filling valve for filling.\nAfter filling is completed, the operator operates the button fillingConfirmButton to trigger the filling completion signal, automatically starting the capping machine for capping.\nAfter capping is completed, the operator operates the button cappingConfirmButton to trigger the capping completion signal, starting the packing machine for packaging.\nAfter packaging is completed, the operator operates the button packingConfirmButton to trigger the packaging completion signal, lighting up the packaging completion indicator light.\nAfter the operator picks up the packaged bottle, they press the confirmation button finishedButton to reset the indicator light and prepare for the next bottle's production cycle.", "type": "FUNCTION_BLOCK", "name": "FB_BottleProcessing", "input": [{"name": "bottleSensor", "type": "Bool", "description": "The bottle reaches the sensor, triggering a signal when a bottle is detected"}, {"name": "cleaningConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the cleaning process"}, {"name": "fillingConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the filling process"}, {"name": "cappingConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the capping process"}, {"name": "packingConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the packaging process"}, {"name": "finishedButton", "type": "Bool", "description": "Operator confirmation button, used to confirm that the bottle has been picked up"}], "output": [{"name": "Pump_Motor", "type": "Bool", "description": "Control output for the operation of the cleaning pump motor"}, {"name": "Filling_Valve", "type": "Bool", "description": "Control output for the operation of the filling valve"}, {"name": "Capping_Machine", "type": "Bool", "description": "Control output for the operation of the capping machine"}, {"name": "Packing_Machine", "type": "Bool", "description": "Control output for the operation of the packing machine"}, {"name": "Completion_Light", "type": "Bool", "description": "Indicator light for packaging completion"}]}
{"title": "Material Proportioning Process Control", "description": "Design a PLC program to control a material proportioning process that requires mixing three types of materials according to specific requirements and then delivering them to the next process through valve D. The system needs to support both manual and automatic operation modes and be able to safely stop all equipment when an emergency stop signal is triggered.\nControl requirements:\nEmergency Stop Logic: The #estop(=FALSE) signal is used for emergency stopping of all equipment.\nManual Mode: #opeMode=false, manually control the start/stop of valves A, B, C, D, and the mixing motor.\nAutomatic Mode: #opeMode=true, equipment operates automatically according to the process flow.\nImplement the emergency stop logic to ensure that all equipment stops immediately when the emergency stop signal is triggered.\nIn manual mode, manually control the start/stop of valves and the mixing motor.\nFor example, pressing the valve A start button valveAStart (triggering a rising edge) causes valve A to run (valveARun=TRUE); pressing the valve A start button valveAStart again (triggering a rising edge) stops valve A (valveARun=FALSE).\nIn automatic mode, implement the following control logic based on the process flow:\nPress the autoStart button to start the automatic process, first opening valve A.\nWhen the liquid level sensor #levelSensor reaches 50cm, close valve A and open valve B.\nWhen the liquid level sensor reaches 80cm, close valve B.\nBased on #processMode:\nIf #processMode=false, start the mixing motor; after receiving the mixing complete signal, stop the mixing motor, open valve D, and the automatic process ends.\nIf #processMode=true, open valve C; when the liquid level sensor reaches 100cm, close valve C, start the mixing motor; after receiving the mixing complete signal, stop the mixing motor, open valve D, and the automatic process ends.", "type": "FUNCTION_BLOCK", "name": "MaterialMixing", "input": [{"name": "estop", "type": "Bool", "description": "Emergency Stop Signal\nFALSE: Emergency stop triggered\nTRUE: No emergency stop triggered"}, {"name": "opeMode", "type": "Bool", "description": "Operation Mode\nFALSE: Manual Operation Mode\nTRUE: Automatic Operation Mode"}, {"name": "valveAStart", "type": "Bool", "description": "Valve A Start Button"}, {"name": "valveBStart", "type": "Bool", "description": "Valve B Start Button"}, {"name": "valveCStart", "type": "Bool", "description": "Valve C Start Button"}, {"name": "valveDStart", "type": "Bool", "description": "Valve D Start Button"}, {"name": "mixMotorStart", "type": "Bool", "description": "Mixing Motor Start Button"}, {"name": "autoStart", "type": "Bool", "description": "Automatic Start Button"}, {"name": "processMode", "type": "Bool", "description": "Process Mode"}, {"name": "levelSensor", "type": "Int", "description": "Liquid Level Sensor (unit cm)"}, {"name": "mixMotorComplete", "type": "Bool", "description": "Mixing Complete Signal"}], "output": [{"name": "valveARun", "type": "Bool", "description": "Valve A Run Command"}, {"name": "valveBRun", "type": "Bool", "description": "Valve B Run Command"}, {"name": "valveCRun", "type": "Bool", "description": "Valve C Run Command"}, {"name": "valveDRun", "type": "Bool", "description": "Valve D Run Command"}, {"name": "mixMotorRun", "type": "Bool", "description": "Mixing Motor Run Command"}]}
{"title": "Light Control Program", "description": "Write a function block FB to implement a light control feature.\nA control panel has 3 indicator lights that are controlled by 3 button switches.\n\n1. Input parameters #button1~#button3 represent the 3 button switches, and output parameters #greenLight, #redLight, #yellowLight represent the indicator lights.\n2. When #button1=0, it indicates manual mode, and the indicator lights display different states based on the operation combination of #button2 and #button3:\n   - When both #button2 and #button3 are 0, all indicator lights are off (#greenLight, #redLight, #yellowLight are all 0).\n   - When #button2 is 1 and #button3 is 0, #greenLight is on, and #redLight blinks at a frequency of 0.5Hz, i.e., off for 1 second, on for 1 second.\n   - When #button2 is 0 and #button3 is 1, #redLight is on, and #yellowLight blinks at a frequency of 1Hz, i.e., off for 1 second, on for 1 second.\n   - When both #button2 and #button3 are 1, #yellowLight is on, and #greenLight blinks at a frequency of 1Hz, i.e., off for 1 second, on for 1 second.\n3. When #button1=1, it indicates automatic mode, and the indicator lights automatically cycle through the following sequence:\n   - First, #greenLight is on for 1 second.\n   - Then #greenLight is off, #redLight is on for 1 second.\n   - Then #redLight is off, #yellowLight is on for 1 second.\n   - Then it returns to the initial state where #greenLight is on for 1 second, and the cycle repeats.", "type": "FUNCTION_BLOCK", "name": "LightsControl", "input": [{"name": "button1", "type": "Bool", "description": "Button 1"}, {"name": "button2", "type": "Bool", "description": "Button 2"}, {"name": "button3", "type": "Bool", "description": "Button 3"}], "output": [{"name": "greenLight", "type": "Bool", "description": "Green light"}, {"name": "redLight", "type": "Bool", "description": "Red light"}, {"name": "yellowLight", "type": "Bool", "description": "Yellow light"}]}
{"title": "Parking Space Management System", "description": "Design a PLC program to control the parking management system for a factory's utility cart storage. The garage has 3 rows and 5 columns, totaling 15 parking spaces, which need to implement the control of carts' entry and exit, and allocate and release parking spaces according to specific principles.\nControl requirements:\nParking space information definition: Each parking space has two states, an occupied state (Boolean type) and vehicle data (integer type, vehicle number).\nCart entry rules:\nAllocate parking spaces by using the principle of using the latter row first and then the former row, and using the latter column first and then the former column.\nWhen entering, the cart provides the vehicle number information.\nThe parking space information needs to be updated to the new occupied state and vehicle number.\nCart exit rules:\nRelease parking spaces by the principle of using the former row first and then the latter row, and the former column first and then the latter column.\nThe occupied state of the exit parking space needs to be set to unoccupied and clear the vehicle number.", "type": "FUNCTION_BLOCK", "name": "TruckGarage", "input": [{"name": "enter", "type": "Bool", "description": "Entry operation request"}, {"name": "exit", "type": "Bool", "description": "Exit operation request"}, {"name": "VehicleNumber", "type": "Int", "description": "The vehicle number to be entered"}], "output": [{"name": "truck", "type": "Struct", "description": "The vehicle information to be exited", "fields": {"row": {"type": "Int", "description": "The row position of the vehicle to be exited"}, "col": {"type": "Int", "description": "The column position of the vehicle to be exited"}, "VehicleNumber": {"type": "Int", "description": "The vehicle number to be exited"}}}], "in/out": [{"name": "garage", "type": "Array[1..3, 1..5] of Struct", "description": "Garage information", "fields": {"Occupied": {"type": "Bool", "description": "TRUE: There is a vehicle in the parking space\nFALSE: There is no vehicle in the parking space"}, "VehicleNumber": {"type": "Int", "description": "The vehicle number in the parking space"}}}]}
{"title": "Merge Bytes", "description": "Write a PLC program that receives a variable-length byte array byteArray and a variable-length double word array dwordArray. The goal of the program is to merge each byte from byteArray into dwordArray in sequence. Following the principle of merging every 4 bytes into 1 double word, if the length of byteArray is not a multiple of 4, the remainder part will not be merged. If the length of dwordArray is insufficient to store all double words, the excess part will not be merged. The program also outputs the actual number of merged double words mergeDwordNum\nFor example, byteArray=[16#11, 16#22, 16#33, 16#44], then dwordArray =[16#44332211]", "type": "FUNCTION", "name": "MergeByteArray", "input": [{"name": "byteArray", "type": "Array[*] of Byte", "description": "Byte array to be merged"}], "output": [{"name": "mergeDwordNum", "type": "DInt", "description": "Actual number of merged double words"}], "in/out": [{"name": "dwordArray", "type": "Array[*] of DWord", "description": "Merged double word array"}]}
{"title": "Extracting a substring from a character array", "description": "Write a function FC that can extract a substring from a character array based on a given start string and end string.\n\n1. The function should iterate over searchIn to find the first occurrence of textBefore, then find the subsequent occurrence of textAfter.\n2. If both textBefore and textAfter are found, the function should extract the string between these two boundaries (excluding the boundary strings themselves) and return this substring.\n3. If textBefore or textAfter does not exist in searchIn, the function should return a specific status code.\n\nThe status parameter indicates the execution status of the program:\n- 16#0000: Execution successful\n- 16#8200: The input parameter searchIn is not a character array or byte array\n\nThe return value indicates the result of the search:\n- 16#0000: Search successful, both the head and tail characters have been found\n- 16#9001: Search unsuccessful, only the start boundary was found, the end boundary was not found\n- 16#9002: Search unsuccessful, the start boundary was not found.\n\nExample:\nAssuming searchIn is \"This is a [sample] string with [multiple] boundaries.\", textBefore is \"[\", and textAfter is \"]\". The function should return \"sample\" as the extracted substring.", "type": "FUNCTION", "name": "ExtractStringFromCharArray", "input": [{"name": "textBefore", "type": "String", "description": "The start boundary of the string to be extracted"}, {"name": "textAfter", "type": "String", "description": "The end boundary of the string to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "The extracted string"}, {"name": "status", "type": "Word", "description": "The status code, see description for details"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "The character or byte array in which to search"}], "return_value": [{"type": "Word", "description": "The status code, see description for details"}]}
{"title": "Temperature Logic Control", "description": "Write a function block FB to implement a temperature control logic. The program should include the following functions:\n1. Read the value of the temperature sensor through an analog input module.\n2. Compare the read temperature value TemperatureSensorInput with the set temperature value SetTemperature.\n3. If the actual temperature is lower than the set temperature, start the heater HeaterOutput.\n4. If the actual temperature is higher than the set temperature, turn off the heater HeaterOutput.\n5. If the heater works continuously for more than a certain period (for convenience, using 5s), it should trigger an overheating protection, automatically turn off the heater, and must wait for a certain period (for convenience, using 3s) before the overheating protection can be lifted.\n6. Provide status indication, displaying the current temperature, set temperature, heater status, and whether overheating protection is triggered.\n7. Provide temperature sensor fault judgment, if the read temperature value TemperatureSensorInput is less than 0 or greater than 100, it is considered a sensor fault, and the heater should be turned off.", "type": "FUNCTION_BLOCK", "name": "TempCtrl", "input": [{"name": "TemperatureSensorInput", "type": "Real", "description": "The input value of the temperature sensor, i.e., the actual temperature"}, {"name": "SetTemperature", "type": "Real", "description": "The set temperature value"}], "output": [{"name": "CurrentTemperature", "type": "Real", "description": "Display of the current temperature"}, {"name": "SetTempDisplay", "type": "Real", "description": "Display of the set temperature"}, {"name": "HeaterStatus", "type": "Bool", "description": "Display of the heater status"}, {"name": "OverheatProtection", "type": "Bool", "description": "Display of the overheating protection status"}], "in/out": [{"name": "HeaterOutput", "type": "Bool", "description": "The control output of the heater"}]}
{"title": "Flexible Processing Control", "description": "An automated production line consists of 5 workstations: numbered 1# to 5# from left to right. The 1# station is used for raw material loading, stations 2# to 4# are used for product processing, and the 5# station is used for finished product output and storage.\nThere is a motor in the production line, responsible for moving the product from one workstation to the next. Each workstation has a sensor (used to detect if the product has arrived).\nEach product has a different sequence and number of processing steps, specified by the process sequence 'processSequence'. The processSequence is an array type, storing the sequence numbers of the workstations, and the system automatically sends the raw materials to the corresponding workstation for processing based on the station number.\nControl requirements:\nAt the start of production, when the sensor at the 1# station (sensor1) detects the raw material, the start button at the 1# station (station1Start) is pressed. The system queries the first element of the process sequence 'processSequence', starts the conveyor to move the raw material to the corresponding workstation, and stops after delivery. Upon receiving the processing completion signal from the corresponding workstation (station2Complete to station4Complete), it continues to query the next element of the process sequence 'processSequence', determines the direction of the conveyor, and starts the conveyor (conveyorLeft, conveyorRight). This continues until the product is delivered to the 5# workstation.", "type": "FUNCTION_BLOCK", "name": "FlexibleProduction", "input": [{"name": "sensor1", "type": "Bool", "description": "Sensor at 1# station"}, {"name": "sensor2", "type": "Bool", "description": "Sensor at 2# station"}, {"name": "sensor3", "type": "Bool", "description": "Sensor at 3# station"}, {"name": "sensor4", "type": "Bool", "description": "Sensor at 4# station"}, {"name": "sensor5", "type": "Bool", "description": "Sensor at 5# station"}, {"name": "station1Start", "type": "Bool", "description": "Start button at 1# station"}, {"name": "station2Complete", "type": "Bool", "description": "Processing completion signal at 2# station"}, {"name": "station3Complete", "type": "Bool", "description": "Processing completion signal at 3# station"}, {"name": "station4Complete", "type": "Bool", "description": "Processing completion signal at 4# station"}], "output": [{"name": "conveyorLeft", "type": "Bool", "description": "Conveyor turns left"}, {"name": "conveyorRight", "type": "Bool", "description": "Conveyor turns right"}], "in/out": [{"name": "processSequence", "type": "Array[1..8] of USInt", "description": "Processing sequence"}]}
{"title": "Recipe Management System", "description": "A factory's production line needs to produce a variety of products based on different recipes. The control center of the production line requires a recipe management system that allows operators to add, delete, modify, and query recipe data.\nControl requirements:\nRecipe data should include recipe number, raw material type, raw material ratio, and production temperature.\nThe system should allow input of new recipe data and store it in the recipe database.\nThe system should allow deletion or modification of existing recipe data by recipe number.\nThe system should allow querying recipe details by recipe number and output the recipe.\nNotes:\n1. Recipes are constructed using the Struct data type, which includes recipe number (recipeID), raw material type (ingredientType), raw material ratio (ingredientRatio), and production temperature (productionTemperature). The recipe database can store up to 10 recipes, constructed with Array[1..10] of Struct, where recipe numbers must not be duplicated, and a recipe number of 0 indicates an empty slot.\n2. When a query recipe request signal (queryRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn with all recipes in the recipe database recipe. If the number does not exist, an error status (error=true) and error code (status=16#8001) are output. If the number exists, the recipe is output to the recipe query result (recipeQueryResult).\n3. When an add recipe request signal (addRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn) with all recipes in the recipe database (recipe). If a duplicate number exists, an error status (error=true) and error code (status=16#8002) are output. If there is no empty slot in the recipe database (recipe), an error status (error=true) and error code (status=16#8003) are output. If there are no errors, the input recipe (recipeIn) is stored in the recipe database (recipe), prioritizing the empty slot with the smallest array index.\n4. When a delete recipe request signal (deleteRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn) with all recipes in the recipe database (recipe). If the number does not exist, an error status (error=true) and error code (status=16#8004) are output. If the number exists, the recipe is deleted, i.e., the recipe number (recipeID) in the recipe database (recipe) is set to 0.\n5. When a modify recipe request signal (modifyRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn) with all recipes in the recipe database (recipe). If the number does not exist, an error status (error=true) and error code (status=16#8005) are output. If the number exists, the recipe is replaced with the input recipe (recipeIn).", "type": "FUNCTION_BLOCK", "name": "FB_RecipeManager", "input": [{"name": "addRecipe", "type": "Bool", "description": "Add Recipe Request Signal"}, {"name": "deleteRecipe", "type": "Bool", "description": "Delete Recipe Request Signal"}, {"name": "modifyRecipe", "type": "Bool", "description": "Modify Recipe Request Signal"}, {"name": "queryRecipe", "type": "Bool", "description": "Query Recipe Request Signal"}, {"name": "recipeIn", "type": "Struct", "description": "Input Recipe", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe Number"}, {"name": "ingredientType", "type": "Int", "description": "Raw Material Type"}, {"name": "ingredientRatio", "type": "Real", "description": "Raw Material Ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production Temperature"}]}], "output": [{"name": "recipeAdded", "type": "Bool", "description": "Recipe Added Success Indicator"}, {"name": "recipeDeleted", "type": "Bool", "description": "Recipe Deleted Success Indicator"}, {"name": "recipeModified", "type": "Bool", "description": "Recipe Modified Success Indicator"}, {"name": "recipeQueryResult", "type": "Struct", "description": "Recipe Query Result Output", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe Number"}, {"name": "ingredientType", "type": "Int", "description": "Raw Material Type"}, {"name": "ingredientRatio", "type": "Real", "description": "Raw Material Ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production Temperature"}]}, {"name": "error", "type": "Bool", "description": "Error Status Indicator\nFALSE: No Error Occurred\nTRUE: Execution Error"}, {"name": "status", "type": "Word", "description": "Status Code"}], "in/out": [{"name": "recipe", "type": "Array[1..10] of Struct", "description": "Recipe Database", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe Number"}, {"name": "ingredientType", "type": "Int", "description": "Raw Material Type"}, {"name": "ingredientRatio", "type": "Real", "description": "Raw Material Ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production Temperature"}]}]}
{"title": "Floating-point Number Interval Linearization Conversion", "description": "In some automated control systems, it may be necessary to convert a measured physical quantity (such as temperature, pressure, etc.) into another linearized or standardized value for the processing or display of control algorithms. For example, a physical quantity measured by a sensor may vary within a specific non-linear range, but the control system requires a linearized value for calculations.\nControl requirements:\nSystem needs to receive a floating-point number as input, representing the original measured value.\nBased on the size of the input value, it is converted to different linear ranges, and the linearized value after conversion is output.\nWhen the input value is between 1200 and 3600, it is converted to the range of 150 to 240.\nWhen the input value is between 3600 and 4800, it is converted to the range of 240 to 560.\nWhen the input value is between 4800 and 7000, it is converted to the range of 560 to 720.\nIf the input value is less than 1200 or greater than 7000, the converted value should be the linearized value corresponding to 1200 or 7000, and an error status error=1, status=16#8001 is output.", "type": "FUNCTION_BLOCK", "name": "FB_LinearizeValue", "input": [{"name": "InputValue", "type": "Real", "description": "Floating-point input, original measured value"}], "output": [{"name": "LinearizedValue", "type": "Real", "description": "Linearized value after conversion"}, {"name": "Error", "type": "Bool", "description": "Error status indicator\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "Status", "type": "Word", "description": "Status code"}]}
{"title": "Separate Bytes into Bits", "description": "Write a PLC program that receives a variable-length byte array byteArray and a variable-length boolean array bitArray. The goal of the program is to sequentially separate each byte in byteArray into bitArray, ensuring that all 8 bits of each byte are separated and stored. If the length of bitArray is insufficient to store all bits, only separate up to the maximum number of bits that bitArray can accommodate. The program also outputs the actual number of bytes separated splitByteNum\nFor example, if byteArray=[16#2D], then bitArray=[1,0,1,1,0,1,0,0]", "type": "FUNCTION", "name": "SplitByteArray", "input": [{"name": "byteArray", "type": "Array[*] of Byte", "description": "Byte array to be separated"}], "output": [{"name": "splitByteNum", "type": "DInt", "description": "Actual number of bytes separated"}], "in/out": [{"name": "bitArray", "type": "Array[*] of Bool", "description": "Separated boolean array"}]}
{"title": "Shift Register", "description": "Write a PLC program that receives an array of variable data types 'buffer' and performs shift operations on the array.\nIt can perform a left shift (shiftLeft=TRUE), where elements with higher index numbers move to lower index numbers.\nIt can also perform a right shift (shiftRight=TRUE), where elements with lower index numbers move to higher index numbers.\nThe length of the shift is determined by the shift range 'shiftRange'.\nEmpty positions after moving are covered with the initial value 'initialItem'.\nWhen the clear operation (clear=TRUE) is performed, all elements of the array are initialized to the initial value 'initialItem'.", "type": "FUNCTION_BLOCK", "name": "ShiftSequence", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Shift left"}, {"name": "shiftRight", "type": "Bool", "description": "Shift right"}, {"name": "shiftRange", "type": "UInt", "description": "Shift range"}, {"name": "clear", "type": "Bool", "description": "Clear operation"}, {"name": "initialItem", "type": "Variant", "description": "Initial value"}], "in/out": [{"name": "buffer", "type": "Variant", "description": "Array queue to be shifted"}]}
{"title": "Convert String to IP Address and Port Number", "description": "In Siemens PLC programming, it is often necessary to receive strings containing IP addresses and port numbers from user input or external devices and parse them into integer formats for network communication.\nWrite a function FC that converts a string containing an IP address and possibly a port number into integer forms of IP address and port number. The string format should be \"xxx.xxx.xxx.xxx[:port]\", where xxx represents numbers between 0-255, and port represents a port number between 0-65535 (optional). If the string contains a port number, return it; if not, return the default port number (e.g., 0). Return the converted IP address and port number to the corresponding positions of the system data type TADDR_Param structure.\nThe function should check if the input string conforms to the \"IP_ADDRESS:PORT\" format requirement, where the IP address consists of four integers between 0 and 255 separated by dots, and the port number is an integer between 0 and 65535.\nIf the string format is correct, the function should parse it into an IP address represented by a four-byte integer array and a port number represented by an integer, and return these values.\nIf the string format is incorrect, the function should output an error status and an error code.\nStatus codes:\n16#0000: Execution of FC without error\n16#811x: IP address contains too many characters, where x indicates the lowest byte sequence number with an error, e.g., if the 2nd byte of the IP address is wrong, then x=2\n16#812x: IP address string is an empty string, x means the same as above\n16#813x: Exceeds the maximum IP address value (255), x means the same as above\n16#8150: Too many port number characters\n16#8151: Port number string is empty\n16#8152: Exceeds the maximum port number value (65535)", "type": "FUNCTION", "name": "StringToTaddr", "input": [{"name": "ipAddressString", "type": "String", "description": "The input string"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FC"}, {"name": "status", "type": "Word", "description": "Status code"}], "return_value": [{"type": "TADDR_Param", "description": "The converted IP address and port number"}]}
{"title": "Automated Warehouse Shelf Position Management System", "description": "An automated warehouse requires a system to manage the storage positions of workpieces to ensure they can be stored and retrieved efficiently. There is a shelf in the warehouse with 9 levels, numbered from 1 to 9, with each level capable of storing only one workpiece.\nControl requirements:\n1. The system needs to maintain the storage status of the shelf, recording whether each level is occupied by a workpiece.\n2. When a workpiece is stored:\n   - Query the storage status of the shelf.\n   - If there is a free position, store it in the position with the higher number first.\n   - If all positions are occupied, output an error status with error=1 and error code status16#8001.\n3. When a workpiece is retrieved:\n   - Query the storage status of the shelf.\n   - If there is a workpiece on the shelf, retrieve the workpiece from the position with the lower number first.\n   - If all positions are empty, output an error status with error=1 and error code status16#8002.\n4. The system should be able to output the current number of workpieces in stock and the number of free positions on the shelf.", "type": "FUNCTION_BLOCK", "name": "FB_WarehouseManagement", "input": [{"name": "requestIn", "type": "Bool", "description": "Storage request signal"}, {"name": "requestOut", "type": "Bool", "description": "Retrieval request signal"}], "output": [{"name": "productNum", "type": "Int", "description": "Number of workpieces in stock"}, {"name": "libFreeNum", "type": "Int", "description": "Number of free positions on the shelf"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "library", "type": "Array[1..9] of Bool", "description": "Occupancy status of each level of the shelf, 1 indicates occupied, 0 indicates free"}]}
{"title": "Integration Function", "description": "Write a function block FB that implements the integration of an input signal, with start and reset functions. Integration is the cumulative summation of the input signal over time, commonly used to calculate the cumulative value of physical quantities such as flow and displacement. The start function is used to begin the integration calculation, while the reset function resets the integration value to zero.\nIf there is an error reading the system time, an error status and error code are output.\nStatus codes:\n16#0000: Execution of FB without error\n16#8600: Error reading system time", "type": "FUNCTION_BLOCK", "name": "Integration", "input": [{"name": "enable", "type": "Bool", "description": "Start signal, when this signal is TRUE, the integration calculation is enabled; if FALSE, the integration calculation will stop, and the integral output will display the last calculated value."}, {"name": "value", "type": "LReal", "description": "The input signal value to be integrated"}, {"name": "reset", "type": "Bool", "description": "Reset signal, when this signal is TRUE, the integration value is reset to zero"}], "output": [{"name": "integral", "type": "LReal", "description": "The integrated value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "FIFO First-In-First-Out Queue", "description": "Write a function block FB to implement the functionality of a First-In-First-Out (FIFO) circular queue, where the maximum length and data type of the queue are variable. The circular queue should support the following operations:\n\n1. Enqueue operation: Add an element to the end of the queue when the queue is not full.\n2. Dequeue operation: Remove an element from the front of the queue when the queue is not empty and return the value of that element.\n3. Check if the queue is empty: Check if there are no elements in the queue.\n4. Check if the queue is full: Check if the queue has reached its maximum capacity.\n5. Get the number of elements in the queue: Return the current number of elements in the queue.\nStatus codes:\n16#0000: Execution of FB without error\n16#8001: The queue is empty\n16#8002: The queue is full", "type": "FUNCTION_BLOCK", "name": "FIFO", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue operation, add an element to the end of the queue when the queue is not full"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue operation, remove an element from the front of the queue when the queue is not empty and return the value of that element."}, {"name": "reset", "type": "Bool", "description": "Reset operation, reset head and tail pointers, elementCount output is set to zero, and isEmpty output is set to TRUE."}, {"name": "clear", "type": "Bool", "description": "Clear operation, reset head and tail pointers, the queue will be cleared and initialized with the initial value initialItem. ElementCount output is set to zero, and isEmpty output is set to TRUE."}, {"name": "initialItem", "type": "Variant", "description": "The value used to initialize the queue"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "elementCount", "type": "DInt", "description": "The number of elements in the queue"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE when the queue is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The value used to add to the queue or return from the queue"}, {"name": "buffer", "type": "Variant", "description": "Used as an array for the queue"}], "status_codes": {"16#0000": "No error in execution of FB", "16#8001": "The queue is empty", "16#8002": "The queue is full"}}
{"title": "Mechanical Arm Control", "description": "Design a PLC program to control an automated mechanical arm that performs handling tasks on the production line. The mechanical arm has six basic actions: down, up, left, right, grip, and release. The operating modes of the mechanical arm include four types: manual, single step, single cycle, and continuous.\nControl requirements:\n1. Manual mode: Allows the operator to control each action of the mechanical arm individually through the control panel, provided it is not yet in position. For example, pressing the down button (DownButton=1), if not at the down position (DownLimitSwitch=0), then move down (MoveDown=1); if at the down position (DownLimitSwitch=1), stop moving down. Releasing the down button also stops the movement down.\n2. Single step mode: The mechanical arm automatically executes one action according to the preset program, and the operator needs to confirm after each action is completed to execute the next action.\nThe initial position of the mechanical arm is at the top left.\nWhen the start button is pressed once, the mechanical arm executes the down command MoveDown, and stops after reaching the down position.\nWhen the start button is pressed again, the mechanical arm executes the grip command ActivateGrip, and stops after gripping.\nWhen the start button is pressed again, the mechanical arm executes the up command MoveUp, and stops after reaching the up position.\nWhen the start button is pressed, the mechanical arm executes the right command MoveRight, and stops after reaching the right position.\nWhen the start button is pressed, the mechanical arm executes the down command MoveDown, and stops after reaching the down position.\nWhen the start button is pressed, the mechanical arm executes the release command ActivateRelease, and stops after releasing.\nWhen the start button is pressed again, the mechanical arm executes the up command MoveUp, and stops after reaching the up position.\nWhen the start button is pressed again, the mechanical arm executes the left command MoveLeft, and stops after reaching the left position.\nThen starts the cycle again from the beginning\n3. Single cycle mode: The mechanical arm automatically completes a full handling cycle, including all preset actions, and stops at the end of the cycle waiting for the operator's instruction.\nThe initial position of the mechanical arm is at the top left, when the start button is pressed:\nThe mechanical arm first moves down, then grips after reaching the down position, moves up after gripping, moves right after reaching the up position, moves down after reaching the right position, releases after reaching the down position, moves up after releasing, moves left after reaching the up position, and stops after reaching the left position.\n4. Continuous mode: The initial position of the mechanical arm is at the top left, when the start button is pressed, the mechanical arm continuously executes the handling cycle of the single cycle mode.\n5. The emergency stop function can stop all actions of the mechanical arm at any time.", "type": "FUNCTION_BLOCK", "name": "MechanicalArm", "input": [{"name": "ManualMode", "type": "Bool", "description": "Manual mode"}, {"name": "SingleStepMode", "type": "Bool", "description": "Single step mode"}, {"name": "SingleCycleMode", "type": "Bool", "description": "Single cycle mode"}, {"name": "ContinuousMode", "type": "Bool", "description": "Continuous mode"}, {"name": "EmergencyStop", "type": "Bool", "description": "Emergency stop signal\nFALSE: Emergency stop triggered\nTRUE: No emergency stop triggered"}, {"name": "Start", "type": "Bool", "description": "Start operation"}, {"name": "DownButton", "type": "Bool", "description": "Down button"}, {"name": "UpButton", "type": "Bool", "description": "Up button"}, {"name": "LeftButton", "type": "Bool", "description": "Left button"}, {"name": "RightButton", "type": "Bool", "description": "Right button"}, {"name": "GripButton", "type": "Bool", "description": "Grip button"}, {"name": "ReleaseButton", "type": "Bool", "description": "Release button"}, {"name": "DownLimitSwitch", "type": "Bool", "description": "Down position limit switch"}, {"name": "UpLimitSwitch", "type": "Bool", "description": "Up position limit switch"}, {"name": "LeftLimitSwitch", "type": "Bool", "description": "Left position limit switch"}, {"name": "RightLimitSwitch", "type": "Bool", "description": "Right position limit switch"}, {"name": "GripLimitSwitch", "type": "Bool", "description": "Grip position limit switch"}, {"name": "ReleaseLimitSwitch", "type": "Bool", "description": "Release position limit switch"}], "output": [{"name": "MoveDown", "type": "Bool", "description": "Down command"}, {"name": "MoveUp", "type": "Bool", "description": "Up command"}, {"name": "MoveLeft", "type": "Bool", "description": "Left command"}, {"name": "MoveRight", "type": "Bool", "description": "Right command"}, {"name": "ActivateGrip", "type": "Bool", "description": "Grip command"}, {"name": "ActivateRelease", "type": "Bool", "description": "Release command"}]}
{"title": "Console Indicator Light Sequence Control", "description": "A console is equipped with 3 indicator lights, which are green, red, and yellow. It is necessary to cyclically control the status of these lights using a control button.\nControl requirements:\nUse an input parameter 'controlButton' to represent the state of the control button, which is a pulse signal, generating a transition from 0 to 1 each time it is triggered.\nUse three output parameters 'greenLight', 'redLight', and 'yellowLight' to control the corresponding green, red, and yellow indicator lights.\nThe sequence of button triggers and the corresponding light statuses are as follows:\n1st trigger: Only the green light 'greenLight' is on.\n2nd trigger: Only the red light 'redLight' is on.\n3rd trigger: Only the yellow light 'yellowLight' is on.\n4th trigger: All three lights are on.\n5th trigger: All three lights are off.\n6th trigger and onwards: Repeat the above cycle.", "type": "FUNCTION_BLOCK", "name": "FB_ColorLightControl", "input": [{"name": "controlButton", "type": "Bool", "description": "Control button switch, pulse signal"}], "output": [{"name": "greenLight", "type": "Bool", "description": "Green indicator light"}, {"name": "redLight", "type": "Bool", "description": "Red indicator light"}, {"name": "yellowLight", "type": "Bool", "description": "Yellow indicator light"}]}
{"title": "Dual-Word Edge Detection", "description": "Write a function block FB that checks for rising and falling edges in each bit of a dual-word (DWord) input value every cycle. The function block should be able to detect and report changes, rising edges, and falling edges in the input value.", "type": "FUNCTION_BLOCK", "name": "BitEdgeDetector", "source_code": "", "input": [{"name": "value", "type": "DWord", "description": "The input value to be checked for changes and edge triggering"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "True indicates that the input value has changed"}, {"name": "hasRisingEdges", "type": "Bool", "description": "True indicates that rising edges have occurred in the input value"}, {"name": "risingBits", "type": "DWord", "description": "The bit stream of rising edges, where each bit indicates whether the corresponding input bit has experienced a rising edge (1 for a rising edge, 0 for no rising edge)"}, {"name": "noOfRisingBits", "type": "USInt", "description": "The number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "True indicates that falling edges have occurred in the input value"}, {"name": "fallingBits", "type": "DWord", "description": "The bit stream of falling edges, where each bit indicates whether the corresponding input bit has experienced a falling edge (1 for a falling edge, 0 for no falling edge)"}, {"name": "noOfFallingBits", "type": "USInt", "description": "The number of falling edges in the input value"}]}
{"title": "Converting date and time of type DTL to a string", "description": "Write a function FC that can convert date and time values of type DTL to a string and output them with a custom separator. The format of the converted string should be YYYY<separator>MM<separator>DD<separator>HH:mm:ss.nnnnnnnn, where <separator> is the character specified by the function parameter. Here, HH represents hours (24-hour format), mm represents minutes, ss represents seconds, and nnnnnnnn represents nanoseconds. Note that the separator should not be applied between hours, minutes, seconds, and nanoseconds.\n\nExample:\nAssuming the input DTL date and time is 2023-09-17 12:34:56.123456789, with a custom separator of -.\nThe function should return the string \"2023-09-17 12:34:56.123456789\" as the conversion result.", "type": "FUNCTION", "name": "DTLToString_ISO", "input": [{"name": "date", "type": "DTL", "description": "Date of type DTL"}, {"name": "separator", "type": "Char", "description": "The separator between year and month, and month and day in the converted date"}], "return_value": [{"type": "String", "description": "The converted date string"}]}
{"title": "Multi-element Queue", "description": "Write a function block FB to implement the function of a first-in-first-out circular queue, which can support multiple elements for enqueue or dequeue operations, and the maximum length of the queue is variable.\nThe circular queue should be able to support the following operations:\n1. Enqueue operation (push): When there is enough space in the queue 'queue', multiple elements are added to the end of the queue. The elements to be added are specified by the starting position 'itemIndex' and the length 'itemLen' in the element array 'item'.\n2. Dequeue operation (pop): When there are enough elements in the queue 'queue', multiple elements are removed from the front of the queue, the number of elements to be removed is specified by 'itemLen', moved to 'item', starting from the position 'itemIndex'.\n3. Reset operation (reset): Clear all elements in the queue.\n4. Get queue information: Return the current number of elements and available space in the queue.", "type": "FUNCTION_BLOCK", "name": "RingQueueMultiItem", "input": [{"name": "push", "type": "Bool", "description": "Enqueue operation"}, {"name": "pop", "type": "Bool", "description": "Dequeue operation"}, {"name": "reset", "type": "Bool", "description": "Reset operation"}, {"name": "itemIndex", "type": "UDInt", "description": "Starting position of the elements to be enqueued or dequeued"}, {"name": "itemLen", "type": "UDInt", "description": "Length of the elements to be enqueued or dequeued"}], "output": [{"name": "queueUsed", "type": "DInt", "description": "Number of elements in the queue"}, {"name": "queueUnused", "type": "DInt", "description": "Remaining space in the queue"}], "in/out": [{"name": "item", "type": "Array[*] of Byte", "description": "Values to be added to the queue or returned from the queue"}, {"name": "queue", "type": "Array[*] of Byte", "description": "Array used as the queue"}]}
{"title": "Case Conversion of Characters", "description": "Write a PLC program that receives a string 'In' and performs conversion based on the 'mode' of conversion, then returns the converted string.\nIf mode=FALSE, it is the lowercase to uppercase mode, i.e., converts all lowercase characters in the string to uppercase.\nIf mode=TRUE, it is the opposite, i.e., converts all uppercase characters in the string to lowercase.\nFor example, In='ABCD1234efgh', mode=TRUE, then the returned string is 'abcd1234efgh'", "type": "FUNCTION", "name": "StringCovert", "input": [{"name": "In", "type": "String", "description": "The string to be converted"}, {"name": "mode", "type": "Bool", "description": "Conversion mode"}], "return_value": [{"type": "String", "description": "The converted string"}]}
{"title": "Recipe Management System Based on Doubly Linked List", "description": "A factory's production line needs to produce various products based on different recipes. The control center of the production line requires a recipe management system that allows operators to add recipe data.\nControl requirements:\nRecipe data should include raw material type, raw material ratio, and production temperature.\nThe system should allow the input of new recipe data and store it in the recipe database.\nNotes:\n1. Recipes are constructed using the Struct data type, which includes ingredientType, ingredientRatio, and productionTemperature. A doubly linked list is used to manage the recipe database, with each recipe having two pointers, Prev and Next. Prev points to the previous recipe position, and Next points to the next recipe position. Prev being -1 indicates the first record in the list, Next being -1 indicates the last record in the list, and if both pointers are -1, it indicates an empty record.\n2. When adding a recipe:\nIf the recipe database is an empty list, the new recipe is added to the first position of the array, and Next is set to point to the second position of the array; If the recipe database is not an empty list, the new recipe is added to the end of the list.", "type": "FUNCTION", "name": "AddRecipeLinkedList", "input": [{"name": "exe", "type": "Bool", "description": "Initiate adding recipe"}, {"name": "recipeAdded", "type": "Struct", "description": "Recipe to be added", "fields": [{"name": "ingredientType", "type": "Int", "description": "Type of raw material"}, {"name": "ingredientRatio", "type": "Real", "description": "Ratio of raw material"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}], "in/out": [{"name": "recipeList", "type": "Array[0..19] of Struct", "description": "Recipe database", "fields": [{"name": "Prev", "type": "DInt", "description": "Previous pointer, pointing to the array index of the previous recipe"}, {"name": "Next", "type": "DInt", "description": "Next pointer, pointing to the array index of the next recipe"}, {"name": "recipe", "type": "Struct", "description": "Recipe", "fields": [{"name": "ingredientType", "type": "Int", "description": "Type of raw material"}, {"name": "ingredientRatio", "type": "Real", "description": "Ratio of raw material"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}]}]}
{"title": "Batch High-Low Word Swapping", "description": "Write a PLC program that receives two variable-length arrays of double words, dataIn and dataOut. The goal of the program is to swap the high and low words of each double word in dataIn and store them sequentially in dataOut. If the lengths of the two arrays are not the same, the processing is done according to the length of the shorter array. The program also outputs the number of double words actually swapped, swapNum\nFor example, if dataIn=[16#11223344], then dataOut=[16#33441122]", "type": "FUNCTION", "name": "SwapDWord", "input": [{"name": "dataIn", "type": "Array[*] of DWord", "description": "Array of double words to be swapped"}], "output": [{"name": "swapNum", "type": "DInt", "description": "Number of double words actually swapped"}], "in/out": [{"name": "dataOut", "type": "Array[*] of DWord", "description": "Array of double words after swapping"}]}
{"title": "PLC Database Data Storage and Management System", "description": "In some automation applications, PLCs need to collect and store a large amount of data, such as sensor readings, production counts, or other process variables. This data is typically stored in the PLC's internal database or an external database system.\nControl requirements:\nThe system needs to receive a set of data dataInput, constructed as a byte array, where the first byte dataInput[0] of this set indicates the byte length of the data to be stored.\nThe data storage operation is triggered by the input storeTrigger.\nData needs to be stored in the database in sequence, with each set of data possibly having different lengths.\nWhen the remaining space in the database is not enough to store a new set of data, the system should trigger an error error.\nThe system should provide a reset function, which clears the database and resets the error through the input resetTrigger.\nThe system should be able to output the current usage and remaining space of the database.\nInstructions:\n1. When the storage signal storeTrigger is triggered, first check whether the data input length information (i.e., the first byte dataInput[0] of the array) is illegal. If it is less than or equal to 0 or greater than 5, output an error status error=true and error code status=16#8001. If the remaining space in the database is not enough to store new data, output an error status error=true and error code status=16#8002. If there are no such errors, extract the data starting from the second byte of the input array according to the length information and store it in the database. When storing, do not overwrite the original data in the database, and store it sequentially after the original data.\n2. When the reset signal resetTrigger is triggered, clear all data in the database and reset the error status error=0 and status=0.\n3. The used space and remaining space of the database are output respectively through usedSpace and remainingSpace.", "type": "FUNCTION_BLOCK", "name": "FB_DatabaseManager", "input": [{"name": "dataInput", "type": "Array[0..5] of Byte", "description": "Data input, byte array"}, {"name": "storeTrigger", "type": "Bool", "description": "Storage trigger signal"}, {"name": "resetTrigger", "type": "Bool", "description": "Reset trigger signal"}], "output": [{"name": "usedSpace", "type": "Int", "description": "Used space in the database"}, {"name": "remainingSpace", "type": "Int", "description": "Remaining space in the database"}, {"name": "error", "type": "Bool", "description": "Error status indication\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "dataBase", "type": "Array[1..20] of Byte", "description": "Database, byte array"}]}
{"title": "Matrix Multiplication", "description": "Write a function to implement the multiplication of two matrices.\nThis function takes two variable-length two-dimensional floating-point arrays, matrix1 and matrix2, as input parameters.\nCalculation starts when execute=TRUE.", "type": "FUNCTION", "name": "MatrixMulti", "input": [{"name": "execute", "type": "Bool", "description": "Start calculation"}, {"name": "matrix1", "type": "Array[*, *] of Real", "description": "Input matrix 1"}, {"name": "matrix2", "type": "Array[*, *] of Real", "description": "Input matrix 2"}], "in/out": [{"name": "matrixResult", "type": "Array[*, *] of Real", "description": "Output calculation result matrix"}]}
{"title": "Matrix Addition", "description": "Write a function FC that implements the addition of two matrices.\n\nThe function accepts two two-dimensional arrays of floating-point numbers, matrix1 and matrix2, of variable lengths as input parameters. The function should check whether the two input matrices and the output matrix for the result have the same number of rows and columns. If they do not, it should return an error status and a specific error code.\n\nStatus codes:\n16#0000: Execution of FC without error\n16#8200: The lower bound of the first matrix array rows is different from the lower bound of the second matrix rows\n16#8201: The lower bound of the first matrix array rows is different from the lower bound of the result matrix rows\n16#8202: The lower bound of the first matrix array columns is different from the lower bound of the second matrix columns\n16#8203: The lower bound of the first matrix array columns is different from the lower bound of the result matrix columns\n16#8204: The upper bound of the first matrix array rows is different from the upper bound of the second matrix rows\n16#8205: The upper bound of the first matrix array rows is different from the upper bound of the result matrix rows\n16#8206: The upper bound of the first matrix array columns is different from the upper bound of the second matrix columns\n16#8207: The upper bound of the first matrix array columns is different from the upper bound of the result matrix columns", "type": "FUNCTION", "name": "MatrixAddition", "input": [{"name": "matrix1", "type": "Array[* *] of LReal", "description": "The first matrix"}, {"name": "matrix2", "type": "Array[* *] of LReal", "description": "The second matrix"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FC"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrixResult", "type": "Array[* *] of LReal", "description": "The matrix where the calculation result is stored"}]}
{"title": "Parity Check", "description": "Write a PLC program that receives a data of variable data type 'value', which can be of type word, Dword, or LWord. The goal of the program is to calculate the number of 1s in the binary value of the data 'value', referred to as countBitsTrue, and based on the set parity mode 'odd', return the parity check result. The program also outputs the number of 0s in the binary value of the data 'value', referred to as countBitsFalse.\n\nIf odd=FALSE, it is even parity: return the check result as TRUE when countBitsTrue is even, otherwise return the check result as FALSE.\nIf odd=TRUE, it is odd parity: return the check result as TRUE when countBitsTrue is odd, otherwise return the check result as FALSE.", "type": "FUNCTION", "name": "ParityVariant", "input": [{"name": "value", "type": "Variant", "description": "Data to be checked"}, {"name": "odd", "type": "Bool", "description": "Parity mode\nFALSE: Even Parity\nTRUE: Odd Parity"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of FALSEs in the data"}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of TRUEs in the data"}], "return_value": [{"type": "Bool", "description": "Parity check result"}]}
{"title": "Automated Production Line Control", "description": "A simple automated production line consists of three workstations: Workstation A, Workstation B, and Workstation C. The product needs to go through these three stations in sequence to be considered fully completed. There is a motor in the production line that is responsible for moving the product from one workstation to the next. The sequence of the line is from Workstation A to Workstation B, and then to Workstation C. Each workstation has a sensor (used to detect if the product has arrived) and a button (used to trigger the signal that the station's processing is complete).\nControl requirements:\n1. Mode Switching: The mode switch (Mode) is used to switch between manual and automatic modes of the production line.\n2. Manual Mode: In manual mode, the forward rotation button (ForwardButton) controls the forward rotation of the motor, and the reverse rotation button (ReverseButton) controls the reverse rotation of the motor. Forward and reverse rotation operations need to be interlocked and cannot be performed simultaneously.\n3. Automatic Mode:\n   - When the product arrives at Workstation A, SensorA detects the product, and after the operator triggers the processing complete signal via ButtonA, the motor starts forward rotation to move the product to Workstation B.\n   - When the product arrives at Workstation B, SensorB detects the product, the motor stops, and after the operator triggers the processing complete signal via ButtonB, the motor starts forward rotation to move the product to Workstation C.\n   - When the product arrives at Workstation C, SensorC detects the product, the motor stops, and after the operator triggers the processing complete signal via ButtonC, the completion indicator light (CompletionLight) turns on, indicating that the product processing is complete. When the product is taken away, i.e., SensorC no longer detects the product, the completion indicator light (CompletionLight) turns off.", "type": "FUNCTION_BLOCK", "name": "FB_ProductionLineControl", "input": [{"name": "Mode", "type": "Bool", "description": "Used to switch the production line between manual and automatic modes, 0=manual mode, 1=automatic mode"}, {"name": "ForwardButton", "type": "Bool", "description": "Forward rotation button"}, {"name": "ReverseButton", "type": "Bool", "description": "Reverse rotation button"}, {"name": "SensorA", "type": "Bool", "description": "Sensor A"}, {"name": "SensorB", "type": "Bool", "description": "Sensor B"}, {"name": "SensorC", "type": "Bool", "description": "Sensor C"}, {"name": "ButtonA", "type": "Bool", "description": "Button A"}, {"name": "ButtonB", "type": "Bool", "description": "Button B"}, {"name": "ButtonC", "type": "Bool", "description": "Button C"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "Motor forward rotation output"}, {"name": "MotorReverse", "type": "Bool", "description": "Motor reverse rotation output"}, {"name": "CompletionLight", "type": "Bool", "description": "Indicator light for product processing completion"}]}
{"title": "Custom String Extraction", "description": "Write a function FC that, based on a given starting string and ending string, can extract the required substring from a character array.\nDescription:\n1. The function should traverse charArray, starting from the search position startPos to find the first occurrence of textBefore, and then find the position of the subsequent appearance of textAfter.\n2. If textBefore and textAfter are found, the function should extract the string between these two boundaries (if includeBeforeAfter=FALSE, the boundary characters themselves are not included, otherwise, they are included) and return this substring retString. It should also return the position of the first character of the extracted string in the array, and the length of the extracted string.", "type": "FUNCTION", "name": "GetString", "input": [{"name": "textBefore", "type": "String", "description": "The starting boundary of the string to be extracted"}, {"name": "textAfter", "type": "String", "description": "The ending boundary of the string to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "FALSE: Exclude boundaries\nTRUE: Include boundaries"}, {"name": "startPos", "type": "DInt", "description": "The starting position from which to search in the array, 0 corresponds to the first element"}], "output": [{"name": "retString", "type": "String", "description": "The extracted string"}, {"name": "position", "type": "DInt", "description": "The position of the first character of the extracted string in the array, 0 corresponds to the first element"}, {"name": "length", "type": "Int", "description": "The length of the extracted string"}], "in/out": [{"name": "charArray", "type": "Variant", "description": "The character or byte array in which to perform the search"}]}
{"title": "Production Control", "description": "An automated production line consists of 5 workstations: material loading station, cleaning station, weighing station, firing station, and finished product station. The production line has a motor responsible for moving products from one workstation to the next, the sequence of the line is from the material loading station, cleaning station, weighing station, firing station, to the finished product station. Each workstation has a sensor (used to detect if the product has arrived).\nControl requirements:\n1. Mode Switching: The mode switch (Mode) is used to switch between manual and automatic modes of the production line. 0 = manual mode, 1 = automatic mode.\n2. Manual Mode: In manual mode, the forward rotation button (ForwardButton) controls the forward rotation of the motor, and the reverse rotation button (ReverseButton) controls the reverse rotation of the motor. Forward and reverse rotation operations need to be interlocked and cannot be performed simultaneously.\n3. Automatic Mode:\n   - When the material arrives at the material loading station, the SensorFeed detects the material, the motor starts forward rotation, and moves the material to the cleaning station.\n   - When the material arrives at the cleaning station, the SensorWash detects the material, the motor stops, and upon receiving the signal washComplete after cleaning is finished, the motor starts forward rotation, moving the material to the weighing station.\n   - When the material arrives at the weighing station, the SensorWeight detects the material, the motor stops, and upon receiving the signal after weighing is complete, the material is judged to be qualified based on the weight value. If the weight value is greater than or equal to 100 and less than or equal to 200, it is qualified, otherwise not.\n     If the material is unqualified, the rejection command kick is initiated.\n     If the material is qualified, the firing temperature is calculated based on the weight value. The calculation rule is that the weight value from 100 to 200 linearly corresponds to the temperature value from 500 to 550. The firing temperature firingTemp is output. At the same time, the motor starts forward rotation, moving the material to the firing station.\n   - When the product arrives at the firing station, the SensorFiring detects the material, the motor stops, and upon receiving the signal firingComplete after firing is finished, the motor starts forward rotation, moving the product to the finished product station.\n   - When the product arrives at the finished product station, the SensorOutput detects the product, the motor stops, and the completion light (CompletionLight) turns on, indicating that the product processing is complete. When the product is taken away, i.e., the SensorOutput does not detect the product, the completion light (CompletionLight) turns off.", "type": "FUNCTION_BLOCK", "name": "ProductionControl", "input": [{"name": "Mode", "type": "Bool", "description": "Used to switch the production line between manual and automatic modes, 0 = manual mode, 1 = automatic mode"}, {"name": "ForwardButton", "type": "Bool", "description": "Forward rotation button"}, {"name": "ReverseButton", "type": "Bool", "description": "Reverse rotation button"}, {"name": "SensorFeed", "type": "Bool", "description": "Sensor at the material loading station detecting the arrival of materials"}, {"name": "SensorWash", "type": "Bool", "description": "Sensor at the cleaning station detecting the arrival of materials"}, {"name": "SensorWeight", "type": "Bool", "description": "Sensor at the weighing station detecting the arrival of materials"}, {"name": "SensorFiring", "type": "Bool", "description": "Sensor at the firing station detecting the arrival of materials"}, {"name": "SensorOutput", "type": "Bool", "description": "Sensor at the finished product station detecting the arrival of products"}, {"name": "washComplete", "type": "Bool", "description": "Signal indicating completion of cleaning"}, {"name": "weightComplete", "type": "Bool", "description": "Signal indicating completion of weighing"}, {"name": "weight", "type": "Real", "description": "Weight value"}, {"name": "firingComplete", "type": "Bool", "description": "Signal indicating completion of firing"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "Output for motor forward rotation"}, {"name": "MotorReverse", "type": "Bool", "description": "Output for motor reverse rotation"}, {"name": "kick", "type": "Bool", "description": "Rejection output"}, {"name": "CompletionLight", "type": "Bool", "description": "Indicator light for product processing completion"}, {"name": "firingTemp", "type": "Real", "description": "Firing temperature"}]}
{"title": "Generate Pulse Signal", "description": "Write a function block FB that generates a periodic signal that toggles between FALSE and TRUE. The duration of the TRUE state and the FALSE state in each cycle is determined by the given frequency and pulse pause ratio. The pulse pause ratio defines the ratio of the duration of the TRUE state to the duration of the FALSE state within each cycle.", "type": "FUNCTION_BLOCK", "name": "PulseGenerator", "input": [{"name": "frequency", "type": "Real", "description": "Clock frequency in Hz"}, {"name": "pulsePauseRatio", "type": "Real", "description": "Pulse pause ratio, which defines the ratio of the duration of the TRUE state to the duration of the FALSE state in each cycle. For example, if pulsePauseRatio is 2, the duration of the TRUE state will be twice that of the FALSE state."}], "output": [{"name": "pulse", "type": "Bool", "description": "Pulse output"}, {"name": "remainingTime", "type": "Time", "description": "Remaining time of the current state"}]}
{"title": "Alarm Handling", "description": "In industrial automation systems, monitoring the status of equipment is crucial. When equipment parameters exceed the normal range, the system needs to issue an alarm. To avoid frequent triggering of alarms due to minor fluctuations in parameters, an alarm management system with hysteresis function needs to be implemented.\nWhen Value is greater than hiLevel, trigger high alarm hiAlarm.\nWhen Value is less than hiLevel-hystWindow, exit high alarm hiAlarm.\nWhen Value is less than loLevel, trigger low alarm loAlarm.\nWhen Value is greater than loLevel+hystWindow, exit low alarm loAlarm.\nIf loLevel is greater than or equal to hiLevel, output error error=true, status=16#8001, and exit the program\nIf the hysteresis window value hystWindow is greater than or equal to the deviation range between hiLevel and loLevel, output error error=true, status=16#8002", "type": "FUNCTION_BLOCK", "name": "AlarmProcess", "input": [{"name": "Value", "type": "Real", "description": "Input value"}, {"name": "hiLevel", "type": "Real", "description": "High limit alarm value"}, {"name": "loLevel", "type": "Real", "description": "Low limit alarm value"}, {"name": "hystWindow", "type": "Real", "description": "Hysteresis window"}], "output": [{"name": "hiAlarm", "type": "Bool", "description": "High limit alarm"}, {"name": "loAlarm", "type": "Bool", "description": "Low limit alarm"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred;\nTRUE: Error occurred during execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "Conveyor Line Control System", "description": "Design a PLC program to control a conveyor line system, which is used to transport three different specifications of workpieces to designated warehouses and classify and store them based on the workpiece number and specification information.\nControl requirements:\nThe conveyor line starts from the initial station and passes through station 1, station 2, and station 3 sequentially.\nEach station has a detection element to detect the presence of a workpiece.\nWorkpieces have specification information and a unique number, and the system needs to transport the workpieces to the corresponding station based on the specification and store them in the corresponding warehouse.\nWorkpiece specification classification:\nSmall workpieces: Warehouse 1\nMedium workpieces: Warehouse 2\nLarge workpieces: Warehouse 3\nWhen the start station sensor SensorStart detects a workpiece and the start button StartButton is pressed, the conveyor belt run command ConveyorRun=true is triggered. According to the workpiece specification PartSpec, the workpiece is transported to the corresponding station, and when the corresponding station sensor (Sensor1, Sensor2, Sensor3) detects the workpiece, the conveyor belt stops ConveyorRun=false. After the corresponding station unloading is completed (corresponding UnloadComplete1, UnloadComplete2, UnloadComplete3 are TRUE), the workpiece number PartNumber is stored in the corresponding database (WarehouseDatabase1, WarehouseDatabase2, WarehouseDatabase3).", "type": "FUNCTION_BLOCK", "name": "ConveyorSystem", "input": [{"name": "StartButton", "type": "Bool", "description": "Start Button"}, {"name": "SensorStart", "type": "Bool", "description": "Start Station Sensor"}, {"name": "Sensor1", "type": "Bool", "description": "Station 1 Sensor"}, {"name": "Sensor2", "type": "Bool", "description": "Station 2 Sensor"}, {"name": "Sensor3", "type": "Bool", "description": "Station 3 Sensor"}, {"name": "UnloadComplete1", "type": "Bool", "description": "Station 1 Unloading Complete Signal"}, {"name": "UnloadComplete2", "type": "Bool", "description": "Station 2 Unloading Complete Signal"}, {"name": "UnloadComplete3", "type": "Bool", "description": "Station 3 Unloading Complete Signal"}, {"name": "PartSpec", "type": "Int", "description": "Workpiece Specification"}, {"name": "PartNumber", "type": "Int", "description": "Workpiece Number"}], "output": [{"name": "ConveyorRun", "type": "Bool", "description": "Conveyor Belt Running"}, {"name": "WarehouseDatabase1", "type": "Array[1..10] of Int", "description": "Warehouse 1 Database"}, {"name": "WarehouseDatabase2", "type": "Array[1..10] of Int", "description": "Warehouse 2 Database"}, {"name": "WarehouseDatabase3", "type": "Array[1..10] of Int", "description": "Warehouse 3 Database"}]}
{"title": "Digital Digit Separation Display", "description": "In some automated systems, it may be necessary to separate the digits of an integer for display or further processing. For example, in some counter or production counting applications, it is necessary to separate the current count value into units, tens, hundreds, and thousands.\nControl Requirements:\nThe system needs to receive an integer input of up to four digits.\nBased on the input integer, calculate and output its units, tens, hundreds, and thousands values.\nIf the input integer has fewer than four digits, display 0 on the missing higher places.\nThe output results should be four separate integers, each representing the units, tens, hundreds, and thousands digits, respectively.\nNotes:\n1. The input integer InputNumber must be greater than or equal to 0 and less than 10000, otherwise output an error state with error=true and error code status=16#8001.\n2. After calculating the values of the units, tens, hundreds, and thousands digits, compare the non-0 values among these four digits and output the minimum value to Min; if InputNumber=0, then output Min=0.", "type": "FUNCTION_BLOCK", "name": "FB_SplitNumber", "input": [{"name": "InputNumber", "type": "Int", "description": "Four-digit integer input"}], "output": [{"name": "Thousands", "type": "Byte", "description": "Thousands digit output"}, {"name": "Hundreds", "type": "Byte", "description": "Hundreds digit output"}, {"name": "Tens", "type": "Byte", "description": "Tens digit output"}, {"name": "Ones", "type": "Byte", "description": "Units digit output"}, {"name": "Min", "type": "Byte", "description": "The minimum non-0 value among the four digits"}, {"name": "error", "type": "Bool", "description": "Error status indicator\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}]}
