{"title": "Material Proportioning Process Control", "description": "Design a PLC program to control a material proportioning process that requires mixing three types of materials according to specific requirements and then delivering them to the next process through valve D. The system needs to support both manual and automatic operation modes and be able to safely stop all equipment when an emergency stop signal is triggered.\nControl requirements:\nEmergency Stop Logic: The #estop(=FALSE) signal is used for emergency stopping of all equipment.\nManual Mode: #opeMode=false, manually control the start/stop of valves A, B, C, D, and the mixing motor.\nAutomatic Mode: #opeMode=true, equipment operates automatically according to the process flow.\nImplement the emergency stop logic to ensure that all equipment stops immediately when the emergency stop signal is triggered.\nIn manual mode, manually control the start/stop of valves and the mixing motor.\nFor example, pressing the valve A start button valveAStart (triggering a rising edge) causes valve A to run (valveARun=TRUE); pressing the valve A start button valveAStart again (triggering a rising edge) stops valve A (valveARun=FALSE).\nIn automatic mode, implement the following control logic based on the process flow:\nPress the autoStart button to start the automatic process, first opening valve A.\nWhen the liquid level sensor #levelSensor reaches 50cm, close valve A and open valve B.\nWhen the liquid level sensor reaches 80cm, close valve B.\nBased on #processMode:\nIf #processMode=false, start the mixing motor; after receiving the mixing complete signal, stop the mixing motor, open valve D, and the automatic process ends.\nIf #processMode=true, open valve C; when the liquid level sensor reaches 100cm, close valve C, start the mixing motor; after receiving the mixing complete signal, stop the mixing motor, open valve D, and the automatic process ends.", "type": "FUNCTION_BLOCK", "name": "MaterialMixing", "input": [{"name": "estop", "type": "Bool", "description": "Emergency Stop Signal\nFALSE: Emergency stop triggered\nTRUE: No emergency stop triggered"}, {"name": "opeMode", "type": "Bool", "description": "Operation Mode\nFALSE: Manual Operation Mode\nTRUE: Automatic Operation Mode"}, {"name": "valveAStart", "type": "Bool", "description": "Valve A Start Button"}, {"name": "valveBStart", "type": "Bool", "description": "Valve B Start Button"}, {"name": "valveCStart", "type": "Bool", "description": "Valve C Start Button"}, {"name": "valveDStart", "type": "Bool", "description": "Valve D Start Button"}, {"name": "mixMotorStart", "type": "Bool", "description": "Mixing Motor Start Button"}, {"name": "autoStart", "type": "Bool", "description": "Automatic Start Button"}, {"name": "processMode", "type": "Bool", "description": "Process Mode"}, {"name": "levelSensor", "type": "Int", "description": "Liquid Level Sensor (unit cm)"}, {"name": "mixMotorComplete", "type": "Bool", "description": "Mixing Complete Signal"}], "output": [{"name": "valveARun", "type": "Bool", "description": "Valve A Run Command"}, {"name": "valveBRun", "type": "Bool", "description": "Valve B Run Command"}, {"name": "valveCRun", "type": "Bool", "description": "Valve C Run Command"}, {"name": "valveDRun", "type": "Bool", "description": "Valve D Run Command"}, {"name": "mixMotorRun", "type": "Bool", "description": "Mixing Motor Run Command"}]}
{"title": "Matrix Multiplication", "description": "Write a function to implement the multiplication of two matrices.\nThis function takes two variable-length two-dimensional floating-point arrays, matrix1 and matrix2, as input parameters.\nCalculation starts when execute=TRUE.", "type": "FUNCTION", "name": "MatrixMulti", "input": [{"name": "execute", "type": "Bool", "description": "Start calculation"}, {"name": "matrix1", "type": "Array[*, *] of Real", "description": "Input matrix 1"}, {"name": "matrix2", "type": "Array[*, *] of Real", "description": "Input matrix 2"}], "in/out": [{"name": "matrixResult", "type": "Array[*, *] of Real", "description": "Output calculation result matrix"}]}
{"title": "Conveyor Line Control System", "description": "Design a PLC program to control a conveyor line system, which is used to transport three different specifications of workpieces to designated warehouses and classify and store them based on the workpiece number and specification information.\nControl requirements:\nThe conveyor line starts from the initial station and passes through station 1, station 2, and station 3 sequentially.\nEach station has a detection element to detect the presence of a workpiece.\nWorkpieces have specification information and a unique number, and the system needs to transport the workpieces to the corresponding station based on the specification and store them in the corresponding warehouse.\nWorkpiece specification classification:\nSmall workpieces: Warehouse 1\nMedium workpieces: Warehouse 2\nLarge workpieces: Warehouse 3\nWhen the start station sensor SensorStart detects a workpiece and the start button StartButton is pressed, the conveyor belt run command ConveyorRun=true is triggered. According to the workpiece specification PartSpec, the workpiece is transported to the corresponding station, and when the corresponding station sensor (Sensor1, Sensor2, Sensor3) detects the workpiece, the conveyor belt stops ConveyorRun=false. After the corresponding station unloading is completed (corresponding UnloadComplete1, UnloadComplete2, UnloadComplete3 are TRUE), the workpiece number PartNumber is stored in the corresponding database (WarehouseDatabase1, WarehouseDatabase2, WarehouseDatabase3).", "type": "FUNCTION_BLOCK", "name": "ConveyorSystem", "input": [{"name": "StartButton", "type": "Bool", "description": "Start Button"}, {"name": "SensorStart", "type": "Bool", "description": "Start Station Sensor"}, {"name": "Sensor1", "type": "Bool", "description": "Station 1 Sensor"}, {"name": "Sensor2", "type": "Bool", "description": "Station 2 Sensor"}, {"name": "Sensor3", "type": "Bool", "description": "Station 3 Sensor"}, {"name": "UnloadComplete1", "type": "Bool", "description": "Station 1 Unloading Complete Signal"}, {"name": "UnloadComplete2", "type": "Bool", "description": "Station 2 Unloading Complete Signal"}, {"name": "UnloadComplete3", "type": "Bool", "description": "Station 3 Unloading Complete Signal"}, {"name": "PartSpec", "type": "Int", "description": "Workpiece Specification"}, {"name": "PartNumber", "type": "Int", "description": "Workpiece Number"}], "output": [{"name": "ConveyorRun", "type": "Bool", "description": "Conveyor Belt Running"}, {"name": "WarehouseDatabase1", "type": "Array[1..10] of Int", "description": "Warehouse 1 Database"}, {"name": "WarehouseDatabase2", "type": "Array[1..10] of Int", "description": "Warehouse 2 Database"}, {"name": "WarehouseDatabase3", "type": "Array[1..10] of Int", "description": "Warehouse 3 Database"}]}
{"title": "Multi-element Queue", "description": "Write a function block FB to implement the function of a first-in-first-out circular queue, which can support multiple elements for enqueue or dequeue operations, and the maximum length of the queue is variable.\nThe circular queue should be able to support the following operations:\n1. Enqueue operation (push): When there is enough space in the queue 'queue', multiple elements are added to the end of the queue. The elements to be added are specified by the starting position 'itemIndex' and the length 'itemLen' in the element array 'item'.\n2. Dequeue operation (pop): When there are enough elements in the queue 'queue', multiple elements are removed from the front of the queue, the number of elements to be removed is specified by 'itemLen', moved to 'item', starting from the position 'itemIndex'.\n3. Reset operation (reset): Clear all elements in the queue.\n4. Get queue information: Return the current number of elements and available space in the queue.", "type": "FUNCTION_BLOCK", "name": "RingQueueMultiItem", "input": [{"name": "push", "type": "Bool", "description": "Enqueue operation"}, {"name": "pop", "type": "Bool", "description": "Dequeue operation"}, {"name": "reset", "type": "Bool", "description": "Reset operation"}, {"name": "itemIndex", "type": "UDInt", "description": "Starting position of the elements to be enqueued or dequeued"}, {"name": "itemLen", "type": "UDInt", "description": "Length of the elements to be enqueued or dequeued"}], "output": [{"name": "queueUsed", "type": "DInt", "description": "Number of elements in the queue"}, {"name": "queueUnused", "type": "DInt", "description": "Remaining space in the queue"}], "in/out": [{"name": "item", "type": "Array[*] of Byte", "description": "Values to be added to the queue or returned from the queue"}, {"name": "queue", "type": "Array[*] of Byte", "description": "Array used as the queue"}]}
{"title": "Batch High-Low Word Swapping", "description": "Write a PLC program that receives two variable-length arrays of double words, dataIn and dataOut. The goal of the program is to swap the high and low words of each double word in dataIn and store them sequentially in dataOut. If the lengths of the two arrays are not the same, the processing is done according to the length of the shorter array. The program also outputs the number of double words actually swapped, swapNum\nFor example, if dataIn=[16#11223344], then dataOut=[16#33441122]", "type": "FUNCTION", "name": "SwapDWord", "input": [{"name": "dataIn", "type": "Array[*] of DWord", "description": "Array of double words to be swapped"}], "output": [{"name": "swapNum", "type": "DInt", "description": "Number of double words actually swapped"}], "in/out": [{"name": "dataOut", "type": "Array[*] of DWord", "description": "Array of double words after swapping"}]}
{"title": "Custom String Extraction", "description": "Write a function FC that, based on a given starting string and ending string, can extract the required substring from a character array.\nDescription:\n1. The function should traverse charArray, starting from the search position startPos to find the first occurrence of textBefore, and then find the position of the subsequent appearance of textAfter.\n2. If textBefore and textAfter are found, the function should extract the string between these two boundaries (if includeBeforeAfter=FALSE, the boundary characters themselves are not included, otherwise, they are included) and return this substring retString. It should also return the position of the first character of the extracted string in the array, and the length of the extracted string.", "type": "FUNCTION", "name": "GetString", "input": [{"name": "textBefore", "type": "String", "description": "The starting boundary of the string to be extracted"}, {"name": "textAfter", "type": "String", "description": "The ending boundary of the string to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "FALSE: Exclude boundaries\nTRUE: Include boundaries"}, {"name": "startPos", "type": "DInt", "description": "The starting position from which to search in the array, 0 corresponds to the first element"}], "output": [{"name": "retString", "type": "String", "description": "The extracted string"}, {"name": "position", "type": "DInt", "description": "The position of the first character of the extracted string in the array, 0 corresponds to the first element"}, {"name": "length", "type": "Int", "description": "The length of the extracted string"}], "in/out": [{"name": "charArray", "type": "Variant", "description": "The character or byte array in which to perform the search"}]}
{"title": "Parking Space Management System", "description": "Design a PLC program to control the parking management system for a factory's utility cart storage. The garage has 3 rows and 5 columns, totaling 15 parking spaces, which need to implement the control of carts' entry and exit, and allocate and release parking spaces according to specific principles.\nControl requirements:\nParking space information definition: Each parking space has two states, an occupied state (Boolean type) and vehicle data (integer type, vehicle number).\nCart entry rules:\nAllocate parking spaces by using the principle of using the latter row first and then the former row, and using the latter column first and then the former column.\nWhen entering, the cart provides the vehicle number information.\nThe parking space information needs to be updated to the new occupied state and vehicle number.\nCart exit rules:\nRelease parking spaces by the principle of using the former row first and then the latter row, and the former column first and then the latter column.\nThe occupied state of the exit parking space needs to be set to unoccupied and clear the vehicle number.", "type": "FUNCTION_BLOCK", "name": "TruckGarage", "input": [{"name": "enter", "type": "Bool", "description": "Entry operation request"}, {"name": "exit", "type": "Bool", "description": "Exit operation request"}, {"name": "VehicleNumber", "type": "Int", "description": "The vehicle number to be entered"}], "output": [{"name": "truck", "type": "Struct", "description": "The vehicle information to be exited", "fields": {"row": {"type": "Int", "description": "The row position of the vehicle to be exited"}, "col": {"type": "Int", "description": "The column position of the vehicle to be exited"}, "VehicleNumber": {"type": "Int", "description": "The vehicle number to be exited"}}}], "in/out": [{"name": "garage", "type": "Array[1..3, 1..5] of Struct", "description": "Garage information", "fields": {"Occupied": {"type": "Bool", "description": "TRUE: There is a vehicle in the parking space\nFALSE: There is no vehicle in the parking space"}, "VehicleNumber": {"type": "Int", "description": "The vehicle number in the parking space"}}}]}
{"title": "Flexible Processing Control", "description": "An automated production line consists of 5 workstations: numbered 1# to 5# from left to right. The 1# station is used for raw material loading, stations 2# to 4# are used for product processing, and the 5# station is used for finished product output and storage.\nThere is a motor in the production line, responsible for moving the product from one workstation to the next. Each workstation has a sensor (used to detect if the product has arrived).\nEach product has a different sequence and number of processing steps, specified by the process sequence 'processSequence'. The processSequence is an array type, storing the sequence numbers of the workstations, and the system automatically sends the raw materials to the corresponding workstation for processing based on the station number.\nControl requirements:\nAt the start of production, when the sensor at the 1# station (sensor1) detects the raw material, the start button at the 1# station (station1Start) is pressed. The system queries the first element of the process sequence 'processSequence', starts the conveyor to move the raw material to the corresponding workstation, and stops after delivery. Upon receiving the processing completion signal from the corresponding workstation (station2Complete to station4Complete), it continues to query the next element of the process sequence 'processSequence', determines the direction of the conveyor, and starts the conveyor (conveyorLeft, conveyorRight). This continues until the product is delivered to the 5# workstation.", "type": "FUNCTION_BLOCK", "name": "FlexibleProduction", "input": [{"name": "sensor1", "type": "Bool", "description": "Sensor at 1# station"}, {"name": "sensor2", "type": "Bool", "description": "Sensor at 2# station"}, {"name": "sensor3", "type": "Bool", "description": "Sensor at 3# station"}, {"name": "sensor4", "type": "Bool", "description": "Sensor at 4# station"}, {"name": "sensor5", "type": "Bool", "description": "Sensor at 5# station"}, {"name": "station1Start", "type": "Bool", "description": "Start button at 1# station"}, {"name": "station2Complete", "type": "Bool", "description": "Processing completion signal at 2# station"}, {"name": "station3Complete", "type": "Bool", "description": "Processing completion signal at 3# station"}, {"name": "station4Complete", "type": "Bool", "description": "Processing completion signal at 4# station"}], "output": [{"name": "conveyorLeft", "type": "Bool", "description": "Conveyor turns left"}, {"name": "conveyorRight", "type": "Bool", "description": "Conveyor turns right"}], "in/out": [{"name": "processSequence", "type": "Array[1..8] of USInt", "description": "Processing sequence"}]}
{"title": "Separate Bytes into Bits", "description": "Write a PLC program that receives a variable-length byte array byteArray and a variable-length boolean array bitArray. The goal of the program is to sequentially separate each byte in byteArray into bitArray, ensuring that all 8 bits of each byte are separated and stored. If the length of bitArray is insufficient to store all bits, only separate up to the maximum number of bits that bitArray can accommodate. The program also outputs the actual number of bytes separated splitByteNum\nFor example, if byteArray=[16#2D], then bitArray=[1,0,1,1,0,1,0,0]", "type": "FUNCTION", "name": "SplitByteArray", "input": [{"name": "byteArray", "type": "Array[*] of Byte", "description": "Byte array to be separated"}], "output": [{"name": "splitByteNum", "type": "DInt", "description": "Actual number of bytes separated"}], "in/out": [{"name": "bitArray", "type": "Array[*] of Bool", "description": "Separated boolean array"}]}
{"title": "Mechanical Arm Control", "description": "Design a PLC program to control an automated mechanical arm that performs handling tasks on the production line. The mechanical arm has six basic actions: down, up, left, right, grip, and release. The operating modes of the mechanical arm include four types: manual, single step, single cycle, and continuous.\nControl requirements:\n1. Manual mode: Allows the operator to control each action of the mechanical arm individually through the control panel, provided it is not yet in position. For example, pressing the down button (DownButton=1), if not at the down position (DownLimitSwitch=0), then move down (MoveDown=1); if at the down position (DownLimitSwitch=1), stop moving down. Releasing the down button also stops the movement down.\n2. Single step mode: The mechanical arm automatically executes one action according to the preset program, and the operator needs to confirm after each action is completed to execute the next action.\nThe initial position of the mechanical arm is at the top left.\nWhen the start button is pressed once, the mechanical arm executes the down command MoveDown, and stops after reaching the down position.\nWhen the start button is pressed again, the mechanical arm executes the grip command ActivateGrip, and stops after gripping.\nWhen the start button is pressed again, the mechanical arm executes the up command MoveUp, and stops after reaching the up position.\nWhen the start button is pressed, the mechanical arm executes the right command MoveRight, and stops after reaching the right position.\nWhen the start button is pressed, the mechanical arm executes the down command MoveDown, and stops after reaching the down position.\nWhen the start button is pressed, the mechanical arm executes the release command ActivateRelease, and stops after releasing.\nWhen the start button is pressed again, the mechanical arm executes the up command MoveUp, and stops after reaching the up position.\nWhen the start button is pressed again, the mechanical arm executes the left command MoveLeft, and stops after reaching the left position.\nThen starts the cycle again from the beginning\n3. Single cycle mode: The mechanical arm automatically completes a full handling cycle, including all preset actions, and stops at the end of the cycle waiting for the operator's instruction.\nThe initial position of the mechanical arm is at the top left, when the start button is pressed:\nThe mechanical arm first moves down, then grips after reaching the down position, moves up after gripping, moves right after reaching the up position, moves down after reaching the right position, releases after reaching the down position, moves up after releasing, moves left after reaching the up position, and stops after reaching the left position.\n4. Continuous mode: The initial position of the mechanical arm is at the top left, when the start button is pressed, the mechanical arm continuously executes the handling cycle of the single cycle mode.\n5. The emergency stop function can stop all actions of the mechanical arm at any time.", "type": "FUNCTION_BLOCK", "name": "MechanicalArm", "input": [{"name": "ManualMode", "type": "Bool", "description": "Manual mode"}, {"name": "SingleStepMode", "type": "Bool", "description": "Single step mode"}, {"name": "SingleCycleMode", "type": "Bool", "description": "Single cycle mode"}, {"name": "ContinuousMode", "type": "Bool", "description": "Continuous mode"}, {"name": "EmergencyStop", "type": "Bool", "description": "Emergency stop signal\nFALSE: Emergency stop triggered\nTRUE: No emergency stop triggered"}, {"name": "Start", "type": "Bool", "description": "Start operation"}, {"name": "DownButton", "type": "Bool", "description": "Down button"}, {"name": "UpButton", "type": "Bool", "description": "Up button"}, {"name": "LeftButton", "type": "Bool", "description": "Left button"}, {"name": "RightButton", "type": "Bool", "description": "Right button"}, {"name": "GripButton", "type": "Bool", "description": "Grip button"}, {"name": "ReleaseButton", "type": "Bool", "description": "Release button"}, {"name": "DownLimitSwitch", "type": "Bool", "description": "Down position limit switch"}, {"name": "UpLimitSwitch", "type": "Bool", "description": "Up position limit switch"}, {"name": "LeftLimitSwitch", "type": "Bool", "description": "Left position limit switch"}, {"name": "RightLimitSwitch", "type": "Bool", "description": "Right position limit switch"}, {"name": "GripLimitSwitch", "type": "Bool", "description": "Grip position limit switch"}, {"name": "ReleaseLimitSwitch", "type": "Bool", "description": "Release position limit switch"}], "output": [{"name": "MoveDown", "type": "Bool", "description": "Down command"}, {"name": "MoveUp", "type": "Bool", "description": "Up command"}, {"name": "MoveLeft", "type": "Bool", "description": "Left command"}, {"name": "MoveRight", "type": "Bool", "description": "Right command"}, {"name": "ActivateGrip", "type": "Bool", "description": "Grip command"}, {"name": "ActivateRelease", "type": "Bool", "description": "Release command"}]}
{"title": "Production Control", "description": "An automated production line consists of 5 workstations: material loading station, cleaning station, weighing station, firing station, and finished product station. The production line has a motor responsible for moving products from one workstation to the next, the sequence of the line is from the material loading station, cleaning station, weighing station, firing station, to the finished product station. Each workstation has a sensor (used to detect if the product has arrived).\nControl requirements:\n1. Mode Switching: The mode switch (Mode) is used to switch between manual and automatic modes of the production line. 0 = manual mode, 1 = automatic mode.\n2. Manual Mode: In manual mode, the forward rotation button (ForwardButton) controls the forward rotation of the motor, and the reverse rotation button (ReverseButton) controls the reverse rotation of the motor. Forward and reverse rotation operations need to be interlocked and cannot be performed simultaneously.\n3. Automatic Mode:\n   - When the material arrives at the material loading station, the SensorFeed detects the material, the motor starts forward rotation, and moves the material to the cleaning station.\n   - When the material arrives at the cleaning station, the SensorWash detects the material, the motor stops, and upon receiving the signal washComplete after cleaning is finished, the motor starts forward rotation, moving the material to the weighing station.\n   - When the material arrives at the weighing station, the SensorWeight detects the material, the motor stops, and upon receiving the signal after weighing is complete, the material is judged to be qualified based on the weight value. If the weight value is greater than or equal to 100 and less than or equal to 200, it is qualified, otherwise not.\n     If the material is unqualified, the rejection command kick is initiated.\n     If the material is qualified, the firing temperature is calculated based on the weight value. The calculation rule is that the weight value from 100 to 200 linearly corresponds to the temperature value from 500 to 550. The firing temperature firingTemp is output. At the same time, the motor starts forward rotation, moving the material to the firing station.\n   - When the product arrives at the firing station, the SensorFiring detects the material, the motor stops, and upon receiving the signal firingComplete after firing is finished, the motor starts forward rotation, moving the product to the finished product station.\n   - When the product arrives at the finished product station, the SensorOutput detects the product, the motor stops, and the completion light (CompletionLight) turns on, indicating that the product processing is complete. When the product is taken away, i.e., the SensorOutput does not detect the product, the completion light (CompletionLight) turns off.", "type": "FUNCTION_BLOCK", "name": "ProductionControl", "input": [{"name": "Mode", "type": "Bool", "description": "Used to switch the production line between manual and automatic modes, 0 = manual mode, 1 = automatic mode"}, {"name": "ForwardButton", "type": "Bool", "description": "Forward rotation button"}, {"name": "ReverseButton", "type": "Bool", "description": "Reverse rotation button"}, {"name": "SensorFeed", "type": "Bool", "description": "Sensor at the material loading station detecting the arrival of materials"}, {"name": "SensorWash", "type": "Bool", "description": "Sensor at the cleaning station detecting the arrival of materials"}, {"name": "SensorWeight", "type": "Bool", "description": "Sensor at the weighing station detecting the arrival of materials"}, {"name": "SensorFiring", "type": "Bool", "description": "Sensor at the firing station detecting the arrival of materials"}, {"name": "SensorOutput", "type": "Bool", "description": "Sensor at the finished product station detecting the arrival of products"}, {"name": "washComplete", "type": "Bool", "description": "Signal indicating completion of cleaning"}, {"name": "weightComplete", "type": "Bool", "description": "Signal indicating completion of weighing"}, {"name": "weight", "type": "Real", "description": "Weight value"}, {"name": "firingComplete", "type": "Bool", "description": "Signal indicating completion of firing"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "Output for motor forward rotation"}, {"name": "MotorReverse", "type": "Bool", "description": "Output for motor reverse rotation"}, {"name": "kick", "type": "Bool", "description": "Rejection output"}, {"name": "CompletionLight", "type": "Bool", "description": "Indicator light for product processing completion"}, {"name": "firingTemp", "type": "Real", "description": "Firing temperature"}]}
{"title": "Alarm Handling", "description": "In industrial automation systems, monitoring the status of equipment is crucial. When equipment parameters exceed the normal range, the system needs to issue an alarm. To avoid frequent triggering of alarms due to minor fluctuations in parameters, an alarm management system with hysteresis function needs to be implemented.\nWhen Value is greater than hiLevel, trigger high alarm hiAlarm.\nWhen Value is less than hiLevel-hystWindow, exit high alarm hiAlarm.\nWhen Value is less than loLevel, trigger low alarm loAlarm.\nWhen Value is greater than loLevel+hystWindow, exit low alarm loAlarm.\nIf loLevel is greater than or equal to hiLevel, output error error=true, status=16#8001, and exit the program\nIf the hysteresis window value hystWindow is greater than or equal to the deviation range between hiLevel and loLevel, output error error=true, status=16#8002", "type": "FUNCTION_BLOCK", "name": "AlarmProcess", "input": [{"name": "Value", "type": "Real", "description": "Input value"}, {"name": "hiLevel", "type": "Real", "description": "High limit alarm value"}, {"name": "loLevel", "type": "Real", "description": "Low limit alarm value"}, {"name": "hystWindow", "type": "Real", "description": "Hysteresis window"}], "output": [{"name": "hiAlarm", "type": "Bool", "description": "High limit alarm"}, {"name": "loAlarm", "type": "Bool", "description": "Low limit alarm"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred;\nTRUE: Error occurred during execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "Parity Check", "description": "Write a PLC program that receives a data of variable data type 'value', which can be of type word, Dword, or LWord. The goal of the program is to calculate the number of 1s in the binary value of the data 'value', referred to as countBitsTrue, and based on the set parity mode 'odd', return the parity check result. The program also outputs the number of 0s in the binary value of the data 'value', referred to as countBitsFalse.\n\nIf odd=FALSE, it is even parity: return the check result as TRUE when countBitsTrue is even, otherwise return the check result as FALSE.\nIf odd=TRUE, it is odd parity: return the check result as TRUE when countBitsTrue is odd, otherwise return the check result as FALSE.", "type": "FUNCTION", "name": "ParityVariant", "input": [{"name": "value", "type": "Variant", "description": "Data to be checked"}, {"name": "odd", "type": "Bool", "description": "Parity mode\nFALSE: Even Parity\nTRUE: Odd Parity"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of FALSEs in the data"}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of TRUEs in the data"}], "return_value": [{"type": "Bool", "description": "Parity check result"}]}
{"title": "Analog Batch Processing", "description": "In industrial automation applications, analog signals usually need to be converted into specific engineering units or ranges. Write a PLC program that can batch read analog input signals and convert them to specified range. The program receives an array of analog value inputs analogValues and an array for channel settings and conversion outputs channels, with the actual total number of channels specified by the input parameter count, starting from the first element of the array. Each channel is started for conversion by enable, and the conversion is performed according to different rules based on the measuringMode. \nWhen measuringMode=0, it is a non-temperature measurement mode: \nThis mode also needs to be converted based on the polarity bipolar, when bipolar=0, it is unipolar, then the analog input value analogValues from 0 to 27648 is linearly mapped to the lower limit loLIM to the upper limit hiLIM of the output value outputFile; when bipolar=1, it is bipolar, then the analog input value analogValues from -27648 to 27648 is linearly mapped to the lower limit loLIM to the upper limit hiLIM of the output value outputFile. \nWhen measuringMode=1, it is a standard temperature measurement mode: \nIn this mode, the output value outputFile is one-tenth of the analog input value analogValues. \nWhen measuringMode=2, it is a climatic temperature measurement mode: \nIn this mode, the output value outputFile is one-hundredth of the analog input value analogValues. \nThe program also requires checking the correctness of the input parameters: \nIf measuringMode is a value other than 0, 1, 2, then retVal=16#8001, and no conversion is performed for this channel; \nIf hiLIM is less than or equal to loLIM, then retVal=16#8002, and no conversion is performed for this channel.", "type": "FUNCTION_BLOCK", "name": "AIConvert", "input": [{"name": "count", "type": "DInt", "description": "Number of channels to be converted"}], "in/out": [{"name": "analogValues", "type": "Array[*] of Int", "description": "Array of analog values for each channel input"}, {"name": "channels", "type": "Array[*] of Struct", "description": "Settings and converted output values for each channel", "fields": [{"name": "enable", "type": "Bool", "description": "Enable conversion for this channel"}, {"name": "hiLIM", "type": "Real", "description": "Upper limit"}, {"name": "loLIM", "type": "Real", "description": "Lower limit"}, {"name": "bipolar", "type": "Bool", "description": "FALSE: Unipolar\nTRUE: Bipolar"}, {"name": "measuringMode", "type": "Int", "description": "0: Non-temperature measurement\n1: Standard temperature measurement\n2: Climatic temperature measurement"}, {"name": "retVal", "type": "Word", "description": "Status information"}, {"name": "outputValue", "type": "Real", "description": "Converted output value"}]}]}
{"title": "Merge Bytes", "description": "Write a PLC program that receives a variable-length byte array byteArray and a variable-length double word array dwordArray. The goal of the program is to merge each byte from byteArray into dwordArray in sequence. Following the principle of merging every 4 bytes into 1 double word, if the length of byteArray is not a multiple of 4, the remainder part will not be merged. If the length of dwordArray is insufficient to store all double words, the excess part will not be merged. The program also outputs the actual number of merged double words mergeDwordNum\nFor example, byteArray=[16#11, 16#22, 16#33, 16#44], then dwordArray =[16#44332211]", "type": "FUNCTION", "name": "MergeByteArray", "input": [{"name": "byteArray", "type": "Array[*] of Byte", "description": "Byte array to be merged"}], "output": [{"name": "mergeDwordNum", "type": "DInt", "description": "Actual number of merged double words"}], "in/out": [{"name": "dwordArray", "type": "Array[*] of DWord", "description": "Merged double word array"}]}
{"title": "Shift Register", "description": "Write a PLC program that receives an array of variable data types 'buffer' and performs shift operations on the array.\nIt can perform a left shift (shiftLeft=TRUE), where elements with higher index numbers move to lower index numbers.\nIt can also perform a right shift (shiftRight=TRUE), where elements with lower index numbers move to higher index numbers.\nThe length of the shift is determined by the shift range 'shiftRange'.\nEmpty positions after moving are covered with the initial value 'initialItem'.\nWhen the clear operation (clear=TRUE) is performed, all elements of the array are initialized to the initial value 'initialItem'.", "type": "FUNCTION_BLOCK", "name": "ShiftSequence", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Shift left"}, {"name": "shiftRight", "type": "Bool", "description": "Shift right"}, {"name": "shiftRange", "type": "UInt", "description": "Shift range"}, {"name": "clear", "type": "Bool", "description": "Clear operation"}, {"name": "initialItem", "type": "Variant", "description": "Initial value"}], "in/out": [{"name": "buffer", "type": "Variant", "description": "Array queue to be shifted"}]}
{"title": "Case Conversion of Characters", "description": "Write a PLC program that receives a string 'In' and performs conversion based on the 'mode' of conversion, then returns the converted string.\nIf mode=FALSE, it is the lowercase to uppercase mode, i.e., converts all lowercase characters in the string to uppercase.\nIf mode=TRUE, it is the opposite, i.e., converts all uppercase characters in the string to lowercase.\nFor example, In='ABCD1234efgh', mode=TRUE, then the returned string is 'abcd1234efgh'", "type": "FUNCTION", "name": "StringCovert", "input": [{"name": "In", "type": "String", "description": "The string to be converted"}, {"name": "mode", "type": "Bool", "description": "Conversion mode"}], "return_value": [{"type": "String", "description": "The converted string"}]}
{"title": "Multiple Data Type Selection Sort", "description": "Write a function block FB to implement an ascending order selection sort algorithm. This function block should accept an array of variable length and data types (including Sint, Int, DInt, LInt, Real, LReal, USint, UInt, UDInt, ULint) and write the sorted results back to the original array.\nBased on the program execution results, output the corresponding error status and status code:\n16#0000: No error occurred when executing FB\n16#8A01: The queue seq is not an array type", "type": "FUNCTION_BLOCK", "name": "SelectSort", "input": [{"name": "exe", "type": "Bool", "description": "Start sorting"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred\nTRUE: Error occurred while executing FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "seq", "type": "Variant", "description": "Array to be sorted"}]}
{"title": "Multi-Pump Switching Control System", "description": "In an industrial water supply system, there are 5 pumps, each of which can be controlled independently. The system needs to support both manual and automatic operating modes.\nBased on the value of the mode variable, switch to the corresponding operating mode.\nIn manual mode, control the start and stop of the selected pump based on the value of pumpGroup[1..5].selection.\nIn automatic mode, compare the priority of each pump, and automatically select the 3 pumps with higher priority for water supply according to the method of three in use and two on standby.", "type": "FUNCTION_BLOCK", "name": "MultiPumpCtrl", "input": [{"name": "mode", "type": "Bool", "description": "FALSE: Manual mode\nTRUE: Automatic mode"}, {"name": "start", "type": "Bool", "description": "Start button, used to start the manually selected or automatically selected pump"}, {"name": "stop", "type": "Bool", "description": "Stop button, used to stop all pumps"}], "in/out": [{"name": "pumpGroup", "type": "Array[1..5] of Struct", "description": "Pump group control structure", "fields": {"priority": {"type": "Int", "description": "Represents the priority of each pump, the higher the value, the higher the priority"}, "selection": {"type": "Bool", "description": "Whether the pump is selected in manual mode, TRUE=selected"}, "RunComd": {"type": "Bool", "description": "Pump run command, TRUE=run, FALSE=stop"}}}]}
{"title": "Recipe Management System Based on Doubly Linked List", "description": "A factory's production line needs to produce various products based on different recipes. The control center of the production line requires a recipe management system that allows operators to add recipe data.\nControl requirements:\nRecipe data should include raw material type, raw material ratio, and production temperature.\nThe system should allow the input of new recipe data and store it in the recipe database.\nNotes:\n1. Recipes are constructed using the Struct data type, which includes ingredientType, ingredientRatio, and productionTemperature. A doubly linked list is used to manage the recipe database, with each recipe having two pointers, Prev and Next. Prev points to the previous recipe position, and Next points to the next recipe position. Prev being -1 indicates the first record in the list, Next being -1 indicates the last record in the list, and if both pointers are -1, it indicates an empty record.\n2. When adding a recipe:\nIf the recipe database is an empty list, the new recipe is added to the first position of the array, and Next is set to point to the second position of the array; If the recipe database is not an empty list, the new recipe is added to the end of the list.", "type": "FUNCTION", "name": "AddRecipeLinkedList", "input": [{"name": "exe", "type": "Bool", "description": "Initiate adding recipe"}, {"name": "recipeAdded", "type": "Struct", "description": "Recipe to be added", "fields": [{"name": "ingredientType", "type": "Int", "description": "Type of raw material"}, {"name": "ingredientRatio", "type": "Real", "description": "Ratio of raw material"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}], "in/out": [{"name": "recipeList", "type": "Array[0..19] of Struct", "description": "Recipe database", "fields": [{"name": "Prev", "type": "DInt", "description": "Previous pointer, pointing to the array index of the previous recipe"}, {"name": "Next", "type": "DInt", "description": "Next pointer, pointing to the array index of the next recipe"}, {"name": "recipe", "type": "Struct", "description": "Recipe", "fields": [{"name": "ingredientType", "type": "Int", "description": "Type of raw material"}, {"name": "ingredientRatio", "type": "Real", "description": "Ratio of raw material"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}]}]}
