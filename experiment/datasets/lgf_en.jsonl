{"title": "Timer with various time switch points", "name": "LGF_TimerSwitch", "description": "This case is a timer function block that can set and reset output signals at specific times and dates on a daily, weekly, monthly, or yearly basis, as well as on specific times during weekdays or weekends. The inputs include the time, date, and mode for setting and resetting signals. The outputs include the output signal, the current local time, and error status. This function block can be used to control the operation of equipment at specific times.", "type": "FUNCTION_BLOCK", "input": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation)"}], "output": [{"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_MODE_SELECTED", "16#8600": "ERR_RD_LOC_T"}, "user_defined_types": [], "description_zh": "\n    // 该案例是一个定时器功能块，可以根据不同的模式在每天的、每周的、每月的或每年的特定时间点以及工作日或周末的特定时间点设置和重置输出信号。输入包括设置和重置信号的时间、日期和模式。输出包括输出信号、当前本地时间和错误状态。该功能块可以用于在特定时间点控制设备的操作。\n\n\n"}
{"title": "File Writing to UserFiles Folder", "name": "LGF_FileWrite", "description": "This function block implements the functionality of writing data as binary/serialized data streams to a file and storing the file in the UserFiles folder on the memory card of the PLC. It provides features such as executing file write operations, checking write progress, obtaining error status, and getting the length of the data written.\n\nWhen the input signal \"execute\" rises, the function block begins the file write operation. The write operation includes the following steps:\n1. Initialization: Check the file path and buffer boundaries, initialize the file handle.\n2. Parameter processing: Serialize data into the buffer array.\n3. File processing: Write the data from the buffer array to the file.\n\nThe function block provides the following outputs:\n- done: Indicates whether the command function has been successfully completed.\n- busy: Indicates whether the function block is performing the write operation.\n- error: Indicates whether an error has occurred during the execution of the function block.\n- status: Indicates the state or error identification of the function block.\n- dataLength: Indicates the length of the data written to the file (the serialized length of the data).\n- diagnostics: Provides detailed information about the block status or errors that occur.\n\nThe function block uses a state machine to manage the different stages of the write operation. It also provides an error handling mechanism to deal with various errors that may occur during the execution of the write operation.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: UserFiles/test.dat"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length written to file (serialized length of data)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set to write into file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8603": "ERR_DATA_SERIALIZE", "16#8604": "ERR_FILE_WRITE_INIT", "16#8605": "ERR_FILE_WRITE"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}], "description_zh": "\n该函数块实现将数据作为二进制/序列化数据流写入文件的功能，并将文件存储在PLC的内存卡中的UserFiles文件夹中。它提供了执行文件写入操作、检查写入进度、获取错误状态和写入数据长度等功能。\\n\\n当输入信号“execute”上升沿触发时，函数块开始执行文件写入操作。写入操作包括以下步骤：\\n1. 初始化：检查文件路径和缓冲区边界，初始化文件句柄。\\n2. 参数处理：将数据序列化到缓冲区数组中。\\n3. 文件处理：将缓冲区数组中的数据写入文件。\\n\\n函数块提供以下输出：\\n- done：指示命令功能是否已成功完成。\\n- busy：指示函数块是否正在执行写入操作。\\n- error：指示在执行函数块期间是否发生错误。\\n- status：指示函数块的状态或错误识别。\\n- dataLength：指示写入文件的数据长度（数据的序列化长度）。\\n- diagnostics：提供有关块状态或错误发生的详细信息。\\n\\n函数块使用状态机来管理写入操作的不同阶段。它还提供错误处理机制，以处理在执行写入操作期间可能发生的各种错误。\n\n\n"}
{"title": "Unix Time to DTL Time Converter", "name": "LGF_UnixTimeToDTL", "description": "A function FC that converts a Unix timestamp of type DInt to a datetime value of type DTL. The conversion is based on UTC time and does not consider time zones. The function only accepts timestamps after January 1, 1990.\n\nThe function accepts one input parameter of type DInt called timeUnix, which represents the Unix timestamp to be converted.\n\nThe function outputs two parameters:\n- error (Bool): Indicates whether an error occurred during the execution.\n- status (Word): Indicates the function's status for error identification.\n\nThe return value of the function is a DTL type of time, and if an error occurs, it returns 0 (error = true).\n\nPossible status codes are as follows:\n- 16#0000: STATUS_NO_ERROR, indicating no error occurred.\n- 16#6001: WARN_CONVERSION_LIMIT, indicating the timestamp is exactly at the lower limit of January 1, 1990.\n- 16#8000: ERR_TIME_BEFORE_1990, indicating the timestamp is before January 1, 1990.\n\nThe function first checks if the input Unix timestamp is less than January 1, 1990. If so, it sets the error flag and the status code to ERR_TIME_BEFORE_1990, then returns.\n\nNext, the function calculates the date part, converts the Unix timestamp to days, and uses the DATE_TO_DTL function to convert it to a DTL date.\n\nThen, the function calculates the time part, converts the remaining seconds to hours, minutes, and seconds, and assigns them to the hour, minute, and second fields of the DTL time, respectively.\n\nFinally, the function sets the output parameters error and status and returns the converted DTL time.", "type": "FUNCTION", "input": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error: 0 (error = true)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将数据类型为DInt的Unix时间戳转换为数据类型为DTL的日期时间值。转换的时间戳是基于UTC时间的，并且不考虑时区。该函数只接受1990年1月1日之后的时间。\n\n函数接受一个DInt类型的输入参数timeUnix，表示要转换的Unix时间戳。\n\n函数输出两个参数：\n- error (Bool): 表示在执行过程中是否发生错误。\n- status (Word): 表示函数的状态，用于错误识别。\n\n函数的返回值是一个DTL类型的时间，如果发生错误，则返回0 (error = true)。\n\n可能的状态代码如下：\n- 16#0000: STATUS_NO_ERROR，表示没有错误发生。\n- 16#6001: WARN_CONVERSION_LIMIT，表示时间戳刚好等于1990年1月1日的下限。\n- 16#8000: ERR_TIME_BEFORE_1990，表示时间戳在1990年1月1日之前。\n\n函数首先检查输入的Unix时间戳是否小于1990年1月1日。如果是，则设置错误标志并将状态码设置为ERR_TIME_BEFORE_1990，然后返回。\n\n接下来，函数计算日期部分，将Unix时间戳转换为天数，并使用DATE_TO_DTL函数将其转换为DTL日期。\n\n然后，函数计算时间部分，将剩余的秒数转换为小时、分钟和秒，并分别赋值给DTL时间的小时、分钟和秒字段。\n\n最后，函数设置输出参数error和status，并返回转换后的DTL时间。\n\n\n"}
{"title": "Fahrenheit to Kelvin Converter", "name": "LGF_FahrenheitToKelvin", "description": "A function FC that converts Fahrenheit temperature to Kelvin temperature. The function accepts a real number as an input parameter representing Fahrenheit temperature and returns a real number as an output parameter representing the corresponding Kelvin temperature. The conversion formula is: (°F - 32) × 5/9 + 273.15 = °K, where °F represents the Fahrenheit temperature and °K represents the Kelvin temperature.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Kelvin"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将华氏温度转换为开尔文温度。函数接受一个实数类型的输入参数，表示华氏温度，并返回一个实数类型的输出参数，表示相应的开尔文温度。转换公式为：(°F - 32) × 5/9 + 273.15 = °K。其中，°F代表华氏温度，°K代表开尔文温度。\n\n\n"}
{"title": "2D distance calculation between points", "name": "LGF_CalcDistance_2D", "description": "A function FC that calculates the distance between two points in a two-dimensional space. The function accepts four input parameters: x1, y1 are the coordinates of the first point, and x2, y2 are the coordinates of the second point. The calculated distance is the straight-line distance between the two points, which can be obtained by squaring the difference in the x-coordinates and the y-coordinates of the two points, adding them together, and then taking the square root. The return value of the function is a distance value of type LReal.\n\nExample:\nAssuming the coordinates of the first point are (3, 2) and the coordinates of the second point are (6, 5). The distance calculated by the function should be 5.", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算二维空间中两点之间的距离。函数接受四个输入参数：x1、y1表示第一个点的坐标，x2、y2表示第二个点的坐标。计算的距离是两点之间的直线距离，可以通过将两点的横坐标差和纵坐标差平方后相加，再开方得到。函数的返回值是一个LReal类型的距离值。\\n\\n示例：\\n假设第一个点的坐标为(3, 2)，第二个点的坐标为(6, 5)。函数计算得到的距离应为5。\n\n\n"}
{"title": "Matrix Comparator", "name": "LGF_MatrixCompare", "description": "A function FC that is used to compare two two-dimensional arrays (matrices) of the same size with LREAL type. The function compares each corresponding element in the two matrices, and returns true (TRUE) if all elements are equal, indicating that the two matrices are identical; if any mismatched elements are found, it immediately returns false (FALSE). Additionally, the function provides error flags and status codes for output, to handle errors when the dimensions of the matrices do not match. The status code is used to indicate the specific situation of mismatched dimensions of the matrices, such as the lower or upper bounds of rows or columns not matching.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First Matrix"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second Matrix"}], "return_value": [{"type": "Bool", "description": "TRUE: Both matrices are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于比较两个相同大小的LREAL类型的二维数组（矩阵）。该函数将比较两个矩阵中的每个对应元素，如果所有元素都相等，则返回真（TRUE），表示两个矩阵相同；如果发现任何不匹配的元素，则立即返回假（FALSE）。此外，该函数还提供了错误标志和状态码输出，以便在矩阵维度不匹配时进行错误处理。状态码用于指示矩阵维度不匹配的具体情况，例如行或列的下界或上界不匹配。\n\n\n"}
{"title": "Ramp Function Generator", "name": "LGF_RampCI", "description": "A function block FB, used to generate a linear interpolation speed curve based on the interpolation point table. This function block can handle operations such as start, hold, continue, and loop, as well as functions like updating time. It accepts an array containing setpoints and the time required to reach those setpoints as input, and generates an output value that linearly changes over the set time. The function block can also report the current step number, remaining time, total time, remaining total time, error status, and status code.", "type": "FUNCTION_BLOCK", "input": [{"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "contStepNbr", "type": "Int", "description": "Number of the next interpolation point for continuing"}, {"name": "contStepTime", "type": "Time", "description": "Remaining time to continue to the interpolation point"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "start", "type": "Bool", "description": "Run down the interpolation point table"}, {"name": "hold", "type": "Bool", "description": "Freeze/hold output at actual value"}, {"name": "continue", "type": "Bool", "description": "Continuing"}, {"name": "cyclicOP", "type": "Bool", "description": "Repeat interpolation point table cyclically"}, {"name": "updateTime", "type": "Bool", "description": "Update time values"}, {"name": "reset", "type": "Bool", "description": "Complete reset of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output value"}, {"name": "actTimeTable", "type": "Bool", "description": "Interpolation point table will be edited"}, {"name": "stepNumber", "type": "Int", "description": "Current interpolation point number"}, {"name": "remainTime", "type": "Time", "description": "Remaining time until reaching the next interpolation point"}, {"name": "totalTime", "type": "Time", "description": "Total time for setpoint table"}, {"name": "remainTotalTime", "type": "Time", "description": "Total remaining time"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeRampTimeTable", "description": "Interpolation point table."}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_FURTHER_CALLS", "16#8200": "ERR_OB_UNAVAILABLE", "16#8201": "ERR_ARRAY_LOWER_BOUND", "16#8400": "ERR_QRY_CINT"}, "user_defined_types": [{"name": "LGF_typeRampTimeTable", "description": "Data type for setup a speed curve", "member": [{"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Setpoint Value to reach by the interpolation curve"}, {"name": "time", "type": "Time", "default": "T#0s", "description": "Time until the interpolation point is reached"}]}], "description_zh": "\n一个函数块FB，用于根据插值点表生成线性插值的速度曲线。该函数块可以处理启动、保持、继续、循环操作以及更新时间等功能。它接收一个包含设定值和达到该设定值所需时间的数组作为输入，并生成一个输出值，该值在设定的时间内线性变化。函数块还可以报告当前步骤编号、剩余时间、总时间、剩余总时间以及错误状态和状态代码。\n\n\n"}
{"title": "Unsigned Integer Histogram Calculation Function Block", "name": "LGF_Histogram_UDInt", "description": "A function block FB for calculating the probability distribution histogram of a series of unsigned integer (UDInt) data. The histogram displays the frequency distribution of samples through classes. The function block accepts a boolean execution signal (execute) and an unsigned integer type (UInt) for the number of classes (numberOfClasses) as inputs. It also accepts an array containing the data series (values) as an input/output parameter. The outputs of the function block include a boolean error signal (error), a word type status (status), a word type subfunction status (subfunctionStatus), a two-dimensional array containing relative frequencies and class centers (histValues), an array specifying axis values (axis), and a real number returning the calculated class width (classWidth). Status codes include execution completion, no call state, first call, Shell sort error, and incorrect number of classes, etc. The function block uses a Shell sort function named LGF_ShellSort_UDInt to sort the data and calculates the histogram-related parameters based on the sorted data.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_UDInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算包含无符号整数（UDInt）数据系列的概率分布直方图。该直方图通过类（class）显示样本的频率分布。函数块接受一个布尔类型的执行信号（execute）和一个无符号整数类型（UInt）的类数量（numberOfClasses）作为输入。它还接受一个包含数据系列的数组（values）作为输入/输出参数。函数块的输出包括一个布尔类型的错误信号（error）、一个字类型的的状态（status）、一个字类型的子函数状态（subfunctionStatus）、一个包含相对频率和类中心的二维数组（histValues）、一个指定轴值的数组（axis）以及一个返回计算类宽度的实数（classWidth）。状态码包括执行完成、无调用的状态、第一次调用、Shell排序错误以及错误类数量等。该函数块使用了一个名为LGF_ShellSort_UDInt的Shell排序函数来进行数据排序，并根据排序后的数据计算直方图的相关参数。\n\n\n"}
{"title": "String Lower Case Converter", "name": "LGF_ToLower", "description": "This is a function FC that converts all uppercase letters in a string to their corresponding lowercase letters. The function takes a string as an input parameter and returns the converted string as a result.\n\nExample:\nIf the input string is \"Hello, World!\", the function should return the string \"hello, world!\" as the conversion result.", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，该函数能够将字符串中的所有大写字母转换为对应的小写字母。函数接受一个字符串作为输入参数，并返回转换后的字符串作为结果。\\n\\n示例：\\n假设输入字符串为\\\"Hello, World!\\\"，函数应返回字符串\\\"hello, world!\\\"作为转换结果。\n\n\n"}
{"title": "DInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_DInt", "description": "A function FC that searches for the minimum and maximum values in an array of DInt type and returns their indices within the array. The function accepts an array of DInt type as input and outputs four values: the minimum value, the index of the minimum value, the maximum value, and the index of the maximum value. The function first validates the bounds of the input array, then starts iterating from the second element of the array, comparing each element to record the minimum and maximum values and their indices. Finally, it copies the found minimum and maximum values and their indices to the output parameters.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "DInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于在DInt类型的数组中查找最小值和最大值，并返回这些值在数组中的索引。函数接受一个DInt类型的数组作为输入，并输出四个值：最小值、最小值索引、最大值和最大值索引。函数首先验证输入数组的上下界，然后从数组的第二个元素开始遍历，比较每个元素，记录下最小和最大值及其索引。最后，将找到的最小和最大值及其索引复制到输出参数中。\n\n\n"}
{"title": "Linear Scaler for Input Variable", "name": "LGF_ScaleLinear", "description": "The function FC is used to scale the input variable (of type LReal) through a linear equation. The function accepts an input value x, as well as the coordinates of two points (x1, y1) and (x2, y2) of the linear function, and the minimum and maximum values of the output y (yMin and yMax). The function scales the input value x according to the linear equation y = m*x + t, where m is the slope and t is the y-intercept. If the difference between x1 and x2 is less than a very small precision value PRECISION multiplied by the absolute value of x1, the slope is considered to be close to 0, in which case a special case handling is used, which is to return y1 directly. The scaled y value will be restricted between yMin and yMax. If the y value exceeds this range, the function will limit the y value to yMin or yMax, and set the corresponding status code and error flag. The function returns the scaled output value y, and outputs the status code and error flag. The status code is used to indicate whether an error or warning has occurred, for example, if the output y value is restricted to yMin or yMax. Note: The ENO mechanism is not used in this function and is强制 set to true.", "type": "FUNCTION", "input": [{"name": "x", "type": "LReal", "description": "Input value `x` to be scaled"}, {"name": "x1", "type": "LReal", "description": "Point 1 (P1) -`x` coordinate of the linear function"}, {"name": "y1", "type": "LReal", "description": "Point 1 (P1) -`y` coordinate of the linear function"}, {"name": "x2", "type": "LReal", "description": "Point 2 (P2) -`x` coordinate of the linear function"}, {"name": "y2", "type": "LReal", "description": "Point 2 (P2) -`y` coordinate of the linear function"}, {"name": "yMin", "type": "LReal", "description": "Lower limit value of the output"}, {"name": "yMax", "type": "LReal", "description": "High limit value of the output"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Scaled output value `y`"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#6001": "WARN_Y_LIMITED_TO_YMIN", "16#6002": "WARN_Y_LIMITED_TO_YMAX", "16#8200": "ERR_LOW_LIM_OVER_UP_LIM"}, "user_defined_types": [], "description_zh": "\n该函数FC用于将输入变量（LReal类型）通过线性方程进行缩放。函数接受输入值x，以及线性函数的两个点坐标（x1, y1）和（x2, y2），还有输出y的最小值yMin和最大值yMax。函数将输入值x按照线性方程y = m*x + t进行缩放，其中m是斜率，t是截距。如果x1和x2的差值小于一个非常小的精度值PRECISION乘以x1的绝对值，则认为斜率接近于0，此时使用一个特殊情况的处理，即直接返回y1。缩放后的y值将被限制在yMin和yMax之间。如果y值超出了这个范围，函数将y值限制为yMin或yMax，并设置相应的状态码和错误标志。函数返回缩放后的输出值y，并输出状态码和错误标志。状态码用于指示是否发生了错误或警告，例如输出y值被限制在yMin或yMax。注意：ENO机制在这个函数中没有使用，强制设置为true。\n\n\n"}
{"title": "Rate of Change Limiter", "name": "LGF_LimRateOfChangeCI", "description": "A function block FB that restricts the rate of change of input variables, converting a step function into a ramp function. It accepts an input signal (of type LReal) and limits its rate of change to ensure that the output signal's variation does not exceed the set rate of change. If a default output value is enabled, the output variable will be assigned the default value. The function block also handles OB calls and reads the OB's cycle time for calculations. If the rate of change of the input is set to a negative value, or if the OB is not available, the function block will generate an error message. Ultimately, the function block outputs the restricted value and may report an error status.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "setChangeRate", "type": "LReal", "description": "Rate of change of ramp function"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "delayedValue", "type": "LReal", "description": "Output variable"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块限制输入变量的变化速率，将一个阶跃函数转换为斜坡函数。它接受一个输入信号（LReal类型），并限制其变化率，确保输出信号的变化不会超过设定的变化率。如果启用了默认输出值，则输出变量将被赋予默认值。函数块还处理OB调用，并读取OB的循环时间以进行计算。如果输入的变化率设置为负值，或者OB不可用，函数块将生成错误信息。最终，函数块将输出限制后的值，并可能报告错误状态。\n\n\n"}
{"title": "Polynomial Smoothing Function Block", "name": "LGF_SmoothByPolynomFB", "description": "A function block FB that cyclically smooths input values using a third-order polynomial. It accepts a boolean enable input and an insert signal. When the insert signal rises, the input value is stored, and after storing five values, a smoothed value is calculated.\\n\\nStatus codes:\\n16#7000: STATUS_NO_CALL - The function block is waiting to be activated through the `enable` parameter.\\n16#7001: STATUS_FIRST_CALL - First call to FB after enabling.\\n16#7002: STATUS_SUBSEQUENT_CALL - Processing activity, subsequent call to FB.\\n16#7010: STATUS_NOT_ENOUGH_VALUES - The function block needs five (5) values to calculate the smoothed value.\\n\\nThe function block uses an array to store input values and updates this array on each rising edge of the insert signal. When enough values are stored in the array, it calculates a smoothed value and outputs it. If an error occurs, the function block sets an error output (error) and returns the corresponding status code (status).", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a smoothed value."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块通过使用三阶多项式对输入值进行循环平滑处理。它接受一个布尔型使能输入（enable）和一个插入信号（insert），当插入信号发生上升沿时，输入的数值（value）将被存储，并在存储了五个数值后计算出平滑后的数值（smoothedValue）。\\n\\n状态码：\\n16#7000：STATUS_NO_CALL：函数块等待通过参数`enable`激活。\\n16#7001：STATUS_FIRST_CALL：使能后第一次调用FB。\\n16#7002：STATUS_SUBSEQUENT_CALL：处理活动，后续调用FB。\\n16#7010：STATUS_NOT_ENOUGH_VALUES：函数块需要五个（5）个值来计算平滑值。\\n\\n函数块使用一个数组来存储输入值，并在每次插入信号发生上升沿时更新这个数组。当数组中存储了足够的值时，它将计算出一个平滑值，并输出。如果发生错误，函数块将设置错误输出（error）并返回相应的状态码（status）。\n\n\n"}
{"title": "Kelvin to Fahrenheit Converter", "name": "LGF_KelvinToFahrenheit", "description": "A function FC that converts temperature values from Kelvin (°Kelvin) to Fahrenheit (°Fahrenheit). The conversion formula is: Fahrenheit temperature = (Kelvin temperature - 273.15) * 1.8 + 32. Where 273.15 is the value of the freezing point of water in the Kelvin scale, 1.8 is the coefficient of proportionality between Fahrenheit and Kelvin temperatures, and 32 is the offset of the Fahrenheit temperature.\n\nExample:\nAssuming the input Kelvin temperature is 300K, the converted Fahrenheit temperature is 80.33°F.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Fahrenheit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将温度值从开尔文（°Kelvin）转换为华氏温度（°Fahrenheit）。转换公式为：华氏温度 = （开尔文温度 - 273.15）* 1.8 + 32。其中，273.15是水的冰点在开尔文温标下的值，1.8是华氏温度和开尔文温度的比例系数，32是华氏温度的偏移量。\\n\\n示例：\\n假设输入的开尔文温度为300K，则转换后的华氏温度为80.33°F。\n\n\n"}
{"title": "Temperature Unit Converter", "name": "LGF_ConvertTemperature", "description": "A function FC that converts temperature values from one unit to another based on given mode parameters. It supports the following conversion modes:\n\n1. From Celsius to Fahrenheit\n2. From Fahrenheit to Celsius\n3. From Celsius to Kelvin\n4. From Kelvin to Celsius\n5. From Fahrenheit to Kelvin\n6. From Kelvin to Fahrenheit\n7. From Rankine to Kelvin\n8. From Kelvin to Rankine\n\nIf the given mode parameter is incorrect, the function will return an error status ERR WRONG MODE.", "type": "FUNCTION", "input": [{"name": "mode", "type": "Int", "description": "Conversion mode"}, {"name": "value", "type": "Real", "description": "Temperature value to be converted"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature result"}], "status_codes": {"16#8200": "ERR_WRONG_MODE"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据给定的模式参数，将温度值从一个单位转换为另一个单位。支持以下转换模式：\\n\\n1. 从摄氏度转换为华氏度\\n2. 从华氏度转换为摄氏度\\n3. 从摄氏度转换为开尔文\\n4. 从开尔文转换为摄氏度\\n5. 从华氏度转换为开尔文\\n6. 从开尔文转换为华氏度\\n7. 从兰金转换为开尔文\\n8. 从开尔文转换为兰金\\n\\n如果给定的模式参数不正确，函数将返回错误状态ERR_WRONG_MODE。\n\n\n"}
{"title": "LIFO Buffer Management", "name": "LGF_LIFO", "description": "A function block FB implements the management of a Last-In-First-Out (LIFO) stack buffer. This function block can store incoming data and output the latest/recently unprocessed data.\n\nThe function block supports the following operations:\n1. Push operation: Adds an element to the top of the stack.\n2. Pop operation: Removes an element from the top of the stack and returns its value.\n3. Peek operation: Views the element at the top of the stack without removing it from the stack.\n4. Reset operation: Initializes the stack buffer (resets indices and counters).\n5. Clear operation: Clears the stack buffer and initializes it with an initial value initialItem (resets indices and counters).\n\nThe function block also provides some output parameters so that users can understand the status of the stack buffer, such as:\n- error: Whether an error occurred during the execution of FB\n- status: The status of FB, error identification\n- subFunctionStatus: Return value or status of called FBs, FCs, and system blocks\n- elementCount: The number of elements in the stack buffer\n- isEmpty: Whether the stack buffer is empty\n\nThe function block uses a variant array as the stack buffer, allowing it to store data of any data type.", "type": "FUNCTION_BLOCK", "input": [{"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value initialItem (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: 0 / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_LAST_ENTRY", "16#8612": "ERR_POP_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，实现了一个后进先出（LIFO）堆栈缓冲区的管理。该函数块可以存储传入的数据，并输出最新/最近未被处理的数据。\n\n该函数块支持以下操作：\n1. 入栈操作（push）：将一个元素添加到堆栈的顶部。\n2. 出栈操作（pop）：从堆栈顶部移除一个元素，并返回该元素的值。\n3. 堆栈查看操作（peek）：查看堆栈顶部的元素，但不从堆栈中移除它。\n4. 重置操作（reset）：初始化堆栈缓冲区（重置索引和计数器）。\n5. 清除操作（clear）：清除堆栈缓冲区，并用初始值initialItem初始化它（重置索引和计数器）。\n\n该函数块还提供了一些输出参数，以便用户可以了解堆栈缓冲区的状态，例如：\n- error：在执行FB期间是否发生错误\n- status：FB的状态，错误识别\n- subFunctionStatus：调用FB、FC和系统块的返回值或状态\n- elementCount：堆栈缓冲区中的元素数量\n- isEmpty：堆栈缓冲区是否为空\n\n该函数块使用了一个变体数组作为堆栈缓冲区，因此可以存储任何数据类型的数据。\n\n\n"}
{"title": "Pulse Generator", "name": "LGF_Impulse", "description": "This function block FB is capable of generating pulse signals with a given frequency. The pulse signal lasts for one cycle within each control cycle. If the input frequency is less than or equal to 0, the pulse generator is disabled, the output pulse signal is false, and the countdown time is 0. If the input frequency is greater than 0, the FB calculates the pulse cycle based on the input frequency and outputs a pulse signal within each cycle. Additionally, the FB calculates and outputs the time before the next pulse signal is generated (countdown). The timer used is a self-restarting timer, whose duration is calculated from the input frequency. The outputs include the pulse signal (impulse) and the countdown time (countdown).", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}], "output": [{"name": "impulse", "type": "Bool", "description": "Impulse signal output"}, {"name": "countdown", "type": "Time", "description": "Time until next pulse"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块FB能够生成具有给定频率的脉冲信号。脉冲信号在每个控制周期内持续一个周期。如果输入的频率小于或等于0，则脉冲发生器被禁用，输出脉冲信号为假，倒计时时间为0。如果输入频率大于0，则FB会根据输入频率计算脉冲周期，并在每个周期内输出一个脉冲信号。同时，FB还会计算并输出下一个脉冲信号产生之前的时间（倒计时）。使用的计时器是自重启计时器，其时间由输入频率计算得出。输出包括脉冲信号（impulse）和倒计时时间（countdown）。\n\n\n"}
{"title": "CRC-8 Calculator", "name": "LGF_CalcCRC8", "description": "The function LGF_CalcCRC8 implements the CRC-8 algorithm to calculate the Cyclic Redundancy Check (CRC) value of a data stream (array). The function uses an 8-bit generator polynomial (mask) for CRC computation. Users can specify the starting value for the calculation (initValue), the generator polynomial (mask), and the number of data elements to be included in the computation (noOfElements). The function iterates over the input array, performing CRC calculation for each byte, and returns the final CRC value. If the specified number of elements exceeds the actual size of the array, the function sets an error flag and returns an error status code ERR_NO_OF_ELEMENTS (16#8400). Otherwise, the function executes successfully and returns the calculated CRC value with a status code of STATUS_NO_ERROR (16#0000).", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n该函数LGF_CalcCRC8实现了CRC-8算法，用于计算一个数据流（数组）的循环冗余校验（CRC）值。函数使用8位生成多项式（掩码）进行CRC计算。用户可以指定计算的起始值（initValue）、生成多项式（mask）以及要参与计算的数据元素数量（noOfElements）。函数会遍历输入数组，对每个字节执行CRC计算，并返回最终的CRC值。如果指定的元素数量超出数组实际大小，函数会设置错误标志并返回错误状态码ERR_NO_OF_ELEMENTS (16#8400)。否则，函数会成功执行并返回计算出的CRC值，状态码为STATUS_NO_ERROR (16#0000)。\n\n\n"}
{"title": "4-Byte to DWord Merger", "name": "LGF_MergeBytesToDWord", "description": "The function FC combines four single-byte data (byte3, byte2, byte1, byte0) into a double word (DWord) data. In the process of combination, byte3 serves as the most significant byte (MSB), and byte0 as the least significant byte (LSB). The function does not perform error handling on the input data, assuming that the input data is always valid.", "type": "FUNCTION", "input": [{"name": "byte3", "type": "Byte", "description": "Input Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Input Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Input Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Byte sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC将四个单字节数据（byte3、byte2、byte1、byte0）合并成一个双字（DWord）数据。在合并过程中，byte3作为最高字节（MSB），byte0作为最低字节（LSB）。函数不对输入数据进行错误处理，假设输入数据总是有效的。\n\n\n"}
{"title": "Advanced CRC-32 Calculator", "name": "LGF_CalcCRC32Advanced", "description": "A function FC that calculates the Cyclic Redundancy Check (CRC) value of an input data stream based on the CRC-32 algorithm. The function supports multiple parameters, including an initial value, a mask (generator polynomial), a final XOR value, input/output reflection flags, and the number of data elements to be used for CRC calculation. The function checks whether the number of input data elements exceeds the size of the array and reflects input bytes and/or results as needed during the calculation process. The final calculated CRC value can be XORed with the final XOR value. The function returns the calculated CRC value and sets error flags and status codes to indicate whether there were any errors during the calculation process.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "DWord", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数根据CRC-32算法计算输入数据流的循环冗余校验（CRC）值。该函数支持多种参数，包括初始值、掩码（生成多项式）、最终异或值、输入/输出反射标志以及要用于CRC计算的数据元素数量。函数会检查输入数据元素的数量是否超出数组的大小，并在计算过程中根据需要反射输入字节和/或结果。最终计算出的CRC值可以与最终异或值进行异或操作。函数返回计算出的CRC值，并设置错误标志和状态代码以指示计算过程中是否存在错误。\n\n\n"}
{"title": "2-Word to DWord Merger", "name": "LGF_MergeWordsToDWord", "description": "The function \"LGF_MergeWordsToDWord\" merges two Word-type input variables into one DWord-type output variable. Among them, the input variable word1 serves as the most significant word (MSB) of the merged DWord, and the input variable word0 serves as the least significant word (LSB). The function does not perform error handling, so ENO is always TRUE. The function completes the merging of two Words into a DWord through direct assignment operations.", "type": "FUNCTION", "input": [{"name": "word1", "type": "Word", "description": "Input Word 1 - MSB"}, {"name": "word0", "type": "Word", "description": "Input Word 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Word sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数\"LGF_MergeWordsToDWord\"将两个单字（Word）类型的输入变量合并成一个双字（DWord）类型的输出变量。其中，输入变量word1作为合并后的双字的高位字（MSB），输入变量word0作为合并后的双字的低位字（LSB）。函数不进行错误处理，因此ENO始终为TRUE。函数通过直接赋值操作完成两个单字到双字的合并。\n\n\n"}
{"title": "String Upper Case Converter", "name": "LGF_ToUpper", "description": "A function FC that converts all lowercase letters in the input string to uppercase. The function accepts a string as an input parameter and returns the transformed string. Non-alphabetic characters are not processed and remain unchanged.", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数将输入字符串中的所有小写字母转换为大写字母。函数接受一个字符串作为输入参数，并返回转换后的字符串。函数不处理非字母字符，它们保持不变。\n\n\n"}
{"title": "German public holiday detection", "name": "LGF_IsGermanHoliday", "description": "A function FC that determines whether a given date is a German public holiday. The function takes into account all German public holidays, including some regional ones, which can be selectively enabled or disabled through input parameters.\n\nThe function first calculates the number of days from the given date to January 1st of the same year, then calculates the date of Easter Sunday for that year, and based on these two calculations, determines whether the given date is a public holiday.\n\nExample:\nAssuming the input date is October 3, 2023, and all regional holiday parameters are set to TRUE.\nThe function should return TRUE, because October 3, 2023, is German Unity Day, which is a German public holiday.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date, which has to be evaluated"}, {"name": "threeKings", "type": "Bool", "description": "Three Kings"}, {"name": "roseMonday", "type": "Bool", "description": "Rose Monday"}, {"name": "ascension", "type": "Bool", "description": "Ascension"}, {"name": "corpusChristi", "type": "Bool", "description": "Corpus Christi"}, {"name": "augsburgerFriedensfest", "type": "Bool", "description": "Augsburger Friedensfest"}, {"name": "assumptionOfMary", "type": "Bool", "description": "Assumption Of Mary"}, {"name": "reformationDay", "type": "Bool", "description": "Reformation Day"}, {"name": "allSaintDay", "type": "Bool", "description": "All Saint Day"}, {"name": "bussUndBettag", "type": "Bool", "description": "Day of Prayer and Repentance (Buss und Bettag)"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "If the date at the input parameter is a public holiday - returning TRUE, otherwise returning FALSE"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数用于判断给定的日期是否为德国的公共假日。该函数考虑了德国所有的公共假日，包括一些区域性的假日，这些区域性的假日可以通过输入参数选择性地启用或禁用。\\n\\n函数首先计算给定日期距离当年1月1日的天数，然后计算当年复活节星期日的日期，并基于这两个计算结果判断给定日期是否为公共假日。\\n\\n示例：\\n假设输入日期为2023年10月3日，所有的区域性假日参数都设置为TRUE。\\n函数应返回TRUE，因为2023年10月3日是德国的统一日，是德国的公共假日。\n\n\n"}
{"title": "DWord to 2-Word Splitter", "name": "LGF_SplitDWordToWords", "description": "The function \"LGF_SplitDWordToWords\" splits a double word (DWord) type input variable into two single word (Word) type output variables. The input double word variable contains a 32-bit bit sequence, which the function divides into two 16-bit parts. The first output word (word1) contains the higher 16 bits of the double word (i.e., the Most Significant Word, MSW), while the second output word (word0) contains the lower 16 bits of the double word (i.e., the Least Significant Word, LSW). This function does not have error handling because it assumes that the split operation always succeeds.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "word1", "type": "Word", "description": "Output Word 1 - MSW"}, {"name": "word0", "type": "Word", "description": "Output Word 0 - LSW"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数\"LGF_SplitDWordToWords\"将一个双字（DWord）类型的输入变量分割成两个单字（Word）类型的输出变量。输入的双字变量包含一个32位的位序列，该函数将其分为两个16位的部分。输出的第一个单字（word1）包含双字的高16位（即Most Significant Word，MSW），而输出的第二个单字（word0）包含双字的低16位（即Least Significant Word，LSW）。这个函数没有错误处理，因为它认为分割操作总是成功的。\n\n\n"}
{"title": "DInt range random number generation", "name": "LGF_Random_DInt", "description": "A function FC that generates a random number within the range of DInt each time it is called. The function generates a random number by reading the system time and uses the nanosecond part of the system time to create a random starting value. This starting value is then converted into a random number within the DInt range through bit manipulation. If there is an error while reading the system time, the function will return an error flag and a status code. A status code of 16#0000 indicates that the function executed without errors, while 16#8600 indicates an error occurred while reading the system time.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random number in the DInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数在每次调用时生成一个范围为DInt的随机数。函数通过读取系统时间来生成随机数，并使用系统时间的纳秒部分来创建一个随机的起始值。然后，这个起始值通过位操作转换为一个DInt范围内的随机数。如果读取系统时间时出现错误，函数将返回一个错误标志和状态码。状态码16#0000表示函数执行没有错误，16#8600表示读取系统时间时出现错误。\n\n\n"}
{"title": "DInt to String Converter", "name": "LGF_IntToString", "description": "A function FC that converts a 32-bit signed integer (DInt) to a string representation. The function accepts a DInt type input value and returns a string that represents the textual form of the input integer, including the positive or negative sign. For example, if the input value is 123, it returns the string \"123\"; if the input value is -456, it returns the string \"-456\".", "type": "FUNCTION", "input": [{"name": "value", "type": "DInt", "description": "Double-Integer value to convert"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Converted value as string. Example: '+16927'"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将32位有符号整型数（DInt）转换为字符串形式。函数接受一个DInt类型的输入值，并返回一个字符串，该字符串表示输入整数的文本形式，包括正负号。例如，输入值为123，则返回字符串\\\"123\\\"；输入值为-456，则返回字符串\\\"-456\\\"。\n\n\n"}
{"title": "Natural number factorial calculation", "name": "LGF_GetFactorial", "description": "Here is a Python function named FC that calculates the factorial of a natural number between 0 and 12 and returns the result along with an error indicator:\n\n```python\ndef FC(n):\n    factorials = {\n        0: 1,\n        1: 1,\n        2: 2,\n        3: 6,\n        4: 24,\n        5: 120,\n        6: 720,\n        7: 5040,\n        8: 40320,\n        9: 362880,\n        10: 3628800,\n        11: 39916800,\n        12: 479001600\n    }\n    if 0 <= n <= 12:\n        return factorials[n], False\n    else:\n        return None, True\n```", "type": "FUNCTION", "input": [{"name": "naturalNumber", "type": "Int", "description": "Natural number (0..12)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Calculated factorial"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8101": "ERR_WRONG_VALUE_RANGE"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数计算自然数（0到12之间）的阶乘，并返回计算结果。函数能够处理输入值在0到12之间的自然数，如果输入值超出这个范围，函数将返回一个错误状态。阶乘的计算是通过预定义的常量来实现的，这些常量对应于0到12的阶乘值。函数的输出包括计算结果以及一个错误指示，如果输入值在有效范围内，则错误指示为FALSE，否则为TRUE。\n\n\n"}
{"title": "Odd Parity Checker for DWord", "name": "LGF_IsParityOdd", "description": "A function FC that checks the parity of a double word (DWord) type input variable. The function calculates the number of bits set to `TRUE` in the input variable, and returns `TRUE` if the number of bits is odd. The function uses bit operations to efficiently calculate the parity, avoiding the tedious process of checking each bit individually. The function does not use the ENO mechanism because it is impossible to generate an error during execution.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is odd"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数用于检查一个双字（DWord）类型输入变量的奇偶性。函数通过计算输入变量中置为`TRUE`的位数，如果位数是奇数，则返回`TRUE`。函数使用位操作来高效地计算奇偶性，避免了逐位检查的繁琐过程。函数不使用ENO机制，因为在执行过程中不可能产生错误。\n\n\n"}
{"title": "GPS-based Sunrise and Sunset Time Determination", "name": "LGF_AstroClock", "description": "This function block (FB) is used to calculate the sunrise and sunset times based on the local time at a specific location on Earth. It accepts GPS position information and allows for custom sunrise and sunset time offsets. The FB will output valid calculation results and indicate whether it is currently daytime.\n\nInput parameters include:\n- enable: Activate the functionality of the FB\n- positionGps: GPS position used for calculating sunrise and sunset times\n- offsetSunrise: Sunrise time offset (added to the sunrise time)\n- offsetSunset: Sunset time offset (added to the sunset time)\n\nOutput parameters include:\n- valid: Output value is valid\n- busy: The FB is performing calculations\n- error: Whether an error occurred during execution\n- status: The status or error code of the FB\n- subFunctionStatus: The status or return value of the called FB, FC, or system block\n- actualLocalTime: Current local time\n- sunriseTime: Time of sunrise\n- sunsetTime: Time of sunset\n- isDaytime: Whether the current controller local time is between sunrise and sunset\n\nThe FB first checks if the input latitude and longitude values are within a valid range, then calculates the sunrise and sunset times based on these values and the system time. If the input values are invalid, the FB will output an error status. If the calculation is successful, the FB will output valid sunrise, sunset times, and whether it is currently daytime.\n\nNote: This FB assumes that the system time has been synchronized with UTC time and does not use the ENO mechanism for error handling.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and sunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at `isDaytime`, negative time allowed)"}, {"name": "positionGps", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at `isDaytime`, negative time allowed)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between “sunrise” and “sunset”"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_IN_OPERATION", "16#8204": "ERR_LATITUDE_VALUE", "16#8205": "ERR_LONGITUDE_VALUE", "16#8601": "ERR_RD_SYS_T", "16#8602": "ERR_RD_LOC_T"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees. For a whole GPS Data set.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places (Unit: degree decimal), North = positive; South = negative) valid value range [-90.00000..90.00000] "}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude with decimal places (Unit: degree decimal), East = positive; West = negative) valid value range [-180.00000..180.00000] "}]}], "description_zh": "\n该函数块FB用于根据地球上一个特定位置的本地时间计算日出和日落的时间。它接受GPS位置信息，并可以添加自定义的日出和日落时间偏移。FB将输出有效的计算结果，并指示是否处于白天时间。\n\n输入参数包括：\n- enable：激活FB的功能\n- positionGps：用于计算日出和日落时间的GPS位置\n- offsetSunrise：日出时间偏移（加到日出时间上）\n- offsetSunset：日落时间偏移（加到日落时间上）\n\n输出参数包括：\n- valid：输出值有效\n- busy：FB正在执行计算\n- error：执行过程中是否发生错误\n- status：FB的状态或错误代码\n- subFunctionStatus：调用FB、FC或系统块的状态或返回值\n- actualLocalTime：当前本地时间\n- sunriseTime：日出时间\n- sunsetTime：日落时间\n- isDaytime：当前控制器本地时间是否在日出和日落之间\n\nFB首先检查输入的经纬度值是否在有效范围内，然后根据这些值和系统时间计算日出和日落时间。如果输入值无效，FB将输出错误状态。如果计算成功，FB将输出有效的日出、日落时间和当前是否为白天。\n\n注意：该FB假设系统时间已经与UTC时间同步，并且没有使用ENO机制进行错误处理。\n\n\n"}
{"title": "Sawtooth Signal Profile Generator", "name": "LGF_SawTooth", "description": "This function block FB is used to generate a sawtooth signal profile with a defined number of steps. Input parameters include start value (startValue), time range (timeRange), increment range (incrementRange), number of steps (numberSteps), whether to loop endlessly (endlessSteps), and reset signal (reset). The output parameter is the current value of the sawtooth signal (value).\n\nWhen the function block is called for the first time or receives a reset signal, it initializes all static values. If the timer completes and there is no reset signal, the function block calculates a new value and increments the step counter. If the number of steps has not reached the defined value, the function block continues to generate the sawtooth signal; if the number of steps reaches the defined value, it restarts and generates the sawtooth signal from the start value. If set to endless loop, the step counter is reset. Finally, the function block writes the current value to the output parameter and ends execution.", "type": "FUNCTION_BLOCK", "input": [{"name": "startValue", "type": "Int", "description": "0"}, {"name": "timeRange", "type": "Time", "description": "T#0s"}, {"name": "incrementRange", "type": "Int", "description": "0"}, {"name": "numberSteps", "type": "Int", "description": "0"}, {"name": "endlessSteps", "type": "Bool", "description": "FALSE"}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Int", "description": "Current value of the sawtooth signal."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成具有定义步数的锯齿形信号配置文件。输入参数包括起始值（startValue）、时间范围（timeRange）、增量范围（incrementRange）、步数（numberSteps）、是否无限循环（endlessSteps）以及重置信号（reset）。输出参数为当前锯齿信号的值（value）。\\n\\n当第一次调用函数块或接收到重置信号时，函数块将初始化所有静态值。如果定时器完成且没有重置信号，函数块将计算新的值，并增加步数计数器。如果步数未达到定义值，函数块将继续生成锯齿信号；如果步数达到定义值，则重启并从起始值开始生成锯齿信号。如果设置为无限循环，步数计数器将被重置。最后，函数块将当前值写入输出参数，并结束执行。\n\n\n"}
{"title": "Advanced CRC-16 Calculator", "name": "LGF_CalcCRC16Advanced", "description": "The function FC calculates the Cyclic Redundancy Check (CRC) value of data based on the CRC-16 advanced algorithm. The function supports multiple parameters, including initialization value, mask, final XOR value, input/output inversion flag, and the number of elements to be calculated. The function can process bytes in the input array and return the calculated CRC value. If the specified number of elements exceeds the array size, the function will set an error flag and return an error status code. During the calculation process, the function will bit-reverse the input bytes (if reflectInput is true) and shift the byte into the most significant bit of the CRC in each iteration. Then, the function performs division operation using the mask and calculates the CRC value through the XOR function. Finally, if reflectResult is true, the function will bit-reverse the calculated CRC value and perform a final XOR operation using the finalXorValue. The function does not use the ENO mechanism, as there is no error handling.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Word", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n该函数FC根据CRC-16高级算法计算数据的循环冗余校验（CRC）值。函数支持多种参数，包括初始化值、掩码、最终异或值、输入输出反转标志以及要计算元素的数量。函数可以处理输入数组中的字节，并返回计算出的CRC值。如果指定的元素数量超出数组大小，函数将设置错误标志并返回错误状态代码。在计算过程中，函数会对输入字节进行位反转（如果reflectInput为真），并在每次迭代中将字节移位到CRC的最高有效位。然后，函数使用掩码进行除法运算，并通过异或函数计算CRC值。最后，如果reflectResult为真，函数会对计算出的CRC值进行位反转，并使用finalXorValue进行最终异或操作。函数不使用ENO机制，因为没有错误处理。\n\n\n"}
{"title": "DWORD falling edge counting", "name": "LGF_CountFalInDWord", "description": "A function block FB, which is used to analyze and count the number of 1-0 sequences (i.e., falling edges) in a DWORD type variable. The function block will output the total number of falling edges.\n\nExample:\nAssuming the input DWORD value is 2#1010111100111110, the number of falling edges is 4.\n\nNotes:\n1. This function block does not use the ENO mechanism, therefore ENO is强制 set to true.\n2. This function block does not perform error handling.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the falling edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of falling edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块用于分析和统计DWORD类型变量中1-0序列（即下降沿）出现的次数。函数块将输出下降沿的总数。\\n\\n示例：\\n假设输入的DWORD值为2#1010111100111110，则下降沿的数量为4。\\n\\n注意：\\n1. 该函数块不使用ENO机制，因此ENO被强制设置为真。\\n2. 该函数块不执行错误处理。\n\n\n"}
{"title": "Device Activation and Deactivation State Machine", "name": "LGF_ActDeactDevice", "description": "A function block FB is used to implement a state machine that can activate and monitor or deactivate distributed devices. The state machine handles the following operations:\n\n1. Enable and disable FB functionality.\n2. Activate or deactivate the device specified by `hwId`.\n3. Monitor the device status, including connection status and error status.\n\nThe state machine has the following states:\n\n* FB_STATE_NO_PROCESSING: No processing state\n* FB_STATE_ENABLING_START: Enabling start state\n* FB_STATE_ENABLING_WAIT: Enabling wait state\n* FB_STATE_DEACTIVATE_START: Deactivate start state\n* FB_STATE_DEACTIVATE_WAIT: Deactivate wait state\n* FB_STATE_DEACTIVATED: Deactivated state\n* FB_STATE_ACTIVATE_START: Activate start state\n* FB_STATE_ACTIVATE_WAIT: Activate wait state\n* FB_STATE_ACTIVATED: Activated state\n* FB_STATE_DISABLING_START: Disabling start state\n* FB_STATE_DISABLING_WAIT: Disabling wait state\n\nThe function block also handles the following errors:\n\n* ERR_UNDEFINED_STATE: State in the state machine is undefined\n* ERR_LOG2GEO / ERR_GEO2LOG: Log2Geo or Geo2Log error\n* ERR_DEVICE_DEACTIVATING: Error during device deactivation\n* ERR_DEVICE_DEACTIVATING_TIME_OUT: Device deactivation timeout error\n* ERR_DEVICE_ACTIVATING: Error during device activation\n* ERR_DEVICE_ACTIVATING_TIME_OUT: Device activation timeout error\n* ERR_READ_DEVICES_STATES_DURING_ACTIVATION: Error reading device states during activation\n* ERR_READ_DEVICES_STATES_WHILE_ACTIVE: Error reading device states while active\n* ERR_DEVICE_STATE_WHILE_ACTIVE: Device state error and not accessible, device or IO system failure\n* ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE: Error reading activation state while active\n* ERR_DISABLING_DEACT_DEVICE: Error during device deactivation while disabling\n* ERR_DISABLING_WATCHDOG: Watchdog timer timeout error while disabling device", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enable functionality of FB"}, {"name": "activate", "type": "Bool", "description": "Rising edge: Activate device given by `hwId`"}, {"name": "deactivate", "type": "Bool", "description": "Rising edge: Deactivate device given by `hwId`"}, {"name": "hwId", "type": "HW_DEVICE", "description": "Hardware ID of the device which should be activated / deactivated"}, {"name": "parameter", "type": "LGF_typeActDeactDeviceParameter", "description": "Parameter dataset for the function `LGF_ActDeactDevice`"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification"}, {"name": "activating", "type": "Bool", "description": "Activation of device active"}, {"name": "isActivated", "type": "Bool", "description": "Device activated"}, {"name": "deactivating", "type": "Bool", "description": "Deactivating of device active"}, {"name": "isDeactivated", "type": "Bool", "description": "Device deactivated"}, {"name": "deviceStateOK", "type": "Bool", "description": "Device is activated and connected to IO-System"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#8600": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine", "16#8601": "ERR_LOG2GEO / ERR_GEO2LOG: Log2Geo or Geo2Log error, check diagnostics for more info", "16#8640": "ERR_DEVICE_DEACTIVATING: Error during device deactivation", "16#8641": "ERR_DEVICE_DEACTIVATING_TIME_OUT: Deactivation timeout error", "16#8660": "ERR_DEVICE_ACTIVATING: Error during device activation", "16#8661": "ERR_DEVICE_ACTIVATING_TIME_OUT: Activation timeout error", "16#8662": "ERR_READ_DEVICES_STATES_DURING_ACTIVATION: Error: Read Device states (DeviceStates) during device activation", "16#8670": "ERR_READ_DEVICES_STATES_WHILE_ACTIVE:Error: Read Device states (DeviceStates) while device active", "16#8671": "ERR_DEVICE_STATE_WHILE_ACTIVE: Device states present error and is unreachable, faulty Device or IO-System", "16#8672": "ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE:Activation state (D_ACT_DP) of device is wrong", "16#8690": "ERR_DISABLING_DEACT_DEVICE: Deactivation (D_ACT_DP) of device throws an error while disabling", "16#8691": "ERR_DISABLING_WATCHDOG:Watchdog timer expired while disabling"}, "user_defined_types": [{"name": "LGF_typeActDeactDeviceParameter", "description": "UDT for configuring the behavior of the activation and deactivation process.", "member": [{"name": "timeOutActDeact", "type": "Time", "default": "T#2500ms", "description": "Time to monitor activation and deactivation commands"}, {"name": "timeOutStateMonitoring", "type": "Time", "default": "T#100ms", "description": "Time to monitor device state"}, {"name": "enableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during startup"}, {"name": "enableAndActivate", "type": "Bool", "default": "FALSE", "description": "Enable device during startup"}, {"name": "disableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during module disabling"}]}, {"name": "LGF_typeDiagnostics", "description": "UDT for diagnostic information from blocks.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the block or error identification"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine where error occurred"}]}], "description_zh": "\n\n一个函数块FB，用于实现一个状态机，该状态机能够激活和监控或停用分布式设备。状态机处理以下操作：\\n\\n1. 启用和禁用FB功能。\\n2. 激活或停用由`hwId`指定的设备。\\n3. 监控设备状态，包括连接状态和错误状态。\\n\\n状态机具有以下状态：\\n\\n* FB_STATE_NO_PROCESSING：无处理状态\\n* FB_STATE_ENABLING_START：启用开始状态\\n* FB_STATE_ENABLING_WAIT：启用等待状态\\n* FB_STATE_DEACTIVATE_START：停用开始状态\\n* FB_STATE_DEACTIVATE_WAIT：停用等待状态\\n* FB_STATE_DEACTIVATED：已停用状态\\n* FB_STATE_ACTIVATE_START：激活开始状态\\n* FB_STATE_ACTIVATE_WAIT：激活等待状态\\n* FB_STATE_ACTIVATED：已激活状态\\n* FB_STATE_DISABLING_START：禁用开始状态\\n* FB_STATE_DISABLING_WAIT：禁用等待状态\\n\\n函数块还处理以下错误：\\n\\n* ERR_UNDEFINED_STATE：状态机中的状态未定义\\n* ERR_LOG2GEO / ERR_GEO2LOG：Log2Geo或Geo2Log错误\\n* ERR_DEVICE_DEACTIVATING：设备停用过程中发生错误\\n* ERR_DEVICE_DEACTIVATING_TIME_OUT：设备停用超时错误\\n* ERR_DEVICE_ACTIVATING：设备激活过程中发生错误\\n* ERR_DEVICE_ACTIVATING_TIME_OUT：设备激活超时错误\\n* ERR_READ_DEVICES_STATES_DURING_ACTIVATION：设备激活期间读取设备状态错误\\n* ERR_READ_DEVICES_STATES_WHILE_ACTIVE：设备激活时读取设备状态错误\\n* ERR_DEVICE_STATE_WHILE_ACTIVE：设备状态错误且无法访问，设备或IO系统故障\\n* ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE：设备激活状态错误\\n* ERR_DISABLING_DEACT_DEVICE：禁用设备时发生错误\\n* ERR_DISABLING_WATCHDOG：禁用设备时看门狗定时器超时\n\n\n"}
{"title": "Value tolerance range check", "name": "LGF_IsValueInTolerance", "description": "This function is used to check whether a given value is within the tolerance range of a set point. The set point is a reference value, and the tolerance range is a percentage relative to the set point. The function calculates the upper and lower limits and determines whether the input value exceeds these boundaries.\\n\\nIf the input value is greater than the upper limit or less than the lower limit, the function will return false, indicating that the input value is not within the tolerance range. The function will also output a flag indicating whether the input value is above the upper limit or below the lower limit. If the input value is within the tolerance range, the function will return true.\\n\\nStatus codes:\\n16#0000: Execution without error\\n16#8401: Input value exceeds the set range", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "tolerance", "type": "LReal", "description": "Tolerance range around the set point in percent"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the value exceeds the upper limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE if the value is below the lower limit"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if the value is in the value range"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": [], "description_zh": "\n该函数用于检查一个给定的值是否位于设定点的容忍范围内。设定点是参考值，容忍范围是相对于设定点的百分比。函数会计算上限和下限，并根据输入值判断是否超出这些界限。\\n\\n如果输入值大于上限或小于下限，函数将返回false，表示输入值不在容忍范围内。同时，函数还会输出一个标志，指示输入值是超出了上限还是低于下限。如果输入值在容忍范围内，函数将返回true。\\n\\n状态码：\\n16#0000：执行没有出错\\n16#8401：输入值超出设定范围\n\n\n"}
{"title": "International Date String to DTL Converter", "name": "LGF_StringToDTL_ISO", "description": "A function FC that converts a datetime string in the international format (YYYY-MM-DD HH:mm:ss.nnnnnnnnn) to a DTL type. The function accepts a string input, splits the string into year, month, day, hour, minute, second, and nanosecond parts based on separators, and then converts these parts into corresponding numerical values, checking if they are within valid ranges. If the input string format is correct, the function returns a DTL value containing the converted date and time. If the input string format is incorrect, the function returns an error status and a corresponding error code. Additionally, the function outputs a boolean error flag indicating whether an error has occurred.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_JOB", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将符合国际格式（YYYY-MM-DD HH:mm:ss.nnnnnnnnn）的日期时间字符串转换为DTL类型。函数接受一个字符串输入，并根据分隔符将字符串分割成年、月、日、时、分、秒和纳秒等部分。然后，函数将这些部分转换为对应的数值，并检查它们是否在有效的范围内。如果输入字符串的格式正确，函数将返回一个包含转换后的日期和时间的DTL值。如果输入字符串的格式错误，函数将返回一个错误状态和相应的错误代码。此外，函数还输出一个布尔类型的错误标志，指示是否发生了错误。\n\n\n"}
{"title": "Shell Sort for DInt Arrays", "name": "LGF_ShellSort_DInt", "description": "A function block FB that uses the Shell sort algorithm to sort an array of DInt type. The array can contain any number of elements (up to 1000) and can be sorted in ascending or descending order based on a parameter. The sorted array will overwrite the original array.\n\nExample:\nSuppose there is an array [5, 3, 1, 4, 2], and we choose to sort it in ascending order.\nThe sorted array will be [1, 2, 3, 4, 5].", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块使用希尔排序算法对DInt类型的数组进行排序。数组可以包含任意数量的元素（最多1000个），并且可以根据参数选择升序或降序排序。排序后的数组将覆盖原始数组。\\n\\n示例：\\n假设有一个数组[5, 3, 1, 4, 2]，并且我们选择升序排序。\\n排序后的数组将是[1, 2, 3, 4, 5]。\n\n\n"}
{"title": "Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax", "description": "Function FC(inputArray As Variant) As Variant\n    Dim minVal As Variant\n    Dim maxVal As Variant\n    Dim minIndex As Integer\n    Dim maxIndex As Integer\n    Dim i As Integer\n    Dim isError As Boolean = False\n    Dim statusCode As Integer = 0\n    \n    ' Check if input is an array\n    If Not IsArray(inputArray) Then\n        isError = True\n        statusCode = 1 ' Error code for input not being an array\n        Return CreateObject(\"Scripting.Dictionary\")\n    End If\n    \n    ' Check for correct data types in the array\n    For i = LBound(inputArray) To UBound(inputArray)\n        If Not (VarType(inputArray(i)) = VarType(minVal) Or VarType(inputArray(i)) = VarType(maxVal)) Then\n            isError = True\n            statusCode = 2 ' Error code for mismatched data types\n            Return CreateObject(\"Scripting.Dictionary\")\n        End If\n    Next\n    \n    ' Initialize min and max values and their indices\n    minVal = inputArray(LBound(inputArray))\n    maxVal = inputArray(LBound(inputArray))\n    minIndex = LBound(inputArray)\n    maxIndex = LBound(inputArray)\n    \n    ' Search for min and max values and their indices\n    For i = LBound(inputArray) To UBound(inputArray)\n        If inputArray(i) < minVal Then\n            minVal = inputArray(i)\n            minIndex = i\n        End If\n        If inputArray(i) > maxVal Then\n            maxVal = inputArray(i)\n            maxIndex = i\n        End If\n    Next\n    \n    ' Check for errors during value copying\n    ' Assuming MOVE_BLK_VARIANT is a hypothetical subroutine for moving variant data\n    ' If an error occurs, set the error flag and status code\n    ' If isError Then\n    '     statusCode = 3 ' Error code for error during value copying\n    '     Return CreateObject(\"Scripting.Dictionary\")\n    ' End If\n    \n    ' Return results in a dictionary\n    Dim result As Object\n    Set result = CreateObject(\"Scripting.Dictionary\")\n    result.Add \"MinValue\", minVal\n    result.Add \"MinIndex\", minIndex\n    result.Add \"MaxValue\", maxVal\n    result.Add \"MaxIndex\", maxIndex\n    result.Add \"StatusCode\", statusCode\n    Return result\nEnd Function", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}], "output": [{"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE", "16#8202": "ERR_NOT_EQUAL_TYPES", "16#8203": "ERR_MOVE_BLK_VARIANT"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数在一个DInt类型的数组中搜索最大值和最小值，并返回这些值在数组中的相应索引。函数接受一个Variant类型的数组作为输入，并输出最小值、最小值索引、最大值和最大值索引。如果输入不是数组或者数组元素类型与输出变量类型不匹配，函数将设置错误标志并返回相应的状态代码。函数支持多种数据类型，包括Int、UInt、DInt、UDInt、USInt、SInt、Real和LReal。如果MOVE_BLK_VARIANT子函数在复制值时出现错误，函数也会报告错误。\n\n\n"}
{"title": "TADDR_Param to String Converter", "name": "LGF_TaddrToString", "description": "A function FC that converts a variable of system data type TADDR_Param to a string data type. TADDR_Param contains an IP address and a port number, and the function concatenates these two parts into a string. The string format is the IP address part (four decimal numbers separated by dots), followed by a colon and the port number if it exists. Note that if any part of the IP address is less than 10, it will not be padded with a zero. If the port number is 0, the port number part will not be included in the string.\n\nExample:\nAssuming the input TADDR_Param variable contains an IP address of 192.168.1.1 and a port number of 8080.\nThe function should return the string \"192.168.1.1:8080\" as the conversion result.", "type": "FUNCTION", "input": [{"name": "ipAdressTaddr", "type": "TADDR_Param", "description": "IP-Address and Port number to convert into string"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "IP-Address and Port number as string"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将系统数据类型为TADDR_Param的变量转换为字符串数据类型。TADDR_Param包含了IP地址和端口号，函数将这两个部分连接起来，形成一个字符串输出。字符串格式为IP地址部分（四个十进制数，每部分之间用点分隔），如果存在端口号，则紧接着是一个冒号和端口号。注意，IP地址的每个部分如果小于10，前面不会补0。如果端口号为0，则不会在字符串中包含端口号部分。\\n\\n示例：\\n假设输入的TADDR_Param变量包含IP地址为192.168.1.1，端口号为8080。\\n函数应返回字符串\\\"192.168.1.1:8080\\\"作为转换结果。\n\n\n"}
{"title": "Numeric Differentiation Function", "name": "LGF_DifferenceQuotientFC", "description": "The function FC is used to calculate the first derivative of a signal sampled at equal time intervals. The function accepts an input parameter deltaT of type LReal, representing the equal time interval between two measurements. It also accepts two array-type input/output parameters: values and derivedValues. The values array contains the signal values to be differentiated, while the derivedValues array will be used to store the results after differentiation.\n\nWhen the function is executed, it first checks whether the sizes of the input arrays are equal and contain at least 4 elements, as differentiation requires at least 4 data points. If the array sizes do not match or the number of elements is insufficient, the function will return an error status.\n\nIf the input parameter deltaT is 0, the function will also return an error status, as this would result in division by zero.\n\nIf all checks pass, the function will calculate the first derivative of the signal using the central difference method and store the results in the derivedValues array. The calculation formula takes into account the array boundaries and uses special difference formulas for the boundary points.\n\nAfter the function execution is completed, if no error has occurred, the error output will be set to FALSE, and the status output will be set to the STATUS_FINISHED_NO_ERROR status code. If an error occurs, the error output will be set to TRUE, and the corresponding status code will be set based on the error type.\n\nSince the ENO mechanism is not used, the function forcibly sets ENO to TRUE.", "type": "FUNCTION", "input": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_DELTA_T Error: Delta time `deltaT` must not be zero.", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": [], "description_zh": "\n该函数FC用于计算等时间间隔采样信号的一阶导数。函数接受一个LReal类型的输入参数deltaT，表示两个测量值之间的等距时间间隔。它还接受两个数组类型的输入/输出参数：values和derivatedValues。values数组包含将要进行微分的信号值，而derivatedValues数组将用于存储微分后的结果。\n\n函数执行时，首先检查输入数组的大小是否相等，以及是否至少包含4个元素，因为微分计算需要至少4个数据点。如果数组大小不匹配或元素数量不足，函数将返回错误状态。\n\n如果输入参数deltaT为0，函数也会返回错误状态，因为这将导致除以零的情况。\n\n如果所有检查都通过，函数将使用中心差分法计算信号的一阶导数，并将结果存储在derivatedValues数组中。计算公式考虑了数组边界的情况，并对边界点使用了特殊的差分公式。\n\n函数执行结束后，如果没有错误发生，将设置error输出为FALSE，status输出为STATUS_FINISHED_NO_ERROR状态码。如果发生错误，error输出将被设置为TRUE，并根据错误类型设置相应的status状态码。\n\n由于ENO机制未使用，函数强制将ENO设置为TRUE。\n\n\n"}
{"title": "Kelvin to Celsius Converter", "name": "LGF_KelvinToCelsius", "description": "A function FC that converts temperature values from Kelvin (°K) to Celsius (°C). The function accepts a real number as an input parameter representing the temperature value (in Kelvin) and returns a real number as an output parameter representing the converted temperature value (in Celsius). The conversion formula is: Celsius = Kelvin - 273.15. This function does not handle any errors and does not require error handling.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Celsius"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将温度值从开尔文（°Kelvin）转换为摄氏度（°Celsius）。该函数接受一个实数类型的输入参数，表示温度值（以开尔文为单位），并返回一个实数类型的输出参数，表示转换后的温度值（以摄氏度为单位）。转换公式为：摄氏度 = 开尔文 - 273.15。该函数不处理任何错误，并且不需要错误处理。\n\n\n"}
{"title": "Advanced CRC-8 Calculator", "name": "LGF_CalcCRC8Advanced", "description": "A function FC that performs CRC calculation based on the advanced CRC-8 algorithm. The function accepts parameters such as an initial value, a mask, a final XOR value, an input/output reflection flag, and the number of data elements to be used for CRC calculation. The function calculates the CRC value of the input array (array) and supports bit reflection. The final calculated CRC value can be XORed with the final XOR value, and it can be optionally bit-reflected. The function checks if the provided number of elements exceeds the array size and sets an error flag and status code in case of an error. It ultimately returns the calculated CRC value.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Byte", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据CRC-8高级算法进行CRC计算。该函数接受初始值、掩码、最终异或值、输入/输出反射标志以及要用于CRC计算的数据元素数量作为参数。函数计算输入数组（array）的CRC值，并支持位反射功能。最终计算出的CRC值可以与最终异或值进行异或操作，并可以选择是否对结果进行位反射。函数会检查提供的元素数量是否超出数组大小，并在发生错误时设置错误标志和状态码。最终返回计算出的CRC值。\n\n\n"}
{"title": "Profinet Interface Parameter Reader", "name": "LGF_ReadPnInterfaceParameter", "description": "A function block FB used for reading parameters from a Profinet interface, including IP address, subnet mask, default gateway, MAC address, and PN name. When the input execute is triggered, the FB will start the read operation. The FB uses a state machine to manage the read process, including two states: reading records and processing records. In the reading records state, the FB will call a sub-function block RDREC to read the interface parameters. In the processing records state, the FB will parse the records read and update the output parameters. When the operation is completed, the FB will set the output parameter done to TRUE, indicating that the operation has been successfully completed. If an error occurs during the process, the FB will set the output parameter error to TRUE and return the error status. The status code is used to represent the execution status and error information of the FB.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "hardwareId", "type": "HW_ANY", "description": "Hardware ID of the Interface where the parameter should be read"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished, new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "DWord", "description": "Status of the FB and error identification"}, {"name": "address", "type": "IP_V4", "description": "IP Address from interface"}, {"name": "subnetMask", "type": "IP_V4", "description": "Subnet mask from interface"}, {"name": "standardGateway", "type": "IP_V4", "description": "Standard gateway address from interface"}, {"name": "macAddress", "type": "Array[0..5] of Byte", "description": "MAC Address from interface"}, {"name": "pnName", "type": "String", "description": "Profinet name from interface"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#9000": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于读取Profinet接口的参数，包括IP地址、子网掩码、默认网关、MAC地址和PN名称。当触发输入execute时，FB将开始执行读取操作。FB使用状态机来管理读取过程，包括读取记录和处理记录两个状态。在读取记录状态，FB将调用一个子函数块RDREC来读取接口参数。在处理记录状态，FB将解析读取到的记录并更新输出参数。当操作完成时，FB将设置输出参数done为TRUE，表示操作成功完成。如果过程中发生错误，FB将设置输出参数error为TRUE，并返回错误状态。状态代码用于表示FB的执行状态和错误信息。\n\n\n"}
{"title": "DWord to 4-Byte Splitter", "name": "LGF_SplitDWordToBytes", "description": "The function FC splits a double word (DWord) type variable into four byte (Byte) type variables. The input double word variable contains 32 bits of information, which the function divides into four groups of 8 bits each, storing them in four output byte variables. The output byte variables are: byte3 (the highest byte, i.e., the leftmost 8 bits), byte2 (the second highest byte), byte1 (the second lowest byte), and byte0 (the lowest byte, i.e., the rightmost 8 bits).\n\nExample:\nAssuming the input double word variable value is 2#101011112233445566778899AABBCCDDEEFF, the output should be:\nbyte3 = 2#10101111\nbyte2 = 2#12233445\nbyte1 = 2#56677889\nbyte0 = 2#AABBCCDD", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "byte3", "type": "Byte", "description": "Output Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Output Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Output Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC将一个双字（DWord）类型的变量分割成4个字节（Byte）类型的变量。输入的双字变量包含32位信息，该函数将这32位分成4组，每组8位，分别存储在4个输出字节变量中。输出的字节变量分别为：byte3（最高字节，即最左边的8位），byte2（次高字节），byte1（次低字节），和byte0（最低字节，即最右边的8位）。\\n\\n示例：\\n假设输入的双字变量值为2#101011112233445566778899AABBCCDDEEFF，那么输出应为：\\nbyte3 = 2#10101111\\nbyte2 = 2#12233445\\nbyte1 = 2#56677889\\nbyte0 = 2#AABBCCDD\n\n\n"}
{"title": "Even Parity Checker for DWord", "name": "LGF_IsParityEven", "description": "This function is used to check the parity of a double word (DWord) input variable and returns a boolean value. If the number of bits set to `TRUE` in the input variable is even, it returns `TRUE`; otherwise, it returns `FALSE`. The function uses bit operations to calculate the parity of the input variable and does not use the ENO mechanism for error handling.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is even"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n该函数用于检查一个双字（DWord）输入变量的奇偶性，并返回一个布尔值。如果输入变量中设置为`TRUE`的位数是偶数，则返回`TRUE`，否则返回`FALSE`。函数使用了位操作来计算输入变量的奇偶性，并且不使用ENO机制进行错误处理。\n\n\n"}
{"title": "Random UDInt Range Number Generator", "name": "LGF_RandomRange_UDInt", "description": "The function's purpose is to generate a random number within a specified range, with the data type being UDInt. The function's input parameters are minValue and maxValue, which represent the minimum and maximum values of the random number, respectively. The output parameters include an error flag, status code, subfunction status, and the generated random number item. The function first checks if the maxValue is less than the minValue, and if so, it returns an error. Then, the function reads the system time and uses the nanosecond value to generate a time-based random starting value. This random starting value is then normalized between 0.0 and 1.0, and finally, it is scaled to the range specified by minValue and maxValue. If there are no errors during the execution, the generated random number is returned.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "UDInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random UDInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数功能是生成一个在指定范围内的随机数，数据类型为UDInt。函数的输入参数为随机数的最小值minValue和最大值maxValue，输出参数包括错误标志error，状态码status，子函数状态subfunctionStatus以及生成的随机数item。函数首先检查最大值是否小于最小值，如果是，则返回错误。然后，函数读取系统时间，并使用纳秒值来生成一个基于时间的随机起始值。接着，将这个随机起始值归一化到0.0到1.0之间，并最终将其缩放到minValue和maxValue指定的范围内。如果执行过程中没有错误，则返回生成的随机数。\n\n\n"}
{"title": "Single Byte CRC-8 Calculator", "name": "LGF_CalcCRC8For1Byte", "description": "This function is used to calculate the CRC-8 checksum for a single data byte for error detection during data transmission. The function accepts three input parameters: initValue (initial value), mask (generator polynomial), and value (the data byte for which the CRC is to be calculated). It computes the CRC of the input byte using the CRC-8 algorithm and returns the result. The CRC-8 algorithm is a cyclic redundancy check that treats the data as a binary number and calculates the checksum by dividing by the generator polynomial. The output result is a byte-sized CRC value that can be used for subsequent data verification processes.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "value", "type": "Byte", "description": "Data byte for which the CRC value will be calculated"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n该函数用于计算单个数据字节的CRC-8校验值，以便在数据传输过程中进行错误检测。函数接受三个输入参数：initValue（初始值），mask（生成多项式）和value（待计算CRC值的数据字节）。函数通过CRC-8算法计算输入字节的CRC值，并返回计算结果。其中，CRC-8算法是一个循环冗余校验，它将数据看作是一个二进制数，通过除以生成多项式来计算校验值。输出结果为一个字节大小的CRC值，可以用于后续的数据校验过程。\n\n\n"}
{"title": "Kelvin to Rankine Converter", "name": "LGF_KelvinToRankine", "description": "A function FC that converts temperature values from Kelvin (°Kelvin) to Rankine (°Rankine). The conversion formula is: Rankine temperature = Kelvin temperature × 1.8.\n\n\nExample:\nAssuming the input Kelvin temperature is 300K, the converted Rankine temperature would be 540°R.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Rankine"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将温度值从开尔文（°Kelvin）转换为兰金（°Rankine）。转换公式为：兰金温度 = 开尔文温度 × 1.8。\\n\\n示例：\\n假设输入的开尔文温度为300K，则转换后的兰金温度为540°R。\n\n\n"}
{"title": "Cosine Signal Generator", "name": "LGF_CosinusCI", "description": "This function block is used to generate a cosine wave signal, utilizing the time interval of the periodic interrupt organization block (OB) that calls it to calculate the output value. The function block accepts the following input parameters: amplitude, offset, period, phase shift, call OB, and reset signal. It outputs the current cosine wave signal value (value), error status (error), status word (status), and sub-function status (subFunctionStatus).\n\nEach time the OB is called, the function block increments a counter based on the period time and converts it to radians. It then calculates the cosine value at the current moment, taking into account the amplitude, offset, and phase shift to generate the final output value. If the reset signal is true, the counter is reset to 0, and the output value is also set to 0.\n\nThe function block also contains error handling logic to deal with errors that may occur when querying the periodic interrupt OB. If the query function QRY_CINT returns an error, or if the OB is not available, the function block sets the error status to true and returns the corresponding error code.\n\nThe status word and sub-function status are used to provide information about the execution status of the function block. The ENO mechanism is not used in this function block and is therefore强制设置为真 (forcibly set to true).", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the cosinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块用于生成一个余弦波信号，它利用调用它的周期性中断组织块（OB）的时间间隔来计算输出值。函数块接受以下输入参数：振幅（amplitude）、偏移量（offset）、周期（periode）、相移（phaseShift）、调用OB（callOB）和重置（reset）信号。它将输出当前的余弦波信号值（value）、错误状态（error）、状态字（status）和子函数状态（subFunctionStatus）。\n\n在每次OB被调用时，函数块会根据周期时间增加一个计数器，并将其转换为弧度。然后，它会计算当前时刻的余弦值，并考虑振幅、偏移量和相移来生成最终的输出值。如果重置信号为真，则计数器会被重置为0，输出值也会被设置为0。\n\n函数块还包含错误处理逻辑，用于处理查询周期性中断OB时可能出现的错误。如果查询函数QRY_CINT返回错误，或者OB不可用，函数块会将错误状态设置为真，并返回相应的错误代码。\n\n状态字和子函数状态用于提供函数块的执行状态信息。ENO机制在该函数块中不使用，因此被强制设置为真。\n\n\n"}
{"title": "Binary to Gray Code Converter", "name": "LGF_BinaryToGray", "description": "A function FC that converts binary numbers to Gray code. The function takes a 32-bit unsigned integer binary encoded value as input and returns a 32-bit unsigned integer Gray code encoded value as output. The conversion from binary to Gray code is performed by performing an XOR operation between the input value and the result of its own right shift by one position. For example, the binary number 0110 is converted to Gray code 0101.", "type": "FUNCTION", "input": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Gray-coded value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，实现二进制数到格雷码的转换。函数接受一个32位无符号整数的二进制编码值作为输入，并返回一个32位无符号整数的格雷码编码值作为输出。二进制到格雷码的转换是通过将输入值与其自身右移一位后的结果进行异或操作来完成的。例如，二进制数0110转换为格雷码0101。\n\n\n"}
{"title": "Histogram Calculation Function Block for Integer Data", "name": "LGF_Histogram_DInt", "description": "A function block FB used for calculating the histogram of a series of integer data. The function block accepts a boolean input execute to initiate the calculation, and an unsigned integer input numberOfClasses to specify the number of categories for the histogram. The function block outputs a two-dimensional array histValues, which contains the frequency distribution values and the mid-values of each category. Additionally, it outputs an array axis, which includes the minimum, maximum, origin, and maximum frequency values of the histogram's coordinate axis. The function block also returns a real output classWidth, representing the width of each category. If an error occurs during execution, the function block sets a boolean output error to TRUE and returns specific error information through the status word status and the sub-function status word subFunctionStatus. The histogram calculation includes sorting the input array values, determining the minimum and maximum values, calculating the class width, counting the frequency and relative frequency of each category, and calculating the mid-value of each category. The function block uses the LGF_ShellSort_DInt function to sort the input array, and if an error occurs during sorting, the function block records the error status and returns the corresponding error code. If the specified number of categories is incorrect, the function block also returns an error code. The entire calculation process is triggered on the rising edge of the execute signal.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Outputs the calculated values in a two-dimensional array."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_DInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算一系列整数型数据的直方图。该函数块接受一个布尔型输入execute来启动计算，以及一个无符号整型输入numberOfClasses来指定直方图的分类数量。函数块会输出一个二维数组histValues，其中包含每个分类的频率分布值和分类的中间值。此外，还会输出一个数组axis，其中包含直方图坐标轴的最小值、最大值、原点和最大频率值。函数块还会返回一个实型输出classWidth，表示每个分类的宽度。如果执行过程中出现错误，函数块会设置布尔型输出error为TRUE，并通过状态字status和子函数状态字subFunctionStatus返回具体的错误信息。直方图计算包括对输入数组values进行排序、确定最小值和最大值、计算分类宽度、统计每个分类的频率和相对频率，并计算每个分类的中间值。函数块使用LGF_ShellSort_DInt函数对输入数组进行排序，如果排序过程中出现错误，函数块会记录错误状态并返回相应的错误代码。如果指定的分类数量不正确，函数块也会返回错误代码。整个计算过程在execute信号的上升沿触发。\n\n\n"}
{"title": "Calendar day calculation", "name": "LGF_GetCalendarDay", "description": "A function FC that calculates the number of calendar days that have passed since January 1st of the current year based on a specified date. The function accepts a date input of type DTL and returns a value of type DInt, representing the difference in days from January 1st to the input date. If the input date exceeds the valid range, the function will return an error status.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date for the calculation of the calendar days since 1 January."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Days past since January 1st."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": [], "description_zh": "\n一个函数FC，根据指定的日期计算从当年1月1日起已经过去的日历天数。该函数接受一个DTL类型的日期输入，并返回一个DInt类型的值，表示从1月1日到输入日期的天数差。如果输入日期超出有效范围，函数将返回一个错误状态。\n\n\n"}
{"title": "Arithmetic Mean and Standard Deviation Calculator", "name": "LGF_AverageAndDeviation", "description": "A function FC that calculates the arithmetic mean and standard deviation of a series of numbers. The input is an array of type LReal, and the output is the arithmetic mean and standard deviation. The function first checks the bounds of the input array to determine the number of elements. Then, it calculates the arithmetic mean by summing the numbers and dividing by the number of elements. Next, it computes the standard deviation by calculating the square of the difference between each number and the mean, summing these squares, dividing by the number of elements, and finally taking the square root. The output arithmetic mean and standard deviation can be used for subsequent data analysis.", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Array[*] of LReal", "description": "Sequence of numbers to calculate with"}], "output": [{"name": "arithmeticAverage", "type": "LReal", "description": "Calculated arithmetic average value"}, {"name": "standardDeviation", "type": "LReal", "description": "Calculated standard deviation"}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数计算一系列数的算术平均值和标准差。输入为一个LReal类型的数组，输出为算术平均值和标准差。函数首先检查输入数组的上下界，以确定数组中元素的数量。然后，通过求和并除以元素数量来计算算术平均值。接着，通过计算每个数值与平均值之差的平方，求和后除以元素数量，最后开方得到标准差。输出的算术平均值和标准差可以用于后续的数据分析。\n\n\n"}
{"title": "DTL to ISO 8601 Date String", "name": "LGF_DTLToString_ISO", "description": "The function FC converts DTL formatted date-time values into a string format that conforms to the ISO 8601 international standard (YYYY-MM-DD). The function accepts two input parameters: one is the DTL date-time value that needs to be converted, and the other is a custom separator used to separate the date-time components. If no separator is specified, a hyphen (-) is used as the default separator. The function outputs a string that contains the year, month, and day, with each component arranged according to the ISO 8601 format, i.e., the year is represented by four digits, and both the month and day are represented by two digits with leading zeros. There is no error handling mechanism in the function, so ENO is always set to true.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string in accordance with the ISO 8601 format."}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC将DTL格式的日期时间值转换为符合ISO 8601国际标准的字符串格式（YYYY MM DD）。函数接受两个输入参数：一个是需要转换的DTL日期时间值，另一个是用于分隔日期时间组件的自定义分隔符。如果未指定分隔符，则默认使用短横线（-）作为分隔符。函数会输出一个字符串，其中包含年、月、日，并且每个组件都按照ISO 8601的格式排列，即年份使用4位数字表示，月份和日期都使用2位数字表示，并且前面会补零。函数中没有错误处理机制，因此ENO始终设置为真。\n\n\n"}
{"title": "Bit assignment operation in DWORD", "name": "LGF_BitSetTo", "description": "This function is used to set or reset a specified bit in a DWORD type data. The function accepts three input parameters: value (DWord type) represents the variable in which the bit is to be set, bitNo (USInt type) represents the specific bit number to be set, and setTo (Bool type) indicates whether to set the bit to true (TRUE) or false (FALSE). The return value of the function is a DWORD type variable, in which the specified bit has been set or reset according to the value of the setTo parameter. If setTo is TRUE, the specified bit is set to 1; if setTo is FALSE, the specified bit is set to 0. The function internally uses bit shifting and logical operations to achieve the setting or resetting of the bit.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set / reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}, {"name": "setTo", "type": "Bool", "description": "Set bit to FALSE / TRUE"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with set bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于在DWORD类型的数据中设置或重置指定位置的位。函数接收三个输入参数：value（DWord类型）表示要设置位的变量，bitNo（USInt类型）表示要设置的具体位号，setTo（Bool类型）表示将该位设置为真（TRUE）或假（FALSE）。函数的返回值是一个DWORD类型的变量，其中指定位置的位已经根据setTo参数的值进行了设置或重置。如果setTo为TRUE，则将指定位置的位设置为1；如果setTo为FALSE，则将指定位置的位设置为0。函数内部使用位移和逻辑运算来实现位的设置或重置。\n\n\n"}
{"title": "DTL to Julian Date Converter", "name": "LGF_DTLToJulianDate", "description": "A function FC that converts a datetime value of type DTL to the Julian date and the modified Julian date, returning the results as LReal (double precision floating-point) types. The timestamp calculation is based on UTC time, without considering time zones. Only datetime values after January 1, 1990, are allowed.\\n\\nExample:\\nAssuming the input DTL datetime is 2023-09-17 12:34:56.123456789.\\nThe function should return the Julian date and the modified Julian date as the conversion results.\\n\\nNote:\\nIf the input DTL datetime format is invalid or the time is earlier than January 1, 1990, the function will return an error status.", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to Julian Date"}], "output": [{"name": "julianDate", "type": "LReal", "description": "Converted Julian date"}, {"name": "modifiedJulianDate", "type": "LReal", "description": "Converted modified Julian date"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "Void", "description": "---"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_DTL_INPUT_VALUE_INVALID", "16#8001": "ERR_TIME_BEFORE_1990"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为儒略日（Julian date）和修正儒略日（modified Julian date），结果以LReal（双精度浮点数）类型返回。函数计算的时间戳基于UTC时间，不考虑时区。只有1990年1月1日之后的日期时间被允许。\\n\\n示例：\\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789。\\n函数应返回儒略日和修正儒略日作为转换结果。\\n\\n注意：\\n如果输入的DTL日期时间格式无效或时间早于1990年1月1日，函数将返回错误状态。\n\n\n"}
{"title": "Simple Smoothing Function", "name": "LGF_SimpleSmoothingFC", "description": "A function FC, which performs a simple smoothing on the input LReal array. It achieves smoothing by calculating the average of each element and its two adjacent elements in the array. If the length of the input array and the output array do not match or the length is less than 3, the function will return an error status. The function does not return a value.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_NOT_ENOUGH_VALUES Error: Not enough values.", "16#8401": "ERR_ARRAY_DIFFERENT Error: The Arraysizes are not equal."}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数对输入的LReal型数组进行简单的平滑处理。它通过计算数组中每个元素及其相邻两个元素的平均值来实现平滑。如果输入数组和输出数组的长度不匹配或长度小于3，函数将返回错误状态。函数没有返回值。\n\n\n"}
{"title": "8-Bit to Byte Merger", "name": "LGF_MergeBitsToByte", "description": "The function \"LGF_MergeBitsToByte\" merges 8 boolean input bits (bit7 to bit0) into a byte-type output variable. Each boolean input bit corresponds to a bit in the byte, with bit7 being the most significant bit (MSB) and bit0 being the least significant bit (LSB). The function combines these bits into a byte through direct assignment operations. The output byte contains the combined state of the input bits and can be directly used in other scenarios that require byte-type data.", "type": "FUNCTION", "input": [{"name": "bit7", "type": "Bool", "description": "Input Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Composite Bit sequence stored as Byte variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数\"LGF_MergeBitsToByte\"将8个布尔类型的输入位（bit7至bit0）合并成一个字节类型的输出变量。每个布尔输入位对应于字节中的一个位，其中bit7是最高有效位（MSB），bit0是最低有效位（LSB）。函数通过直接赋值操作将这些位组合成一个字节。输出字节包含了输入位的组合状态，可以直接用于其他需要字节类型数据的场合。\n\n\n"}
{"title": "Boxplot Calculation for Real Data", "name": "LGF_Boxplot_LReal", "description": "A function block FB, which is used for Boxplot analysis on a set of real number data. Boxplot is a type of statistical chart used to display the distribution of a set of data, including the minimum value, the first quartile (Q25), the median (Q50), the third quartile (Q75), and the maximum value. In addition, the function block can also detect outliers in the data and calculate skewness.\\n\\nExample:\\nAssuming the input data array is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], and the outlier detection parameter is 1.5.\\nThe function block should calculate the minimum value as 1, the first quartile as 3, the median as 5.5, the third quartile as 7, the maximum value as 10, and detect no outliers, with a skewness of 0.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "LReal", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "LReal", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块用于对一组实数数据进行盒须图（Boxplot）分析。盒须图是一种统计图表，用于显示一组数据的分布情况，包括最小值、第一四分位数（Q25）、中位数（Q50）、第三四分位数（Q75）和最大值。此外，该函数块还可以检测数据中的异常值，并计算偏度。\\n\\n示例：\\n假设输入的数据数组为[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，异常值检测参数为1.5。\\n函数块应计算出最小值为1，第一四分位数为3，中位数为5.5，第三四分位数为7，最大值为10，并检测出没有异常值，偏度为0。\n\n\n"}
{"title": "Structured data comparison", "name": "LGF_CompareVariant", "description": "The function is used to compare two structured variables and outputs whether they have the same data type and the same values. The function first checks if the data types of the two variables are the same, then serializes them into byte arrays and compares the size of the arrays. If the sizes are the same, the function compares the values in the byte arrays byte by byte. If all values are the same, the function returns true (TRUE), indicating that the two variables have the same data type and the same values; if any value is different, the function returns false (FALSE). If the input variables have different data types or different sizes, the function will return an error status. The maximum serialization length supported by the function is 200 bytes.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "variableA", "type": "Variant", "description": "First comparison variable with any data type"}, {"name": "variableB", "type": "Variant", "description": "Second comparison variable with any data type"}], "return_value": [{"type": "Bool", "description": "FALSE: Values of comparison variables or PLC data types are different. TRUE: Values of the comparison variables are equal and PLC data types are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_INPUT_TYPES_MUST_MATCH", "16#8202": "ERR_INPUT_TYPES_LENGTH_NOT_EQUAL", "16#8601": "ERR_SERIALIZE_VARIABLE_A", "16#8602": "ERR_SERIALIZE_VARIABLE_B"}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个结构化的变量，并输出它们是否具有相同的数据类型和相同的值。函数首先检查两个变量的数据类型是否相同，然后将其序列化为字节数组，并比较数组的大小。如果大小相同，函数将逐字节比较字节数组中的值。如果所有值都相同，函数返回真（TRUE），表示两个变量具有相同的数据类型和相同的值；如果有任何值不同，函数返回假（FALSE）。如果输入变量的数据类型不相同或大小不同，函数将返回错误状态。函数支持的最大序列化长度为200字节。\n\n\n"}
{"title": "Random Real Range Number Generator", "name": "LGF_RandomRange_Real", "description": "The function FC is designed to generate a random real number within a specified range each time it is called. The function accepts two input parameters: minValue and maxValue, which define the range of the random number. The function checks if the minValue is less than or equal to maxValue, and if so, uses the system time as the seed for generating random numbers, producing a random real number between minValue and maxValue. If an error occurs (such as minValue being greater than maxValue, or an error occurs while reading the system time), the function will return an error flag and a corresponding status code. The function does not use the ENO mechanism for error handling.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "Real", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "Real", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数FC旨在每次调用时生成一个指定范围内的随机实数。函数接受两个输入参数：最小值（minValue）和最大值（maxValue），这两个参数定义了随机数的范围。函数会检查最小值是否小于等于最大值，如果是，则使用系统时间作为随机数生成的种子，生成一个介于最小值和最大值之间的随机实数。如果发生错误（如最小值大于最大值，或者读取系统时间时出错），函数将返回一个错误标志和相应的状态码。函数不使用ENO机制进行错误处理。\n\n\n"}
{"title": "Simple Smoothing Function Block", "name": "LGF_SimpleSmoothingFB", "description": "A function block FB used for smoothing a series of measurement values. This function block achieves the smoothing effect by calculating the linear average of the input values. Its working principle is: when the enable signal `enable` is true and the `insert` signal rises, the input value `value` is inserted into an array. When three values have been accumulated in the array, the function block calculates the average of these three values and outputs this average as the smoothed value `smoothedValue`. If there are fewer than three accumulated values, the output status `status` will indicate \"STATUS_NOT_ENOUGH_VALUES\". The function block also provides an error output `error` to indicate whether an error has occurred during execution. The status code is used to represent the current state of the function block, such as waiting for activation, first call, subsequent calls, etc.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if three values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires three (3) values to calculate a smoothed value."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于对一系列测量值进行平滑处理。该函数块通过计算输入值的线性平均值来实现平滑效果。它的工作原理是：当使能信号`enable`为真且`insert`信号发生上升沿时，将输入值`value`插入到一个数组中。当数组中积累了三个值后，函数块计算这三个值的平均值，并将这个平均值作为平滑后的值`smoothedValue`输出。如果积累的值不足三个，输出状态`status`将指示“STATUS_NOT_ENOUGH_VALUES”。函数块还提供一个错误输出`error`，用于指示在执行过程中是否发生错误。状态码用于表示函数块的当前状态，例如等待激活、首次调用、后续调用等。\n\n\n"}
{"title": "Bit status check operation", "name": "LGF_BitTest", "description": "A function FC that checks whether the bit at a specified position in a DWORD type variable is TRUE or FALSE. The function takes two input parameters: a DWORD type variable and a USInt type bit number. The function determines the state of the bit at the specified position by shifting a TRUE bit to the left by the specified number of bits and then performing a bitwise AND operation with the input DWORD variable. If the bit is TRUE, the function returns TRUE; otherwise, it returns FALSE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be tested"}, {"name": "bitNo", "type": "USInt", "description": "bit number to test in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Value of the checked bit."}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检查DWORD类型变量中指定位置的位是TURE还是FALSE。函数接收两个输入参数：一个DWORD类型的变量和一个USInt类型的位号。函数通过将一个TURE位左移指定的位数，然后与输入的DWORD变量进行按位与操作，来判断指定位置的位的状态。如果该位为TURE，则函数返回TURE；否则返回FALSE。\n\n\n"}
{"title": "Matrix Subtractor", "name": "LGF_MatrixSubtraction", "description": "A function FC that calculates the difference between two matrices of the same dimension with LREAL type. The function accepts two input matrices and one output matrix, with the output matrix containing the difference of the corresponding elements of the two input matrices. The function checks if the dimensions of the input matrices are consistent; if the dimensions do not match, it sets an error flag and returns the corresponding status code. If the dimensions match, the function calculates the difference and writes the result to the output matrix. This function does not return a value.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First matrix - minuend"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second matrix - subtrahend"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算两个具有相同维度的LREAL类型矩阵的差值。该函数接受两个输入矩阵和一个输出矩阵，输出矩阵将包含两个输入矩阵对应元素的差值。函数会检查输入矩阵的维度是否一致，如果维度不匹配，则会设置错误标志并返回相应的状态代码。如果维度匹配，函数将计算差值并将结果写入输出矩阵。该函数没有返回值。\n\n\n"}
{"title": "LReal numbers comparison with fixed precision", "name": "LGF_CompareLReal", "description": "This function is used to compare two floating-point numbers of type LReal to determine if they are approximately equal. It achieves this by using an approximation formula and a fixed precision constant of 1.0E-12 (picometers). The function accepts two input parameters of type LReal, valueA and valueB, and returns a boolean value indicating whether the two numbers are approximately equal. If the absolute difference between the two numbers is less than or equal to the product of the precision constant and one of the input numbers, the function returns TRUE, indicating that the two numbers are approximately equal; otherwise, it returns FALSE. This function does not use the ENO mechanism and has no error handling.", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个LReal类型的浮点数是否近似相等。函数通过使用一个近似公式和固定的精度常量1.0E-12（皮克）来实现这一点。函数接受两个LReal类型的输入参数valueA和valueB，并返回一个布尔值，指示两个数是否近似相等。如果两个数之差的绝对值小于等于精度常量与两个输入数之一的乘积，则函数返回TRUE，表示两个数近似相等；否则返回FALSE。该函数不使用ENO机制，并且没有错误处理。\n\n\n"}
{"title": "DTL to Traditional German Date String", "name": "LGF_DTLToString_DE", "description": "A function FC that converts a datetime value of type DTL to a string, formatted with a custom separator. The resulting string format should be DD<separator>MM<separator>YYYY<separator>HH:mm:ss.nnnnnnnn, where <separator> is a character specified by the function parameter. Here HH represents hours (24-hour format), mm represents minutes, ss represents seconds, and nnnnnnnn represents nanoseconds. Note that the separator should not be used between hours, minutes, seconds, and nanoseconds.\n\nExample:\nAssuming the input DTL datetime is 2023-09-17 12:34:56.123456789, and the custom separator is -.\nThe function should return the string \"17-09-2023 12:34:56.123456789\" as the conversion result.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string according to the traditional format."}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为字符串，并按照自定义的分隔符输出。转换后的字符串格式应为DD<分隔符>MM<分隔符>YYYY<分隔符>HH:mm:ss.nnnnnnnn，其中<分隔符>为函数参数指定的字符。这里HH代表小时（24小时制），mm代表分钟，ss代表秒，nnnnnnnn代表纳秒。注意，分隔符不应用于时分秒纳秒之间。\\n\\n示例：\\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789，自定义分隔符为-。\\n函数应返回字符串\\\"17-09-2023 12:34:56.123456789\\\"作为转换结果。\n\n\n"}
{"title": "FIFO Buffer Management", "name": "LGF_FIFO", "description": "This function block implements the management functionality of a First-In-First-Out (FIFO) queue. It uses a variable-length array as a circular buffer, supporting the following operations: enqueue, dequeue, reset, and clear.\n\nThe enqueue operation adds a new element to the end of the queue, while the dequeue operation removes and returns the oldest unprocessed element from the front of the queue. The reset operation initializes the queue to an empty state, and the clear operation removes all elements from the queue and reinitializes it with initial values.\n\nThe function block provides error and status outputs, as well as information on the number of elements in the queue. If the queue is empty, the isEmpty output is true. If an error occurs during an operation, the error output is set to true, and the status and subFunctionStatus are set accordingly to indicate the type of error.\n\nExample:\nAssuming the initial length of the queue is 5 with an initial value of 0, using the enqueue operation to add new elements 1, 2, 3, 4, and 5 to the queue. Then, using the dequeue operation to consecutively remove and return elements 1, 2, 3, 4, and 5. After each dequeue operation, the elementCount will decrement until it reaches 0, at which point isEmpty will become true.", "type": "FUNCTION_BLOCK", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue item to the buffer"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue item from the buffer and return it on `item`"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value `initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: `0` / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8601": "ERR_INDEX_IN_ARRAY_LIMITS_1", "16#8602": "ERR_INDEX_IN_ARRAY_LIMITS_2", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_FIRST_ENTRY", "16#8612": "ERR_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": [], "description_zh": "\n该函数块实现了一个先进先出（FIFO）队列的管理功能。它使用一个变长数组作为循环缓冲区，支持以下操作：入队（enqueue）、出队（dequeue）、重置（reset）和清空（clear）。\\n\\n入队操作将新元素添加到队列的队尾，出队操作则从队首移除并返回最旧的未处理元素。重置操作将队列初始化为空状态，而清空操作则将队列中的所有元素清除，并用初始值重新初始化队列。\\n\\n函数块提供了错误和状态输出，以及队列中元素数量的信息。如果队列为空，则isEmpty输出为真。如果操作过程中发生错误，error输出将被设置为真，并相应地设置status和subFunctionStatus以指示错误类型。\\n\\n示例：\\n假设队列的初始长度为5，初始值为0。使用enqueue操作将新元素1、2、3、4和5添加到队列中。然后，使用dequeue操作连续移除并返回元素1、2、3、4和5。在每次dequeue操作后，elementCount将递减，直到为0，isEmpty将变为真。\n\n\n"}
{"title": "Pulse relay and toggle flip-flop operation", "name": "LGF_PulseRelay", "description": "This function block implements the functionality of a pulse relay or a flip-flop trigger, including set and reset inputs. When the rising edge of the trigger signal (trigger) arrives, the output signal (out) will switch (toggle). When the rising edge of the set signal (set) arrives, the output signal will be set to TRUE. When the rising edge of the reset signal (reset) arrives, the output signal will be set to FALSE. The reset signal takes precedence over the set signal or the trigger signal.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "FALSE Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "FALSE Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "FALSE Reset signal, rising edge (prior to set)"}], "output": [{"name": "out", "type": "Bool", "description": "Ooutput signal"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块实现了一个脉冲继电器或触发式触发器的功能，包括置位和复位输入。当触发信号（trigger）的上升沿到来时，输出信号（out）会进行切换（翻转）。当置位信号（set）的上升沿到来时，输出信号会被设置为TRUE。当复位信号（reset）的上升沿到来时，输出信号会被设置为FALSE。复位信号优先于置位信号或触发信号。\n\n\n"}
{"title": "Time to String Converter", "name": "LGF_TimeToString", "description": "A function FC that converts a system data type Time value to a string. The converted string format is \"\\\"DaysD_HoursH_MinutesM_SecondsS_MillisecondsMS\\\"\", where only the existing time units are added to the string. For example, if the time value only has hours and minutes, the string will only contain hours and minutes.\n\nExample:\nAssuming the input time value is T#1D_3H_45M_6S, the function should return the string \"\\\"1D3H45M6S0MS\\\"\" as the conversion result.", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "Time", "description": "Time value to convert Example: T#1D_3H_45M_6S"}], "output": [{"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "in/out": [], "return_value": [{"type": "String", "description": "Converted time as string. Example: 1D3H45M6S0MS"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将系统数据类型Time的时间值转换为字符串。转换后的字符串格式为\\\"天数D小时H分钟M秒S毫秒MS\\\"，其中只有存在的时间单位才会被添加到字符串中。例如，如果时间值只有小时和分钟，那么字符串将只包含小时和分钟。\\n\\n示例：\\n假设输入的时间值为T#1D_3H_45M_6S，那么函数应返回字符串\\\"1D3H45M6S0MS\\\"作为转换结果。\n\n\n"}
{"title": "Numeric Differentiation Function Block", "name": "LGF_DifferenceQuotientFB", "description": "A function block (FB) for calculating the first derivative (derivative) of a signal sampled at equal time intervals. The FB begins operation when the enable signal is activated. An insert signal is used to indicate when to include the input value in the derivative calculation. The FB requires at least five equally spaced sample values to calculate the derivative value, with the time interval specified by the parameter `deltaT`. An error will occur if `deltaT` is zero. The calculated derivative value is provided at the `derivatedValue` output. Status and error information are passed through the `error` and `status` outputs.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `derivatedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that must be included in the differentiation."}, {"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "derivatedValue", "type": "LReal", "description": "The differentiated value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification of the FB"}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a differentiated value.", "16#8200": "ERR_DELTA_T: Delta time `deltaT` must not be zero."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算等时间间隔采样信号的一阶导数（微分）。当使能信号激活时，该FB开始工作。插入信号用于指示何时将输入值包含在微分计算中。FB需要至少五个等时间间隔的采样值来计算微分值，其中时间间隔由参数`deltaT`指定。如果`deltaT`为零，则会发生错误。计算出的微分值在`derivatedValue`输出中提供。状态和错误信息通过`error`和`status`输出传递。\n\n\n"}
{"title": "Rectangle Signal Generator", "name": "LGF_RectangleCI", "description": "This function block FB is used to generate a rectangular signal waveform. It utilizes the time interval of the cyclic interrupt OB that calls it to control the waveform's period. The parameters of the rectangular wave include amplitude, offset, period, and phase shift. The function block calculates the current signal value based on these parameters and the OB's time interval, and returns it in the output parameter 'value'. If an error occurs, such as the OB being unavailable or a failure in querying OB information, the function block sets the output parameter 'error' and provides error codes in 'status' and 'subFunctionStatus'. The status code 16#0000 indicates no error, 16#8600 indicates that the OB is unavailable, and 16#8601 indicates a failure in querying OB information. If the input parameter 'reset' is set to TRUE, the function block will reset the counter and the signal value.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the rectangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个矩形信号波形。它利用调用它的循环中断OB的时间间隔来控制波形的周期。矩形波的参数包括振幅、偏移量、周期和相位偏移。函数块会根据这些参数和OB的时间间隔计算出当前信号值，并在输出参数value中返回。如果发生错误，比如OB不可用或者查询OB信息失败，函数块会在输出参数error中置位，并在status和subFunctionStatus中提供错误代码。状态代码16#0000表示没有错误，16#8600表示OB不可用，16#8601表示查询OB信息失败。如果输入参数reset为TRUE，函数块会将计数器和信号值重置。\n\n\n"}
{"title": "Linear Regression Calculator", "name": "LGF_RegressionLine", "description": "A function FC that calculates the linear regression line for data points. The function receives an array containing multiple data points, with each data point including X and Y coordinates. The calculation results include the slope and intercept of the regression line, or an error status if there are not enough data points. If the number of data points is less than two, the function is unable to calculate the regression line and returns an error status. The function does not return any value, but provides the calculation results through output parameters.", "type": "FUNCTION", "input": [], "output": [{"name": "slope", "type": "LReal", "description": "Gradient of straight line"}, {"name": "intercept", "type": "LReal", "description": "The intersection with the Y axis"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LGF_typeRegressionLine", "description": "The data points are transferred with their X- and Y-values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#8200": "ERR_NOT_ENOUGH_VALUES Error: Not enough Values."}, "user_defined_types": [{"name": "LGF_typeRegressionLine", "description": "UDT for transferring datapoints to LGF_RegressionLine", "member": [{"name": "x", "type": "Real", "default": "0.0", "description": "X-Axis value"}, {"name": "y", "type": "Real", "default": "0.0", "description": "Y-Axis value"}]}], "description_zh": "\n一个函数FC，用于计算数据点的线性回归线。该函数接收一个包含多个数据点的数组，每个数据点包含X和Y坐标。计算结果包括回归线的斜率（slope）和截距（intercept），如果没有足够的数据点，则返回错误状态。如果数据点的数量少于两个，函数将无法计算回归线，并返回错误状态。函数不返回任何值，但会通过输出参数提供计算结果。\n\n\n"}
{"title": "Sawtooth Signal Generator", "name": "LGF_SawToothCI", "description": "This function block FB is used to generate a sawtooth waveform signal. It utilizes the timing interval of calling the periodic interrupt OB to generate the signal and allows for setting the signal's amplitude, offset, period, and phase shift. The function block updates the current value of the signal at each periodic interrupt OB call and outputs this value. If an error occurs (such as the interrupt OB being unavailable), the function block sets an error flag and outputs the corresponding status code. A status code of 16#0000 indicates execution without error, 16#8600 indicates that the interrupt OB is unavailable, and 16#8601 indicates an error when querying the periodic interrupt.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sawtooth signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个锯齿波形的信号。它利用调用周期性中断OB的时间间隔来生成信号，并可以设置信号的振幅、偏移量、周期和相移。函数块在每次周期性中断OB调用时更新信号的当前值，并输出该值。如果出现错误（如中断OB不可用），函数块会设置错误标志并输出相应的状态码。状态码16#0000表示执行没有错误，16#8600表示中断OB不可用，16#8601表示查询周期性中断时出错。\n\n\n"}
{"title": "Matrix Scalar Multiplier", "name": "LGF_MatrixScalarMultiplication", "description": "This function is used to multiply a two-dimensional array (matrix) of type LREAL by a scalar. The function checks if the dimensions of the input matrix and the result matrix are consistent. If they match, it multiplies each element of the input matrix by the scalar and stores the result in the result matrix. If the matrix dimensions are inconsistent, the function will return an error status. Upon successful execution, the function will return the STATUS_NO_ERROR status code.", "type": "FUNCTION", "input": [{"name": "scalar", "type": "LReal", "description": "Scalar value where the matrix is multiplied"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrixInput", "type": "Array[*, *] of LReal", "description": "Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "The result matrix of the multiplication"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_MATRICES_LOWER_BOUND_ROWS_DONT_MATCH", "16#8202": "ERR_MATRICES_UPPER_BOUND_ROWS_DONT_MATCH", "16#8203": "ERR_MATRICES_LOWER_BOUND_COLUMNS_DONT_MATCH", "16#8204": "ERR_MATRICES_UPPER_BOUND_COLUMNS_DONT_MATCH"}, "user_defined_types": [], "description_zh": "\n该函数用于将一个LREAL类型的二维数组（矩阵）与一个标量（scalar）相乘。函数会检查输入矩阵和结果矩阵的维度是否一致，如果一致，则将输入矩阵的每个元素乘以标量，并将结果存储在结果矩阵中。如果矩阵维度不一致，则函数会返回错误状态。成功执行后，函数将返回STATUS_NO_ERROR状态码。\n\n\n"}
{"title": "N-th root extraction", "name": "LGF_NthRoot", "description": "A function FC that calculates and returns the nth root of a given number. The function accepts two input parameters: value (LReal type), which represents the number for which the root is to be calculated; and root (LReal type), which represents the exponent of the root. The function checks whether the input number is negative because negative numbers do not have real square roots. If the input number is negative, the function will return an error flag and an error status code. Otherwise, the function calculates and returns the nth root of the given number.\n\nExample:\nAssuming the input number is 8 and the root exponent is 3, the function should return 2 as the result of the cube root.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value from which the root should be calculated"}, {"name": "root", "type": "LReal", "description": "Exponent of root"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Returns the Nth root of a value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NEG_VAR"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数计算并返回给定数值的n次方根。函数接受两个输入参数：value（LReal类型），表示要计算其根的数值；root（LReal类型），表示根的指数。函数会检查输入的数值是否为负数，因为负数没有实数平方根。如果输入数值为负数，函数将返回错误标志和错误状态代码。否则，函数计算并返回给定数值的n次方根。\\n\\n示例：\\n假设输入数值为8，根的指数为3，函数应返回2作为立方根的结果。\n\n\n"}
{"title": "US calendar week calculation", "name": "LGF_GetCalendarWeek_US", "description": "Function FC, used to calculate the calendar week number in countries such as the United States and some others. The function accepts a date parameter of type DTL and calculates the calendar week number for that date as well as the number of days since January 1st of the same year. The calendar week starts on Sunday, and the week containing January 1st is always considered Week 1. A year may have either 52 or 53 weeks, depending on the day of the week January 1st falls on and whether the year is a leap year.\n\nThe function will check if the input date is within a valid range and return an appropriate error code in case of an error. If the input date is valid, the function will return the calendar week number and the number of days since January 1st.\n\nExample:\nIf the input date is January 1, 2023, the function should return a calendar week number of 1 and the number of days since January 1st as 0.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算美国及其他一些国家使用的日历周数。该函数接收一个DTL类型的日期参数，并计算出该日期所处的日历周数以及距离当年1月1日以来的天数。日历周数以周日为一周的开始，并且包含1月1日的周总是第1周。一年可能有52周或53周，具体取决于1月1日是星期几以及当年是否为闰年。\\n\\n函数会检查输入日期是否超出有效范围，并在发生错误时返回相应的错误代码。如果输入日期有效，函数将返回日历周数和自1月1日起的天数。\\n\\n示例：\\n如果输入日期为2023年1月1日，则函数应返回日历周数为1，自1月1日起的天数为0。\n\n\n"}
{"title": "String to TADDR_Param Converter", "name": "LGF_StringToTaddr", "description": "The function FC converts a string-formatted IPv4 address and an optional port number into the TADDR_Param system data type. The IPv4 address string format is \"192.168.1.200\", and the port number, if specified, is formatted as \"192.168.1.200:55047\".\n\nThe function first processes the input string, splitting it into four IP segments and checking if each segment is empty, if its length is correct, and if its numerical value does not exceed the maximum IP address range. If the input format is correct, each segment's value is converted to a number and stored in the corresponding position of the TADDR_Param data type. If the input string contains a port number, it also checks if the length of the port number is correct and if its value does not exceed the maximum port number range. If the port number format is correct, it is converted to a number and stored in the port number position of the TADDR_Param data type.\n\nIf an error occurs during the conversion process, the function sets an error flag 'error' and returns the corresponding error status 'status'. If the conversion is successful, the function returns the TADDR_Param data type containing the IPv4 address and the port number.", "type": "FUNCTION", "input": [{"name": "ipAddressString", "type": "String", "description": "IPV4 address string in the format of 192.168.1.200:55047 [Port number including colon : is optional]"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "TADDR_Param", "description": "IP-Address and Port number as TADDR_Param data type"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8110": "ERR_OCTET_WRONG_NUMBER_OF_CHAR", "16#8120": "ERR_OCTET_STRING_IS_EMPTY", "16#8130": "ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS", "16#8150": "ERR_PORT_WRONG_NUMBER_OF_CHAR", "16#8151": "ERR_PORT_STRING_IS_EMPTY", "16#8152": "ERR_PORT_EXCEEDS_MAX_PORT"}, "user_defined_types": [], "description_zh": "\n该函数FC将字符串格式的IPv4地址和端口号转换为TADDR_Param系统数据类型。IPv4地址字符串格式为\"192.168.1.200\"，端口号为可选参数，如果指定则格式为\"192.168.1.200:55047\"。\n\n函数首先对输入的字符串进行处理，将其分为四个IP段，并检查每个IP段是否为空，长度是否正确，数值是否超出最大IP地址范围。如果输入格式正确，则将每个IP段的值转换为数值，并存储在TADDR_Param数据类型的相应位置。如果输入字符串中包含端口号，则还会检查端口号的长度是否正确，数值是否超出最大端口号范围。如果端口号格式正确，则将其转换为数值，并存储在TADDR_Param数据类型的端口号位置。\n\n如果转换过程中出现错误，则函数会设置错误标志error，并返回相应的错误状态status。如果转换成功，则函数会返回包含IPv4地址和端口号的TADDR_Param数据类型。\n\n\n"}
{"title": "Value range limit check", "name": "LGF_IsValueInLimits", "description": "A function FC that checks whether a given real number (LReal type) is within two specified limits. The limits are defined by the input parameters lowLimit and highLimit. The function returns a boolean value, returning TRUE if the input value value is within the limits; otherwise, it returns FALSE. Additionally, the function provides two output parameters, overHighLimit and belowLowLimit, which indicate whether the input value exceeds the upper limit or is below the lower limit, respectively. If the upper limit value is less than the lower limit value, the function reports an error and sets the status code to ERR_RANGE_HIGH_BELOW_LOW_LIMIT.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_HIGH_BELOW_LOW_LIMIT"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检查一个给定的实数（LReal类型）是否位于两个指定界限之间。界限由输入参数lowLimit和highLimit定义。函数会返回一个布尔值，如果输入值value在界限之内，则返回TRUE；否则返回FALSE。此外，函数还提供了两个输出参数overHighLimit和belowLowLimit，分别指示输入值是否超过了上限或低于下限。如果上限值小于下限值，函数将报告一个错误，并将状态码设置为ERR_RANGE_HIGH_BELOW_LOW_LIMIT。\n\n\n"}
{"title": "Double word edge detection", "name": "LGF_GetBitStates", "description": "A function block FB that detects the rising and falling edges of each bit in a 32-bit double word (DWord) input value. The function block returns a boolean value indicating whether the input value has changed, and two boolean values indicating the presence of a rising edge or a falling edge, respectively. Additionally, the function block returns a DWord containing the bit streams of rising and falling edges, as well as two USInt type outputs, indicating the number of rising and falling edges, respectively.\n\nExample:\nAssuming the input value changes from 2#101 to 2#11011, the number of rising edges is 3, the bit stream of the rising edges is 2#11010, the number of falling edges is 1, and the bit stream of the falling edges is 2#100.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Check input value for changes and edges"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "Input value has changed (compared to the previous cycle)"}, {"name": "hasRisingEdges", "type": "Bool", "description": "Input value has rising edges"}, {"name": "risingBits", "type": "DWord", "description": "Bitstream with the rising edges"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "Input value has falling edges"}, {"name": "fallingBits", "type": "DWord", "description": "Bitstream with the falling edges"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于检测32位双字（DWord）输入值中的每个比特的上升沿和下降沿。函数块会返回一个布尔值，指示输入值是否发生变化，以及两个布尔值，分别指示是否存在上升沿或下降沿。同时，函数块还会返回一个包含上升沿和下降沿位流的DWord，以及两个USInt类型的输出，分别表示上升沿和下降沿的数量。\\n\\n示例：\\n假设输入值从2#101变为2#11011，则上升沿数量为3，上升边沿的位流为2#11010，下降沿数量为1，下降边沿的位流为2#100。\n\n\n"}
{"title": "Non-Linear Interpolation Function", "name": "LGF_NonLinearInterpolation", "description": "A function block FB, used to implement non-linear interpolation functionality. This function block realizes characteristic curves by defining interpolation point tables and uses linear interpolation to calculate the output value corresponding to the input value. The characteristic curve can be non-linear, achieved by smoothly transitioning the curve through linear interpolation between interpolation points.\n\nThe function block has the following features:\n1. Calculate output value: Based on the input value and interpolation point table, calculate the corresponding output value.\n2. Default output value: If the default output value is enabled, the input value is directly used as the output value.\n3. Tracking mode: If in tracking mode, the output value will follow the input value changes without using the characteristic curve for interpolation.\n4. Reset: If changes in the interpolation point table are detected during operation, the interpolation process can be reset.\n\nThe function block has the following input and output parameters:\n- Input value (value): The input parameter used to calculate the output value.\n- Default output value (defaultOutValue): The preset output value.\n- Enable default output value (enDefaultOutValue): A boolean value indicating whether to use the default output value.\n- Tracking mode (track): A boolean value indicating whether to use tracking mode.\n- Reset (reset): A boolean value indicating whether to reset the interpolation process.\n- Output value (outputValue): The calculated output value.\n- Interpolation point table (setpoints): An array of interpolation points used to define the characteristic curve. \n\nThe function block uses the linear interpolation method to calculate between the given interpolation points to obtain the output value corresponding to the input value.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Input value for calculating the output value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow the value of the input without using the characteristic curve"}, {"name": "reset", "type": "Bool", "description": "Reset the interpolation if the point table is changed in running operation"}], "output": [{"name": "outputValue", "type": "LReal", "description": "The calculated output value from the input value"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeNonLinSetpoints", "description": "Setpoint table for defining the characteristic curve"}], "return_value": [], "status_codes": {}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}], "description_zh": "\n一个函数块FB，用于实现非线性插值功能。该函数块通过定义插值点表来实现特性曲线，并使用线性插值来计算输入值对应的输出值。特性曲线可以是非线性的，通过在插值点之间进行线性插值来实现曲线的平滑过渡。\n\n函数块具有以下功能：\n1. 计算输出值：根据输入值和插值点表，计算得到对应的输出值。\n2. 默认输出值：如果使能默认输出值，则将输入值直接作为输出值。\n3. 跟踪模式：如果处于跟踪模式，则输出值将跟随输入值变化，不使用特性曲线进行插值。\n4. 重置：如果检测到插值点表在运行过程中发生变化，可以重置插值过程。\n\n函数块具有以下输入输出参数：\n- 输入值（value）：用于计算输出值的输入参数。\n- 默认输出值（defaultOutValue）：预设的输出值。\n- 使能默认输出值（enDefaultOutValue）：布尔值，用于指示是否使用默认输出值。\n- 跟踪模式（track）：布尔值，用于指示是否使用跟踪模式。\n- 重置（reset）：布尔值，用于指示是否重置插值过程。\n- 输出值（outputValue）：计算得到的输出值。\n- 插值点表（setpoints）：用于定义特性曲线的插值点数组。\n\n函数块使用线性插值方法，在给定的插值点之间进行计算，得到输入值对应的输出值。\n\n\n"}
{"title": "32-Bit to DWord Merger", "name": "LGF_MergeBitsToDWord", "description": "The function's purpose is to combine 32 boolean variables (each representing a bit) into a 32-bit double word (DWord) variable. The input 32 boolean variables represent bits 31 to 0 of the DWord variable (with bit 31 being the most significant bit and bit 0 being the least significant bit). The function merges these boolean variables into a DWord variable through bit-by-bit operations and returns this combined DWord variable. There is no error handling in the function, so ENO is always set to TRUE.", "type": "FUNCTION", "input": [{"name": "bit31", "type": "Bool", "description": "Input Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Input Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Input Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Input Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Input Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Input Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Input Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Input Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Input Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Input Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Input Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Input Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Input Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Input Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Input Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Input Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Input Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Bit sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数功能是将32个布尔型变量（每个代表一个比特位）合并成一个32位双字（DWord）变量。输入的32个布尔变量分别代表DWord变量的第31位到第0位（其中第31位是最高位，第0位是最低位）。函数通过逐位操作将这些布尔变量合并成一个DWord变量，并返回这个合并后的DWord变量。函数中没有错误处理，因此ENO始终设置为TRUE。\n\n\n"}
{"title": "Word to 16-Bit Splitter", "name": "LGF_SplitWordToBits", "description": "A function FC that takes a Word type variable and splits it into 16 Boolean (Bool) outputs, with each Boolean output corresponding to a bit in the word. The Boolean variables are output from bit15 to bit0, where bit15 corresponds to the most significant bit (MSB) of the word, and bit0 corresponds to the least significant bit (LSB).", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "bit15", "type": "Bool", "description": "Output Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数将一个字（Word）类型的变量分割成16个布尔型（Bool）的输出，每个布尔型输出对应字中的一个位。输出的布尔型变量从bit15到bit0，其中bit15对应字的最高位（MSB），bit0对应字的最低位（LSB）。\n\n\n"}
{"title": "2-Byte to Word Merger", "name": "LGF_MergeBytesToWord", "description": "The function merges two single-byte data (byte1 and byte0) into a double-word (word) data. In the merging process, byte1 serves as the high byte, and byte0 as the low byte. The function uses byte access instructions to write the input byte data into the high byte and low byte parts of the double-word variable, respectively, and then returns the merged double-word data as the function's return value.", "type": "FUNCTION", "input": [{"name": "byte1", "type": "Byte", "description": "Input Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Byte sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数功能将两个单字节数据(byte1和byte0)合并成一个双字(word)数据。在合并过程中，byte1作为高字节，byte0作为低字节。函数使用字节访问指令，将输入的字节数据分别写入双字变量的高字节和低字节部分，然后将合并后的双字数据作为函数返回值输出。\n\n\n"}
{"title": "Matrix Inverter", "name": "LGF_MatrixInverse", "description": "This is a function FC that calculates and outputs the inverse of a two-dimensional array (matrix) of type LREAL. The function first checks if the input matrix is a square matrix, meaning the number of rows and columns are equal. If the input matrix is not a square matrix, the function will return the error status ERR_NOT_SQUARE_MATRIX. Next, the function checks if the boundaries of the input and output matrices are consistent; if not, it will return the corresponding error status. If all checks pass, the function will calculate the inverse of the input matrix and store it in the output matrix. During the calculation process, the function uses the Gaussian-Jordan elimination method and avoids division by zero. If the algorithm cannot be executed, it will return the error status ERR_ALGORITHM_NOT_POSSIBLE. If the calculation is successful, the function will return the status STATUS_NO_ERROR, indicating that no error has occurred.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Square input matrix that will be inversed"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Inverted matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NOT_SQUARE_MATRIX", "16#8201": "ERR_ALGORITHM_NOT_POSSIBLE", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，用于计算并输出一个LREAL类型的二维数组（矩阵）的逆矩阵。函数首先检查输入矩阵是否为方阵，即行数和列数相等。如果输入矩阵不是方阵，函数将返回错误状态ERR_NOT_SQUARE_MATRIX。接下来，函数检查输入矩阵和输出矩阵的边界是否一致，如果不一致，将返回相应的错误状态。如果所有检查都通过，函数将计算输入矩阵的逆矩阵，并将其存储在输出矩阵中。计算过程中，函数使用高斯-约当消元法，并避免除以零的情况。如果算法无法执行，将返回错误状态ERR_ALGORITHM_NOT_POSSIBLE。如果计算成功，函数将返回状态STATUS_NO_ERROR，表示没有错误发生。\n\n\n"}
{"title": "Bit toggle operation in DWORD", "name": "LGF_BitToggle", "description": "A function FC that takes a DWord type input value and an unsigned short integer (USInt) bit position input. The function's purpose is to toggle the bit at the specified position in the input DWord. If the bit is originally 0, it is changed to 1; if it is originally 1, it is changed to 0. The bit position is counted from 0, with the least significant bit being bit 0. The function returns the DWord result after the bit has been toggled.\n\nExample:\nAssuming the input DWord value is 2#10101010 and the bit position is 3. The function should toggle bit 3 (the fourth bit from the left) and return the value 2#10100010.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be toggled"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to be toggled in the “value” parameter."}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with toggled bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数接受一个双字（DWord）类型的输入值和一个无符号短整型（USInt）的位号输入。函数的作用是切换输入双字中指定位置的位。如果该位原本是0，则切换为1；如果原本是1，则切换为0。位号从0开始计数，即最低位是位0。函数会返回切换位后的双字结果。\\n\\n示例：\\n假设输入的双字值为2#10101010，位号为3。函数应切换位3（从左数第四位），返回值为2#10100010。\n\n\n"}
{"title": "Boxplot Calculation for Unsigned Integer Data", "name": "LGF_Boxplot_UDInt", "description": "A function block FB used for calculating the Boxplot of an unsigned integer data array. This function block receives a boolean input signal `execute`, which activates the calculation upon a rising edge. Another input parameter `rangeOutlier` is used to specify the parameters for outlier detection. The function block sorts the input unsigned integer array `values` and calculates five key statistics: the minimum value (non-outlier), the first quartile (Q25), the median (Q50), the third quartile (Q75), and the maximum value (non-outlier). Additionally, the function block calculates the percentage of outliers and the skewness of the data. If the input array is empty or the `rangeOutlier` parameter is invalid, the function block reports an error. Finally, the function block outputs the calculation results, including whether an error occurred, status code, sub-function status code, percentage of outliers, the five key statistics, and skewness.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "UDInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "UDInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于对无符号整型数据数组进行盒须图（Boxplot）计算。该函数块接收一个布尔型输入信号`execute`，当该信号发生上升沿时激活计算。另一个输入参数`rangeOutlier`用于指定异常值检测的参数。函数块对输入的无符号整型数组`values`进行排序，并计算五个关键统计量：最小值（非异常值）、第一四分位数（Q25）、中位数（Q50）、第三四分位数（Q75）和最大值（非异常值）。此外，函数块还计算异常值的百分比和数据的偏度。如果输入数组为空或者`rangeOutlier`参数不合法，函数块将报告错误。最终，函数块输出计算结果，包括是否发生错误、状态码、子函数状态码、异常值百分比、五个关键统计量和偏度。\n\n\n"}
{"title": "Function Curve Area Calculator", "name": "LGF_Integration", "description": "This function block is used to calculate the area under a function curve. It performs approximate integration using the trapezoidal rule. When the enable input is true, the function block reads the analog input values and calculates the time difference since the last read time. It then uses this information to update the accumulated area under the curve and stores the result in the output \"integral\". If the reset input is true, the integral value is reset to 0.0. The function block also includes error flags and status code outputs to indicate any issues during execution. The status codes include execution completed without errors and an error in reading the system time. The function block does not use the ENO mechanism for error handling but relies on error and status outputs instead.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enables integral calculation"}, {"name": "value", "type": "LReal", "description": "Analog value of the continuous function curve, based on [ms]"}, {"name": "reset", "type": "Bool", "description": "Sets the output 'integral' to '0.0'"}], "output": [{"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8600": "ERR_READ_SYS_TIME"}, "user_defined_types": [], "description_zh": "\n该函数块用于计算函数曲线下的面积。它使用梯形法则进行近似积分。当使能输入为真时，函数块会读取模拟输入值，并计算从上次读取时间以来的时间差。然后，它使用这些信息来更新曲线下的累积面积，并将结果存储在输出“integral”中。如果重置输入为真，则积分值会被重置为0.0。函数块还包括错误标志和状态码输出，用于指示执行过程中的任何问题。状态码包括执行完成且无错误以及读取系统时间出错。函数块不使用ENO机制，而是通过错误和状态输出进行错误处理。\n\n\n"}
{"title": "16-Bit to Word Merger", "name": "LGF_MergeBitsToWord", "description": "A function FC that takes 16 boolean input bits and combines them into a Word type output. The 16 boolean values correspond to the 16 bits in the output Word value, with the most significant bit (MSB) being bit15 and the least significant bit (LSB) being bit0.\n\nExample:\nAssuming the 16 boolean inputs are as follows:\nbit15: TRUE\nbit14: FALSE\nbit13: TRUE\nbit12: FALSE\nbit11: TRUE\nbit10: FALSE\nbit9: TRUE\nbit8: FALSE\nbit7: TRUE\nbit6: FALSE\nbit5: TRUE\nbit4: FALSE\nbit3: TRUE\nbit2: FALSE\nbit1: TRUE\nbit0: FALSE\n\nThe function should convert these boolean values into the corresponding binary sequence and store that sequence in a Word variable, which will be returned as the function's output. The converted Word value is 0xAAAA.", "type": "FUNCTION", "input": [{"name": "bit15", "type": "Bool", "description": "Input Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Bit sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将16个布尔类型的输入位合并成一个字（Word）类型的输出。输入的16个布尔值分别对应于输出的Word值中的16个位，其中最高有效位（MSB）为bit15，最低有效位（LSB）为bit0。\\n\\n示例：\\n假设输入的16个布尔值分别为：\\nbit15: TRUE\\nbit14: FALSE\\nbit13: TRUE\\nbit12: FALSE\\nbit11: TRUE\\nbit10: FALSE\\nbit9: TRUE\\nbit8: FALSE\\nbit7: TRUE\\nbit6: FALSE\\nbit5: TRUE\\nbit4: FALSE\\nbit3: TRUE\\nbit2: FALSE\\nbit1: TRUE\\nbit0: FALSE\\n\\n函数应将这些布尔值转换为对应的二进制序列，并将该序列存储在一个Word变量中，作为函数的返回值。转换后的Word值为0xAAAA。\n\n\n"}
{"title": "Shell Sort for LReal Arrays", "name": "LGF_ShellSort_LReal", "description": "A function block FB that can sort an LReal array of any length (up to a maximum of 1000 elements) in ascending or descending order. The sorting result will overwrite the original array. The function block accepts a boolean input parameter sortDirection, where FALSE indicates ascending order and TRUE indicates descending order. The function block also provides an error output error and a status output status to indicate whether an error has occurred during the sorting process and the type of error. If the input array is empty or the number of elements exceeds 1000, the function block will return an error status.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块可以对任意长度的LReal数组（最大1000个元素）进行升序或降序排序。排序结果会覆盖原始数组。函数块接受一个布尔类型的输入参数sortDirection，当为FALSE时表示升序排序，为TRUE时表示降序排序。函数块还提供了错误输出error和状态输出status，用于指示排序过程中是否出现错误以及错误类型。如果输入数组为空或者元素数量超过1000，函数块会返回错误状态。\n\n\n"}
{"title": "CRC-32 Calculator", "name": "LGF_CalcCRC32", "description": "A function FC that calculates the CRC-32 value of an input data stream. The function uses a 32-bit generator polynomial (mask) for CRC computation and allows specifying an initial value for the calculation. The inputs to the function include an initialization value, a generator polynomial, the number of elements to compute, and a byte array. The output of the function is the computed CRC value, an error flag, and a status code. If the specified number of elements exceeds the size of the array, the function will return an error status ERR_NO_OF_ELEMENTS (16#8400). Otherwise, the function will compute and return the CRC value with a status code of STATUS_NO_ERROR (16#0000).", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算输入数据流的CRC-32值。该函数使用32位生成多项式（掩码）来进行CRC计算，并允许指定计算的起始值。函数的输入包括初始化值、生成多项式、要计算元素的数量以及一个字节数组。函数的输出为计算得到的CRC值，以及错误标志和状态码。如果指定的元素数量超出数组大小，函数将返回错误状态ERR_NO_OF_ELEMENTS (16#8400)。否则，函数将计算并返回CRC值，状态码为STATUS_NO_ERROR (16#0000)。\n\n\n"}
{"title": "Boolean signal edge detection", "name": "LGF_CountBooleanEdges", "description": "A function block FB used for monitoring a boolean input signal and evaluating its different states within a certain period of time. This function block is capable of detecting the rising edge of the signal and outputs different state signals based on the number of edges that appear during the monitoring period. Specifically, it can detect the following states:\n\n1. Single edge (single): Only one edge is detected during the monitoring period, and the input signal is FALSE after this edge.\n2. Double edge (double): Two edges are detected during the monitoring period.\n3. Long signal (long): Only one edge is detected during the monitoring period, and the input signal remains TRUE after this edge.\n4. Several edges (severalEdges): Multiple edges are detected during the monitoring period.\n\nAdditionally, the function block also outputs the total number of edges detected during the monitoring period (noOfEdges).\n\nExample:\nAssuming the input signal turns TRUE, then FALSE, and then TRUE again and remains TRUE during the monitoring period, the function block should output a single edge (single) and a long signal (long).", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to evaluate signal"}, {"name": "monitorTime", "type": "Time", "description": "Time to monitor and count edges on `trigger` input"}], "output": [{"name": "single", "type": "Bool", "description": "Single edge until monitoring time expires"}, {"name": "double", "type": "Bool", "description": "Two edges in between the monitoring time"}, {"name": "long", "type": "Bool", "description": "Just a single edge in the monitoring time, the `trigger` input stays TRUE after the edge appears"}, {"name": "severalEdges", "type": "Bool", "description": "Numerous Edges occur within the monitoring time"}, {"name": "noOfEdges", "type": "USInt", "description": "Number of edges in between the monitoring time frame"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于监测一个布尔型输入信号，并在一定时间内评估该信号的不同状态。该函数块能够检测信号的上升沿，并根据监测时间内出现的边缘数量，输出不同的状态信号。具体来说，它可以检测以下状态：\\n\\n1. 单个边缘（single）：在监测时间内只检测到一个边缘，并且该边缘之后输入信号为FALSE。\\n2. 双边缘（double）：在监测时间内检测到两个边缘。\\n3. 长信号（long）：在监测时间内只检测到一个边缘，并且该边缘之后输入信号保持为TRUE。\\n4. 多个边缘（severalEdges）：在监测时间内检测到多个边缘。\\n\\n此外，该函数块还会输出在监测时间内检测到的边缘总数（noOfEdges）。\\n\\n示例：\\n假设输入信号在监测时间内先变为TRUE，然后又变为FALSE，然后再变为TRUE并保持为TRUE，则该函数块应输出单个边缘（single）和长信号（long）。\n\n\n"}
{"title": "Bit reset operation in DWORD", "name": "LGF_BitReset", "description": "This is a function FC that is used to reset specified bits to 0 in a DWORD data type variable. The function takes two input parameters: one is the DWORD value in which the bits need to be reset, and the other is the bit number to be reset. The bit number starts from 0 and can go up to 31, corresponding to the 32 bits of the DWORD. The function creates a bit mask with only the specified bit set to 0 by shifting a true bit (i.e., the bit with the lowest bit as 1 and all other bits as 0) left by the specified number of positions, and then using the XOR operation to combine the result with a DWORD of all 1s. Finally, the AND operation is used to apply this bit mask to the original DWORD value, thereby resetting the specified bit.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with reset bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，用于将DWORD数据类型变量中的指定位重置为0。函数接收两个输入参数：一个是要重置位的DWORD值，另一个是要重置的位的编号。位的编号从0开始，最大值为31，对应于DWORD的32位。函数通过将一个真实的位（即最低位为1，其他位为0的位）左移指定的位数，然后使用XOR操作将结果与全1的DWORD进行异或，从而创建一个只在指定位置为0的位掩码。最后，使用AND操作将这个位掩码与原始的DWORD值进行AND操作，从而重置指定的位。\n\n\n"}
{"title": "Shell Sort for UDInt Arrays", "name": "LGF_ShellSort_UDInt", "description": "A function block FB that sorts an array of type UDInt using the Shell sort algorithm. The array can contain any number of elements (up to a maximum of 1000), and can be sorted in ascending or descending order based on the input parameter sortDirection. The sorted array will overwrite the original array. If the array is empty or the number of elements exceeds the maximum limit, the function will return an error status.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of UDInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块使用希尔排序算法对UDInt类型的数组进行排序。该数组可以包含任意数量的元素（最多1000个），并且可以根据输入参数sortDirection选择升序或降序排列。排序后的数组将覆盖原始数组。如果数组为空或元素数量超过最大限制，函数将返回错误状态。\n\n\n"}
{"title": "Advanced Rate of Change Limiter", "name": "LGF_LimRateOfChangeAdvancedCI", "description": "The function block FB is used to limit the rate of change of input variables and has multiple operating modes. It is capable of processing and limiting the rate of change of input signals, providing manual control over output values, and restricting the slope of rise and fall within positive and negative value ranges. Additionally, it can set high and low limit values and provides a default output value. The function block supports automatic, manual, and tracking modes and is able to restart in the event of an error. It can also invoke periodic interrupt organization blocks (OB) for wake-up alarms.\n\nIn automatic mode, the function block calculates the output value based on the set rates of rise and fall, as well as the cycle time. If the input value exceeds the set rate limits, the output value will be restricted to the maximum or minimum allowable value. In manual mode, the output value is determined by the manual control value. In tracking mode, the output value will follow the changes of the input value.\n\nThe function block also includes error handling and status codes for diagnosis in the event of an error. Status codes include no error, negative rate limit error, negative rate change error, query CINT error, and OB unavailable error.", "type": "FUNCTION_BLOCK", "input": [{"name": "autoValue", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "manualValue", "type": "LReal", "description": "Manually controlled output value"}, {"name": "posUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the positive value range"}, {"name": "posDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the positive value range"}, {"name": "negUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the negative value range"}, {"name": "negDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the negative value range"}, {"name": "highLim", "type": "LReal", "description": "High limit value"}, {"name": "lowLim", "type": "LReal", "description": "Low limit value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow / tracking of Input variable"}, {"name": "manOp", "type": "Bool", "description": "Manual mode on"}, {"name": "reset", "type": "Bool", "description": "Complete restart of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output variable"}, {"name": "posUpRateLim", "type": "Bool", "description": "Rise limitation in positive range tripped"}, {"name": "posDownRateLim", "type": "Bool", "description": "Down rate limit in positive range reached"}, {"name": "negUpRateLim", "type": "Bool", "description": "Up rate limit in negative range reached"}, {"name": "negDownRateLim", "type": "Bool", "description": "Down rate limit in negative range reached"}, {"name": "highLim", "type": "Bool", "description": "High limit reached"}, {"name": "lowLim", "type": "Bool", "description": "Low limit reached"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8202": "ERR_NEG_RATE_OF_CHANGE", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table for function", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}], "description_zh": "\n该函数块FB用于限制输入变量的变化速率，具有多种操作模式。它能够处理并限制输入信号的变化速率，提供手动控制输出值，以及限制在正值和负值范围内的上升和下降斜率。此外，它还能够设置高限制值和低限制值，并提供默认输出值。该函数块支持自动模式、手动模式和跟踪模式，并能够在出现错误时进行重启。它还能够调用周期性中断组织块（OB）以进行唤醒警报。\n\n在自动模式下，函数块会根据设定的上升和下降速率限制以及周期时间来计算输出值。如果输入值超出了设定的速率限制，输出值将会被限制在最大或最小允许值内。在手动模式下，输出值将由手动控制值决定。在跟踪模式下，输出值将会跟随输入值的变化。\n\n该函数块还包括了错误处理和状态代码，以便在出现错误时进行诊断。状态代码包括完成且无错误、负速率限制错误、负速率变化错误、查询CINT错误和OB不可用错误。\n\n\n"}
{"title": "Word Endianness Adjuster", "name": "LGF_SwapBlockWord", "description": "The function FC is used to adjust the byte order of multi-byte data type values. It takes an array of Word type as input and swaps the bytes of each Word element in the array to achieve conversion between big-endian and little-endian byte order. The function does not care about the byte order of the original or target system, so it can be used universally on any system. The function iterates through the array elements in a loop and swaps the byte order internally, thus adjusting the byte order. This adjustment process is very useful for handling data exchange between systems with different byte orders. The function does not return a value; all conversions are performed within the input array.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of Word", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC用于调整多字节数据类型值的字节序。函数接收一个Word类型的数组作为输入，并对数组中的每个Word元素进行字节交换，以实现大端和小端字节序之间的转换。函数不关心原始系统或目标系统的字节序，因此可以在任何系统上通用使用。函数通过一个循环迭代数组元素，并在内部交换字节顺序，从而实现字节序的调整。这个调整过程对于处理不同字节序系统之间的数据交换非常有用。函数没有返回值，所有的转换都在输入数组中进行。\n\n\n"}
{"title": "UTF-8 Byte Stream Decoder", "name": "LGF_DecodeUtf8", "description": "和\n\nA function FC that decodes a UTF-8 encoded byte stream into a wide string WString. The function takes a UTF-8 encoded byte stream array, the starting position for decoding, and the number of characters to decode as input. If the number of characters is 0, the function will decode all characters from the starting position to the end of the byte stream. The function also outputs the decoded string and a status code, which is used to indicate errors or warnings during the decoding process, such as characters being out of the supported range, the byte stream length exceeding the maximum limit, etc. The function uses some temporary variables internally to store intermediate results during the decoding process, such as the Unicode code point of the current character being decoded, the current position, etc. Finally, the function outputs the decoded string and status code.", "type": "FUNCTION", "input": [{"name": "byteStream", "type": "Array[*] of Byte", "description": "UTF-8 encoded byte stream"}, {"name": "startPos", "type": "DInt", "description": "Position in byte stream to start decoding from"}, {"name": "count", "type": "UInt", "description": "Number of character (not bytes) to decode; 0: byte stream is decoded until end"}], "output": [], "in/out": [{"name": "decodedString", "type": "WString", "description": "Decoded string"}], "return_value": [{"type": "Word", "description": "Status of the FC, Error identification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7FFD": "WARN_UNSUPPORTED_CHAR", "16#7FFE": "WARN_STREAM_EXCEEDS_MAX_LEN", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS", "16#8203": "ERR_COUNT_EXCEEDS_MAX_LEN"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将UTF-8编码的字节流解码为宽字符串WString。函数接收一个UTF-8编码的字节流数组、开始解码的位置和要解码的字符数量作为输入。如果字符数量为0，则函数会解码从开始位置到字节流末尾的所有字符。函数还会输出解码后的字符串和状态码，状态码用于指示解码过程中的错误或警告，例如字符超出支持范围、字节流长度超过最大限制等。函数内部使用了一些临时变量来存储解码过程中的中间结果，例如当前解码字符的Unicode码点、当前位置等。最后，函数将解码后的字符串和状态码输出。\n\n\n"}
{"title": "String to DInt Converter", "name": "LGF_StringToInt", "description": "This is a function FC that converts a string to a double integer (DInt) value. The function accepts a string input parameter and returns a double integer type output value.\\n\\nExample:\\nIf the input string is \\\"+16927\\\", the function should return the double integer value 16927 as the conversion result.\\nNote that the input string can be signed or unsigned. If the value represented by the string exceeds the range of the double integer type, the function may return an error value.", "type": "FUNCTION", "input": [{"name": "value", "type": "String", "description": "String value to be converted to Double-Integer. Example: ‘+16927’"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted Double-Integer value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，该函数能够将字符串转换为双整数（DInt）类型的数值。函数接受一个字符串类型的输入参数，并返回一个双整数类型的输出值。\\n\\n示例：\\n假设输入的字符串为\\\"+16927\\\"，函数应返回双整数值16927作为转换结果。\\n注意，输入的字符串可以是带符号的，也可以是不带符号的。如果字符串表示的数值超出了双整数类型的范围，函数可能会返回一个错误值。\n\n\n"}
{"title": "GPS-DD to GPS Direction DMS Converter", "name": "LGF_GpsDDToGps", "description": "A function FC that converts GPS decimal degrees (DD) format to direction, degrees, minutes, and seconds (DMS) format GPS data. The function accepts GPS data in decimal degrees for latitude and longitude as input and returns a GPS data structure containing direction, degrees, minutes, and seconds. Additionally, the function checks the validity of the input values and reports an error status when the input values are invalid.", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS_DD", "description": "GPS-Data to be converted (decimal degrees)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS", "description": "Converted GPS-Data (direction, degrees, minutes, and seconds)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8201": "ERR_LATITUDE_VALUE", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}, {"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}], "description_zh": "\n一个函数FC，用于将GPS的十进制度数（DD）格式转换为方向、度、分、秒（DMS）格式的GPS数据。函数接受一个包含纬度和经度的十进制度数GPS数据作为输入，并返回一个包含方向、度、分、秒的GPS数据结构。同时，函数会检查输入值的有效性，并在输入值无效时报告错误状态。\n\n\n"}
{"title": "Celsius to Fahrenheit Converter", "name": "LGF_CelsiusToFahrenheit", "description": "A function FC that converts Celsius temperature values to Fahrenheit temperature values. The function accepts a real number type input parameter representing the Celsius temperature and returns a real number type output parameter representing the corresponding Fahrenheit temperature. The conversion formula is: Fahrenheit temperature = Celsius temperature * 1.8 + 32. The function does not define error handling, so ENO is always TRUE.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Fahrenheit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将摄氏温度值转换为华氏温度值。函数接受一个实数类型的输入参数，表示摄氏温度，并返回一个实数类型的输出参数，表示对应的华氏温度。转换公式为：华氏温度 = 摄氏温度 * 1.8 + 32。函数中未定义错误处理，因此ENO始终为TRUE。\n\n\n"}
{"title": "Endianness Detection Function", "name": "LGF_IsBigEndian", "description": "A function FC, used to detect whether the system executing the function is big-endian or little-endian. The function checks the system's endianness by shifting a specific bit pattern to the most significant bit and then checking if the least significant bit is 1. If it is a big-endian system, the least significant bit should be 1, and the function returns TRUE; if it is a little-endian system, the least significant bit should be 0, and the function returns FALSE.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if big endianness is detected"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检测执行该函数的系统是大端还是小端。函数通过将一个特定的位模式移动到最高有效位，然后检查最低有效位是否为1来判断系统的端序。如果是大端系统，最低有效位应为1，函数返回TRUE；如果是小端系统，最低有效位应为0，函数返回FALSE。\n\n\n"}
{"title": "Value set point range check", "name": "LGF_IsValueInRange", "description": "The function is used to check whether a given value is within a specified range of a setpoint. The function accepts three input parameters: value (the value to be checked), setpoint (the setpoint), and range (the valid range of the setpoint). The function calculates the upper and lower limits of the setpoint and determines whether the value is within this range. If the value is greater than the upper limit or less than the lower limit, the corresponding output overHighLimit or belowLowLimit will be set to TRUE. If the value is within the range, the function returns TRUE. If the input value exceeds the data range, the function will return an error status ERR_RANGE_LIMIT_VALUES. The function does not use the ENO mechanism for error handling but reports errors through the error and status outputs.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "range", "type": "LReal", "description": "Area where the setpoint is in range"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": [], "description_zh": "\n该函数用于检查一个给定的值是否位于设定点的指定范围内。函数接受三个输入参数：value（要检查的值），setpoint（设定点），range（设定点的有效范围）。函数将计算设定点的上下限，并判断value是否位于这个范围内。如果value大于上限或小于下限，相应的输出overHighLimit或belowLowLimit将被置为TRUE。如果value在范围内，函数返回TRUE。如果输入值超出数据范围，函数将返回错误状态ERR_RANGE_LIMIT_VALUES。函数不使用ENO机制进行错误处理，而是通过error和status输出进行错误报告。\n\n\n"}
{"title": "CRC-16 Calculator", "name": "LGF_CalcCRC16", "description": "A function FC that calculates the checksum value based on the CRC-16 algorithm for error detection during data transmission. The function takes an initial value, a generator polynomial mask, and the number of data elements to be used for CRC calculation as inputs, and returns the computed CRC value. It also outputs an error flag and a status code indicating whether an error has occurred. Internally, the function uses XOR operations and shift operations to implement the CRC calculation process.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据CRC-16算法计算数据流校验值，以便在数据传输过程中进行错误检测。函数接收初始值、生成多项式掩码和要用于CRC计算的数据元素数量作为输入，并返回计算出的CRC值。它还输出错误标志和状态码，指示是否发生错误。函数内部使用XOR函数和移位操作来实现CRC计算过程。\n\n\n"}
{"title": "DWORD rising edge counting", "name": "LGF_CountRisInDWord", "description": "This function block is used to analyze and calculate the number of 0-1 sequences (rising edges) that occur in a DWORD type variable. The function block receives a DWORD type input value and outputs the number of rising edges within it.\n\nDuring each execution, the function block compares the input value of the current cycle with that of the previous cycle to detect rising edges. Specifically, it checks whether the least significant bit of the input value in the current cycle is 1 and the second least significant bit of the input value in the previous cycle is 0. If this is the case, a rising edge is detected, and the counter is incremented by one.\n\nThen, the function block goes through a loop, checking each bit of the input value one by one, repeating the above detection process. If a bit is 1 and the previous bit is 0, a rising edge is detected, and the counter is incremented again.\n\nFinally, the function block copies the input value of the current cycle to a variable used to store the input value of the previous cycle, so it can be compared in the next cycle.\n\nThe output result is an Int type variable called numberOfEdges, representing the total number of rising edges detected in the DWORD variable.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the rising edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of rising edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块用于分析和计算一个DWORD类型变量中0-1序列（上升沿）出现的次数。函数块接收一个DWORD类型的输入值，并输出其中上升沿的数量。\n\n在每次执行时，函数块会比较当前周期的输入值与上一周期的输入值，以检测上升沿。具体来说，它会检查当前周期的输入值的最低位是否为1，而上一周期的输入值的次低位是否为0，如果是这种情况，则认为检测到一个上升沿，并将计数器加一。\n\n然后，函数块会通过一个循环，逐位检查输入值的每一位，重复上述检测过程。如果某一位的值为1，而前一位的值为0，则认为检测到一个上升沿，并将计数器再次加一。\n\n最后，函数块将当前周期的输入值复制到用于保存上一周期输入值的变量中，以便在下一周期进行比较。\n\n输出结果为Int类型的numberOfEdges，表示在DWORD变量中检测到的上升沿的总数。\n\n\n"}
{"title": "Random DInt Range Number Generator", "name": "LGF_RandomRange_DInt", "description": "The function FC is used to generate a random DInt value within a specified range. The function accepts two DInt type input parameters: minValue and maxValue, which represent the lower and upper limits of the random number range, respectively. The function generates a random number based on the system time and ensures that the random number is between minValue and maxValue. If minValue is greater than maxValue, the function will return an error status ERR_MAX_LESS_MIN. The function also checks whether the operation to read the system time is successful; if it fails, it will return an error status ERR_RD_SYS_T. After successful execution, the function returns a random DInt number within the specified range and sets the status to STATUS_FINISHED_NO_ERROR.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "DInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random DInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数FC用于生成一个指定范围内的随机DInt数值。函数接收两个DInt类型的输入参数：minValue和maxValue，分别代表随机数范围的下限和上限。函数会根据系统时间生成一个随机数，并确保该随机数在minValue和maxValue之间。如果minValue大于maxValue，函数将返回一个错误状态ERR_MAX_LESS_MIN。函数还会检查读取系统时间的操作是否成功，如果失败，将返回错误状态ERR_RD_SYS_T。成功执行后，函数返回一个在指定范围内的随机DInt数，并设置状态为STATUS_FINISHED_NO_ERROR。\n\n\n"}
{"title": "ISO 8601 calendar week calculation", "name": "LGF_GetCalendarWeek_ISO", "description": "A function FC that calculates the calendar week number and the day number from the beginning of the year according to the ISO 8601 standard for a specified date. The function takes into account the ISO 8601 standard followed by European countries, which considers the new week starting on Monday, the first week of the year containing the first Thursday, and a year having either 52 or 53 weeks. The function also checks if the previous year had 53 weeks and corrects the number of days passed based on the day of the week of January 1st. If the calculated week number is less than 1, it determines whether it is week 53 or 52 based on whether the previous year had 53 weeks. Similarly, if the calculated week number is 53, it checks if the current year has 53 weeks to determine whether it is week 53 or week 1. The function returns the calendar week number and outputs the status information on whether an error occurred during the calculation process.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据ISO 8601标准计算指定日期的日历周数和该日期距离年初的天数。函数考虑了欧洲国家遵循的ISO 8601标准，即新的一周从周一开始，每年的第一周包含该年的第一个星期四，一年有52或53周。函数还会检查前一年是否有53周，并根据1月1日的星期几对已过的天数进行校正。如果计算出的日期周数小于1，则需要根据前一年是否有53周来确定是第53周还是第52周。同样，如果计算出的周数为53周，则需要检查当年是否有53周来确定是第53周还是第1周。函数返回日历周数，并输出计算过程中是否发生错误的状态信息。\n\n\n"}
{"title": "Bit set operation in DWORD", "name": "LGF_BitSet", "description": "This function is used to set a specific bit in a DWORD type data. It takes two input parameters: one is the DWORD value in which the bit needs to be set, and the other is the position of the bit to be set (bitNo). The function will return the DWORD value after the bit is set. Bit numbering starts from 0, with the maximum number being 31, corresponding to the 32 bits of the DWORD. If the input bit number exceeds the range, the function will automatically perform a modulus operation to ensure that the bit number is between 0 and 31. The function uses bit shifting and bitwise OR operations to implement the bit setting.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with the set bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于在DWORD类型的数据中设置指定位置的位。函数接收两个输入参数：一个是需要设置位的DWORD值，另一个是要设置位的位置（bitNo）。函数会返回设置位后的DWORD值。位的编号从0开始，最大编号为31，对应DWORD的32位。如果输入的位编号超出范围，函数会自动取模运算，确保位编号在0到31之间。函数使用位移和按位或操作来实现位的设置。\n\n\n"}
{"title": "LReal Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_LReal", "description": "This function is used to find the minimum and maximum values in an array of LReal type and return their corresponding indices in the array. The function accepts an array of LReal type as input and outputs four values: the minimum value, the index of the minimum value, the maximum value, and the index of the maximum value. The function first obtains the upper and lower bounds of the array, then starts iterating from the second element of the array, comparing the value of each element, and recording the minimum and maximum values and their indices. Finally, the found minimum and maximum values and their indices are copied to the output parameters.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "LReal", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于在LReal类型的数组中查找最小值和最大值，并返回它们在数组中的相应索引。函数接受一个LReal类型的数组作为输入，并输出四个值：最小值、最小值索引、最大值和最大值索引。函数首先获取数组的上下界，然后从数组的第二个元素开始遍历，比较每个元素的值，记录下最小值和最大值及其索引。最后，将找到的最小值和最大值以及它们的索引复制到输出参数中。\n\n\n"}
{"title": "LWord Endianness Adjuster", "name": "LGF_SwapBlockLWord", "description": "A function FC, used to adjust the byte order of multi-byte data type values. The function takes an array of LWord type as input and adjusts the byte order of each LWord element in the array in-place. The adjustment process involves swapping the high byte and the low byte of each LWord to achieve conversion between big-endian and little-endian byte orders. The function does not care about the byte order of the original or target system, making it universally applicable. The function does not return a value; the adjusted array is returned through the input-output parameter data.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of LWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于调整多字节数据类型值的字节序。函数接收一个LWord类型的数组作为输入，并原地（in-place）调整数组中每个LWord元素的字节序。调整过程是将每个LWord的高字节和低字节进行交换，以实现大端和小端字节序之间的转换。函数不关心原始系统或目标系统的字节序，因此可以通用使用。函数没有返回值，调整后的数组通过输入输出参数data返回。\n\n\n"}
{"title": "String Position Finder in Character Array", "name": "LGF_FindStringInCharArray", "description": "This is a function FC that searches for a specified string within a character array and returns the position of the string in the array. If the string is not found, the return value is -1. The function accepts three parameters: the string to search for (searchFor), the position to start the search in the array (startPos), and the character array to search in (searchIn). The function will check if the input array is of character or byte type, and if not, it will terminate the execution and return an error status ERR_NO_ARRAY. If the input is valid, the function will start from the specified starting position, convert the characters in the array to a string, and search for the specified string within it. If the string is found, it returns the position of the string in the array; if not found, it returns -1.", "type": "FUNCTION", "input": [{"name": "searchFor", "type": "String", "description": "Text that is searched for"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "DInt", "description": "Position (index) of the first character of the text that is searched for within the input array (index zero based). Return -1 if nothing found."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，该函数在一个字符数组中搜索指定的字符串，并返回字符串在数组中的位置。如果字符串未找到，则返回值为-1。函数接受三个参数：要搜索的字符串（searchFor），在数组中开始搜索的位置（startPos）以及要搜索的字符数组（searchIn）。函数会检查输入的数组是否为字符或字节类型，如果不是，则终止执行并返回错误状态ERR_NO_ARRAY。如果输入有效，函数会从指定的起始位置开始，将数组中的字符转换为字符串，并在其中搜索指定的字符串。如果找到字符串，则返回字符串在数组中的位置；如果未找到，则返回-1。\n\n\n"}
{"title": "Histogram Calculation Function Block for Real Data", "name": "LGF_Histogram_LReal", "description": "A function block FB for calculating histograms of a series of real number (LReal) data. The histogram is displayed through a class to show the frequency distribution of samples. The function block accepts a Boolean input execute, indicating whether to perform the calculation, and an unsigned integer input numberOfClasses, indicating the desired number of classes. The outputs of the function block include a Boolean error flag error, a character status status, a character subfunction status subfunctionStatus, a two-dimensional LReal array histValues to display relative frequencies and class centers, a LReal array axis to specify axis values, and a LReal output classWidth returning the calculated class width. The function block also accepts a LReal array values as an input/output parameter, containing the data series for calculation.\n\nWhen the execute input signal has a rising edge, the function block begins the calculation. First, it checks whether the input number of classes is within the allowed range (between 1 and 15). Then, it calculates the number of elements in the array values and sorts the array. Next, the function block identifies the maximum and minimum values in the array and calculates the class width. It traverses the sorted array, counts the number of values in each class, and calculates the relative frequencies. Finally, the function block finds the midpoint value for each class and copies all the calculated results into the output arrays.\n\nThe function block's status codes include execution completed without error, not called, first call, and number of classes error. The subfunction status codes are used to indicate the status or return value of the called subfunctions.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_LReal`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算包含实数（LReal）数据系列的直方图。该直方图通过类（class）显示样本的频率分布。函数块接受一个布尔型输入execute，表示是否执行计算，以及一个无符号整型输入numberOfClasses，表示期望的类数量。函数块的输出包括一个布尔型错误标志error，一个字型状态status，一个字型子函数状态subfunctionStatus，一个二维LReal数组histValues，用于显示相对频率和类中心，一个LReal数组axis，用于指定轴值，以及一个LReal型输出classWidth，返回计算出的类宽度。函数块还接受一个LReal数组values作为输入/输出参数，包含用于计算的数据系列。\n\n当execute输入信号有上升沿时，函数块开始执行计算。首先，它检查输入的类数量是否在允许的范围内（1到15之间）。然后，它计算数组values中的元素数量，并对数组进行排序。接下来，函数块识别数组中的最大值和最小值，并计算类宽度。它遍历排序后的数组，统计每个类中的值数量，并计算相对频率。最后，函数块找到每个类的中间值，并将所有计算结果复制到输出数组中。\n\n函数块的状态码包括执行完成无错误、没有调用、第一次调用和类数量错误等。子函数状态码用于指示调用的子函数的状态或返回值。\n\n\n"}
{"title": "String to Time Converter", "name": "LGF_StringToTime", "description": "```python\ndef FC(time_str):\n    time_units = {\n        'D': 'Day',\n        'H': 'Hour',\n        'M': 'Minute',\n        'S': 'Second',\n        'MS': 'Millisecond'\n    }\n    result = 'T#'\n    parts = []\n    \n    i = 0\n    while i < len(time_str):\n        if time_str[i].isdigit():\n            num_start = i\n            while i < len(time_str) and time_str[i].isdigit():\n                i += 1\n            num = time_str[num_start:i]\n            unit = time_units[time_str[i]]\n            parts.append(f\"{num}{unit}\")\n        i += 1\n    \n    result += '_'.join(parts)\n    return result\n\n# Example usage:\ntime_string = \"1D3H45M6S0MS\"\nprint(FC(time_string))\n```", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "String", "description": "Time to be converted as string Example: 1D3H45M6S0MS"}], "output": [], "in/out": [], "return_value": [{"type": "Time", "description": "Converted time value Example: T#1D_3H_45M_6S"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将字符串转换为系统数据类型Time的时间值。该函数能够处理包含天、小时、分钟、秒和毫秒的时间字符串，并按照指定格式转换。字符串中的每个时间单位前必须有一个数字，且时间单位之间可以包含任意数量的空格。转换后的时间值将按照Time数据类型表示。\\n\\n示例：\\n假设输入的时间字符串为\\\"1D3H45M6S0MS\\\"，函数应返回T#1D_3H_45M_6S_0MS作为转换结果。\n\n\n"}
{"title": "Value Tolerance Checker by Time", "name": "LGF_IsValueInToleranceByTime", "description": "A function block (FB) that checks whether a given value is within a specified percentage range of a setpoint. This FB can be configured to use either absolute value or percentage to represent tolerance, and provides monitoring time to detect setpoint changes, upper limit violations, and lower limit violations. If the value exceeds the set tolerance range, the FB will output the corresponding signal. Additionally, the FB will also detect and output a signal if there is a change in the setpoint.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "Lower limit/tolerance of the setpoint in percent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "Upper limit/tolerance of the setpoint in percent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUE_CALC", "16#8402": "ERR_SETPOINT_ABOVE_HIGH_LIMIT", "16#8403": "ERR_SETPOINT_BELOW_LOW_LIMIT"}, "user_defined_types": [{"name": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters", "member": [{"name": "disableLimits", "type": "Bool", "default": "FALSE", "description": "TRUE: Disable the monitoring timer. Leaving the tolerance triggers immediately"}, {"name": "limitsAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Limit given as absolut value / FALSE: Limits given as tolerance from setpoint"}, {"name": "toleranceAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Toleranze given as absolut value / FALSE: Toleranze in percent from Setpoint"}, {"name": "upperLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the upper limit violation"}, {"name": "lowerLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the lower limit violation"}, {"name": "setpointChangeMonitoringTime", "type": "Time", "default": "T#20S", "description": "Monitoring time for setpoint changes"}]}], "description_zh": "\n一个函数块FB，用于检查给定的值是否在设定点的指定百分比范围内。该FB可以配置为使用绝对值或百分比来表示容差，并提供监控时间以检测设定点变化、上限违反和下限违反。如果值超出设定的容差范围，FB将输出相应的信号。此外，如果设定点发生变化，FB也会进行检测并输出信号。\n\n\n"}
{"title": "System time, local time, and time zone setting", "name": "LGF_SetTime", "description": "The function block FB is used to set the system time, local time, and time zone of the PLC. When the \"execute\" input signal rises, the FB begins to execute the operation. If the \"isLocalTime\" input is TRUE, the \"systemTime\" input is considered as local time; if FALSE, it is considered as UTC time. It is also possible to set the time zone (\"timeZone\") and daylight saving time (\"isDaylightSavingTime\").\n\nThe function block FB has the following outputs:\n- \"done\": Indicates whether the operation has been successfully completed.\n- \"busy\": Indicates whether the FB is currently executing an operation.\n- \"error\": Indicates whether an error has occurred during execution.\n- \"lastSetTimeZone\": Returns the name of the last set time zone.\n- \"status\": Returns the status or error code of the FB.\n- \"subFunctionStatus\": Returns the status or return value of the called sub-function.\n\nStatus codes:\n- 16#0000: STATUS_EXECUTION_FINISHED_NO_ERROR - Operation completed with no errors.\n- 16#7000: STATUS_NO_CALL - FB was not called.\n- 16#7001: STATUS_FIRST_CALL - FB was called for the first time.\n- 16#7002: STATUS_SUBSEQUENT_CALL - FB was called subsequently.\n- 16#8201: ERR_SET_TIME_LOCAL - Error occurred while setting local time.\n- 16#8202: ERR_SET_TIME_UTC - Error occurred while setting UTC time.\n- 16#8203: ERR_SET_TIMEZONE - Error occurred while setting the time zone.\n- 16#8600: ERR_UNDEFINED_STATE - Reached an undefined state.\n- 16#8601: ERR_WRONG_TIMEZONE - Time zone parameter is incorrect.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "systemTime", "type": "DTL", "description": "System time to be set in PLC"}, {"name": "isLocalTime", "type": "Bool", "description": "TRUE: `systemTime` is local time, FALSE: `systemTime` is UTC time"}, {"name": "timeZone", "type": "Int", "description": "Timezones HHMM [-1200.. -330.. 0.. 930.. 1200.. 1300]"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time changeover, TRUE: activated, FALSE: deactivated"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "lastSetTimeZone", "type": "String", "description": "Time zone that was set last by this block"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_SET_TIME_LOCAL", "16#8202": "ERR_SET_TIME_UTC", "16#8203": "ERR_SET_TIMEZONE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_WRONG_TIMEZONE"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于设置PLC的系统时间、本地时间以及时区。当\"execute\"输入信号出现上升沿时，FB开始执行操作。如果\"isLocalTime\"输入为TRUE，则\"systemTime\"输入被视为本地时间；如果为FALSE，则视为UTC时间。还可以设置时区（\"timeZone\"）和夏令时（\"isDaylightSavingTime\"）。\n\n函数块FB具有以下输出：\n- \"done\"：表示操作是否成功完成。\n- \"busy\"：表示FB是否正在执行操作。\n- \"error\"：表示是否在执行过程中发生错误。\n- \"lastSetTimeZone\"：返回上次设置的时区名称。\n- \"status\"：返回FB的状态或错误代码。\n- \"subFunctionStatus\"：返回调用子函数的状态或返回值。\n\n状态代码：\n- 16#0000：STATUS_EXECUTION_FINISHED_NO_ERROR - 操作完成且没有错误。\n- 16#7000：STATUS_NO_CALL - FB没有被调用。\n- 16#7001：STATUS_FIRST_CALL - FB被第一次调用。\n- 16#7002：STATUS_SUBSEQUENT_CALL - FB被后续调用。\n- 16#8201：ERR_SET_TIME_LOCAL - 设置本地时间时出错。\n- 16#8202：ERR_SET_TIME_UTC - 设置UTC时间时出错。\n- 16#8203：ERR_SET_TIMEZONE - 设置时区时出错。\n- 16#8600：ERR_UNDEFINED_STATE - 达到未定义的状态。\n- 16#8601：ERR_WRONG_TIMEZONE - 时区参数错误。\n\n\n"}
{"title": "Value Min/Max Storer", "name": "LGF_StoreMinMax", "description": "This function block FB, upon each call, receives a variable value of type LReal and outputs the maximum and minimum values read since the first call. If the input parameter 'reset' is TRUE, the history of minimum/maximum values will be reset, and the evaluation will start anew.\n\nExample:\n\nAssuming the input value is 10.5 on the first call, 5.2 on the second call, 20.7 on the third call, 'reset' is TRUE on the fourth call, and the input value is 3.8 on the fifth call, the output minimum value 'minValue' will be 3.8, and the maximum value 'maxValue' will be 20.7.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation starts over again."}], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n这个函数块FB，在每次调用时接收一个LReal类型的变量值，并输出自第一次调用以来读取的最大值和最小值。如果输入参数'reset'为TRUE，则最小/最大值的历史记录将被重置，评估将重新开始。\n\n示例：\\n\\n假设首次调用时输入值为10.5，第二次调用时输入值为5.2，第三次调用时输入值为20.7，第四次调用时'reset'为TRUE，第五次调用时输入值为3.8。\\n则输出的最小值'minValue'为3.8，最大值'maxValue'为20.7。\n\n\n"}
{"title": "Gray to Binary Code Converter", "name": "LGF_GrayToBinary", "description": "A function FC that converts a Gray code value to a binary code value. Gray code is a numeral system where the binary representation of adjacent numbers differs by only one bit, which can reduce errors in digital signals. The function accepts a Gray code input value of type DWord and returns a binary output value of type DWord. The function uses a series of shift and XOR operations to achieve the conversion.", "type": "FUNCTION", "input": [{"name": "variableGray", "type": "DWord", "description": "Gray coded value to convert to binary value"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Binary value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将格雷码编码的值转换为二进制编码的值。格雷码是一种数字系统，其中相邻数值的二进制表示只有一个位不同，这样可以减少在数字信号中的错误。该函数接受一个DWord类型的格雷码输入值，并返回一个DWord类型的二进制值作为输出。函数使用了一系列的位移和异或操作来实现转换。\n\n\n"}
{"title": "Boxplot Calculation for Integer Data", "name": "LGF_Boxplot_DInt", "description": "A function block FB that is capable of sorting an integer data array and calculating the statistics required for a boxplot, including the maximum value, minimum value, quartiles (Q25, median, Q75), outliers, and skewness. The function block begins calculation upon receiving an execution signal and uses another function block named LGF_ShellSort_DInt for sorting. The calculation results include outliers, which are determined based on the input parameter rangeOutlier. If the rangeOutlier parameter is greater than 1.0 or equal to 0.0, the values in the data are considered outliers. The function block also calculates the skewness of the data series, which describes the symmetry of the data distribution.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块能够对整数数据数组进行排序，并计算盒须图所需的统计量，包括最大值、最小值、四分位数（Q25、中位数、Q75）、异常值和偏度。函数块在接收到执行信号时开始计算，并使用另一个名为LGF_ShellSort_DInt的函数块进行排序。计算结果包括异常值，这些异常值是根据输入参数rangeOutlier来确定的。如果rangeOutlier参数大于1.0或等于0.0，则认为数据中的值是异常值。函数块还计算了数据系列的偏度，偏度描述了数据分布的对称性。\n\n\n"}
{"title": "Julian Date to DTL Time Converter", "name": "LGF_JulianTimeToDTL", "description": "A function FC that converts a Julian Day (standard or modified) to a datetime value of type DTL. The conversion is based on UTC time, without considering time zones. Only dates after January 1, 1990, are allowed.\\n\\nExample:\\nAssuming the input Julian Day is 2459754.5 (corresponding to noon on December 1, 2021), and isModifiedDate is FALSE.\\nThe function should return a datetime value of type DTL, representing noon on December 1, 2021.\\n\\nIf the input Julian Day is less than or equal to 2440587.5 (corresponding to a point in time before January 1, 1990), the function will return an error status ERR_TIME_BEFORE_1990, indicating that the time is not supported before 1990. If the input Julian Day is exactly equal to 2440587.5, the function will return a warning status WARN_CONVERSION_LIMIT, indicating that the time is at the lower limit of the supported range.", "type": "FUNCTION", "input": [{"name": "julianDate", "type": "LReal", "description": "Julian date to convert (standard or modified, depends on isModifiedDate)"}, {"name": "isModifiedDate", "type": "Bool", "description": "TRUE: julianDate is the modified Julian date FALSE: julianDate is the regular Julian date"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error DTL default value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将儒略日（标准或修改后的）转换为数据类型为DTL的日期时间值。转换基于UTC时间，不考虑时区。只有1990年1月1日之后的时间才被允许。\\n\\n示例：\\n假设输入的儒略日为2459754.5（对应于2021年12月1日中午12点），isModifiedDate为FALSE。\\n函数应返回DTL类型的日期时间值，表示2021年12月1日中午12点。\\n\\n如果输入的儒略日小于或等于2440587.5（对应于1990年1月1日之前的某个时间点），函数将返回一个错误状态ERR_TIME_BEFORE_1990，表示时间在1990年之前不被支持。如果输入的儒略日刚好等于2440587.5，函数将返回一个警告状态WARN_CONVERSION_LIMIT，表示时间刚好在支持范围的下限。\n\n\n"}
{"title": "Random UDInt Number Generator", "name": "LGF_Random_UDInt", "description": "The function's purpose is to generate a random number of type UDInt. It works by reading the system time and using the nanosecond part of the value to generate the random number. Specifically, it converts the nanosecond value of the system time into a double word (DWord), and then recombines different bytes of this double word through bit operations to create a random value. This random value is finally converted to the UDInt type and returned. If there is an error while reading the system time, the function will return an error flag and a status code.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random number in the UDInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数功能是生成一个随机数，类型为UDInt。它的工作原理是读取系统时间，并使用纳秒部分的值来生成随机数。具体来说，它将系统时间的纳秒值转换为一个双字（DWord），然后通过位运算来重新组合这个双字的不同字节，从而生成一个随机值。这个随机值最终被转换为UDInt类型并返回。如果读取系统时间时出现错误，函数将返回一个错误标志和状态码。\n\n\n"}
{"title": "Binary mask comparison", "name": "LGF_BinaryMaskCompare", "description": "This function is used to compare two 32-bit binary values, 'source' and 'compare', using a 'mask' to determine which bits are involved in the comparison. The function returns a boolean value, which is true (TRUE) if and only if the values of 'source' and 'compare' are exactly the same at the bits specified by the mask. If a bit in the mask is 0, that bit does not participate in the comparison; if it is 1, that bit does participate. This comparison method can be applied to words or bytes, simply by converting the parameters to be compared to the DWord type.", "type": "FUNCTION", "input": [{"name": "source", "type": "DWord", "description": "Source value to compare"}, {"name": "compare", "type": "DWord", "description": "Value to compare against"}, {"name": "mask", "type": "DWord", "description": "Mask the data - bits will pass if TRUE or block if FALSE"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Return TRUE if masked values are equal"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个32位二进制数值source和compare，比较过程中使用一个掩码mask来决定哪些位参与比较。函数的返回值为布尔类型，当且仅当在掩码指定的位上，source和compare的值完全相同时，返回值为真（TRUE）。如果掩码中某位为0，则该位不参与比较；如果为1，则该位参与比较。这种比较方式可以用于字（Word）或字节（Byte），只需将要比较的参数转换为DWord类型即可。\n\n\n"}
{"title": "Endianness Detection Function for Little Endian", "name": "LGF_IsLittleEndian", "description": "A function FC that detects whether the system executing the program is little-endian. The function checks the byte order of the system by shifting a word-sized data left by 15 bits and then checking if the least significant bit is 0. If the least significant bit is 0, the system is considered little-endian, and the function returns TRUE; otherwise, it returns FALSE.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if little endianness is detected"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检测执行程序的系统是否为小端字节序。函数通过将一个字（Word）类型的数据左移15位，然后检查最低位是否为0来判断系统的字节序。如果最低位为0，则认为系统是小端字节序，函数返回TRUE；否则返回FALSE。\n\n\n"}
{"title": "DWORD bit count operation", "name": "LGF_BitCount", "description": "This function is used to count the number of bits set to 1 (true) and set to 0 (false) in a DWORD type variable, and outputs these two counts separately. The input parameters include the DWORD value to be counted and a USInt type parameter indicating the number of bits in the input value. The two output USInt type parameters represent the number of bits set to false and the number of bits set to true, respectively. The function works by iterating through each bit of the input value, using bit shift operations to determine the state of each bit, and finally counting the number of true and false bits.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of Byte=8, Word=16, DWord=32"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于统计一个DWORD类型变量中设置为1（真）和设置为0（假）的位的数量，并分别输出这两个数量。输入参数包括要统计的DWORD值和一个表示输入值中位数数量的USInt类型参数。输出的两个USInt类型参数分别表示设置为假的位数数量和设置为真的位数数量。函数通过遍历输入值的每个位，并使用位移操作来判断每一位的状态，最后统计真和假位的数量。\n\n\n"}
{"title": "WString to UTF-8 Byte Stream Encoder", "name": "LGF_EncodeUtf8", "description": "A function FC that encodes a wide string (WString) into a UTF-8 encoded byte stream. The function takes a wide string and a starting position as input, and begins inserting the encoded wide characters into the output byte stream array from that position. The function also returns a status value indicating whether the conversion was successful, and the number of bytes actually used.\n\nExample:\nAssuming the input wide string is \"你好世界\", with a custom starting position of 0, the encoded byte stream should be stored in the output byte stream array. The function should return the status value STATUS_NO_ERROR, indicating a successful conversion, and return the actual number of bytes used as output.", "type": "FUNCTION", "input": [{"name": "sourceString", "type": "WString", "description": "Character that shall be converted to UTF-8"}, {"name": "startPos", "type": "DInt", "description": "Position in encoded byte stream to start insert encoded WChars (Array lower bound is added)"}], "output": [{"name": "bytesUsed", "type": "UInt", "description": "Number of Bytes converted. Ranges from 1 to 3."}], "in/out": [{"name": "encodedByteStream", "type": "Array[*] of Byte", "description": "UTF-8 conformant byte sequence."}], "return_value": [{"type": "Word", "description": "Status of the FC, Erroridentification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将宽字符串（WString）编码为UTF-8编码的字节流。函数接收一个宽字符串和一个起始位置作为输入，从该位置开始在输出的字节流数组中插入编码后的宽字符。函数还会返回一个状态值，指示转换是否成功，以及实际使用的字节数。\\n\\n示例：\\n假设输入的宽字符串为\\\"你好世界\\\"，自定义起始位置为0，编码后的字节流应存储在输出的字节流数组中。函数应返回状态值STATUS_NO_ERROR，表示转换成功，并返回实际使用的字节数作为输出。\n\n\n"}
{"title": "Standalone Data Logger with Advanced Configuration", "name": "LGF_DataLogC", "description": "An independent, high-configuration data logger FB that integrates all data logging system functions and can be used as a standalone data logger.\n\nMain features:\n1. Enable or disable data logging functionality.\n2. Set the name of the data log, which is also used as the file name.\n3. Trigger an entry in the data log by a rising edge (only when `parameter.isLoggingByInterval` := FALSE).\n4. Clear the data log file.\n5. Delete the data log file if it exists.\n6. The behavior of the data logger can be set through the configuration parameter `parameter`, such as the maximum number of entries, timestamp format, whether to clear old entries, etc.\n\nExample:\nSuppose the data log is named \"MyDataLog\", the maximum number of entries is 1000, the timestamp format is YYYY-MM-DD HH:MM:SS, and if the maximum number of entries is reached, enable circular buffering and overwrite old entries.\nIn this case, the data logger will create a file named \"MyDataLog\" containing 1000 entries and record data in the specified timestamp format.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if `parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and lists all possible parameter to configure its behaviour."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set, start from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [{"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#7010": "STATUS_MAX_ENTRIES_REACHED", "16#8401": "ERR_WRONG_COMMAND_CALL_ORDER", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_DATALOG_OPEN", "16#8602": "ERR_DATALOG_CREATE", "16#8603": "ERR_DATALOG_CLOSE", "16#8604": "ERR_DATALOG_WRITE", "16#8605": "ERR_DATALOG_DELETE"}, "user_defined_types": [{"name": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module LGF_DataLogC and lists all possible parameter to configure its behaviour.", "member": [{"name": "header", "type": "String", "default": "", "description": "Headline of datalog, string of all data fields, separated by a comma: \"field1,field2,field3,...\""}, {"name": "maxNumberOfEntries", "type": "UDInt", "default": "1000", "description": "Maximum number of entries in datalog"}, {"name": "timestampFormat", "type": "USInt", "default": "0", "description": "Timestamp format"}, {"name": "clearOnOpen", "type": "Bool", "default": "FALSE", "description": "Clear datalog during opening datalog while enabling block"}, {"name": "deleteFile", "type": "Bool", "default": "FALSE", "description": "Delete as well datalog file during datalog delete"}, {"name": "enableRingBuffer", "type": "Bool", "default": "FALSE", "description": "TRUE: Overwrite old values and start from the beginning if datalog reaches its maximum entries FALSE: Stop logging if `maxNumberOfEntries` entries reached"}, {"name": "loggingByInterval", "type": "Bool", "default": "FALSE", "description": "TRUE: Log on interval time parameter FALSE: log on \"triggerEntry\""}, {"name": "loggingInterval", "type": "Time", "default": "T#1M", "description": "Time for automatic logging interval"}]}, {"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}], "description_zh": "\n一个独立的、具有高级配置功能的数据记录器FB，该函数块集成了所有数据记录系统功能，可以用作独立的数据记录器。\\n\\n主要功能：\\n1. 启用或禁用数据记录功能。\\n2. 设置数据记录的名称，该名称也用作文件名。\\n3. 通过上升沿触发数据记录中的一个条目（仅当`parameter.isLoggingByInterval` := FALSE时）。\\n4. 清除数据记录文件。\\n5. 删除数据记录文件（如果存在）。\\n6. 通过配置参数`parameter`，可以设置数据记录的行为，例如最大条目数、时间戳格式、是否清除旧条目等。\\n\\n示例：\\n假设数据记录被命名为\\\"MyDataLog\\\"，最大条目数为1000，时间戳格式为YYYY-MM-DD HH:MM:SS，如果达到最大条目数，则启用环形缓冲区，并覆盖旧的条目。\\n在这种情况下，数据记录器将创建一个名为\\\"MyDataLog\\\"的文件，其中包含1000个条目，并按照指定的时间戳格式记录数据。\n\n\n"}
{"title": "File Reading from UserFiles Folder", "name": "LGF_FileRead", "description": "A function block FB that provides the functionality to read binary/serialized data streams from files located in the UserFiles folder on the PLC's storage card. It has the following features:\n\n1. The file read operation is initiated by detecting a rising edge on the \"execute\" input.\n2. If the \"dataLengthMustMatch\" input is true, the length of the file dataset must match the length of the dataset in the PLC.\n3. The \"fileName\" input is used to specify the filename to be read, including the path, for example: `UserFiles/test.dat`.\n4. After the read operation is completed, the \"done\" output is set to true, indicating the operation has finished successfully.\n5. If the function block is executing, the \"busy\" output is true.\n6. If an error occurs during execution, the \"error\" output is true, and the \"status\" output contains the error identification status code.\n7. The \"dataLength\" output contains the length of the data read from the file (the serialized length of \"data\").\n8. The \"bufferByteArray\" input/output parameter is used as the byte array buffer for reading/writing files.\n9. The \"data\" input/output parameter is used to store the dataset read from the file.\n\nStatus codes:\n16#0000: STATUS_EXECUTION_FINISHED - Execution finished\n16#7000: STATUS_NO_CALL - No call\n16#7001: STATUS_FIRST_CALL - First call\n16#7002: STATUS_SUBSEQUENT_CALL - Subsequent call\n16#8201: ERR_BUFFER_LOWERBOUND - Buffer lower bound error\n16#8202: ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY - Buffer array too small to copy\n16#8401: ERR_FILE_PATH - File path error\n16#8411: ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE - File size greater than data size\n16#8412: ERR_FILE_SIZE_LESS_THEN_DATA_SIZE - File size less than data size\n16#8600: ERR_UNDEFINED_STATE - Undefined state\n16#8601: ERR_MOVE_BLK_VARIANT - Move block variant error\n16#8602: ERR_DATA_SERIALIZE - Data serialization error\n16#8603: ERR_DATA_DESERIALIZE - Data deserialization error\n16#8604: ERR_FILE_READ_INIT - File read initialization error\n16#8605: ERR_FILE_READ - File read error", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "dataLengthMustMatch", "type": "Bool", "description": "The length of the file data set and the dataset in the PLC have to match."}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8411": "ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE", "16#8412": "ERR_FILE_SIZE_LESS_THEN_DATA_SIZE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8602": "ERR_DATA_SERIALIZE", "16#8603": "ERR_DATA_DESERIALIZE", "16#8604": "ERR_FILE_READ_INIT", "16#8605": "ERR_FILE_READ"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}], "description_zh": "\n一个函数块FB，该函数块提供从PLC的存储卡中位于UserFiles文件夹中的文件读取二进制/序列化数据流的功能。它具有以下特性：\\n\\n1. 通过在\\\"execute\\\"输入上检测上升沿来启动文件读取操作。\\n2. 如果\\\"dataLengthMustMatch\\\"输入为真，则文件数据集的长度必须与PLC中的数据集长度相匹配。\\n3. 使用\\\"fileName\\\"输入指定要读取的文件名，包括路径，例如：`UserFiles/test.dat`。\\n4. 读取完成后，\\\"done\\\"输出置为真，表示操作成功完成。\\n5. 如果函数块正在执行，\\\"busy\\\"输出为真。\\n6. 如果执行过程中发生错误，\\\"error\\\"输出为真，\\\"status\\\"输出包含了错误识别的状态代码。\\n7. \\\"dataLength\\\"输出包含了从文件中读取的数据长度（\\\"data\\\"的序列化长度）。\\n8. 使用\\\"bufferByteArray\\\"输入/输出参数作为读取/写入文件的字节数组缓冲区。\\n9. 使用\\\"data\\\"输入/输出参数存储从文件中读取的数据集。\\n\\n状态代码：\\n16#0000：STATUS_EXECUTION_FINISHED - 执行完成\\n16#7000：STATUS_NO_CALL - 没有调用\\n16#7001：STATUS_FIRST_CALL - 首次调用\\n16#7002：STATUS_SUBSEQUENT_CALL - 后续调用\\n16#8201：ERR_BUFFER_LOWERBOUND - 缓冲区下限错误\\n16#8202：ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY - 缓冲区数组太小无法复制\\n16#8401：ERR_FILE_PATH - 文件路径错误\\n16#8411：ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE - 文件大小大于数据大小\\n16#8412：ERR_FILE_SIZE_LESS_THEN_DATA_SIZE - 文件大小小于数据大小\\n16#8600：ERR_UNDEFINED_STATE - 未定义状态\\n16#8601：ERR_MOVE_BLK_VARIANT - 移动块变量错误\\n16#8602：ERR_DATA_SERIALIZE - 数据序列化错误\\n16#8603：ERR_DATA_DESERIALIZE - 数据反序列化错误\\n16#8604：ERR_FILE_READ_INIT - 文件读取初始化错误\\n16#8605：ERR_FILE_READ - 文件读取错误\n\n\n"}
{"title": "Polynomial Smoothing Function", "name": "LGF_SmoothByPolynomFC", "description": "A function FC, used to calculate the smoothed values of an input array. The function employs a polynomial method for non-periodic smoothing and outputs an array of smoothed values. The function accepts two arrays as input: the 'values' array contains the original values to be smoothed, and the 'smoothedValues' array is used to store the resulting smoothed values. The function checks the length of the input arrays, and if the lengths do not match or are insufficient, the function will return an error status. If the input array lengths are sufficient, the function will apply the polynomial smoothing formula to each element and store the results in the 'smoothedValues' array. The function does not return a value, but reports the execution status through the output parameters 'error' and 'status'.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算输入数组的平滑值。该函数使用多项式方法进行非周期性平滑，并输出平滑后的值数组。函数接受两个数组作为输入：values数组包含要平滑的原始值，smoothedValues数组用于存放平滑后的结果。函数会检查输入数组的长度，如果长度不匹配或长度不足，函数将返回错误状态。如果输入数组长度足够，函数将对每个元素应用多项式平滑公式，并存储结果在smoothedValues数组中。函数没有返回值，但会通过输出参数error和status报告执行状态。\n\n\n"}
{"title": "Matrix Multiplier", "name": "LGF_MatrixMultiplication", "description": "A function FC that calculates the product of two two-dimensional arrays (matrices) of type LREAL. The function accepts two input matrices and an output matrix to store the result. Before performing the multiplication, the function first checks if the dimensions of the input matrices are compatible, i.e., whether the number of columns in the first matrix is equal to the number of rows in the second matrix. If the dimensions are incompatible, the function sets an error flag and returns a corresponding status code. If the dimensions are compatible, the function calculates the product and stores the result in the output matrix. Finally, the function clears the error flag and returns a status code indicating that the operation was successfully completed.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First factor: Matrix to multiply"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second factor: Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Product: The resulting matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR2_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR2_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算两个LREAL类型的二维数组（矩阵）的乘积。函数接受两个输入矩阵和一个用于存放结果的输出矩阵。在执行乘法之前，函数首先检查输入矩阵的维度是否兼容，即第一个矩阵的列数是否等于第二个矩阵的行数。如果维度不兼容，函数将设置错误标志并返回相应的状态代码。如果维度兼容，函数将计算乘积并将结果存储在输出矩阵中。最后，函数清除错误标志并返回状态代码，指示操作成功完成。\n\n\n"}
{"title": "Byte to 8-Bit Splitter", "name": "LGF_SplitByteToBits", "description": "The function FC is designed to split a byte-type variable into 8 boolean/bit variables. The input parameter is a byte, and the output parameters are 8 boolean variables, each representing the most significant bit to the least significant bit of the byte.", "type": "FUNCTION", "input": [{"name": "byte", "type": "Byte", "description": "Bit sequence to be split"}], "output": [{"name": "bit7", "type": "Bool", "description": "Output Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC的功能是将一个字节类型的变量分割成8个布尔型/位变量。输入参数为一个字节（byte），输出参数为8个布尔型变量，分别代表该字节的最高位到最低位。\n\n\n"}
{"title": "Moving Average Calculation Function Block", "name": "LGF_FloatingAverage", "description": "A function block FB used for calculating the moving average of a series of REAL type numerical values. This function block can be configured to execute periodically or be triggered by a signal. It accepts a REAL type numerical value and calculates its moving average, with the window size (i.e., the number of values used for calculating the average) adjustable between 1 and 100, and the default value is 100. If the window size changes or the reset signal is TRUE, the calculation will restart. The function block also provides an output indicating whether the window size has been reached, as well as error and status information. If the window size is set incorrectly, an error status will be returned. The function block uses an array to store the values within the window and updates the average with each calculation.", "type": "FUNCTION_BLOCK", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Read in `value` with every pulse at input `trigger`"}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be determined."}, {"name": "windowSize", "type": "Int", "description": "Window length for sliding averaging in the range from 1..100. The standard value is 100."}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts again."}], "output": [{"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached, TRUE: Maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR: Execution finished without errors", "16#8200": "ERR_WRONG_WINDOW_SIZE: Incorrect window size/width set."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算一系列REAL类型数值的移动平均值。该函数块可以配置为周期性执行或由触发信号触发。它接受一个REAL类型的数值，并计算其移动平均值，窗口大小（即用于计算平均值的数值数量）可以在1到100之间调整，默认值为100。如果窗口大小改变或重置信号为TRUE，计算将重新开始。函数块还提供指示窗口大小是否已达到的输出，以及错误和状态信息。如果窗口大小设置不正确，将返回错误状态。函数块使用数组存储窗口内的数值，并在每次计算时更新平均值。\n\n\n"}
{"title": "Word to 2-Byte Splitter", "name": "LGF_SplitWordToBytes", "description": "A function FC that takes a Word type variable and splits it into two Byte type variables. The Word variable is a 16-bit bit sequence, and the function divides it into the most significant byte (MSB) and the least significant byte (LSB), and outputs them separately. The most significant byte contains the higher 8 bits of the Word variable, and the least significant byte contains the lower 8 bits.\n\nExample:\nAssuming the input Word value is 16#2A3C.\nThe function should return the most significant byte as 2A (hexadecimal) and the least significant byte as 3C (hexadecimal).", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "byte1", "type": "Byte", "description": "Output Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将一个Word类型的变量分割成两个Byte类型的变量。Word变量是一个16位的位序列，该函数将其分割为高字节（MSB）和低字节（LSB），并分别输出。高字节包含Word变量的高8位，低字节包含Word变量的低8位。\\n\\n示例：\\n假设输入的Word值为16#2A3C。\\n函数应返回高字节为2A（16进制），低字节为3C（16进制）。\n\n\n"}
{"title": "Sinusoidal Signal Generator", "name": "LGF_SinusCI", "description": "This function block FB is used to generate a sine wave signal. It calculates the sine value for each cycle using the time interval of the cyclic interrupt OB that calls it. The function block accepts the following input parameters: amplitude (default 1.0), offset (default 0.0), period (default 1000 milliseconds), phase shift (default 0.0), calling OB (callOB), and reset signal (default FALSE). The function block outputs the calculated sine value as the current value (value) and provides error status (error), status code (status), and sub-function status code (subFunctionStatus). If an error occurs, the error status will be set to TRUE, and the status code will indicate the type of error. Under normal conditions, the status code will be set to STATUS_FINISHED_NO_ERROR (16#0000). If the calling OB is unavailable, an ERR_OB_UNAVAILABLE (16#8600) error will be returned; if an error occurs when querying the cyclic interrupt OB, an ERR_QRY_CINT (16#8601) error will be returned.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个正弦波形信号。它利用调用它的循环中断OB的时间间隔来计算每个周期内的正弦值。函数块接受以下输入参数：振幅（amplitude，默认为1.0）、偏移量（offset，默认为0.0）、周期（periode，默认为1000毫秒）、相位偏移（phaseShift，默认为0.0）、调用OB（callOB）和重置信号（reset，默认为FALSE）。函数块将计算出的正弦值输出为当前值（value），并提供错误状态（error）、状态码（status）和子函数状态码（subFunctionStatus）。如果发生错误，错误状态将被设置为TRUE，状态码将指示错误类型。正常情况下，状态码将设置为STATUS_FINISHED_NO_ERROR（16#0000）。如果调用OB不可用，将返回ERR_OB_UNAVAILABLE（16#8600）错误；如果查询循环中断OB时出现错误，将返回ERR_QRY_CINT（16#8601）错误。\n\n\n"}
{"title": "LReal numbers comparison with variable precision", "name": "LGF_CompareLRealByPrecision", "description": "This function is used to compare whether two floating-point numbers of type LReal are approximately equal. The function determines their equality by comparing the difference between the two numbers with the relationship to the given precision parameter. If the difference is less than or equal to the precision multiplied by one of the two input numbers, the two numbers are considered approximately equal. The return value of the function is a boolean type, with FALSE indicating inequality and TRUE indicating approximate equality.", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}, {"name": "precision", "type": "LReal", "description": "Accuracy with which the two values are compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个LReal类型的浮点数是否近似相等。函数通过比较两个数的差值与给定的精度参数之间的关系来判断它们是否相等。如果差值小于或等于精度乘以两个输入数中的一个，则认为这两个数近似相等。函数的返回值为布尔类型，FALSE表示不相等，TRUE表示近似相等。\n\n\n"}
{"title": "DWord Endianness Adjuster", "name": "LGF_SwapBlockDWord", "description": "A function FC, used for adjusting/swapping the byte order of multi-byte data type values. This function takes an array of DWords as input and performs byte order adjustment on each DWord value in the array. The adjustment process is completed by traversing the array elements and internally swapping bytes on each element. This function does not care about the byte order of the original or target systems, allowing for general use across different systems. The function does not return a value; the adjusted array is directly modified through the input/output parameter data.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of DWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于调整/交换多字节数据类型值的字节序。该函数接收一个DWord数组作为输入，并对数组中的每个DWord值进行字节序调整。调整过程是通过遍历数组元素并在每个元素上内部交换字节来完成的。此函数不关心原始系统或目标系统的字节序，从而允许在各个系统上通用使用。函数没有返回值，调整后的数组通过输入/输出参数data直接修改。\n\n\n"}
{"title": "DWord to 32-Bit Splitter", "name": "LGF_SplitDWordToBits", "description": "The function FC's purpose is to split a 32-bit double word (DWord) variable into 32 boolean/ bit variables. The input parameter is a DWord variable, and the output consists of 32 boolean variables, each representing a bit from the 31st to the 0th bit (from the most significant bit to the least significant bit) of the DWord variable.\n\nExample:\nSuppose the input DWord variable value is 2#10101010000000000000000000000000.\nThen the output 32 boolean variables should be respectively:\n- bit31: TRUE\n- bit30: FALSE\n- bit29: TRUE\n- bit28: FALSE\n- bit27: TRUE\n- bit26: FALSE\n- bit25: FALSE\n- bit24: FALSE\n- ... (omitted in the middle)\n- bit2: FALSE\n- bit1: FALSE\n- bit0: FALSE", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "bit31", "type": "Bool", "description": "Output Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Output Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Output Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Output Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Output Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Output Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Output Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Output Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Output Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Output Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Output Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Output Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Output Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Output Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Output Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Output Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Output Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC的功能是将一个32位双字（DWord）类型的变量分割成32个布尔型/位变量。输入参数为一个DWord类型的变量，输出为32个布尔型变量，分别代表DWord变量的第31位到第0位（最高有效位到最低有效位）。\n\n示例：\n假设输入的双字变量值为2#10101010000000000000000000000000。\n则输出的32个布尔型变量应分别为：\n- bit31: TRUE\n- bit30: FALSE\n- bit29: TRUE\n- bit28: FALSE\n- bit27: TRUE\n- bit26: FALSE\n- bit25: FALSE\n- bit24: FALSE\n- ... (中间略)\n- bit2: FALSE\n- bit1: FALSE\n- bit0: FALSE\n\n\n"}
{"title": "String comparison operation", "name": "LGF_CompareString", "description": "A function FC that compares two strings and returns a numerical value indicating the result of the comparison. If the first string is less than the second string, it returns -1; if the first string is greater than the second string, it returns 1; if the two strings are equal, it returns 0.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "left", "type": "String", "description": "Left / first string to compare"}, {"name": "right", "type": "String", "description": "Right / second string to compare"}], "return_value": [{"type": "SInt", "description": "Return values: left < right := -1; left > right := 1; left == right := 0"}], "status_codes": {"0": "RETURN_STRINGS_ARE_EQUAL Strings are equal", "1": "RETURN_STRING_LEFT_GREATER_THAN_RIGHT Left string is greater than right string", "-1": "RETURN_STRING_LEFT_LESS_THAN_RIGHT Left string is less than right string"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于比较两个字符串，并返回一个表示比较结果的数值。如果第一个字符串小于第二个字符串，则返回-1；如果第一个字符串大于第二个字符串，则返回1；如果两个字符串相等，则返回0。\n\n\n"}
{"title": "GPS DMS to GPS-DD Converter", "name": "LGF_GpsToGpsDD", "description": "The function FC is used to convert GPS coordinates from the Degree-Minute-Second (DMS) format to Decimal Degrees (DD) format. The function accepts a single input parameter gps, which contains the direction, degrees, minutes, and seconds information of the latitude and longitude. The function calculates these values and converts them into decimal degrees, stored in the return value item. If the input direction information is invalid, or if an error occurs during the conversion process, the function will set an error flag error and provide a corresponding status code status. The function supports the conversion of North Latitude (N), South Latitude (S), East Longitude (E), and West Longitude (W), and is capable of handling inputs of degrees, minutes, and seconds within reasonable ranges. If the input values exceed the range, the function will return an error.", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS", "description": "GPS-Data to be converted (direction, degrees, minutes, and seconds)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS_DD", "description": "Converted GPS-Data (decimal degrees)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8200": "ERR_LATITUDE_DIRECTION", "16#8201": "ERR_LATITUDE_VALUE", "16#8202": "ERR_LONGITUDE_DIRECTION", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}, {"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}], "description_zh": "\n该函数FC用于将GPS坐标从度分秒（DMS）格式转换为十进制度（DD）格式。函数接受一个输入参数gps，该参数包含经纬度的方向、度、分和秒信息。函数将计算这些值并将其转换为十进制度数值，存储在返回值item中。如果输入的方向信息无效，或者在转换过程中出现其他错误，函数将设置错误标志error，并提供相应的状态码status。函数支持北纬（N）、南纬（S）、东经（E）和西经（W）的转换，并能够处理度、分、秒的值在合理范围内的输入。如果输入值超出范围，函数将返回错误。\n\n\n"}
{"title": "Array element counting", "name": "LGF_CountArrayElements", "description": "A function FC that calculates the number of elements in the input array and returns the count of elements with zero-based indexing (i.e., the type of Array[0..x]). If the input variable is not of array type, it returns -1; if the input variable is a boolean array, it returns -2. This function does not handle boolean arrays.", "type": "FUNCTION", "input": [{"name": "array", "type": "Variant", "description": "Input array to check for number of elements"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of elements in array (zero based); Returning `-1` if input variable is not type `array`; Returning `-2` if input variable is type `bool`"}], "status_codes": {"-1": "RETURN_NO_ARRAY No array is present at the input `array`", "-2": "RETURN_NO_BOOL_ARRAYS_NOT_SUPPORTED Boolean arrays not supported"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算输入数组中的元素数量，并以零为基返回元素的数量（即Array[0..x]的类型）。如果输入变量不是数组类型，则返回-1；如果输入变量是布尔数组，则返回-2。该函数不处理布尔数组。\n\n\n"}
{"title": "Random Real Number Generator", "name": "LGF_Random_Real", "description": "This is a function FC that generates a random real number between 0.0 and 1.0 each time it is called. The function uses the nanosecond part of the system time to generate random numbers, first converting the nanosecond value to a DWORD type, then recombining this DWORD value through bit operations, and finally converting it to a real number type and normalizing it to the range of 0.0 to 1.0. The function also provides an error handling mechanism; if there is an error in reading the system time, it sets an error flag and returns the corresponding status code.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number between 0.0 and 1.0"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，它能够在每次调用时生成一个0.0到1.0之间的随机实数。函数使用了系统时间中的纳秒部分来生成随机数，首先将纳秒值转换为DWORD类型，然后通过位操作重新组合这个DWORD值，最后将其转换成实数类型并归一化到0.0到1.0的范围。函数还提供了错误处理机制，如果读取系统时间出错，会设置错误标志并返回相应的状态码。\n\n\n"}
{"title": "Matrix Transposer", "name": "LGF_MatrixTranspose", "description": "A function FC that transposes a matrix of data type ARRAY[*,*] with LREAL elements. The function does not accept any input parameters but has two output parameters: an error flag (error) and a status code (status). The function has two In/Out parameters: the matrix to be transposed (matrix) and the transposed matrix (matrixTranspose). The transpose operation converts the rows of the matrix into columns and the columns into rows.\n\nExample:\nAssuming the input matrix is a 2x3 matrix as follows:\n1.0  2.0  3.0\n4.0  5.0  6.0\nThe transposed matrix should be a 3x2 matrix as follows:\n1.0  4.0\n2.0  5.0\n3.0  6.0", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Matrix to be transposed"}, {"name": "matrixTranspose", "type": "Array[*, *] of LReal", "description": "Transposed matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_COLUMNS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_COLUMNS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_ROWS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于转置一个数据类型为ARRAY[*,*]的LREAL矩阵。该函数不接受任何输入参数，但有两个输出参数：错误标志（error）和状态码（status）。函数有两个In/Out参数：要转置的矩阵（matrix）和转置后的矩阵（matrixTranspose）。转置操作会将矩阵的行转换为列，列转换为行。\\n\\n示例：\\n假设输入矩阵为一个2x3的矩阵，如下：\\n1.0  2.0  3.0\\n4.0  5.0  6.0\\n转置后的矩阵应该是一个3x2的矩阵，如下：\\n1.0  4.0\\n2.0  5.0\\n3.0  6.0\n\n\n"}
{"title": "3D distance calculation between points", "name": "LGF_CalcDistance_3D", "description": "A function FC that calculates the distance between two points in three-dimensional space. The function accepts the three-dimensional coordinates of two points as input, which are the x1, y1, z1 coordinates of the first point and the x2, y2, z2 coordinates of the second point. The formula for calculating the distance is the square root of the sum of the squares of the differences in the coordinates of the two points. The function returns the calculated distance value.", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "z1", "type": "LReal", "description": "Z coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}, {"name": "z2", "type": "LReal", "description": "Z coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数用于计算三维空间中两点之间的距离。函数接受两个点的三维坐标作为输入，分别是第一点的x1、y1、z1坐标和第二点的x2、y2、z2坐标。计算距离的公式为两点坐标差的平方和的平方根。函数返回计算出的距离值。\n\n\n"}
{"title": "German Traditional Date String to DTL Converter", "name": "LGF_StringToDTL_DE", "description": "A function FC that converts a string conforming to the German traditional date format (DD-MM-YYYY HH:MM:SS.nnnnnnnnn) to a DTL data type. The function checks the input string's format and returns an error status and code if the format is incorrect. If the conversion is successful, it returns a DTL value containing the converted date and time.\n\nExample:\nAssuming the input string is \"17-09-2023 12:34:56.123456789\".\nThe function should return a DTL value containing September 17, 2023, 12:34:56 and 123456789 nanoseconds.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将符合德国传统日期格式（DD-MM-YYYY HH:MM:SS.nnnnnnnnn）的字符串转换为DTL数据类型。函数会检查输入字符串的格式，并在格式错误时返回错误状态和错误代码。如果转换成功，它会返回一个包含转换后的日期和时间的DTL值。\\n\\n示例：\\n假设输入的字符串为\\\"17-09-2023 12:34:56.123456789\\\"。\\n函数应返回一个DTL值，其中包含2023年9月17日12时34分56秒和123456789纳秒。\n\n\n"}
{"title": "UDInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_UDInt", "description": "A function FC that searches for the minimum and maximum values in an array of unsigned double integers and returns the indices of these values in the array. The function accepts an array as input, with the type of UDInt. After the function is executed, it will output the minimum value, the index of the minimum value, the maximum value, and the index of the maximum value.\\n\\nExample:\\nAssuming the input array is {10, 30, 25, 50, 15}.\\nThe function should return the minimum value of 10 at index 1; the maximum value of 50 at index 4.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数在一个无符号双整数数组中搜索最小和最大值，并返回这些值在数组中的索引。函数接受一个数组作为输入，该数组的类型为UDInt。函数执行后，将输出最小值、最小值的索引、最大值和最大值的索引。\\n\\n示例：\\n假设输入数组为{10, 30, 25, 50, 15}。\\n函数应返回最小值为10，索引为1；最大值为50，索引为4。\n\n\n"}
{"title": "Matrix Addition", "name": "LGF_MatrixAddition", "description": "This function is used to calculate the sum of two matrices of the same size with LREAL type. The input consists of two matrices, and the output is a matrix containing the sum of the two matrices. Before calculating the sum, it checks whether the sizes of the two matrices are exactly the same. If the sizes are different, an error is reported and an error status is returned. If the sizes are the same, the corresponding elements of the two matrices are added together, and the result is written into the output matrix. The function has no return value.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First summand (matrix)"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second summand (matrix)"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n该函数用于计算两个相同大小的LREAL类型矩阵的和。输入为两个矩阵，输出为一个包含两矩阵和的矩阵。在计算和之前，会检查两个矩阵的大小是否完全一致，如果大小不一致，则报错并返回错误状态。如果大小一致，则将两个矩阵对应位置的元素相加，并将结果写入输出矩阵。函数没有返回值。\n\n\n"}
{"title": "Frequency Signal Generator", "name": "LGF_Frequency", "description": "This function block FB is used to generate a frequency signal that alternates between FALSE and TRUE under the conditions of a set frequency and pulse pause ratio. The input parameters include frequency (Real type, default value is 0.0) and pulse pause ratio (Real type, default value is 1.0). The outputs include a clock signal (Bool type) and a countdown (Time type), representing the remaining time of the current clock state. The function block internally uses two TOF_TIME type timers to control the duration of the pulse and pause. When the input frequency or pulse pause ratio changes, the pulse and pause times are recalculated, and the clock signal is generated by resetting the two timers. When the pulse timer is running, the countdown indicates the remaining time of the pulse; when the pulse timer is not running, the countdown indicates the remaining time of the pause. The function block does not use the ENO mechanism for error handling, instead forcing ENO to be true.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}, {"name": "pulsePauseRatio", "type": "Real", "description": "1.0"}], "output": [{"name": "clock", "type": "Bool", "description": "Output changes with defined frequency."}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current clock state."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个频率信号，该信号在设定频率和脉冲暂停比的条件下，在FALSE和TRUE之间变化。输入参数包括频率（Real型，默认值为0.0）和脉冲暂停比（Real型，默认值为1.0）。输出包括一个时钟信号（Bool型）和一个倒计时（Time型），表示当前时钟状态的剩余时间。函数块内部使用两个TOF_TIME类型的定时器来实现脉冲和暂停的时间控制。当输入频率或脉冲暂停比发生变化时，会重新计算脉冲和暂停时间，并通过两个定时器相互重置来生成时钟信号。当脉冲定时器运行时，倒计时表示脉冲剩余时间；当脉冲定时器不运行时，倒计时表示暂停剩余时间。函数块不使用ENO机制进行错误处理，而是强制ENO为真。\n\n\n"}
{"title": "Triangular Signal Generator", "name": "LGF_TriangleCI", "description": "This function block FB is used to generate a triangular wave signal. It utilizes the time interval of the cyclic interrupt OB that calls it to generate the signal. The amplitude, offset, period, and phase shift of the triangular wave signal can all be adjusted via input parameters. If an error occurs, such as the OB being unavailable or an error in querying the cyclic interrupt, the function block will return an error status and the corresponding sub-function status. The output parameter 'value' will provide the current value of the triangular wave signal.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the triangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个三角波信号。它利用调用它的循环中断OB的时间间隔来生成信号。三角波信号的振幅、偏移、周期和相位偏移都可以通过输入参数进行调整。如果发生错误，例如OB不可用或查询循环中断错误，函数块会返回错误状态和相应的子功能状态。输出的value参数将提供当前三角波信号的值。\n\n\n"}
{"title": "DTL to UNIX Time Converter", "name": "LGF_DTLToUnixTime", "description": "A function FC that converts a datetime value of type DTL to a UNIX timestamp, with the UNIX timestamp being of type DInt. This timestamp is calculated based on UTC time and does not consider time zones. This function can only handle dates after January 1, 1990. If the input date is earlier than this, the function will return an error status.\n\nThe input of the function is a datetime value of type DTL. The output includes a boolean error flag and a Word type error status code. If the conversion is successful, the function returns a DInt type UNIX timestamp.\n\nStatus codes:\n- 16#0000: Conversion completed without errors\n- 16#8000: Time is earlier than 1990\n- 16#8001: Invalid input DTL value", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to UNIX time"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted UNIX time"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_TIME_BEFORE_1990", "16#8001": "ERR_DTL_INPUT_VALUE_INVALID"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将数据类型为DTL的日期时间值转换为UNIX时间戳，UNIX时间戳的数据类型为DInt。该时间戳是根据UTC时间计算的，不考虑时区。此函数只能处理1990年1月1日之后的时间。如果输入的时间早于这个日期，函数将返回一个错误状态。\n\n函数的输入是一个DTL类型的日期时间值。输出包括一个布尔类型的错误标志和一个Word类型的错误状态代码。如果转换成功，函数返回一个DInt类型的UNIX时间戳。\n\n状态代码：\n- 16#0000：转换完成，没有错误\n- 16#8000：时间早于1990年\n- 16#8001：输入的DTL值无效\n\n\n"}
{"title": "Celsius to Kelvin Converter", "name": "LGF_CelsiusToKelvin", "description": "A function FC that converts Celsius temperature to Kelvin temperature. The function accepts a real number type input parameter representing the Celsius temperature and returns a real number type output representing the corresponding Kelvin temperature. The conversion formula is: Kelvin temperature = Celsius temperature + 273.15.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Kelvin"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将摄氏温度转换为开尔文温度。函数接受一个实数类型的输入参数，表示摄氏温度，并返回一个实数类型的输出，表示相应的开尔文温度。转换公式为：开尔文温度 = 摄氏温度 + 273.15。\n\n\n"}
{"title": "Fahrenheit to Celsius Converter", "name": "LGF_FahrenheitToCelsius", "description": "A function FC that converts Fahrenheit temperature to Celsius temperature. The function accepts a real number as an input parameter representing the Fahrenheit temperature and returns a real number representing the corresponding Celsius temperature. The conversion formula is: (Fahrenheit temperature - 32) / 1.8 = Celsius temperature.\n\nExample:\nAssuming the input Fahrenheit temperature is 98.6°F.\nThe function should return 37.0°C as the conversion result.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Celsius"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将华氏温度转换为摄氏温度。函数接受一个实数类型的输入参数，表示华氏温度，并返回一个实数类型的值，表示相应的摄氏温度。转换公式为：(华氏温度 - 32) / 1.8 = 摄氏温度。\\n\\n示例：\\n假设输入的华氏温度为98.6°F。\\n函数应返回37.0°C作为转换结果。\n\n\n"}
{"title": "Rankine to Kelvin Converter", "name": "LGF_RankineToKelvin", "description": "A function FC that converts temperature values from the Rankine scale (°Rankine) to the Kelvin scale (°Kelvin). The conversion formula is: Kelvin temperature = (5/9) * Rankine temperature. Where the Rankine temperature is the input parameter of the function, and the Kelvin temperature is the return value of the function.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Rankine"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Kelvin"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将温度值从兰金温标(°Rankine)转换为开尔文温标(°Kelvin)。转换公式为：开尔文温度 = (5/9) * 兰金温度。其中，兰金温度为函数输入参数，开尔文温度为函数返回值。\n\n\n"}
{"title": "IEC_Timer implementation", "name": "LGF_IecTimerOnOff", "description": "This function block implements an IEC timer that simultaneously has both rising edge (TON) and falling edge (TOF) functions. When the input signal (in) is FALSE, the timer does not act. When the input signal changes to TRUE, the rising edge timer (TON) starts counting, and when the counting reaches the preset time (timeOnDelay), the output signal (out) becomes TRUE. When the input signal changes to FALSE again, the falling edge timer (TOF) starts counting, and when the counting reaches the preset time (timeOffDelay), the output signal (out) becomes FALSE. This function block is suitable for applications that require delayed turn-on or turn-off functions.", "type": "FUNCTION_BLOCK", "input": [{"name": "in", "type": "Bool", "description": "FALSE Boolean Input value"}, {"name": "timeOnDelay", "type": "Time", "description": "T#0s Preset Time on Delay"}, {"name": "timeOffDelay", "type": "Time", "description": "T#0s Preset Time off Delay"}], "output": [{"name": "out", "type": "Bool", "description": "Delayed Input signal from input `in`"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块实现了一个IEC定时器，该定时器同时具有上升沿（TON）和下降沿（TOF）功能。当输入信号（in）为FALSE时，定时器不动作。当输入信号变为TRUE时，上升沿定时器（TON）开始计时，当计时达到预设时间（timeOnDelay）后，输出信号（out）变为TRUE。当输入信号再次变为FALSE时，下降沿定时器（TOF）开始计时，当计时达到预设时间（timeOffDelay）后，输出信号（out）变为FALSE。该函数块适用于需要延迟开启或关闭功能的场合。\n\n\n"}
{"title": "Shift Register for Datatype Variant", "name": "LGF_ShiftRegister", "description": "The function block FB implements a shift register function for a variable data type, allowing elements in the array bufferRegister to be shifted left or right. It can handle multiple data types and provides features to clear the buffer and fill the buffer with an initial item.\n\nInput parameters include:\n- shiftLeft (Bool): When the rising edge is triggered, shift the elements in the bufferRegister array to the left.\n- shiftRight (Bool): When the rising edge is triggered, shift the elements in the bufferRegister array to the right.\n- shiftRange (UInt): Specifies the number of bits to shift.\n- clear (Bool): Clear the elements in bufferRegister and initialize with initialItem.\n- fill (Bool): After the shift operation, overwrite the elements in bufferRegister with initialItem.\n- initialItem (Variant): The value used to initialize the bufferRegister array.\n\nOutput parameters include:\n- error (Bool): Whether an error occurred during the execution of FB.\n- status (Word): The status and error identification of FB.\n- subFunctionStatus (Word): The return value or status of the called FB, FC, and system blocks.\n\nInOut parameters include:\n- bufferRegister (Variant): As an array buffer/register memory, used to maintain data.\n\nFunction block execution logic:\n1. Detect edge triggering, if shiftLeft, shiftRight, or clear are all true at the same time, report an error.\n2. Check if bufferRegister is an array and get the number of elements in the array.\n3. Check if the number of shift bits is within the valid range.\n4. If clear is true, initialize the bufferRegister array with initialItem.\n5. If the shift operation (shiftLeft or shiftRight) is true, perform the corresponding shift operation.\n6. If fill is true, fill the shifted bufferRegister array with initialItem.\n7. Set the output parameters to indicate whether the operation was successful.\n\nStatus codes:\n- 16#0000: STATUS_NO_ERROR\n- 16#7000: STATUS_NO_CURRENT_JOBS\n- 16#8200: ERR_NO_ARRAY\n- 16#8201: ERR_CLEARING_WITHOUT_INITIAL_ITEM\n- 16#8202: ERR_FILL_WITHOUT_INITIAL_ITEM\n- 16#8203: ERR WRONG_TYPE_INITIAL_ITEM\n- 16#8401: ERR_MORE_THAN_ONE_COMMAND\n- 16#8402: ERR_IN_SHIFT_RANGE\n- 16#8610: ERR_CLEAR_BUFFER\n- 16#8611: ERR_SHIFT_BUFFER_LEFT\n- 16#8612: ERR_SHIFT_BUFFER_LEFT_FILL\n- 16#8622: ERR_SHIFT_BUFFER_RIGHT_FILL", "type": "FUNCTION_BLOCK", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted left."}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted right."}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the bufferRegister input array"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in bufferRegister with initalItem"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the array at input bufferRegister is initialized."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_CLEARING_WITHOUT_INITIAL_ITEM", "16#8202": "ERR_FILL_WITHOUT_INITIAL_ITEM", "16#8203": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8401": "ERR_MORE_THAN_ONE_COMMAND", "16#8402": "ERR_IN_SHIFT_RANGE", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_SHIFT_BUFFER_LEFT", "16#8612": "ERR_SHIFT_BUFFER_LEFT_FILL", "16#8622": "ERR_SHIFT_BUFFER_RIGHT_FILL"}, "user_defined_types": [], "description_zh": "\n该函数块FB实现了一个可变数据类型的移位寄存器功能，可以左移或右移数组bufferRegister中的元素。它能够处理多种数据类型，并提供了清除缓冲区和使用初始项填充缓冲区的功能。\n\n输入参数包括：\n- shiftLeft (Bool): 上升沿触发时，将bufferRegister数组中的元素向左移。\n- shiftRight (Bool): 上升沿触发时，将bufferRegister数组中的元素向右移。\n- shiftRange (UInt): 指定移位的位数。\n- clear (Bool): 清除bufferRegister中的元素，并用initialItem初始化。\n- fill (Bool): 移位操作后，使用initialItem覆盖bufferRegister中的元素。\n- initialItem (Variant): 用于初始化bufferRegister数组的值。\n\n输出参数包括：\n- error (Bool): 执行FB过程中是否发生错误。\n- status (Word): FB的状态和错误识别。\n- subFunctionStatus (Word): 被调用FB、FC和系统块的返回值或状态。\n\nInOut参数包括：\n- bufferRegister (Variant): 作为数组的缓冲区/寄存器内存，用于保持数据。\n\n函数块执行逻辑：\n1. 检测边缘触发，如果shiftLeft、shiftRight或clear同时为真，则报告错误。\n2. 检查bufferRegister是否为数组，并获取数组元素的数量。\n3. 检查移位位数是否在有效范围内。\n4. 如果clear为真，则使用initialItem初始化bufferRegister数组。\n5. 如果移位操作（shiftLeft或shiftRight）为真，则执行相应的移位操作。\n6. 如果fill为真，则使用initialItem填充移位后的bufferRegister数组。\n7. 设置输出参数，表示操作是否成功。\n\n状态代码：\n- 16#0000: STATUS_NO_ERROR\n- 16#7000: STATUS_NO_CURRENT_JOBS\n- 16#8200: ERR_NO_ARRAY\n- 16#8201: ERR_CLEARING_WITHOUT_INITIAL_ITEM\n- 16#8202: ERR_FILL_WITHOUT_INITIAL_ITEM\n- 16#8203: ERR_WRONG_TYPE_INITIAL_ITEM\n- 16#8401: ERR_MORE_THAN_ONE_COMMAND\n- 16#8402: ERR_IN_SHIFT_RANGE\n- 16#8610: ERR_CLEAR_BUFFER\n- 16#8611: ERR_SHIFT_BUFFER_LEFT\n- 16#8612: ERR_SHIFT_BUFFER_LEFT_FILL\n- 16#8622: ERR_SHIFT_BUFFER_RIGHT_FILL\n\n\n"}
{"title": "String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArray", "description": "This function is used to extract a string from a character array, specified by the preceding and following texts. The function accepts two string parameters (textBefore and textAfter) to specify the preceding and following texts of the string to be extracted, and returns the extracted string along with a status. If the array is an array of characters or bytes, the function will continue to execute; otherwise, the program will terminate. If the specified preceding and following texts are found, the function will return the found string and the status \"STATUS_TEXT_FOUND\"; if the starting text is found but the ending text is not, it will return the status \"WARNING_ONLY_START\"; if no text is found, it will return the status \"WARNING_NOTHING_FOUND\".", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Status of the FB"}], "status_codes": {"16#0000": "STATUS_TEXT_FOUND", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": [], "description_zh": "\n该函数用于从字符数组中提取由前后文本指定的字符串。函数接受两个字符串参数（textBefore 和 textAfter）来指定要提取的字符串的前后文本，并返回提取的字符串和状态。如果数组是一个字符或字节类型的数组，函数将继续执行，否则程序将终止。如果找到了指定的前后文本，函数将返回找到的字符串和状态“STATUS_TEXT_FOUND”，如果在找到起始文本但未找到结束文本，则返回状态“WARNING_ONLY_START”，如果未找到任何文本，则返回状态“WARNING_NOTHING_FOUND”。\n\n\n"}
{"title": "Advanced String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArrayAdv", "description": "The function is used to extract a string from a character array, specified by preceding and following texts, with extension options. The function accepts two string parameters, textBefore and textAfter, to specify the preceding and following texts of the string to be extracted. The parameter includeBeforeAfter determines whether to include the preceding and following texts in the extracted string. The parameter startPos specifies the position to start searching in the array (zero-based index). The function outputs extractedString as the extracted string, position as the starting position of the text in the array (zero-based index), length as the length of the extracted text, and status as the state of the function block.\n\nThe function first validates whether the input is a character or byte array and reads the number of elements in the array. Then, it uses a loop to search the array, attempting to find text that matches textBefore. If textBefore is found, it adjusts the position based on the includeBeforeAfter parameter and creates a new string to search for textAfter. If textAfter is found, it truncates the string based on the includeBeforeAfter parameter and updates the output parameters. If textAfter is not found by the end of the array, it outputs the entire string starting after textBefore.\n\nThe function status codes include STATUS_NO_ERROR indicating no error, ERR_NO_ARRAY indicating the input is not an array, WARNING_ONLY_START indicating only the starting text was found, and WARNING_NOTHING_FOUND indicating no text was found.", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "TRUE: textBefore and textAfter are included in the extracted string"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "position", "type": "DInt", "description": "Position (index) within the array where text begins (index zero based)"}, {"name": "length", "type": "Int", "description": "Length of text that was extracted"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Return value: Status of the FB"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": [], "description_zh": "\n该函数用于从字符数组中提取一个由前后文本指定的字符串，并具有扩展选项。函数接受两个字符串参数textBefore和textAfter，用于指定要提取的字符串的前后文本。参数includeBeforeAfter决定是否在提取的字符串中包含前后文本。参数startPos指定在数组中开始搜索的位置（基于零的索引）。函数输出extractedString为提取的字符串，position为文本在数组中的起始位置（基于零的索引），length为提取文本的长度，status为函数块的状态。\n\n函数首先验证输入是否为字符或字节数组，并读取数组元素的数量。然后，它使用一个循环搜索数组，尝试找到与textBefore匹配的文本。如果找到了textBefore，它会根据includeBeforeAfter参数调整位置，并创建一个新的字符串以搜索textAfter。如果找到了textAfter，它会根据includeBeforeAfter参数截取字符串，并更新输出参数。如果在数组结束时没有找到textAfter，它会输出从textBefore之后开始的整个字符串。\n\n函数的状态码有STATUS_NO_ERROR表示没有错误，ERR_NO_ARRAY表示输入不是数组，WARNING_ONLY_START表示只找到了起始文本，WARNING_NOTHING_FOUND表示没有找到任何文本。\n\n\n"}
