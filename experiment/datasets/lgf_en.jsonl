{"title": "UDInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_UDInt", "description": "## Short description ##\n\nThis function searches, in an array of the data type UDInt, for the maximum and minimum value \nand the respective index in the array.\n\n## Functional description ##\n\nAn array of any size is connected via the values input. The elements are then compared in turn. \nThe smallest and largest values, as well as their corresponding index are output to the array.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Binary mask comparison", "name": "LGF_BinaryMaskCompare", "description": "## Short description ##\n\nThis function compares two binary Values source and compare by a given mask.\nBoth given values are masked (input AND mask), and the results is than compared and returned.\nCan be used for Word and Byte as well, by convert the passed parameter using for e.g. \nByte_to_DWord(...).", "type": "FUNCTION", "input": [{"name": "source", "type": "DWord", "description": "Source value to compare"}, {"name": "compare", "type": "DWord", "description": "Value to compare against"}, {"name": "mask", "type": "DWord", "description": "Mask the data - bits will pass if TRUE or block if FALSE"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Return TRUE if masked values are equal"}], "status_codes": {}, "user_defined_types": []}
{"title": "DTL to ISO 8601 Date String", "name": "LGF_DTLToString_ISO", "description": "## Short description ##\n\nThis function converts the date and time of data type DTL to the UNIX time of data type DInt. \nThe timestamp is calculated in UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string in accordance with the ISO 8601 format."}], "status_codes": {}, "user_defined_types": []}
{"title": "Value Min/Max Storer", "name": "LGF_StoreMinMax", "description": "## Short description ##\n\nThis function reads-in a value of a variable at each call and outputs the maximum and minimum \nvalue that has been read in since the first call.\nThe evaluation can be reset if necessary. The block supports the data type LReal.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation starts over again."}], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Natural number factorial calculation", "name": "LGF_GetFactorial", "description": "## Short description ##\n\nThe function calculates the faculty of a natural number (‚Ñï!) and returns the result.\nThe permissible value range of the input parameter naturalNumber is between 0 and 12, as 12 \nis the maximum factorial result fitting into a DInt type", "type": "FUNCTION", "input": [{"name": "naturalNumber", "type": "Int", "description": "Natural number (0..12)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Calculated factorial"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8101": "ERR_WRONG_VALUE_RANGE"}, "user_defined_types": []}
{"title": "System time, local time, and time zone setting", "name": "LGF_SetTime", "description": "## Short description ##\n\nThis block combines the functions of system time, local time, and set time zone.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote The function uses internally the system function WR_LOC_T to write the local time of the CPU \nor WR_SYS_T to write the coordinated world time (UTC). Further it uses the system function \nSET_TIMEZONE to set the time zone of the PLC.\nThis block combines the functions of system time, local time, and set time zone.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "systemTime", "type": "DTL", "description": "System time to be set in PLC"}, {"name": "isLocalTime", "type": "Bool", "description": "TRUE: `systemTime` is local time, FALSE: `systemTime` is UTC time"}, {"name": "timeZone", "type": "Int", "description": "Timezones HHMM [-1200.. -330.. 0.. 930.. 1200.. 1300]"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time changeover, TRUE: activated, FALSE: deactivated"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "lastSetTimeZone", "type": "String", "description": "Time zone that was set last by this block"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_SET_TIME_LOCAL", "16#8202": "ERR_SET_TIME_UTC", "16#8203": "ERR_SET_TIMEZONE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_WRONG_TIMEZONE"}, "user_defined_types": []}
{"title": "CRC-16 Calculator", "name": "LGF_CalcCRC16", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC16 uses 16 bits as the generator polynomial \n(mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\nùëÅùë¢ùëöùëèùëíùëüùëÇùëìùê∏ùëôùëíùëöùëíùëõùë°ùë† <=(ùê¥ùëüùëüùëéùë¶ùëàùëùùëùùëíùëüùêøùëñùëöùëñùë° ‚àí ùê¥ùëüùëüùëéùë¶ùêøùëúùë§ùëíùëüùëàùëõùëëùëíùëüùêøùëñùëöùëñùë° + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "Random UDInt Number Generator", "name": "LGF_Random_UDInt", "description": "## Short description ##\n\nThis function generates a random value with each call.\nThe random number has the data type UDInt.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe function generates random values in the range:\n0 ‚â§ ùëÖùëíùë°ùë¢ùëüùëõùëâùëéùëô ‚â§ 4294967295.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to UDInt.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random number in the UDInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "IEC_Timer implementation", "name": "LGF_IecTimerOnOff", "description": "## Short description ##\n\nThe Block implements an IEC_Timer TON and TOF", "type": "FUNCTION_BLOCK", "input": [{"name": "in", "type": "Bool", "description": "FALSE Boolean Input value"}, {"name": "timeOnDelay", "type": "Time", "description": "T#0s Preset Time on Delay"}, {"name": "timeOffDelay", "type": "Time", "description": "T#0s Preset Time off Delay"}], "output": [{"name": "out", "type": "Bool", "description": "Delayed Input signal from input `in`"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value Tolerance Checker by Time", "name": "LGF_IsValueInToleranceByTime", "description": "## Short description ##\n\nChecks if a given value is within a specified tolerance in percent of a given set point.\nThe block has a configurable timing for set point change hiding, lower limit and as well for upper \nlimit violation hiding.\n\n## Functional description ##\n\nThe setpoint, lowerMinimum and upperMaximum variables define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, inLimits, or overHighLimit show where the value is located.\nBy the configuration it is possible to define whether the borders are given as absolute values or \nin percentage from set point.\nThe timing could be adjusted for set point changes and as well for hiding the violating of the \nlower or upper limit in case of peaks.\nFigure: Principle of operation", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "Lower limit/tolerance of the setpoint in percent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "Upper limit/tolerance of the setpoint in percent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUE_CALC", "16#8402": "ERR_SETPOINT_ABOVE_HIGH_LIMIT", "16#8403": "ERR_SETPOINT_BELOW_LOW_LIMIT"}, "user_defined_types": [{"name": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters", "member": [{"name": "disableLimits", "type": "Bool", "default": "FALSE", "description": "TRUE: Disable the monitoring timer. Leaving the tolerance triggers immediately"}, {"name": "limitsAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Limit given as absolut value / FALSE: Limits given as tolerance from setpoint"}, {"name": "toleranceAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Toleranze given as absolut value / FALSE: Toleranze in percent from Setpoint"}, {"name": "upperLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the upper limit violation"}, {"name": "lowerLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the lower limit violation"}, {"name": "setpointChangeMonitoringTime", "type": "Time", "default": "T#20S", "description": "Monitoring time for setpoint changes"}]}]}
{"title": "CRC-8 Calculator", "name": "LGF_CalcCRC8", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC8 uses 8 bits as the generator polynomial (mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\nùëÅùë¢ùëöùëèùëíùëüùëÇùëìùê∏ùëôùëíùëöùëíùëõùë°ùë† <= (ùê¥ùëüùëüùëéùë¶ùëàùëùùëùùëíùëüùêøùëñùëöùëñùë° ‚àí ùê¥ùëüùëüùëéùë¶ùêøùëúùë§ùëíùëüùëàùëõùëëùëíùëüùêøùëñùëöùëñùë° + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "Matrix Addition", "name": "LGF_MatrixAddition", "description": "## Short description ##\n\nThis block adds two matrices of equal size of the data type ARRAY[*,*] of LREAL.\nThe individual fields of the two incoming matrices are read, added and then output in the matrix \nmatrixResult.\nNote Note that all input and output matrices must have the same low and high limits and therefore \nthe same number of columns and rows.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First summand (matrix)"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second summand (matrix)"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "Even Parity Checker for DWord", "name": "LGF_IsParityEven", "description": "## Short description ##\n\nThe function checks whether the parity of the input variable of type DWord is even. If the \nnumber of bits that are assigned TRUE in the sequence is even, the return value is set to TRUE.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is even"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "Matrix Multiplier", "name": "LGF_MatrixMultiplication", "description": "## Short description ##\n\nThis function multiplies two matrices of the data type ARRAY[*,*] of LREAL.\nThe block multiplies two matrices of variable size. The individual elements of the two incoming \nmatrices are read, multiplied, and then output in the matrixResult matrix.\nNote Note that the number of columns in the first matrix must be equal to the number of rows in \nthe second matrix.\nThe size of the initial matrix (m * n) results from the number of rows (m) of matrix1 and the \nnumber of columns (n) of matrix2.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First factor: Matrix to multiply"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second factor: Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Product: The resulting matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR2_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR2_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "DTL to Traditional German Date String", "name": "LGF_DTLToString_DE", "description": "## Short description ##\n\nThis function converts a date of data type DTL into a character string of data type STRING in \nthe traditional format (DD MM YYYYY‚Ä¶).\n\n## Functional description ##\n\nThe block reads a date of data type DTL and converts the individual components of the date \n(year, month, day, hour‚Ä¶) into a character string and outputs it in traditional format (DE). The \nseparator between the components of the date is variable.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string according to the traditional format."}], "status_codes": {}, "user_defined_types": []}
{"title": "String comparison operation", "name": "LGF_CompareString", "description": "## Short description ##\n\nCompares two strings and returns a number which indicates the result of the comparison.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "left", "type": "String", "description": "Left / first string to compare"}, {"name": "right", "type": "String", "description": "Right / second string to compare"}], "return_value": [{"type": "SInt", "description": "Return values: left < right := -1; left > right := 1; left == right := 0"}], "status_codes": {"0": "RETURN_STRINGS_ARE_EQUAL Strings are equal", "1": "RETURN_STRING_LEFT_GREATER_THAN_RIGHT Left string is greater than right string", "-1": "RETURN_STRING_LEFT_LESS_THAN_RIGHT Left string is less than right string"}, "user_defined_types": []}
{"title": "Array element counting", "name": "LGF_CountArrayElements", "description": "## Short description ##\n\nCount the number of array elements and returns the number of elements zero based (Array[0..x] \nof Type).", "type": "FUNCTION", "input": [{"name": "array", "type": "Variant", "description": "Input array to check for number of elements"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of elements in array (zero based); Returning `-1` if input variable is not type `array`; Returning `-2` if input variable is type `bool`"}], "status_codes": {"-1": "RETURN_NO_ARRAY No array is present at the input `array`", "-2": "RETURN_NO_BOOL_ARRAYS_NOT_SUPPORTED Boolean arrays not supported"}, "user_defined_types": []}
{"title": "Bit reset operation in DWORD", "name": "LGF_BitReset", "description": "## Short description ##\n\nThis block resets a bit at a predefined position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with reset bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "LIFO Buffer Management", "name": "LGF_LIFO", "description": "## Short description ##\n\nLIFO (Last-In First-Out / Stack buffer memory)\nThis function stores incoming data and outputs the latest/most recent not-yet-processed data.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote I computer science the stack is also based on the LIFO principle.\nWith the push input, a new item is stored from the InOut parameter item in the next free position \nin the buffer. The output elementCount is incremented by one.\nWith the pop input, the latest / most recent item is output to the InOut parameter item, and this \nfield in the buffer is replaced by the value at the parameter initialItem. The output \nelementCount is decremented by one.\nThe peek input allows the last entry in the buffer to be read out. The buffer is not changed.\nWith the reset input, the buffer is initialized and the index and counter are reset. The \nelementCount output is set to zero and the isEmpty output is set to TRUE.\nWith the clear input, the buffer is emptied and initialized with the initial value initialItem. Index \nand counter are reset. The elementCount output is set to zero and the isEmpty output is set to \nTRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value initialItem (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: 0 / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_LAST_ENTRY", "16#8612": "ERR_POP_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": []}
{"title": "GPS DMS to GPS-DD Converter", "name": "LGF_GpsToGpsDD", "description": "## Short description ##\n\nThis function converts a given GPS data type (format direction, degrees, minutes, and seconds) \ninto a GPS-DD data type (decimal degrees).\nGPS ‚Äúnative‚Äù to GPS decimal Degree.", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS", "description": "GPS-Data to be converted (direction, degrees, minutes, and seconds)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS_DD", "description": "Converted GPS-Data (decimal degrees)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8200": "ERR_LATITUDE_DIRECTION", "16#8201": "ERR_LATITUDE_VALUE", "16#8202": "ERR_LONGITUDE_DIRECTION", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}, {"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}]}
{"title": "GPS-based Sunrise and Sunset Time Determination", "name": "LGF_AstroClock", "description": "## Short description ##\n\nThis function calculates the times of sunrise and sunset based on the local time for a specific  place on Earth. The exact position is transferred in the form of geographical GPS coordinates (longitude and latitude).\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nIf processes must run automatically depending on the change between day and night, the \nfunction of an astronomical clock is required. Examples of this would be switching outdoor \nlighting on and off or opening and closing roller shutters.\nIf these processes are to be executed with a time delay i.e. a defined time before or after \nsunrise or sunset an offset is required in each case.\nNote For precise execution of the function, it must be ensured that system time and local time of \nthe SIMATIC controller are set correctly.\nBased on the system time/local time of the SIMATIC controller and the set coordinates, the \nblock calculates the times for sunrise and sunset. The offset times are added to the sunrise and \nsunset and output on the sunrise and sunset outputs. If the systems local time of the SIMATIC \ncontroller is between these values, the output isDaytime is set to the value TRUE.\nNote Since the times for sunrise and sunset change daily, it is possible that the isDaytime output \nremains permanently on TRUE or FALSE over a longer period of time:\n‚Ä¢ with correspondingly large offset values\n‚Ä¢ for a place on the other side of the Arctic Circle\nThe input of the GPS coordinate values is checked for valid values. If there are invalid values, \nan appropriate error code is output to status.\nIf there is an invalid coordinate value for a formal parameter, the outputs sunrise and sunset\nare set to the value DTL#1970-01-01-00:00:00.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and sunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at `isDaytime`, negative time allowed)"}, {"name": "positionGps", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at `isDaytime`, negative time allowed)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between ‚Äúsunrise‚Äù and ‚Äúsunset‚Äù"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_IN_OPERATION", "16#8204": "ERR_LATITUDE_VALUE", "16#8205": "ERR_LONGITUDE_VALUE", "16#8601": "ERR_RD_SYS_T", "16#8602": "ERR_RD_LOC_T"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees. For a whole GPS Data set.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places (Unit: degree decimal), North = positive; South = negative) valid value range [-90.00000..90.00000] "}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude with decimal places (Unit: degree decimal), East = positive; West = negative) valid value range [-180.00000..180.00000] "}]}]}
{"title": "UTF-8 Byte Stream Decoder", "name": "LGF_DecodeUtf8", "description": "## Short description ##\n\nDecodes a UTF-8 encoded byte stream into a WString", "type": "FUNCTION", "input": [{"name": "byteStream", "type": "Array[*] of Byte", "description": "UTF-8 encoded byte stream"}, {"name": "startPos", "type": "DInt", "description": "Position in byte stream to start decoding from"}, {"name": "count", "type": "UInt", "description": "Number of character (not bytes) to decode; 0: byte stream is decoded until end"}], "output": [], "in/out": [{"name": "decodedString", "type": "WString", "description": "Decoded string"}], "return_value": [{"type": "Word", "description": "Status of the FC, Error identification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7FFD": "WARN_UNSUPPORTED_CHAR", "16#7FFE": "WARN_STREAM_EXCEEDS_MAX_LEN", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS", "16#8203": "ERR_COUNT_EXCEEDS_MAX_LEN"}, "user_defined_types": []}
{"title": "Bit set operation in DWORD", "name": "LGF_BitSet", "description": "## Short description ##\n\nThis block sets a bit at a given position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with the set bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "String Upper Case Converter", "name": "LGF_ToUpper", "description": "## Short description ##\n\nThis function converts the lowercase letters of a string into their capital equivalents", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": []}
{"title": "Ramp Function Generator", "name": "LGF_RampCI", "description": "## Short description ##\n\nThe function generates a speed curve based on an interpolation point table. Linear interpolation \noccurs between the points within the prescribed time.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nGlobal data\nTogether with the block, you automatically receive the PLC data type LGF_typeRampTimeTable, \nwhich is composed of the parameters outVal for the value of a base point and time for the time, \nuntil the next base point is reached. The declaration takes place in a one-dimensional array of \nthe data type LGF_typeRampTimeTable beginning with the index 0. The array is created in a global \ndata block and then passed to the module LGF_RampCI.\nPrinciple of operation\nWith this block, speed curves can be executed based on parameterized interpolation points; in \neach call cycle values are output according to a schedule, and interpolation takes place \nbetween the interpolation points.\nIn each cycle the currently approached interpolation point number stepNumber, the actual \nremaining time remainTime until reaching the interpolation point, the total time totalTime, and \nthe total remaining time until reaching the end of the speed curve remainTotalTime, are output. \nIn addition, the output actTimeTable is set if the projected speed curve is currently being output.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nFigure: Interconnecting the cyclic interrupt OB\nThe following operating modes can be selected via control inputs:\n‚Ä¢ Restart\n‚Ä¢ Pre-assigning an output\n‚Ä¢ Output a speed curve\n‚Ä¢ Stop processing\n‚Ä¢ Specify processing step and processing time\n‚Ä¢ Switch-on cyclic operation+F1\n‚Ä¢ Update total time and remaining time\nRestart\nThe output outValue is reset to 0.0 with a rising edge at the input reset. With \nenDefaultOutValue = TRUE, defaultOutValue is output at outputValue. The total time and total \nremaining time are updated and output.\nPre-assigning an output\nIf the speed curve should begin with a certain output value, then enDefaultOutValue must be \nTRUE. In this case the value defaultOutValue is present on the output of the timer. The internal \nprocessing of the speed curve continues during this time. If enDefaultOutValue changes to \nFALSE again, interpolation is performed to the currently active calibration point.\nOutput a speed curve\nWith a rising edge at the input start, the speed curve is output - as long as start is TRUE or until \nthe speed curve is terminated by reaching the last interpolation point. Through a subsequent \nrising edge, the speed curve is output again. In addition, the total time is updated at each \nswitch-on.\nSwitch-on cyclic operation\nIf, in addition to the input start, the input cyclicOP is also set to TRUE, the speed curve \nautomatically returns to the start point after outputting the last interpolation point value and \nstarts a new cycle.\nThere is no interpolation between the last interpolation point value and the starting point. The \nfollowing must apply for a smooth transition: last interpolation point value = start point.\nStop speed curve\nWith hold = TRUE the value of the output variable (including time processing) is frozen. When \nresetting hold = FALSE, the program continues at the point of interruption or at a parameterized \npoint (see ‚ÄúDefining the processing step and processing time‚Äù). The processing time of the \nspeed curve is extended by the holding time T1*. (see Figure below).\nSpecify processing step and processing time\nIf the input parameter continue is set to TRUE for continuation while the speed curve is stopped \n(hold = TRUE), then after the input hold has been reset the interpolation point number \ncontStepNbr (target interpolation point) will be approached within the time contStepTime\n(interpolation). The total remaining time will be recalculated.\nUpdating total time and total remaining time\nIf values of the interpolation points are changed, the total time and the total remaining time of \nthe speed curve can change. Since calculation of totalTime and remainTotalTime can \nsignificantly increase the processing time of the function block at many interpolation points, the \ncalculation is only executed once with a rising edge on the updateTime input.", "type": "FUNCTION_BLOCK", "input": [{"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "contStepNbr", "type": "Int", "description": "Number of the next interpolation point for continuing"}, {"name": "contStepTime", "type": "Time", "description": "Remaining time to continue to the interpolation point"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "start", "type": "Bool", "description": "Run down the interpolation point table"}, {"name": "hold", "type": "Bool", "description": "Freeze/hold output at actual value"}, {"name": "continue", "type": "Bool", "description": "Continuing"}, {"name": "cyclicOP", "type": "Bool", "description": "Repeat interpolation point table cyclically"}, {"name": "updateTime", "type": "Bool", "description": "Update time values"}, {"name": "reset", "type": "Bool", "description": "Complete reset of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output value"}, {"name": "actTimeTable", "type": "Bool", "description": "Interpolation point table will be edited"}, {"name": "stepNumber", "type": "Int", "description": "Current interpolation point number"}, {"name": "remainTime", "type": "Time", "description": "Remaining time until reaching the next interpolation point"}, {"name": "totalTime", "type": "Time", "description": "Total time for setpoint table"}, {"name": "remainTotalTime", "type": "Time", "description": "Total remaining time"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeRampTimeTable", "description": "Interpolation point table."}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_FURTHER_CALLS", "16#8200": "ERR_OB_UNAVAILABLE", "16#8201": "ERR_ARRAY_LOWER_BOUND", "16#8400": "ERR_QRY_CINT"}, "user_defined_types": [{"name": "LGF_typeRampTimeTable", "description": "Data type for setup a speed curve", "member": [{"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Setpoint Value to reach by the interpolation curve"}, {"name": "time", "type": "Time", "default": "T#0s", "description": "Time until the interpolation point is reached"}]}]}
{"title": "Advanced CRC-32 Calculator", "name": "LGF_CalcCRC32Advanced", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC32Advanced uses 32 bits as the generator \npolynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nVia the Boolean input parameters reflectInput and reflectResult, you may optionally mirror \nthe bits of the input data or the CRC value. An XOR operation is also performed with the CRC \nvalue at the end and the value finalXorValue.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\nùëÅùë¢ùëöùëèùëíùëüùëÇùëìùê∏ùëôùëíùëöùëíùëõùë°ùë† <= (ùê¥ùëüùëüùëéùë¶ùëàùëùùëùùëíùëüùêøùëñùëöùëñùë° ‚àí ùê¥ùëüùëüùëéùë¶ùêøùëúùë§ùëíùëüùëàùëõùëëùëíùëüùêøùëñùëöùëñùë° + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "DWord", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "String to DInt Converter", "name": "LGF_StringToInt", "description": "## Short description ##\n\nThis function converts a variable of data type String into a variable of data type DInt.", "type": "FUNCTION", "input": [{"name": "value", "type": "String", "description": "String value to be converted to Double-Integer. Example: ‚Äò+16927‚Äô"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted Double-Integer value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "DInt to String Converter", "name": "LGF_IntToString", "description": "## Short description ##\n\nThis function converts a variable of the data type DInt into a variable of the data type String.", "type": "FUNCTION", "input": [{"name": "value", "type": "DInt", "description": "Double-Integer value to convert"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Converted value as string. Example: '+16927'"}], "status_codes": {}, "user_defined_types": []}
{"title": "DWORD rising edge counting", "name": "LGF_CountRisInDWord", "description": "## Short description ##\n\nThe function analyzes a variable of the type DWORD and outputs how often a 0-1 sequence \n(rising edge) occurs in the variable.\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountRisInDWord in the future!\nThis function is no longer maintained!\n\n## Functional description ##\n\nIn a variable of the data type DWORD, the block counts the rising edges (0-1 transitions) from \nleft to right. The output countRisInDWord outputs the number of rising edges.\nSo that rising edges at the variable limit are also detected, the input value is copied to the static \nvariable statDWordPrevCycle at the end of the evaluation and evaluated in the next cycle.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the rising edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of rising edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "LReal Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_LReal", "description": "## Short description ##\n\nThis function searches, in an array of the data type LReal, for the maximum and minimum value \nand the respective index in the array.\n\n## Functional description ##\n\nAn array of any size is connected via the values input. The elements are then compared in turn. \nThe smallest and largest values, as well as their corresponding index are output to the array.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "LReal", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Time to String Converter", "name": "LGF_TimeToString", "description": "## Short description ##\n\nThis function converts a variable of the system data type Time into a variable of the data type \nString.", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "Time", "description": "Time value to convert Example: T#1D_3H_45M_6S"}], "output": [{"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "in/out": [], "return_value": [{"type": "String", "description": "Converted time as string. Example: 1D3H45M6S0MS"}], "status_codes": {}, "user_defined_types": []}
{"title": "Histogram Calculation Function Block for Integer Data", "name": "LGF_Histogram_DInt", "description": "## Short description ##\n\nThe histogram shows the frequency distribution of a sample by class. A class describes a value \ninterval in which the individual frequencies are added together. After specifying the number of \nclasses, the class width and the respective class center are calculated. The number of classes \nis limited to 15.\nThe distribution is represented as a rectangle around the class mean with the class width and \nthe cumulated frequency as height.\nFigure: Distribution\n\n## Functional description ##\n\nThe block sorts the transferred data and calculates the general class width using the transferred \nclass count and data range. The block then counts the values that lie within a class. In order to \ndraw a histogram, the block also calculates the necessary X and Y coordinates.\nThe elements of the passed array values are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe number of classes can be specified using the following rule of thumb:\n\nFormulas\nThe block uses the following formula to calculate the class width:", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Outputs the calculated values in a two-dimensional array."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_DInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": []}
{"title": "8-Bit to Byte Merger", "name": "LGF_MergeBitsToByte", "description": "## Short description ##\n\nThis function merge 8 Bits / 8 Boolean variables into one Byte variable.", "type": "FUNCTION", "input": [{"name": "bit7", "type": "Bool", "description": "Input Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Composite Bit sequence stored as Byte variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "String Position Finder in Character Array", "name": "LGF_FindStringInCharArray", "description": "## Short description ##\n\nThe function searches for a specified String within an array of characters.\nReturning the position of the String in the Array, if the string is not found the return value is -1.", "type": "FUNCTION", "input": [{"name": "searchFor", "type": "String", "description": "Text that is searched for"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "DInt", "description": "Position (index) of the first character of the text that is searched for within the input array (index zero based). Return -1 if nothing found."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY"}, "user_defined_types": []}
{"title": "2-Word to DWord Merger", "name": "LGF_MergeWordsToDWord", "description": "## Short description ##\n\nThis function merge 2 Word variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "word1", "type": "Word", "description": "Input Word 1 - MSB"}, {"name": "word0", "type": "Word", "description": "Input Word 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Word sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "Value range limit check", "name": "LGF_IsValueInLimits", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range. The value range is defined \nwith a lower and an upper limit.\n\n## Functional description ##\n\nThe variables lowLimit and highLimit define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the ‚Äúvalue‚Äù is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the ‚Äúvalue‚Äù is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the ‚Äúvalue‚Äù is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_HIGH_BELOW_LOW_LIMIT"}, "user_defined_types": []}
{"title": "Shell Sort for UDInt Arrays", "name": "LGF_ShellSort_UDInt", "description": "## Short description ##\n\nThis block sorts an array of type UDInt with any number of elements (max. 1000) in ascending \nor descending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: ùí™(ùëõ ‚ãÖ log(ùëõ)^2)\nTable: Execution times of the block LGF_ShellSort‚Ä¶\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of UDInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax", "description": "## Short description ##\n\nThis function searches, in an array of the data type DInt, for the maximum and minimum value \nand the respective index in the array.\nThe following data types of the array elements are supported:\nInt, DInt, UInt, UDInt, USInt, SInt, and Real.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nAn array of any size is connected via the variableArray input. After a data type query in the \nblock, the elements are copied one after the other into a variable of the appropriate type and \ncompared. The smallest and largest values, as well as their corresponding index are output to \nthe array.\nNote The following data types of the array elements are supported:\nInt, DInt, UInt, UDInt, USInt, SInt, and Real.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}], "output": [{"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE", "16#8202": "ERR_NOT_EQUAL_TYPES", "16#8203": "ERR_MOVE_BLK_VARIANT"}, "user_defined_types": []}
{"title": "Unsigned Integer Histogram Calculation Function Block", "name": "LGF_Histogram_UDInt", "description": "## Short description ##\n\nThe histogram shows the frequency distribution of a sample by class. A class describes a value \ninterval in which the individual frequencies are added together. After specifying the number of \nclasses, the class width and the respective class center are calculated. The number of classes \nis limited to 15.\nThe distribution is represented as a rectangle around the class mean with the class width and \nthe cumulated frequency as height.\nFigure: Distribution\n\n## Functional description ##\n\nThe block sorts the transferred data and calculates the general class width using the transferred \nclass count and data range. The block then counts the values that lie within a class. In order to \ndraw a histogram, the block also calculates the necessary X and Y coordinates.\nThe elements of the passed array values are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe number of classes can be specified using the following rule of thumb:\n\nFormulas\nThe block uses the following formula to calculate the class width:", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_UDInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": []}
{"title": "Linear Regression Calculator", "name": "LGF_RegressionLine", "description": "## Short description ##\n\nThe simplest case of a regression is the regression line. This means that the assumed \nrelationship between the input and output signal is a linear straight line.\nFigure: Regression line\n\n## Functional description ##\n\nThe block calculates the regression line with the following line equation:\nùëì(ùë•) = ùëö ‚ãÖ ùë• + ùë°\nùëö: Gradient of straight line\nùë°: Intersection with y-axis\nùëÅ: number of array elements", "type": "FUNCTION", "input": [], "output": [{"name": "slope", "type": "LReal", "description": "Gradient of straight line"}, {"name": "intercept", "type": "LReal", "description": "The intersection with the Y axis"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LGF_typeRegressionLine", "description": "The data points are transferred with their X- and Y-values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#8200": "ERR_NOT_ENOUGH_VALUES Error: Not enough Values."}, "user_defined_types": [{"name": "LGF_typeRegressionLine", "description": "UDT for transferring datapoints to LGF_RegressionLine", "member": [{"name": "x", "type": "Real", "default": "0.0", "description": "X-Axis value"}, {"name": "y", "type": "Real", "default": "0.0", "description": "Y-Axis value"}]}]}
{"title": "Matrix Transposer", "name": "LGF_MatrixTranspose", "description": "## Short description ##\n\nThis function transposes a matrix of the data type ARRAY[*,*] of LREAL.\nCondition: Input matrix (m x n) = output matrix (n x m).\nA matrix is transposed by making columns out of the rows.\nNote Note that the number of rows of the input matrix must be equal to the number of columns of \nthe output matrix. Also, the number of columns of the input matrix must be equal to the \nnumber of rows of the output matrix.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Matrix to be transposed"}, {"name": "matrixTranspose", "type": "Array[*, *] of LReal", "description": "Transposed matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_COLUMNS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_COLUMNS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_ROWS"}, "user_defined_types": []}
{"title": "3D distance calculation between points", "name": "LGF_CalcDistance_3D", "description": "## Short description ##\n\nThe function calculates the distance between two points in 3D space.\n\n## Functional description ##\n\nThe block calculates the distance between two points in a Cartesian coordinate system. The \ndistance is calculated with the following formula:\nresult = 2‚àö((ùë•2 ‚àí ùë•1)^2 + (ùë¶2 ‚àí ùë¶1)^2 + (ùëß2 ‚àí ùëß1)^2)", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "z1", "type": "LReal", "description": "Z coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}, {"name": "z2", "type": "LReal", "description": "Z coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": []}
{"title": "Double word edge detection", "name": "LGF_GetBitStates", "description": "## Short description ##\n\nThis function checks a DWord for falling as well as rising edges.\nIt returns the number of edges, a DWord with the edge bits, and a boolean value if edge(s) are \npresent.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Check input value for changes and edges"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "Input value has changed (compared to the previous cycle)"}, {"name": "hasRisingEdges", "type": "Bool", "description": "Input value has rising edges"}, {"name": "risingBits", "type": "DWord", "description": "Bitstream with the rising edges"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "Input value has falling edges"}, {"name": "fallingBits", "type": "DWord", "description": "Bitstream with the falling edges"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Matrix Subtractor", "name": "LGF_MatrixSubtraction", "description": "## Short description ##\n\nThis function subtracts a matrix of the data type ARRAY[*,*] of LREAL from another one.\nThe individual fields of the two matrices are read, subtracted and then output in the matrix \nmatrixResult.\nNote Note that all input and output matrices must have the same number of columns and rows", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First matrix - minuend"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second matrix - subtrahend"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "FIFO Buffer Management", "name": "LGF_FIFO", "description": "## Short description ##\n\nFIFO (First-In First-Out / Queue / ring buffer memory)\nThis function stores incoming data and outputs the oldest unprocessed data.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote In computer science, the queue is also based on the FIFO principle.\nWith the enqueue input, a new item is stored from the InOut parameter item in the next free \nposition in the buffer. The output elementCount is incremented by one.\nWith the dequeue input, the next element to be processed is output to the InOut parameter item, \nand this field in the buffer is replaced by the value in the parameter initialItem. The output \nelementCount decremented by one.\nWith the reset input, the buffer is initialized and the index and counter are reset. The \nelementCount output is set to zero and the isEmpty output is set to TRUE.\nWith the clear input, the buffer is emptied and initialized with the initial value initialItem. Index \nand counter are reset. The elementCount output is set to zero and the isEmpty output is set to \nTRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue item to the buffer"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue item from the buffer and return it on `item`"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value `initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: `0` / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8601": "ERR_INDEX_IN_ARRAY_LIMITS_1", "16#8602": "ERR_INDEX_IN_ARRAY_LIMITS_2", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_FIRST_ENTRY", "16#8612": "ERR_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": []}
{"title": "Boxplot Calculation for Integer Data", "name": "LGF_Boxplot_DInt", "description": "## Short description ##\n\nIf you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows \nyou in which area the data is located and how it is distributed over this area. A Boxplot consists \nof the following parameters:\n‚Ä¢ Minimum (smallest occurring value of the sample)\n‚Ä¢ Lower or first quartile (below this value are 25% of the sample values)\n‚Ä¢ Median or second quartile (below this value are 50% of the sample values)\n‚Ä¢ Upper or third quartile (below this value are 75% of the sample values)\n‚Ä¢ Maximum (largest occurring value of the sample)\nFigure: Boxplot\n\n## Functional description ##\n\nThe block sorts the data series and then calculates the so-called ‚Äúfive-point summary‚Äù:\nTable: Five-point summary\nCharacteristic value of the five-point summary Output parameter of the block\nMinimum (smallest occurring value of the sample) min\nLower or first quartile (below this value are 25% of \nthe sample values)\nq25\nMedian or second quartile (below this value are \n50% of the sample values)\nmedian\nUpper or third quartile (below this value are 75% of \nthe sample values)\nq75\nMaximum (largest occurring value of the sample) max\nIf outlier detection is activated, the block first calculates the limits. From these limit values, the \nvalues are recognized as outliers:\n\nThe block then calculates new values for the parameters max and min, which lie within the outlier \nlimits. The outliers are counted and output as a percentage.\nTo make it easier to judge how the data is distributed, the block also calculates the skew. The \nskewness lies between the values -1 and 1 with the following meaning:\n‚Ä¢ -1: extremely left skewed distribution\n‚Ä¢ 0: symmetrical distribution\n‚Ä¢ 1: extreme right-skew distribution\nThe elements of the passed array are sorted in ascending order by the block. The \nLGF_Shellsort_DInt block is used for sorting.\nThe parameters are calculated as follows:\nTable: Boxplot formulas Parameters Formula", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": []}
{"title": "DTL to Julian Date Converter", "name": "LGF_DTLToJulianDate", "description": "## Short description ##\n\nThis function converts the date and time of data type DTL to the Julian date and as well the \nmodified Julian Date to data type LReal (Double).\nThe timestamp is calculated based on UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to Julian Date"}], "output": [{"name": "julianDate", "type": "LReal", "description": "Converted Julian date"}, {"name": "modifiedJulianDate", "type": "LReal", "description": "Converted modified Julian date"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "Void", "description": "---"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_DTL_INPUT_VALUE_INVALID", "16#8001": "ERR_TIME_BEFORE_1990"}, "user_defined_types": []}
{"title": "File Writing to UserFiles Folder", "name": "LGF_FileWrite", "description": "## Short description ##\n\nThis function block offers writing data as binary / serialized data stream to a file which is then \nstored on the PLC's memory card in the folder UserFiles.\n\n## Functional description ##\n\nWith the function LGF_FileWrite the data budget of a variable can be written to data in a file. For \nwriting the data it is necessary to serialize it, which the function already takes from the user.\nFor serialization an external buffer in the form of a byte array must be connected which can take \nup the data quantity, if the buffer is too small an error is output.\nThe file name must always be specified in full together with the folder name and the file \nextension in the following format: UserFiles/test.dat.\nNote The file extension (here e.g. dat) can be freely selected or omitted, it is useful for external \nprocessing to indicate the format of the file to the user.\nA file extension in the file name has no influence on the content of the file as well as its \nformatting, to provide the data in an appropriate file format is up to the user.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: UserFiles/test.dat"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length written to file (serialized length of data)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set to write into file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8603": "ERR_DATA_SERIALIZE", "16#8604": "ERR_FILE_WRITE_INIT", "16#8605": "ERR_FILE_WRITE"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Shift Register for Datatype Variant", "name": "LGF_ShiftRegister", "description": "## Short description ##\n\nThe Function represents a shift register for any kind of Datatype (using variant).\nIt is possible to shift the elements in the array at bufferRegister to the left (index \narray[n]:=array[n+1]) or right (index array[n]:=array[n-1]).\nIt could be used for material tracking trough a machine or a process, e.g. for a rotary indexing \ntable.\nNote As this is a real shift operation, it may cause some runtime effects while using big array sizes \nto move at the input bufferRegister.\nPlease consider that a FIFO or LIFO storage, based on indexes, could be used as well for \nmost applications.", "type": "FUNCTION_BLOCK", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted left."}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted right."}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the bufferRegister input array"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in bufferRegister with initalItem"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the array at input bufferRegister is initialized."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_CLEARING_WITHOUT_INITIAL_ITEM", "16#8202": "ERR_FILL_WITHOUT_INITIAL_ITEM", "16#8203": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8401": "ERR_MORE_THAN_ONE_COMMAND", "16#8402": "ERR_IN_SHIFT_RANGE", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_SHIFT_BUFFER_LEFT", "16#8612": "ERR_SHIFT_BUFFER_LEFT_FILL", "16#8622": "ERR_SHIFT_BUFFER_RIGHT_FILL"}, "user_defined_types": []}
{"title": "DInt range random number generation", "name": "LGF_Random_DInt", "description": "## Short description ##\n\nThis function generates a random value with each call.\nThe random number has the data type DInt.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe function generates random values in the range:\n‚àí2147483648 ‚â§ ùëÖùëíùë°ùë¢ùëüùëõùëâùëéùëô ‚â§ 2147483647.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to DInt.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random number in the DInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "DWord to 2-Word Splitter", "name": "LGF_SplitDWordToWords", "description": "## Short description ##\n\nThis function splits a DWord variable into 2 Word variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "word1", "type": "Word", "description": "Output Word 1 - MSW"}, {"name": "word0", "type": "Word", "description": "Output Word 0 - LSW"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Advanced CRC-8 Calculator", "name": "LGF_CalcCRC8Advanced", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC8Advanced uses 8 bits as the generator \npolynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nVia the Boolean input parameters reflectInput and reflectResult, you may optionally mirror \nthe bits of the input data or the CRC value. An XOR operation is also performed with the CRC \nvalue at the end and the value finalXorValue.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\nùëÅùë¢ùëöùëèùëíùëüùëÇùëìùê∏ùëôùëíùëöùëíùëõùë°ùë† <= (ùê¥ùëüùëüùëéùë¶ùëàùëùùëùùëíùëüùêøùëñùëöùëñùë° ‚àí ùê¥ùëüùëüùëéùë¶ùêøùëúùë§ùëíùëüùëàùëõùëëùëíùëüùêøùëñùëöùëñùë° + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Byte", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "Binary to Gray Code Converter", "name": "LGF_BinaryToGray", "description": "## Short description ##\n\nThis function converts a binary coded value into a Gray-coded value.", "type": "FUNCTION", "input": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Gray-coded value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Matrix Inverter", "name": "LGF_MatrixInverse", "description": "## Short description ##\n\nThis function inverts a square matrix of the data type ARRAY[*,*] of LREAL.\nThe square matrix of any size will be inverted according to the Shipley-Coleman method.\nùëöùëéùë°ùëüùëñùë•ùëÖùëíùë†ùë¢ùëôùë° = ùëöùëéùë°ùëüùëñùë•^(‚àí1)\nNote Note that the input matrix must be square. This means that the number of rows must be \nequal to the number of columns. The output matrix must be the same size and have the \nsame array boundaries as the input matrix.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Square input matrix that will be inversed"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Inverted matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NOT_SQUARE_MATRIX", "16#8201": "ERR_ALGORITHM_NOT_POSSIBLE", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "Word to 2-Byte Splitter", "name": "LGF_SplitWordToBytes", "description": "## Short description ##\n\nThis function splits a Word variable into 2 Byte variables.", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "byte1", "type": "Byte", "description": "Output Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "LReal numbers comparison with variable precision", "name": "LGF_CompareLRealByPrecision", "description": "## Short description ##\n\nThis function checks floating point numbers for equality, by using an approximation formula and \na fixed precision by constant 1.0E-12 (pico)\n\n## Functional description ##\n\nThe comparison of the LREAL numbers is based on an given accuracy at the parameter \nprecision. The difference between the two input values must be smaller than the precision\naccuracy value multiplied by one of the two input values.\nEquation:", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}, {"name": "precision", "type": "LReal", "description": "Accuracy with which the two values are compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": []}
{"title": "Endianness Detection Function for Little Endian", "name": "LGF_IsLittleEndian", "description": "## Short description ##\n\nThe function detects the endianness of the executing system.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if little endianness is detected"}], "status_codes": {}, "user_defined_types": []}
{"title": "Simple Smoothing Function", "name": "LGF_SimpleSmoothingFC", "description": "## Short description ##\n\nThe function calculates the linear mean value acyclically.\nThe simplest form of smoothing a sequence of measured values is to calculate the linear mean \nvalue by three points.\nThe function reads an array that is smoothed. ùëÅ ‚àí 2 smoothed measured values can be \ncalculated from N measured values. Therefore, the output array in the index (0) and index (N) \ncontains the value 0.\n\n## Functional description ##\n\nThe function calculates the smoothed values using the following formula:\n\nThe calculated value is output or the calculated values are output at output smoothedValue.\nBased on this formula, the function cannot calculate values for the elements 0 and N.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_NOT_ENOUGH_VALUES Error: Not enough values.", "16#8401": "ERR_ARRAY_DIFFERENT Error: The Arraysizes are not equal."}, "user_defined_types": []}
{"title": "2D distance calculation between points", "name": "LGF_CalcDistance_2D", "description": "## Short description ##\n\nThe function calculates the distance between two points in the plane.\n\n## Functional description ##\n\nThe block calculates the distance between two points in a Cartesian coordinate system. The \ndistance is calculated with the following formula:\nresult = 2‚àö((x2 ‚àí x1)^2 + (y2 ‚àí y1)^2)", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": []}
{"title": "Kelvin to Celsius Converter", "name": "LGF_KelvinToCelsius", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Kelvin to ¬∞Celsius.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Celsius"}], "status_codes": {}, "user_defined_types": []}
{"title": "32-Bit to DWord Merger", "name": "LGF_MergeBitsToDWord", "description": "## Short description ##\n\nThis function merge 32 Bits / 32 Boolean variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "bit31", "type": "Bool", "description": "Input Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Input Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Input Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Input Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Input Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Input Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Input Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Input Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Input Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Input Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Input Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Input Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Input Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Input Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Input Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Input Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Input Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Bit sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "DInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_DInt", "description": "## Short description ##\n\nThis function searches, in an array of the data type DInt, for the maximum and minimum value \nand the respective index in the array.\n\n## Functional description ##\n\nAn array of any size is connected via the values input. The elements are then compared in turn. \nThe smallest and largest values, as well as their corresponding index are output to the array.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "DInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "DTL to UNIX Time Converter", "name": "LGF_DTLToUnixTime", "description": "## Short description ##\n\nThis function converts the date and time of data type DTL to the UNIX time of data type DInt. The timestamp is calculated in UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to UNIX time"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted UNIX time"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_TIME_BEFORE_1990", "16#8001": "ERR_DTL_INPUT_VALUE_INVALID"}, "user_defined_types": []}
{"title": "LWord Endianness Adjuster", "name": "LGF_SwapBlockLWord", "description": "## Short description ##\n\nAdjusts/ switches the endianness of multibyte data typed values.\nFor this to achieve, a loop will iterate through the array elements and swap the bytes \nintrinsically.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of LWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Boxplot Calculation for Unsigned Integer Data", "name": "LGF_Boxplot_UDInt", "description": "## Short description ##\n\nIf you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows \nyou in which area the data is located and how it is distributed over this area. A Boxplot consists \nof the following parameters:\n‚Ä¢ Minimum (smallest occurring value of the sample)\n‚Ä¢ Lower or first quartile (below this value are 25% of the sample values)\n‚Ä¢ Median or second quartile (below this value are 50% of the sample values)\n‚Ä¢ Upper or third quartile (below this value are 75% of the sample values)\n‚Ä¢ Maximum (largest occurring value of the sample)\nFigure: Boxplot\n\n## Functional description ##\n\nThe block sorts the data series and then calculates the so-called ‚Äúfive-point summary‚Äù:\nTable: Five-point summary\nCharacteristic value of the five-point summary Output parameter of the block\nMinimum (smallest occurring value of the sample) min\nLower or first quartile (below this value are 25% of \nthe sample values)\nq25\nMedian or second quartile (below this value are \n50% of the sample values)\nmedian\nUpper or third quartile (below this value are 75% of \nthe sample values)\nq75\nMaximum (largest occurring value of the sample) max\nIf outlier detection is activated, the block first calculates the limits. From these limit values, the \nvalues are recognized as outliers:\n\nThe block then calculates new values for the parameters max and min, which lie within the outlier \nlimits. The outliers are counted and output as a percentage.\nTo make it easier to judge how the data is distributed, the block also calculates the skew. The \nskewness lies between the values -1 and 1 with the following meaning:\n‚Ä¢ -1: extremely left skewed distribution\n‚Ä¢ 0: symmetrical distribution\n‚Ä¢ 1: extreme right-skew distribution\nThe elements of the passed array are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe parameters are calculated as follows:\nTable: Boxplot formulas Parameters Formula", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "UDInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "UDInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": []}
{"title": "4-Byte to DWord Merger", "name": "LGF_MergeBytesToDWord", "description": "## Short description ##\n\nThis function merge 4 Byte variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "byte3", "type": "Byte", "description": "Input Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Input Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Input Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Byte sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "Random Real Number Generator", "name": "LGF_Random_Real", "description": "## Short description ##\n\nThis function generates a random value with each call.\nThe random number has the data type Real in the range from 0.0 to 1.0.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe function generates random values in the range:\n0.0 ‚â§ ùëÖùëíùë°ùë¢ùëüùëõùëâùëéùëô ‚â§ 1.0.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to a floating point.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number between 0.0 and 1.0"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "DWORD falling edge counting", "name": "LGF_CountFalInDWord", "description": "## Short description ##\n\nThe function analyzes a variable of the type DWORD and outputs how often a 1-0 sequence \n(falling edge) occurs in the variable.\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountFalInDWord in the future!\nThis function is no longer maintained!\n\n## Functional description ##\n\nIn a variable of the data type DWORD, the block counts the falling edges (1-0 transitions) from \nleft to right. The output countFalInDWord outputs the number of falling edges.\nSo that falling edges at the variable limit are also detected, the input value is copied to the static \nvariable statDWordPrevCycle at the end of the evaluation and evaluated in the next cycle.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the falling edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of falling edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Linear Scaler for Input Variable", "name": "LGF_ScaleLinear", "description": "## Short description ##\n\nThis function scales an input variable (LReal) via a linear straight-line equation.\n\n## Functional description ##\n\nThe function linearly scales an input variable (e.g. an analog input value) to a specific output \nvariable (e.g. level).\nTo determine the output variable, the following linear equation is used in the function:\nùë• =\n((ùë¶2 ‚àí ùë¶1) / (ùë•2 ‚àí ùë•1)) * (ùë• ‚àí ùë•1) + ùë¶1\nThe straight line is described by the two points, P1 and P2. You specify the points as a \nCartesian coordinate system using x and y coordinates.\nNote If the values of the parameters x1 and x2 are the same, the value of y1 is output on output y\nBy specifying yMin and yMax you can restrict the calculated value of y to a range limited at top \nand bottom. Thus, you avoid override and underride ranges.", "type": "FUNCTION", "input": [{"name": "x", "type": "LReal", "description": "Input value `x` to be scaled"}, {"name": "x1", "type": "LReal", "description": "Point 1 (P1) -`x` coordinate of the linear function"}, {"name": "y1", "type": "LReal", "description": "Point 1 (P1) -`y` coordinate of the linear function"}, {"name": "x2", "type": "LReal", "description": "Point 2 (P2) -`x` coordinate of the linear function"}, {"name": "y2", "type": "LReal", "description": "Point 2 (P2) -`y` coordinate of the linear function"}, {"name": "yMin", "type": "LReal", "description": "Lower limit value of the output"}, {"name": "yMax", "type": "LReal", "description": "High limit value of the output"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Scaled output value `y`"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#6001": "WARN_Y_LIMITED_TO_YMIN", "16#6002": "WARN_Y_LIMITED_TO_YMAX", "16#8200": "ERR_LOW_LIM_OVER_UP_LIM"}, "user_defined_types": []}
{"title": "Profinet Interface Parameter Reader", "name": "LGF_ReadPnInterfaceParameter", "description": "## Short description ##\n\nThe function block provides Interface parameter like the IP Address settings, MAC Address and \nthe PN Name.\n\n## Functional description ##\n\nThe function reads the Interface settings / parameters using the system function RDREC (Read \ndata record).\nTo read the MAC and IP address of the interface provided via it's hardware ID, it is mandatory \nto read the PD_INTERFACE_DATA_REAL data record of any PROFINET compliant interface.\nNote Upon TIA Portal V17, it‚Äôs possible to use as well the system function CommConfig, which is in \nthe Instructions / Communication / Open user communication (Version >= V8.1) located.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "hardwareId", "type": "HW_ANY", "description": "Hardware ID of the Interface where the parameter should be read"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished, new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "DWord", "description": "Status of the FB and error identification"}, {"name": "address", "type": "IP_V4", "description": "IP Address from interface"}, {"name": "subnetMask", "type": "IP_V4", "description": "Subnet mask from interface"}, {"name": "standardGateway", "type": "IP_V4", "description": "Standard gateway address from interface"}, {"name": "macAddress", "type": "Array[0..5] of Byte", "description": "MAC Address from interface"}, {"name": "pnName", "type": "String", "description": "Profinet name from interface"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#9000": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine"}, "user_defined_types": []}
{"title": "GPS-DD to GPS Direction DMS Converter", "name": "LGF_GpsDDToGps", "description": "## Short description ##\n\nThis function converts a given GPS-DD data type (decimal degrees) into a GPS data type \n(direction, degrees, minutes, and seconds).\nGPS decimal degree to GPS ‚Äúnative‚Äù.", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS_DD", "description": "GPS-Data to be converted (decimal degrees)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS", "description": "Converted GPS-Data (direction, degrees, minutes, and seconds)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8201": "ERR_LATITUDE_VALUE", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}, {"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}]}
{"title": "Structured data comparison", "name": "LGF_CompareVariant", "description": "## Short description ##\n\nThe function compares two structured actual parameters (array, PLC data type) and outputs \nwhether they are of the same type and have the same values.\nCompare arrays or plc datatypes and their values up to a max lengh of 200 Bytes of the \nconnected variables. If at least one value of an element is not identical ‚Äì> set function result = \nfalse\nRestrictions:\nThe attached structure must not include Strings\nThe attached structure can not exceed 200 bytes, because of the internal buffer size\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThis block compares two (structured) actual parameters and shows whether they equate to the \nsame value.\nNote The following differences cannot be detected with the comparison method (byte level):\n‚Ä¢ Variables of the data type Struct cannot be compared.\n‚Ä¢ For strings, there may be differences in the range between the actual length and the maximum \nlength.\n‚Ä¢ With REAL numbers in the structure, a disparity can also be displayed for ‚Äúsame‚Äù variables.\n‚Ä¢ Variables of the type ARRAY of BOOL cannot be checked for equality with the function, because \nthe command used, CountOfElements, also counts the filling elements (e.g. 8 is returned with an \nARRAY[0..1] of BOOL).", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "variableA", "type": "Variant", "description": "First comparison variable with any data type"}, {"name": "variableB", "type": "Variant", "description": "Second comparison variable with any data type"}], "return_value": [{"type": "Bool", "description": "FALSE: Values of comparison variables or PLC data types are different. TRUE: Values of the comparison variables are equal and PLC data types are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_INPUT_TYPES_MUST_MATCH", "16#8202": "ERR_INPUT_TYPES_LENGTH_NOT_EQUAL", "16#8601": "ERR_SERIALIZE_VARIABLE_A", "16#8602": "ERR_SERIALIZE_VARIABLE_B"}, "user_defined_types": []}
{"title": "ISO 8601 calendar week calculation", "name": "LGF_GetCalendarWeek_ISO", "description": "## Short description ##\n\nThis function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for ISO 8601 European countries.\n\n## Functional description ##\n\nCounting method for European countries in accordance with ISO 8601\n‚Ä¢     Calendar weeks have 7 days, start on a Monday, and they are counted continuously throughout the year\n‚Ä¢     Calendar week 1 of a year is the week that contains the first Thursday.\n‚Ä¢     Each year has either 52 or 53 calendar weeks.\n‚Ä¢    A year has 53 calendar weeks if the following characteristics apply:\n-    A common year begins on a Thursday and ends on a Thursday.\n-    A leap year begins either on a Wednesday and ends on a Thursday or it begins on a Thursday and ends on a Friday.\n\n\n‚Ä¢    The 29th, 30th and 31st December can belong to the calendar week 1 of the following year.\n‚Ä¢    The 1st, 2nd, and 3rd January can still belong to the last calendar week of the previous year.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": []}
{"title": "Random UDInt Range Number Generator", "name": "LGF_RandomRange_UDInt", "description": "## Short description ##\n\nThis function generates a random value in defined limits with each call.\nThe random number has the data type UDInt in the specified range.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block generates random values that are between the specified minValue and the maxValue. \nThis random value is output via the Ret_Val.The random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to a UDInt.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "UDInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random UDInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "Function Curve Area Calculator", "name": "LGF_Integration", "description": "## Short description ##\n\nThe function approximately calculates the area under a function curve. The function curve is \ntransferred as an analog value (LReal) which varies over time. The integral value is output on \nintegral.\nThe implementation is based on the trapezoidal rule and uses [ms] as time base.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe integral calculation includes the summation of those trapezoidal areas that span between \nthe last two function values on the ‚Äúvalue‚Äù input and the time. The elapsed time is calculated via \nthe system time of the CPU. This trapezoidal area is identical to the product of the mean value \nof the two process values and the time interval.\nNote The calculation takes [ms] as time base. So the analoge value hase to use the same time \nbase, e.g. [volume flow/ms].\nùê¥ = 1/2 * (ùêπùë°1 + ùêπùë°0) * (ùë°1 ‚àí ùë°0) + 1/2 * (ùêπùë°2 + ùêπùë°1) *(ùë°2‚àí ùë°1) + ...\nStart the integral calculation for the inputvalue at the parameter value:\n‚Ä¢ Set the parameter enable to the value TRUE\n‚Ä¢ Set the parameter reset to the value FALSE\nIf the parameter enable is set to the value FALSE, the integral calculation is stopped and the \noutput integral outputs the last calculated value.\nIf the parameter reset is set to the value TRUE, the output integral is reset to 0.0", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enables integral calculation"}, {"name": "value", "type": "LReal", "description": "Analog value of the continuous function curve, based on [ms]"}, {"name": "reset", "type": "Bool", "description": "Sets the output 'integral' to '0.0'"}], "output": [{"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8600": "ERR_READ_SYS_TIME"}, "user_defined_types": []}
{"title": "DWord Endianness Adjuster", "name": "LGF_SwapBlockDWord", "description": "## Short description ##\n\nAdjusts/ switches the endianness of multibyte data typed values.\nFor this to achieve, a loop will iterate through the array elements and swap the bytes \nintrinsically.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of DWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Kelvin to Rankine Converter", "name": "LGF_KelvinToRankine", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Kelvin to ¬∞Rankine.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Rankine"}], "status_codes": {}, "user_defined_types": []}
{"title": "String to Time Converter", "name": "LGF_StringToTime", "description": "## Short description ##\n\nThe function converts a variable of the data type String into a variable of the system data type \nTime.", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "String", "description": "Time to be converted as string Example: 1D3H45M6S0MS"}], "output": [], "in/out": [], "return_value": [{"type": "Time", "description": "Converted time value Example: T#1D_3H_45M_6S"}], "status_codes": {}, "user_defined_types": []}
{"title": "Pulse relay and toggle flip-flop operation", "name": "LGF_PulseRelay", "description": "## Short description ##\n\nThis block corresponds to an impulse relay or a toggle flip-flop including set and reset input.   Pulse relay, Surge relay, Toggle-Flip-Flop, Frequency divider reset is leading / prior to set or trigger\n\n## Functional description ##\n\nFigure: LGF_PulseRelay Signal diagram\n1.   Each rising edge of the input trigger changes the Boolean value of the output out.    \n2.   Each rising edge of the input set sets the Bboolean value of the output out to TRUE.    \n3.   Each rising edge of the input reset sets the Boolean value of the output out to FALSE. \n4.   If the inputs set and reset are set in the same cycle, the reset input has priority.\nThe block can also be used as a frequency divider. If the input trigger is supplied with a fixed frequency, the output out delivers half the frequency.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "FALSE Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "FALSE Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "FALSE Reset signal, rising edge (prior to set)"}], "output": [{"name": "out", "type": "Bool", "description": "Ooutput signal"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value tolerance range check", "name": "LGF_IsValueInTolerance", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range.\nThe value range is defined with a set point, as well as a tolerance range, around the set point in \npercent (%). The function calculates the low limit and high limit of the value range.\n\n## Functional description ##\n\nThe setpoint and tolerance percentage variables define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "tolerance", "type": "LReal", "description": "Tolerance range around the set point in percent"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the value exceeds the upper limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE if the value is below the lower limit"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if the value is in the value range"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": []}
{"title": "Matrix Scalar Multiplier", "name": "LGF_MatrixScalarMultiplication", "description": "## Short description ##\n\nThis function block multiplies a matrix of the data type ARRAY[*,*] of LREAL with a scalar.\nA matrix is multiplied by a scalar, thereby multiplying each matrix element by the scalar. The \nresult is output in the matrixResult matrix.\nNote Note that the input and output matrix must have the same number of columns and rows.", "type": "FUNCTION", "input": [{"name": "scalar", "type": "LReal", "description": "Scalar value where the matrix is multiplied"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrixInput", "type": "Array[*, *] of LReal", "description": "Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "The result matrix of the multiplication"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_MATRICES_LOWER_BOUND_ROWS_DONT_MATCH", "16#8202": "ERR_MATRICES_UPPER_BOUND_ROWS_DONT_MATCH", "16#8203": "ERR_MATRICES_LOWER_BOUND_COLUMNS_DONT_MATCH", "16#8204": "ERR_MATRICES_UPPER_BOUND_COLUMNS_DONT_MATCH"}, "user_defined_types": []}
{"title": "LReal numbers comparison with fixed precision", "name": "LGF_CompareLReal", "description": "## Short description ##\n\nThis function checks floating point numbers for equality, by using an approximation formula and \na fixed precision by constant 1.0E-12 (pico)\n\n## Functional description ##\n\nThe comparison of the LREAL numbers is based on an fixed accuracy of 1.0E-12. The \ndifference between the two input values must be smaller than the PRECISION accuracy multiplied \nby one of the two input values.\nEquation:\nNote If your application requires a different accuracy when comparing the numbers, adapt the \n‚ÄúPRECISION‚Äù constant in the function to your requirements.\nOr you may use the FC LGF_CompareLRealByPrecision.", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": []}
{"title": "Advanced String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArrayAdv", "description": "## Short description ##\n\nThe function extracts a String specified by a text before and after from an array of characters \nwith extended options.", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "TRUE: textBefore and textAfter are included in the extracted string"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "position", "type": "DInt", "description": "Position (index) within the array where text begins (index zero based)"}, {"name": "length", "type": "Int", "description": "Length of text that was extracted"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Return value: Status of the FB"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": []}
{"title": "Word to 16-Bit Splitter", "name": "LGF_SplitWordToBits", "description": "## Short description ##\n\nThis function splits a Word variable into 16 Boolean / 16 Bit variables.", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "bit15", "type": "Bool", "description": "Output Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "International Date String to DTL Converter", "name": "LGF_StringToDTL_ISO", "description": "## Short description ##\n\nThis function converts a character string in international format with date components into the \ndata type DTL.\n\n## Functional description ##\n\nThe block reads a date as a character string and converts it to the data type DTL. The individual \ndate components in the character string are separated according to the international format. The \nseparator between the components in the character string is irrelevant.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_JOB", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": []}
{"title": "Endianness Detection Function", "name": "LGF_IsBigEndian", "description": "## Short description ##\n\nThe function detects the endianness of the executing system.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if big endianness is detected"}], "status_codes": {}, "user_defined_types": []}
{"title": "N-th root extraction", "name": "LGF_NthRoot", "description": "## Short description ##\n\nThis function extracts the n-th root of a given value.\nThe root is defined as follows:\nùëüùëíùë†ùë¢ùëôùë° = ùëüùëúùëúùë°‚àöùë£ùëéùëôùë¢ùëí = ùë£ùëéùëôùë¢ùëí^(1/ùëüùëúùëúùë°)\nSTEP 7 (TIA Portal) results in the following formula:\nùëüùëíùë†ùë¢ùëôùë° = ùë£ùëéùëôùë¢ùëí ** (1/ùëüùëúùëúùë°)", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value from which the root should be calculated"}, {"name": "root", "type": "LReal", "description": "Exponent of root"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Returns the Nth root of a value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NEG_VAR"}, "user_defined_types": []}
{"title": "Word Endianness Adjuster", "name": "LGF_SwapBlockWord", "description": "## Short description ##\n\nAdjusts/ switches the endianness of multibyte data typed values.\nFor this to achieve, a loop will iterate through the array elements and swap the bytes \nintrinsically.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of Word", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Shell Sort for DInt Arrays", "name": "LGF_ShellSort_DInt", "description": "## Short description ##\n\nThis block sorts an array of type DInt with any number of elements (max. 1000) in ascending or \ndescending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: ùí™(ùëõ ‚ãÖ log(ùëõ)^2)\nTable: Execution times of the block LGF_ShellSort‚Ä¶\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Rankine to Kelvin Converter", "name": "LGF_RankineToKelvin", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Rankine to ¬∞Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Rankine"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Kelvin"}], "status_codes": {}, "user_defined_types": []}
{"title": "Pulse Generator", "name": "LGF_Impulse", "description": "## Short description ##\n\nThis function generates pulses at a given frequency. The pulse is always present for one \n(control) cycle.\n\n## Functional description ##\n\nThe function generates pulses at the output impulse with the frequency frequency.\nThe block always begins with a pulse and sets the next pulse after the period that has elapsed.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}], "output": [{"name": "impulse", "type": "Bool", "description": "Impulse signal output"}, {"name": "countdown", "type": "Time", "description": "Time until next pulse"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Numeric Differentiation Function", "name": "LGF_DifferenceQuotientFC", "description": "## Short description ##\n\nThis function numerically differentiates a signal sampled equidistantly in time. For example, the \nvelocity can be calculated from a measured locus curve, or the acceleration can be calculated \nfrom the measured velocity. In order to minimize the effects of a scattering measurement signal, \nthis algorithm uses a compensating polynomial.\nThe function calculates the differentiated values acyclically.\nThe function reads an array that is differentiated. ùëÅ ‚àí 4 smoothed measured values can be \ncalculated from N measured values. The output array contains the value 0 in the index (0,1,N-\n1,N). However, replacement values can be calculated.\n\n## Functional description ##\n\nTo calculate the difference quotient of a scattering signal, a third-degree compensation \npolynomial is first placed through the measured values. This polynomial is then differentiated. \nWith this method, even a distorted input signal can be sensibly differentiated.\nThe difference quotient is calculated with the following formula:\ny'(n)= $ \\frac {y(n-2)-8y(n-1)+8y(n+1)-y(n+2)}{12 \\cdot deltaT} $ \nùëëùëíùëôùë°ùëéùëá: equidistant distance between two measured values (e.g. 1s).\nThe function (FC) can calculate ùëÅ ‚àí 4 differentiated and smoothed measured values from N \nmeasured values. The output array would be assigned with 0 in the index (0,1,N-1,N). However, \nthe following formalisms can be used to calculate substitute values:\ny'(n-2)= $ \\frac {-125y(n-2)+136y(n-1)+48y(n)-88y(n+1)+29y(n+2)}{84\\cdot deltaT} $ \ny'(n-1)= $ \\frac {-38y(n-2)-2y(n-1)+24y(n)+26y(n+1)-10y(n+2)}{84\\cdot deltaT} $ \ny'(n+1)= $ \\frac {10y(n-2)-26y(n-1)-24y(n)+2y(n+1)+38y(n+2)}{84\\cdot deltaT} $ \ny'(n+2)= $ \\frac {-29y(n-2)+88y(n-1)-48y(n)-136y(n+1)+125y(n+2)}{84\\cdot deltaT} $", "type": "FUNCTION", "input": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_DELTA_T Error: Delta time `deltaT` must not be zero.", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": []}
{"title": "Device Activation and Deactivation State Machine", "name": "LGF_ActDeactDevice", "description": "## Short description ##\n\nLGF_ActDeactDevice implements a compact state machine to activate and monitor or deactivate \ndecentral devices.\nThe module monitors as well the device connection and error state after activation.\nIt works for PN (S7-1200 / S7-1500) and DP (S7-1500) devices.\n\n## Functional description ##\n\nThe module provides the procedure for activating and deactivating remote IO-Devices in the \nProfinet (PN, S7-1500 & S7-1200) and Profibus (DP, S7-1500) network.\nThe activation of the device (defined at hwId) is initiated by a rising edge at activate, after \ncomplete activation this is indicated at the output isActivated and deviceStateOK. After that the \nconnection status is displayed at the deviceStateOK output.\nThe connection is monitored and in case of a failure of this of more than the set monitoring time \ntimeOutStateMonitoring at the output and reported as an error. After successful recovery of the \nconnection by the system, the configured time is also waited until the error is reset to ensure \nstability.\nNote The connection status of the decentralized device can also be displayed in the TIA Portal \nproject navigation in the PLC, which is the controller, under the item ‚ÄòDistributed I/O‚Äô, if they \nare online with the engineering system.\nDeactivation of the device (defined at hwId) is initiated by a rising edge at deactivate, after \ncomplete activation this is indicated at the output isDeactivated.\nIt is possible to define the states for switching on and off, as well as the monitoring times for \nactivating and deactivating and the connection monitoring.All errors are automatically reset as soon as the faulty state is eliminated.\nThe exception to this are errors that can only be corrected by an intervention in the software, \nsuch as an incorrect or non-existent hardware ID of a non-existent decentralized IO device.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enable functionality of FB"}, {"name": "activate", "type": "Bool", "description": "Rising edge: Activate device given by `hwId`"}, {"name": "deactivate", "type": "Bool", "description": "Rising edge: Deactivate device given by `hwId`"}, {"name": "hwId", "type": "HW_DEVICE", "description": "Hardware ID of the device which should be activated / deactivated"}, {"name": "parameter", "type": "LGF_typeActDeactDeviceParameter", "description": "Parameter dataset for the function `LGF_ActDeactDevice`"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification"}, {"name": "activating", "type": "Bool", "description": "Activation of device active"}, {"name": "isActivated", "type": "Bool", "description": "Device activated"}, {"name": "deactivating", "type": "Bool", "description": "Deactivating of device active"}, {"name": "isDeactivated", "type": "Bool", "description": "Device deactivated"}, {"name": "deviceStateOK", "type": "Bool", "description": "Device is activated and connected to IO-System"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#8600": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine", "16#8601": "ERR_LOG2GEO / ERR_GEO2LOG: Log2Geo or Geo2Log error, check diagnostics for more info", "16#8640": "ERR_DEVICE_DEACTIVATING: Error during device deactivation", "16#8641": "ERR_DEVICE_DEACTIVATING_TIME_OUT: Deactivation timeout error", "16#8660": "ERR_DEVICE_ACTIVATING: Error during device activation", "16#8661": "ERR_DEVICE_ACTIVATING_TIME_OUT: Activation timeout error", "16#8662": "ERR_READ_DEVICES_STATES_DURING_ACTIVATION: Error: Read Device states (DeviceStates) during device activation", "16#8670": "ERR_READ_DEVICES_STATES_WHILE_ACTIVE:Error: Read Device states (DeviceStates) while device active", "16#8671": "ERR_DEVICE_STATE_WHILE_ACTIVE: Device states present error and is unreachable, faulty Device or IO-System", "16#8672": "ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE:Activation state (D_ACT_DP) of device is wrong", "16#8690": "ERR_DISABLING_DEACT_DEVICE: Deactivation (D_ACT_DP) of device throws an error while disabling", "16#8691": "ERR_DISABLING_WATCHDOG:Watchdog timer expired while disabling"}, "user_defined_types": [{"name": "LGF_typeActDeactDeviceParameter", "description": "UDT for configuring the behavior of the activation and deactivation process.", "member": [{"name": "timeOutActDeact", "type": "Time", "default": "T#2500ms", "description": "Time to monitor activation and deactivation commands"}, {"name": "timeOutStateMonitoring", "type": "Time", "default": "T#100ms", "description": "Time to monitor device state"}, {"name": "enableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during startup"}, {"name": "enableAndActivate", "type": "Bool", "default": "FALSE", "description": "Enable device during startup"}, {"name": "disableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during module disabling"}]}, {"name": "LGF_typeDiagnostics", "description": "UDT for diagnostic information from blocks.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the block or error identification"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine where error occurred"}]}]}
{"title": "Kelvin to Fahrenheit Converter", "name": "LGF_KelvinToFahrenheit", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Kelvin to ¬∞Fahrenheit", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Fahrenheit"}], "status_codes": {}, "user_defined_types": []}
{"title": "Fahrenheit to Celsius Converter", "name": "LGF_FahrenheitToCelsius", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Fahrenheit to ¬∞Celsius.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Celsius"}], "status_codes": {}, "user_defined_types": []}
{"title": "Fahrenheit to Kelvin Converter", "name": "LGF_FahrenheitToKelvin", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Fahrenheit to ¬∞Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Kelvin"}], "status_codes": {}, "user_defined_types": []}
{"title": "Julian Date to DTL Time Converter", "name": "LGF_JulianTimeToDTL", "description": "## Short description ##\n\nThis function converts a given Julian Date (regular or modified) of data type LReal (Double) to a \ndate and time of data type DTL.\nThe timestamp is calculated based on UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "julianDate", "type": "LReal", "description": "Julian date to convert (standard or modified, depends on isModifiedDate)"}, {"name": "isModifiedDate", "type": "Bool", "description": "TRUE: julianDate is the modified Julian date FALSE: julianDate is the regular Julian date"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error DTL default value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": []}
{"title": "Bit toggle operation in DWORD", "name": "LGF_BitToggle", "description": "## Short description ##\n\nThis block toggles (from TRUE to FALSE and viceversa) a bit at a predefined position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be toggled"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to be toggled in the ‚Äúvalue‚Äù parameter."}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with toggled bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "Frequency Signal Generator", "name": "LGF_Frequency", "description": "## Short description ##\n\nThis function generates a signal that changes between the values FALSE and TRUE depending on \na defined frequency and a pulse pause ratio.\n\n## Functional description ##\n\nThe clock output is a Boolean value that toggles at the desired frequency. The pulsePauseRatio\ninput is used to set the pulse pause ratio.\nThe output countdown outputs the remaining time of the current state of clock.\nIf the desired frequency or pulse pause ratio is less than or equal to 0.0, the output clock = \nFALSE and countdown = 0s.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}, {"name": "pulsePauseRatio", "type": "Real", "description": "1.0"}], "output": [{"name": "clock", "type": "Bool", "description": "Output changes with defined frequency."}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current clock state."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "DWord to 32-Bit Splitter", "name": "LGF_SplitDWordToBits", "description": "## Short description ##\n\nThis function splits a DWord variable into 32 Boolean / 32 Bit variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "bit31", "type": "Bool", "description": "Output Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Output Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Output Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Output Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Output Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Output Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Output Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Output Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Output Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Output Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Output Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Output Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Output Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Output Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Output Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Output Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Output Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "16-Bit to Word Merger", "name": "LGF_MergeBitsToWord", "description": "## Short description ##\n\nThis function merge 16 Bits / 16 Boolean variables into one Word variable.", "type": "FUNCTION", "input": [{"name": "bit15", "type": "Bool", "description": "Input Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Bit sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "2-Byte to Word Merger", "name": "LGF_MergeBytesToWord", "description": "## Short description ##\n\nThis function merge 2 Byte variables into one Word variable", "type": "FUNCTION", "input": [{"name": "byte1", "type": "Byte", "description": "Input Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Byte sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "Rectangle Signal Generator", "name": "LGF_RectangleCI", "description": "## Short description ##\n\nThis function generates a rectangular signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a rectangular signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.\nThe Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the rectangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Shell Sort for LReal Arrays", "name": "LGF_ShellSort_LReal", "description": "## Short description ##\n\nThis block sorts an array of type LReal with any number of elements (max. 1000) in ascending \nor descending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: ùí™(ùëõ ‚ãÖ log(ùëõ)^2)\nTable: Execution times of the block LGF_ShellSort‚Ä¶\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Sinusoidal Signal Generator", "name": "LGF_SinusCI", "description": "## Short description ##\n\nThis function generates a sinusoidal signal profile. For this it uses the time interval of the calling \nCyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a sinusoidal signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period (in ms) and the phase shift (in ms) can \nbe set at the input parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "German public holiday detection", "name": "LGF_IsGermanHoliday", "description": "## Short description ##\n\nThe function determines whether a given date is a public holiday.\nAll public holidays in Germany are taken into account.\nHolidays that are NOT uniform nationwide can be switched on or off\n\n## Functional description ##\n\nThe block calculates the public holiday calendar of the year for a given date and displays whether the given date is a public holiday.\nOptionally, holidays that are not uniform nationwide, such as Epiphany (Three Kings), can be taken into account via the appropriate input parameters in the block.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date, which has to be evaluated"}, {"name": "threeKings", "type": "Bool", "description": "Three Kings"}, {"name": "roseMonday", "type": "Bool", "description": "Rose Monday"}, {"name": "ascension", "type": "Bool", "description": "Ascension"}, {"name": "corpusChristi", "type": "Bool", "description": "Corpus Christi"}, {"name": "augsburgerFriedensfest", "type": "Bool", "description": "Augsburger Friedensfest"}, {"name": "assumptionOfMary", "type": "Bool", "description": "Assumption Of Mary"}, {"name": "reformationDay", "type": "Bool", "description": "Reformation Day"}, {"name": "allSaintDay", "type": "Bool", "description": "All Saint Day"}, {"name": "bussUndBettag", "type": "Bool", "description": "Day of Prayer and Repentance (Buss und Bettag)"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "If the date at the input parameter is a public holiday - returning TRUE, otherwise returning FALSE"}], "status_codes": {}, "user_defined_types": []}
{"title": "Gray to Binary Code Converter", "name": "LGF_GrayToBinary", "description": "## Short description ##\n\nThis function converts a gray coded value into a binary coded value.", "type": "FUNCTION", "input": [{"name": "variableGray", "type": "DWord", "description": "Gray coded value to convert to binary value"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Binary value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Random Real Range Number Generator", "name": "LGF_RandomRange_Real", "description": "## Short description ##\n\nThis function generates a random value in defined limits with each call.\nThe random number has the data type Real in the specified range.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block generates random values that are between the specified minValue and the maxValue. \nThis random value is output via the Ret_Val.The random value is formed from the nanoseconds of the current system time of the CPU. The byte order of this value is inverted and then converted to a floating point.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "Real", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "Real", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "Boxplot Calculation for Real Data", "name": "LGF_Boxplot_LReal", "description": "## Short description ##\n\nIf you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows \nyou in which area the data is located and how it is distributed over this area. A Boxplot consists \nof the following parameters:\n‚Ä¢ Minimum (smallest occurring value of the sample)\n‚Ä¢ Lower or first quartile (below this value are 25% of the sample values)\n‚Ä¢ Median or second quartile (below this value are 50% of the sample values)\n‚Ä¢ Upper or third quartile (below this value are 75% of the sample values)\n‚Ä¢ Maximum (largest occurring value of the sample)\nFigure: Boxplot\n\n## Functional description ##\n\nThe block sorts the data series and then calculates the so-called ‚Äúfive-point summary‚Äù:\nTable: Five-point summary\nCharacteristic value of the five-point summary Output parameter of the block\nMinimum (smallest occurring value of the sample) min\nLower or first quartile (below this value are 25% of \nthe sample values)\nq25\nMedian or second quartile (below this value are \n50% of the sample values)\nmedian\nUpper or third quartile (below this value are 75% of \nthe sample values)\nq75\nMaximum (largest occurring value of the sample) max\nIf outlier detection is activated, the block first calculates the limits. From these limit values, the \nvalues are recognized as outliers:\n\nThe block then calculates new values for the parameters max and min, which lie within the outlier \nlimits. The outliers are counted and output as a percentage.\nTo make it easier to judge how the data is distributed, the block also calculates the skew. The \nskewness lies between the values -1 and 1 with the following meaning:\n‚Ä¢ -1: extremely left skewed distribution\n‚Ä¢ 0: symmetrical distribution\n‚Ä¢ 1: extreme right-skew distribution\nThe elements of the passed array are sorted in ascending order by the block. The \nLGF_Shellsort_LReal block is used for sorting.\nThe parameters are calculated as follows:\nTable: Boxplot formulas Parameters Formula", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "LReal", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "LReal", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": []}
{"title": "String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArray", "description": "## Short description ##\n\nThe function extracts a String specified by a text before and after from an array", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Status of the FB"}], "status_codes": {"16#0000": "STATUS_TEXT_FOUND", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": []}
{"title": "Odd Parity Checker for DWord", "name": "LGF_IsParityOdd", "description": "## Short description ##\n\nThe function checks whether the parity of the input variable of type DWord is odd. The return \nvalue is set to TRUE if the number of bits that are assigned TRUE in the sequence is odd.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is odd"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "Byte to 8-Bit Splitter", "name": "LGF_SplitByteToBits", "description": "## Short description ##\n\nThis function splits a Byte variable into 8 Boolean / 8 Bit variables.", "type": "FUNCTION", "input": [{"name": "byte", "type": "Byte", "description": "Bit sequence to be split"}], "output": [{"name": "bit7", "type": "Bool", "description": "Output Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Matrix Comparator", "name": "LGF_MatrixCompare", "description": "## Short description ##\n\nThis function compares two matrices of the data type ARRAY[*,*] of LREAL of equal size.\nIf both matrices are identical, the return value of the function is set to TRUE.\nNote Note that all input matrices must have the same lower and upper limit, and, therefore, the \nsame number of columns and rows.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First Matrix"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second Matrix"}], "return_value": [{"type": "Bool", "description": "TRUE: Both matrices are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "Advanced Rate of Change Limiter", "name": "LGF_LimRateOfChangeAdvancedCI", "description": "## Short description ##\n\nThe function LGF_LimRateOfChangeAdvanced limits the rate of change of an input variable. Jump \nfunctions become ramp functions. In addition, the block has various operating modes.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nFor the positive/negative value range, two rates of change in each case for the ramp (rising and \nfalling values) can be parameterized. The following operating modes can be selected via control \ninputs:\n‚Ä¢ Restart\n‚Ä¢ Pre-assigning an output\n‚Ä¢ Normal operation (automatic)\n‚Ä¢ Switch through controlled variable (manual)\n‚Ä¢ Tracking\nThe output variable can be limited through two parametrize able limits. An active limitation of the \nrate of change of a ramp, as well as an active limitation of the output variable are reported via \noutputs.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nRestart\nAt restart reset = TRUE, the output outputValue is reset to 0.0.\nIf enDefaultOutValue = TRUE is set, defaultOutValue is output. All signal outputs are set to \nFALSE.\nPre-assigning an output\nIf enDefaultOutValue = TRUE is set, the value at defaultOutValue is output. When changing \nfrom TRUE to FALSE, outputValue is ramped from defaultOutValue to autoValue. When changing \nfrom FALSE to TRUE, the output outputValue immediately jumps to defaultOutValue.\nNormal operation\nThe ramps are straight lines of limitation and are based on a rate of change per second; if, for \nexample, the parameter setPosUpRateLim = 10.0 is assigned, then at a sampling time of \n1s/100ms/10ms, 10.0/1.0/0.1 will be added to outputValue at each block call, if autoValue > \noutputValue, until autoValue is reached.\nThe limitation of the rate of change can be parameterized in both positive and negative ranges \nfor the increase and decrease.\nTable: Marking of the ramps\nParameters Ramp\nsetPosUpRateLim outputValue > 0.0 and |outputValue| rising\nsetPosDownRateLim\noutputValue > 0.0 and |outputValue| falling\nsetNegUpRateLim outputValue < 0.0 and |outputValue| rising\nsetNegDownRateLim\noutputValue < 0.0 and |outputValue| falling\nIf the ramps are not parameterized (setPosUpRateLim, setPosDownRateLim, setNegUpRateLim, \nand setNegDownRateLim equal 0.0), the output remains at 0.0 and normal operation is disabled.\nTracking\nIf the input track = TRUE is set, the input variable autoValue is interconnected directly to the \noutput variable outputValue. Thus, jumps of the input variable will also be output.\nSwitch through controlled variable\nIf manOp = TRUE is set, the controlled variable manualValue is interconnected directly to the \noutput variable outputValue.\nIn this operating mode, the parameterization of the ramps or the high/low limitation of the output \nvariable, and the pre-assignment of the output, are ineffective.\nWhen changing from TRUE to FALSE, the output outputValue is ramped again after autoValue.\nAs soon as the value range between the low and high limits is reached, the high and low limits \nare reactivated.\nFigure: Ramp function sequence, operating modes", "type": "FUNCTION_BLOCK", "input": [{"name": "autoValue", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "manualValue", "type": "LReal", "description": "Manually controlled output value"}, {"name": "posUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the positive value range"}, {"name": "posDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the positive value range"}, {"name": "negUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the negative value range"}, {"name": "negDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the negative value range"}, {"name": "highLim", "type": "LReal", "description": "High limit value"}, {"name": "lowLim", "type": "LReal", "description": "Low limit value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow / tracking of Input variable"}, {"name": "manOp", "type": "Bool", "description": "Manual mode on"}, {"name": "reset", "type": "Bool", "description": "Complete restart of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output variable"}, {"name": "posUpRateLim", "type": "Bool", "description": "Rise limitation in positive range tripped"}, {"name": "posDownRateLim", "type": "Bool", "description": "Down rate limit in positive range reached"}, {"name": "negUpRateLim", "type": "Bool", "description": "Up rate limit in negative range reached"}, {"name": "negDownRateLim", "type": "Bool", "description": "Down rate limit in negative range reached"}, {"name": "highLim", "type": "Bool", "description": "High limit reached"}, {"name": "lowLim", "type": "Bool", "description": "Low limit reached"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8202": "ERR_NEG_RATE_OF_CHANGE", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table for function", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}]}
{"title": "WString to UTF-8 Byte Stream Encoder", "name": "LGF_EncodeUtf8", "description": "## Short description ##\n\nEncodes a WString into an UTF-8 encoded byte stream.", "type": "FUNCTION", "input": [{"name": "sourceString", "type": "WString", "description": "Character that shall be converted to UTF-8"}, {"name": "startPos", "type": "DInt", "description": "Position in encoded byte stream to start insert encoded WChars (Array lower bound is added)"}], "output": [{"name": "bytesUsed", "type": "UInt", "description": "Number of Bytes converted. Ranges from 1 to 3."}], "in/out": [{"name": "encodedByteStream", "type": "Array[*] of Byte", "description": "UTF-8 conformant byte sequence."}], "return_value": [{"type": "Word", "description": "Status of the FC, Erroridentification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS"}, "user_defined_types": []}
{"title": "Triangular Signal Generator", "name": "LGF_TriangleCI", "description": "## Short description ##\n\nThis function generates a triangular signal profile. For this it uses the time interval of the calling \nCyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a triangular signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the triangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "DWORD bit count operation", "name": "LGF_BitCount", "description": "## Short description ##\n\nThis block counts in a variable of type DWord how many bits are set (TRUE) and how many are \nnot set (FALSE) and outputs the number at the outputs.\nInstead of DWord, Word and Byte can also be used by converting the past parameter with e.g. \nBYTE_TO_DWORD and connecting the corresponding bit length of the data type at the \nparameter ‚ÄúnumberOfBits‚Äù.\nByte=8, Word=16, DWord=32", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of Byte=8, Word=16, DWord=32"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Advanced CRC-16 Calculator", "name": "LGF_CalcCRC16Advanced", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC16Advanced uses 16 bits as the generator \npolynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nVia the Boolean input parameters reflectInput and reflectResult, you may optionally mirror \nthe bits of the input data or the CRC value. An XOR operation is also performed with the CRC \nvalue at the end and the value finalXorValue.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\nùëÅùë¢ùëöùëèùëíùëüùëÇùëìùê∏ùëôùëíùëöùëíùëõùë°ùë† <= (ùê¥ùëüùëüùëéùë¶ùëàùëùùëùùëíùëüùêøùëñùëöùëñùë° ‚àí ùê¥ùëüùëüùëéùë¶ùêøùëúùë§ùëíùëüùëàùëõùëëùëíùëüùêøùëñùëöùëñùë° + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Word", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "TADDR_Param to String Converter", "name": "LGF_TaddrToString", "description": "## Short description ##\n\nThe system data type TADDR_Param contains address information consisting of an IPV4 address \nand the port number.\nThe LGF_TaddrToString function converts a TADDR_Param system data type variable to a String\ndata type variable.\n\n## Functional description ##\n\nThe function converts the IPV4 address with or without port number. The system data type \nTADDR_Param is a structured data type. This structure contains the variable REM_PORT_NR. If this \nvariable is 0, no port is written to the parameter Ret_Val.", "type": "FUNCTION", "input": [{"name": "ipAdressTaddr", "type": "TADDR_Param", "description": "IP-Address and Port number to convert into string"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "IP-Address and Port number as string"}], "status_codes": {}, "user_defined_types": []}
{"title": "German Traditional Date String to DTL Converter", "name": "LGF_StringToDTL_DE", "description": "## Short description ##\n\nThis function converts a character string in the traditional format (DE) with date components into \nthe data type DTL.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": []}
{"title": "Moving Average Calculation Function Block", "name": "LGF_FloatingAverage", "description": "## Short description ##\n\nThis function calculates a moving arithmetic mean value from REAL values. This method can be \nused to smooth data series. The values can be read in cyclically or triggered.\n\n## Functional description ##\n\nNote The block LGF_FloatingAverage does not query the data type for the input parameter value. \nFor data types other than REAL, either an implicit conversion is performed automatically or \nan error is generated during compilation.\nYou can find further information in the Chapter ‚ÄúOverview of Data Type Conversion‚Äù in the \nOnline Help section of the TIA Portal or under:\nhttps://support.industry.siemens.com/cs/ww/en/view/109773506/100611494667\nThe block calculates the (moving) mean value based on the set window width. The window \nwidth indicates the maximum number of values read in last. After the maximum number of \nvalues has been read, the output windowSizeReached is set and each newly read value replaces \nthe oldest value (FIFO principle).\nTwo options are available for reading the values. With the input cyclicExecution, the values are \nread and calculated cyclically. With the trigger input, the values are read in and calculated with \neach pulse.", "type": "FUNCTION_BLOCK", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Read in `value` with every pulse at input `trigger`"}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be determined."}, {"name": "windowSize", "type": "Int", "description": "Window length for sliding averaging in the range from 1..100. The standard value is 100."}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts again."}], "output": [{"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached, TRUE: Maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR: Execution finished without errors", "16#8200": "ERR_WRONG_WINDOW_SIZE: Incorrect window size/width set."}, "user_defined_types": []}
{"title": "CRC-32 Calculator", "name": "LGF_CalcCRC32", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC32 uses 32 bits as the generator polynomial \n(mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\nùëÅùë¢ùëöùëèùëíùëüùëÇùëìùê∏ùëôùëíùëöùëíùëõùë°ùë† <= (ùê¥ùëüùëüùëéùë¶ùëàùëùùëùùëíùëüùêøùëñùëöùëñùë° ‚àí ùê¥ùëüùëüùëéùë¶ùêøùëúùë§ùëíùëüùëàùëõùëëùëíùëüùêøùëñùëöùëñùë° + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "US calendar week calculation", "name": "LGF_GetCalendarWeek_US", "description": "## Short description ##\n\nThis function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for the USA and many other countries.\n\n## Functional description ##\n\nCounting method for the USA and many other countries\n‚Ä¢     Calendar weeks have 7 days, start on a Sunday and are counted continuously throughout the year\n‚Ä¢     Calendar week 1 of a year is the week that contains January 1.\n‚Ä¢     Each year has either 52 or 53 calendar weeks.\n‚Ä¢    A year has 53 calendar weeks if the following characteristics apply:\n-    A common year begins on a Saturday and ends on a Saturday.\n-    A leap year begins either on a Saturday and ends on a Sunday or it begins on a Friday and ends on a Saturday.\n\n\n‚Ä¢    The days after the last Saturday in December can belong to the first calendar week of the following year.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": []}
{"title": "Sawtooth Signal Generator", "name": "LGF_SawToothCI", "description": "## Short description ##\n\nThis function generates a sawtooth-shaped signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a sawtooth-shaped signal profile, which is output to the \noutput parameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sawtooth signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Celsius to Kelvin Converter", "name": "LGF_CelsiusToKelvin", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Celsius to ¬∞Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Kelvin"}], "status_codes": {}, "user_defined_types": []}
{"title": "DWord to 4-Byte Splitter", "name": "LGF_SplitDWordToBytes", "description": "## Short description ##\n\nThis function splits a DWord variable into 4 Byte variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "byte3", "type": "Byte", "description": "Output Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Output Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Output Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value set point range check", "name": "LGF_IsValueInRange", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range.\nThe value range is defined with a set point and a range around this set point. The function \ncalculates the low limit and high limit of the value range.\n\n## Functional description ##\n\nThe setpoint and range variables define a range of values.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "range", "type": "LReal", "description": "Area where the setpoint is in range"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the ‚Äúvalue‚Äù is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the ‚Äúvalue‚Äù is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the ‚Äúvalue‚Äù is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": []}
{"title": "Boolean signal edge detection", "name": "LGF_CountBooleanEdges", "description": "## Short description ##\n\nThis function evaluates a input signal for different states in a certain amount of time.\nThe states are:\n‚Ä¢ One edge and input present over the whole monitoring time\n‚Ä¢ Single edge\n‚Ä¢ Double edge\n‚Ä¢ N-Edges in between the monitoring time\nThe Output signal is present for at least on cycle after the monitoring time has expired, or as \nlong as the input trigger remains TRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to evaluate signal"}, {"name": "monitorTime", "type": "Time", "description": "Time to monitor and count edges on `trigger` input"}], "output": [{"name": "single", "type": "Bool", "description": "Single edge until monitoring time expires"}, {"name": "double", "type": "Bool", "description": "Two edges in between the monitoring time"}, {"name": "long", "type": "Bool", "description": "Just a single edge in the monitoring time, the `trigger` input stays TRUE after the edge appears"}, {"name": "severalEdges", "type": "Bool", "description": "Numerous Edges occur within the monitoring time"}, {"name": "noOfEdges", "type": "USInt", "description": "Number of edges in between the monitoring time frame"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Sawtooth Signal Profile Generator", "name": "LGF_SawTooth", "description": "## Short description ##\n\nThis function generates a sawtooth-shaped signal profile. Each sawtooth consists of a defined \nnumber of steps (increments).\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountRisInDWord in the future!\nThis function is no longer maintained\n\n## Functional description ##\n\nNote Please note that changes at the input parameters only become effective with reset.\nThe block calculates the values for a sawtooth-shaped signal profile, which is output to the \noutput parameter value. The signal begins with the start value startValue and is added with the \nvalue increment after each elapse of the time interval timeRange. The value can also be \nnegative.\nIf the variable endlessSteps is set to FALSE, the number of add operations is counted. If this \nexceeds the value numberSteps, the output parameter value is set back to the start value. A new \nsawtooth begins.\nIf the variable endlessSteps is set to TRUE, the value increment is added without interruption, \nstarting once at startValue. If the maximum positive INT value range (32767) of the output \nparameter value is exceeded, value changes to the maximum negative INT value range (-32768) and will continue to be added up.\nNote The duration of a sawtooth at endlessSteps on FALSE is calculated as follows:\nDuration = #timeRange * (#numberSteps + 1)", "type": "FUNCTION_BLOCK", "input": [{"name": "startValue", "type": "Int", "description": "0"}, {"name": "timeRange", "type": "Time", "description": "T#0s"}, {"name": "incrementRange", "type": "Int", "description": "0"}, {"name": "numberSteps", "type": "Int", "description": "0"}, {"name": "endlessSteps", "type": "Bool", "description": "FALSE"}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Int", "description": "Current value of the sawtooth signal."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Histogram Calculation Function Block for Real Data", "name": "LGF_Histogram_LReal", "description": "## Short description ##\n\nThe histogram shows the frequency distribution of a sample by class. A class describes a value \ninterval in which the individual frequencies are added together. After specifying the number of \nclasses, the class width and the respective class center are calculated. The number of classes \nis limited to 15.\nThe distribution is represented as a rectangle around the class mean with the class width and \nthe cumulated frequency as height.\nFigure: Distribution\n\n## Functional description ##\n\nThe block sorts the transferred data and calculates the general class width using the transferred \nclass count and data range. The block then counts the values that lie within a class. In order to \ndraw a histogram, the block also calculates the necessary X and Y coordinates.\nThe elements of the passed array values are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe number of classes can be specified using the following rule of thumb:\n\nFormulas", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_LReal`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": []}
{"title": "Random DInt Range Number Generator", "name": "LGF_RandomRange_DInt", "description": "## Short description ##\n\nThis function generates a random value in defined limits with each call.\nThe random number has the data type DInt in the specified range.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block generates random values that are between the specified minValue and the maxValue. \nThis random value is output via the Ret_Val.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to a DInt.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "DInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random DInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "Numeric Differentiation Function Block", "name": "LGF_DifferenceQuotientFB", "description": "## Short description ##\n\nThis function numerically differentiates a signal sampled equidistantly in time. For example, the \nvelocity can be calculated from a measured locus curve, or the acceleration can be calculated \nfrom the measured velocity. In order to minimize the effects of a scattering measurement signal, \nthis algorithm uses a compensating polynomial.\nThe function block calculates the differentiated values cyclically.\nThe function block reads-in a value with each positive edge on the insert been read in, the \nblock calculates a differentiated value and outputs it.\n\n## Functional description ##\n\nTo calculate the difference quotient of a scattering signal, a third-degree compensation \npolynomial is first placed through the measured values. This polynomial is then differentiated. \nWith this method, even a distorted input signal can be sensibly differentiated.\nThe difference quotient is calculated with the following formula:\n\nThe function (FC) can calculate ùëÅ ‚àí 4 differentiated and smoothed measured values from N \nmeasured values. The output array would be assigned with 0 in the index (0,1,N-1,N). However, \nthe following formalisms can be used to calculate substitute values:", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `derivatedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that must be included in the differentiation."}, {"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "derivatedValue", "type": "LReal", "description": "The differentiated value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification of the FB"}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a differentiated value.", "16#8200": "ERR_DELTA_T: Delta time `deltaT` must not be zero."}, "user_defined_types": []}
{"title": "Cosine Signal Generator", "name": "LGF_CosinusCI", "description": "## Short description ##\n\nThis function generates a cosinusoidal signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a cosinusoidal signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period (in ms) and the phase shift (in ms) can \nbe set at the input parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =ùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.\nThe Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the cosinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Calendar day calculation", "name": "LGF_GetCalendarDay", "description": "## Short description ##\n\nThis function uses the specified date to calculate the number of days that have passed since the beginning of the year (1st January).\nThe function is used in the functions ‚ÄúLGF_GetCalendarWeek_ISO‚Äù and\n‚ÄúLGF_GetCalendarWeek_US‚Äù .", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date for the calculation of the calendar days since 1 January."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Days past since January 1st."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": []}
{"title": "File Reading from UserFiles Folder", "name": "LGF_FileRead", "description": "## Short description ##\n\nThis function block offers reading data as binary / serialized data stream from files stored on the \nPLC's memory card in the folder UserFiles.\n\n## Functional description ##\n\nWith the function LGF_FileRead a file can be read into the data budget of a variable at data. To \nread the data it is necessary to deserialize it, which the function already takes from the user.\nFor deserialization an external buffer in the form of a byte array must be connected which can \ntake up the amount of data, if the buffer is too small an error is output.\nThe file name must always be specified in full together with the folder name and the file \nextension in the following format: UserFiles/test.dat.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "dataLengthMustMatch", "type": "Bool", "description": "The length of the file data set and the dataset in the PLC have to match."}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8411": "ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE", "16#8412": "ERR_FILE_SIZE_LESS_THEN_DATA_SIZE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8602": "ERR_DATA_SERIALIZE", "16#8603": "ERR_DATA_DESERIALIZE", "16#8604": "ERR_FILE_READ_INIT", "16#8605": "ERR_FILE_READ"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Polynomial Smoothing Function", "name": "LGF_SmoothByPolynomFC", "description": "## Short description ##\n\nThis function calculates the smoothed values by polynomial acyclically.\nFor smoothing, a 3rd degree polynomial is placed through five value points. The error squares \nof the distances between polynomial and real value are minimized. The smoothed values can \nbe determined from the polynomial parameters obtained in this way.\nThe function reads an array that is smoothed. ùëÅ ‚àí 4 smoothed measured values can be \ncalculated from N measured values. The output array contains the value 0 in the index (0,1,N-\n1,N). However, replacement values can be calculated.\n\n## Functional description ##\n\nThe 3rd degree compensation polynomial is calculated as follows:\n\nùëÅ ‚àí 4 smoothed measured values can thus be calculated from the N measured values. The \noutput array contains the value 0 in the index (0.1, N-1, N).\nThese ‚Äúmissing‚Äù values are calculated with the following formalisms:", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": []}
{"title": "Simple Smoothing Function Block", "name": "LGF_SimpleSmoothingFB", "description": "## Short description ##\n\nThe function calculates the linear mean value cyclically.\nThe simplest form of smoothing a sequence of measured values is to calculate the linear mean \nvalue by three points.\nThe function reads-in a value with each positive edge on the insert input. As soon as three \nvalues have been read in, the block calculates a smoothed value and outputs it.\n\n## Functional description ##\n\nThe function calculates the smoothed values using the following formula:\nùë¶(ùëõ) = (ùë¶(ùëõ ‚àí 1) + ùë¶(ùëõ) + ùë¶(ùëõ + 1)) / 3\nThe calculated value is output or the calculated values are output at output smoothedValue.\nBased on this formula, the function cannot calculate values for the elements 0 and N.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if three values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires three (3) values to calculate a smoothed value."}, "user_defined_types": []}
{"title": "String to TADDR_Param Converter", "name": "LGF_StringToTaddr", "description": "## Short description ##\n\nThe system data type TADDR_Param contains address information consisting of an IPV4 address \nand the port number.\nThe LGF_StringToTaddr function converts a variable od data type String to a TADDR_Param\nsystem data type variable.\n\n## Functional description ##\n\nThe function converts the IPV4 address with or without port number from data type String to \nTADDR_Param.\nThe string must be in the following form:\n‚Ä¢ without port number: [0..255].[0..255].[0..255].[0..255]\n‚Ä¢ with port number: [0..255].[0..255].[0..255].[0..255]:[0..65535]", "type": "FUNCTION", "input": [{"name": "ipAddressString", "type": "String", "description": "IPV4 address string in the format of 192.168.1.200:55047 [Port number including colon : is optional]"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "TADDR_Param", "description": "IP-Address and Port number as TADDR_Param data type"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8110": "ERR_OCTET_WRONG_NUMBER_OF_CHAR", "16#8120": "ERR_OCTET_STRING_IS_EMPTY", "16#8130": "ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS", "16#8150": "ERR_PORT_WRONG_NUMBER_OF_CHAR", "16#8151": "ERR_PORT_STRING_IS_EMPTY", "16#8152": "ERR_PORT_EXCEEDS_MAX_PORT"}, "user_defined_types": []}
{"title": "Bit status check operation", "name": "LGF_BitTest", "description": "## Short description ##\n\nThis block checks whether a bit is TRUE or FALSE at a given position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be tested"}, {"name": "bitNo", "type": "USInt", "description": "bit number to test in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Value of the checked bit."}], "status_codes": {}, "user_defined_types": []}
{"title": "Arithmetic Mean and Standard Deviation Calculator", "name": "LGF_AverageAndDeviation", "description": "## Short description ##\n\nThis function calculates the arithmetic mean and the standard deviation from a series of \nnumbers.\n\n## Functional description ##\n\nAn array of any size is connected via the variableArray input. After reading-out the array \nboundaries, the arithmetic mean value and the standard deviation will be calculated from the \nvalues and both will be output.\nNote An array with too many elements can cause the cycle monitoring time to be exceeded.", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Array[*] of LReal", "description": "Sequence of numbers to calculate with"}], "output": [{"name": "arithmeticAverage", "type": "LReal", "description": "Calculated arithmetic average value"}, {"name": "standardDeviation", "type": "LReal", "description": "Calculated standard deviation"}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Bit assignment operation in DWORD", "name": "LGF_BitSetTo", "description": "## Short description ##\n\nThis block sets a bit to TRUE or FALSE at a predefined position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set / reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}, {"name": "setTo", "type": "Bool", "description": "Set bit to FALSE / TRUE"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with set bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "String Lower Case Converter", "name": "LGF_ToLower", "description": "## Short description ##\n\nThis function converts the capital letters of a string into their lower case equivalents.", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": []}
{"title": "Single Byte CRC-8 Calculator", "name": "LGF_CalcCRC8For1Byte", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent (Byte). The receiver detects a faulty transmission due to \nthe unequal CRC value. The function LGF_CalcCRC8For1Byte uses 8 bits as the generator \npolynomial (mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data byte value. The start value initValue and \nthe generator polynomial mask can be freely selected.\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "value", "type": "Byte", "description": "Data byte for which the CRC value will be calculated"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "Polynomial Smoothing Function Block", "name": "LGF_SmoothByPolynomFB", "description": "## Short description ##\n\nThis function calculates the smoothed values by polynomial cyclically.\nFor smoothing, a 3rd degree polynomial is placed through five value points. The error squares \nof the distances between polynomial and real value are minimized. The smoothed values can \nbe determined from the polynomial parameters obtained in this way.\nThe function reads-in a value with each positive edge on the insert input. As soon as five \nvalues have been read in, the block calculates a smoothed value and outputs it.\n\n## Functional description ##\n\nThe 3rd degree compensation polynomial is calculated as follows:\n\nùëÅ ‚àí 4 smoothed measured values can thus be calculated from the N measured values. The \noutput array contains the value 0 in the index (0.1, N-1, N).\nThese ‚Äúmissing‚Äù values are calculated with the following formalisms:", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a smoothed value."}, "user_defined_types": []}
{"title": "Temperature Unit Converter", "name": "LGF_ConvertTemperature", "description": "## Short description ##\n\nThis function converts a temperature value from one into another unit by using an appropriate \ngiven mode parameter.", "type": "FUNCTION", "input": [{"name": "mode", "type": "Int", "description": "Conversion mode"}, {"name": "value", "type": "Real", "description": "Temperature value to be converted"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature result"}], "status_codes": {"16#8200": "ERR_WRONG_MODE"}, "user_defined_types": []}
{"title": "Timer with various time switch points", "name": "LGF_TimerSwitch", "description": "## Short description ##\n\nThis block is a timer. It is possible to define daily, weekly, monthly, yearly time switch points and \ntime switch points for working days or weekend days.\nMode: Permanently off: 0, Daily: 1, Weekly: 2, Monthly: 3, Yearly: 4, Workday: 5, Weekend: 6, \nPermanently on: 10\nThe time value is always compared with the local time of the PLC, therefore the time value \nspecified at the On and Off parameters must be specified as local time.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote The function uses internally the system function RD_LOC_T to read the local time of the CPU, \nfor the correct function it is therefore necessary that the local time of the CPU is set correctly.\nThe block offers various timer types, which are determined in the mode parameter:\n‚Ä¢ Permanently off (mode = 0)\n‚Ä¢ Daily timer (mode = 1)\n‚Ä¢ Weekly timer (mode = 2)\n‚Ä¢ Monthly timer (mode = 3)\n‚Ä¢ Yearly timer (mode = 4)\n‚Ä¢ Weekdays, Monday to Friday (mode = 5)\n‚Ä¢ Weekend, Saturday and Sunday (mode = 6)\n‚Ä¢ Permanently on (mode = 10)\nThe time value is always compared with the local time of the PLC, therefore the time value \nspecified at the On and Off parameters must be specified as local time.\nDepending on the mode, the following formal parameters must be interconnected:\nMode. Mode Required - formal parameters\n0 . Permanently OFF ‚Äì none\n1 . Daily timer ‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n2 . Weekly timer ‚Äì onWeekday / offWeekday\n‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n3 . Monthly timer ‚Äì onDay / offDay\n‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n4 . Yearly timer ‚Äì onMonth / offMonth\n‚Äì onDay / offDay\n‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n5 . Weekdays ‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n6 . Weekend ‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n10 . Permanently ON ‚Äì none\nIf the set start time equals the current local time of the controller, the output signal is set to \nTRUE. If the set switch-off time equals the current local time of the controller, the signal output is \nreset again.\nNote Please note that the block can be used in the ‚ÄúMonthly timer‚Äù modes (mode = 3) or ‚Äúyearly \ntimer‚Äù (mode = 4) the block only switches if the days that you specify at the input parameters, \n‚ÄúonDay‚Äù and ‚ÄúoffDay‚Äù, actually occur in this month.", "type": "FUNCTION_BLOCK", "input": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation)"}], "output": [{"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_MODE_SELECTED", "16#8600": "ERR_RD_LOC_T"}, "user_defined_types": []}
{"title": "Rate of Change Limiter", "name": "LGF_LimRateOfChangeCI", "description": "## Short description ##\n\nThis function limits the rate of change of an input variable. A jump function becomes a ramp \nfunction.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe ramp is a limit line and refers to a rate of change per second; if, for example, setChangeRate \n= 10.0 is parameterized at a sampling time of 1s/100ms/10ms for every block call, then if value \n> delayedValue, 10.0/1.0/0.1 is added to delayedValue until value is reached.\nThe limitation of the rate of change applies to both positive and negative values for the rise and \nfall.\nThe output delayedValue can be preset or initialized.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nPre-assigning an output\nIf enDefaultOutValue = TRUE is set, the value at defaultOutValue is output. When changing \nfrom TRUE to FALSE, the output delayedValue is ramped from defaultOutValue to value. When \nchanging from FALSE to TRUE, the output delayedValue immediately jumps to defaultOutValue.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "setChangeRate", "type": "LReal", "description": "Rate of change of ramp function"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "delayedValue", "type": "LReal", "description": "Output variable"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": []}
{"title": "Standalone Data Logger with Advanced Configuration", "name": "LGF_DataLogC", "description": "## Short description ##\n\nLGF_DataLogC (C -> Compact) function integrates all the datalog system functions and can be \nused as standalone data logger.\n\n## Functional description ##\n\nThe function LGF_DataLogC combines the system functions for creating and writing data logs in \none block.\nThe procedure provides that an existing Datalog is opened on the basis of the name (name), if it \nwas not created before, this is recognized and the function creates the Datalog.\nAfterwards, depending on the parameterization, the data is written from data in an adjustable \ninterval or only on request to triggerLogEntry.\nReadMe The functionality of Datalogs can be found in the user manual:\n‚Ä¢ DataLogCreate\n‚Ä¢ DataLogOpen\n‚Ä¢ DataLogClose\n‚Ä¢ DataLogWrite\n‚Ä¢ DataLogClear\n‚Ä¢ DataLogDelete\nNOTICE The following parameters are only effective when creating a data log:\n‚Ä¢ parameter.header\n‚Ä¢ parameter.maxNumberOfEntries\n‚Ä¢ parameter.timestampFormat (S7-1200 and the S7-1500 support different formats, see the \nmanual DataLogCreate)\nNOTICE When logging data by interval (isLoggingByInterval) time variances occur, which are \ncaused by a fluctuating cycle time.\nTherefore it is recommended to call the function in a time interrupt OB besides the call in the \ncyclic program and to set the trigger for writing in this interrupt OB.\nNOTICE A data log which is deleted by the function without deleting the file cannot be created again \nas long as the file exists, it must first be deleted manually in the system.\nPlease also note the parameter parameter.deleteFile which also deletes the file next to the \ndata in case of a delete command deleteLog.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if `parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and lists all possible parameter to configure its behaviour."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set, start from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [{"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#7010": "STATUS_MAX_ENTRIES_REACHED", "16#8401": "ERR_WRONG_COMMAND_CALL_ORDER", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_DATALOG_OPEN", "16#8602": "ERR_DATALOG_CREATE", "16#8603": "ERR_DATALOG_CLOSE", "16#8604": "ERR_DATALOG_WRITE", "16#8605": "ERR_DATALOG_DELETE"}, "user_defined_types": [{"name": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module LGF_DataLogC and lists all possible parameter to configure its behaviour.", "member": [{"name": "header", "type": "String", "default": "", "description": "Headline of datalog, string of all data fields, separated by a comma: \"field1,field2,field3,...\""}, {"name": "maxNumberOfEntries", "type": "UDInt", "default": "1000", "description": "Maximum number of entries in datalog"}, {"name": "timestampFormat", "type": "USInt", "default": "0", "description": "Timestamp format"}, {"name": "clearOnOpen", "type": "Bool", "default": "FALSE", "description": "Clear datalog during opening datalog while enabling block"}, {"name": "deleteFile", "type": "Bool", "default": "FALSE", "description": "Delete as well datalog file during datalog delete"}, {"name": "enableRingBuffer", "type": "Bool", "default": "FALSE", "description": "TRUE: Overwrite old values and start from the beginning if datalog reaches its maximum entries FALSE: Stop logging if `maxNumberOfEntries` entries reached"}, {"name": "loggingByInterval", "type": "Bool", "default": "FALSE", "description": "TRUE: Log on interval time parameter FALSE: log on \"triggerEntry\""}, {"name": "loggingInterval", "type": "Time", "default": "T#1M", "description": "Time for automatic logging interval"}]}, {"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Celsius to Fahrenheit Converter", "name": "LGF_CelsiusToFahrenheit", "description": "## Short description ##\n\nThis function converts a temperature value - from ¬∞Celsius to ¬∞Fahrenheit.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in ¬∞Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in ¬∞Fahrenheit"}], "status_codes": {}, "user_defined_types": []}
{"title": "Non-Linear Interpolation Function", "name": "LGF_NonLinearInterpolation", "description": "## Short description ##\n\nThis function implements a characteristic curve. The characteristic curve is defined via an \ninterpolation point table with linear interpolation between the interpolation points. A prescribed \ninput value generates an output value in each cycle based on the characteristic curve from the \ninterpolation point table.\n\n## Functional description ##\n\nThe value of the output outputValue based on the following priority:\n1. As long as the input enDefaultOutValue is set, the value defined via the parameter \ndefaultOutValue will be output as output value.\n2. As long as the input reset is set, the block is reset and the output value is 0.0.\n3. If the input track is set, the output value will be output directly as input value, without \nconsideration of the characteristic curve.\n4. Based on the input value, a characteristic curve value is calculated via the linearly \ninterpolated, interpolation point table and output as an output value.\n‚Äì If the input value is between two interpolation points within the interpolation point table, \nthe output value is calculated as the intersection with the connecting line between the \npreceding and following interpolation points (see Figure below).\n‚Äì If the input value is before the first interpolation point (lowest value defined in the \ninterpolation point table), the output value will be calculated as the intersection of the \nline formed by the first two interpolation points of the interpolation point table.\n‚Äì If the input value is after the last interpolation point (highest value defined in the \ninterpolation point table), the output value will be calculated as the intersection of the \nline formed by the last two interpolation points of the interpolation point table.\nInterpolation point table\nThe interpolation point table is implemented through a variable of the data type Array. The type \nof the array corresponds to the PLC data type LGF_typeNonLinSetpoints.\nYou can create the interpolation point table in any global data block. The size of the array \ndepends on the number of interpolation points.\nNOTICE To keep the computing time of the block as short as possible, there is no check of the \nparameterization or the data of the interpolation point table.\nWhen entering the interpolation points in the interpolation point table, the following \nparticularities must be considered. If these particularities are not taken into account, it can \nlead to a malfunction of the block.\n‚Ä¢ At least two interpolation points must be entered in the interpolation point table.\n‚Ä¢ The interpolation points in the interpolation point table must be entered in the Table in ascending \norder of the input values.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Input value for calculating the output value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow the value of the input without using the characteristic curve"}, {"name": "reset", "type": "Bool", "description": "Reset the interpolation if the point table is changed in running operation"}], "output": [{"name": "outputValue", "type": "LReal", "description": "The calculated output value from the input value"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeNonLinSetpoints", "description": "Setpoint table for defining the characteristic curve"}], "return_value": [], "status_codes": {}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}]}
{"title": "Unix Time to DTL Time Converter", "name": "LGF_UnixTimeToDTL", "description": "## Short description ##\n\nThis function converts the Unix time of data type DInt to a date and time of data type DTL. The \ntimestamp is calculated in UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error: 0 (error = true)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": []}
