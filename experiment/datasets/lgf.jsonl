{"title": "Timer with various time switch points", "name": "LGF_TimerSwitch", "description": "This block is a timer. It is possible to define daily, weekly, monthly, yearly time switch points and time switch points for working days or weekend days.", "type": "FUNCTION_BLOCK", "input": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation)"}], "output": [{"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_MODE_SELECTED", "16#8600": "ERR_RD_LOC_T"}, "user_defined_types": [], "description_zh": "\n    // 该案例是一个定时器功能块，可以根据不同的模式在每天的、每周的、每月的或每年的特定时间点以及工作日或周末的特定时间点设置和重置输出信号。输入包括设置和重置信号的时间、日期和模式。输出包括输出信号、当前本地时间和错误状态。该功能块可以用于在特定时间点控制设备的操作。\n\n\n"}
{"title": "File Writing to UserFiles Folder", "name": "LGF_FileWrite", "description": "This function block offers writing data as binary / serialized data stream to a file which is then stored on the PLC's memory card in the folder UserFiles.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: UserFiles/test.dat"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length written to file (serialized length of data)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set to write into file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8603": "ERR_DATA_SERIALIZE", "16#8604": "ERR_FILE_WRITE_INIT", "16#8605": "ERR_FILE_WRITE"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}], "description_zh": "\n该函数块实现将数据作为二进制/序列化数据流写入文件的功能，并将文件存储在PLC的内存卡中的UserFiles文件夹中。它提供了执行文件写入操作、检查写入进度、获取错误状态和写入数据长度等功能。\\n\\n当输入信号“execute”上升沿触发时，函数块开始执行文件写入操作。写入操作包括以下步骤：\\n1. 初始化：检查文件路径和缓冲区边界，初始化文件句柄。\\n2. 参数处理：将数据序列化到缓冲区数组中。\\n3. 文件处理：将缓冲区数组中的数据写入文件。\\n\\n函数块提供以下输出：\\n- done：指示命令功能是否已成功完成。\\n- busy：指示函数块是否正在执行写入操作。\\n- error：指示在执行函数块期间是否发生错误。\\n- status：指示函数块的状态或错误识别。\\n- dataLength：指示写入文件的数据长度（数据的序列化长度）。\\n- diagnostics：提供有关块状态或错误发生的详细信息。\\n\\n函数块使用状态机来管理写入操作的不同阶段。它还提供错误处理机制，以处理在执行写入操作期间可能发生的各种错误。\n\n\n"}
{"title": "Unix Time to DTL Time Converter", "name": "LGF_UnixTimeToDTL", "description": "This function converts the Unix time of data type DInt to a date and time of data type DTL. The timestamp is calculated in UTC.", "type": "FUNCTION", "input": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error: 0 (error = true)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将数据类型为DInt的Unix时间戳转换为数据类型为DTL的日期时间值。转换的时间戳是基于UTC时间的，并且不考虑时区。该函数只接受1990年1月1日之后的时间。\n\n函数接受一个DInt类型的输入参数timeUnix，表示要转换的Unix时间戳。\n\n函数输出两个参数：\n- error (Bool): 表示在执行过程中是否发生错误。\n- status (Word): 表示函数的状态，用于错误识别。\n\n函数的返回值是一个DTL类型的时间，如果发生错误，则返回0 (error = true)。\n\n可能的状态代码如下：\n- 16#0000: STATUS_NO_ERROR，表示没有错误发生。\n- 16#6001: WARN_CONVERSION_LIMIT，表示时间戳刚好等于1990年1月1日的下限。\n- 16#8000: ERR_TIME_BEFORE_1990，表示时间戳在1990年1月1日之前。\n\n函数首先检查输入的Unix时间戳是否小于1990年1月1日。如果是，则设置错误标志并将状态码设置为ERR_TIME_BEFORE_1990，然后返回。\n\n接下来，函数计算日期部分，将Unix时间戳转换为天数，并使用DATE_TO_DTL函数将其转换为DTL日期。\n\n然后，函数计算时间部分，将剩余的秒数转换为小时、分钟和秒，并分别赋值给DTL时间的小时、分钟和秒字段。\n\n最后，函数设置输出参数error和status，并返回转换后的DTL时间。\n\n\n"}
{"title": "Fahrenheit to Kelvin Converter", "name": "LGF_FahrenheitToKelvin", "description": "This function converts a temperature value - from °Fahrenheit to °Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Kelvin"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将华氏温度转换为开尔文温度。函数接受一个实数类型的输入参数，表示华氏温度，并返回一个实数类型的输出参数，表示相应的开尔文温度。转换公式为：(°F - 32) × 5/9 + 273.15 = °K。其中，°F代表华氏温度，°K代表开尔文温度。\n\n\n"}
{"title": "2D distance calculation between points", "name": "LGF_CalcDistance_2D", "description": "The function calculates the distance between two points in the plane.", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算二维空间中两点之间的距离。函数接受四个输入参数：x1、y1表示第一个点的坐标，x2、y2表示第二个点的坐标。计算的距离是两点之间的直线距离，可以通过将两点的横坐标差和纵坐标差平方后相加，再开方得到。函数的返回值是一个LReal类型的距离值。\\n\\n示例：\\n假设第一个点的坐标为(3, 2)，第二个点的坐标为(6, 5)。函数计算得到的距离应为5。\n\n\n"}
{"title": "Matrix Comparator", "name": "LGF_MatrixCompare", "description": "This function compares two matrices of the data type ARRAY[*,*] of LREAL of equal size.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First Matrix"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second Matrix"}], "return_value": [{"type": "Bool", "description": "TRUE: Both matrices are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于比较两个相同大小的LREAL类型的二维数组（矩阵）。该函数将比较两个矩阵中的每个对应元素，如果所有元素都相等，则返回真（TRUE），表示两个矩阵相同；如果发现任何不匹配的元素，则立即返回假（FALSE）。此外，该函数还提供了错误标志和状态码输出，以便在矩阵维度不匹配时进行错误处理。状态码用于指示矩阵维度不匹配的具体情况，例如行或列的下界或上界不匹配。\n\n\n"}
{"title": "Ramp Function Generator", "name": "LGF_RampCI", "description": "Generates a speed curve based on an interpolation point table with linear interpolation.", "type": "FUNCTION_BLOCK", "input": [{"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "contStepNbr", "type": "Int", "description": "Number of the next interpolation point for continuing"}, {"name": "contStepTime", "type": "Time", "description": "Remaining time to continue to the interpolation point"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "start", "type": "Bool", "description": "Run down the interpolation point table"}, {"name": "hold", "type": "Bool", "description": "Freeze/hold output at actual value"}, {"name": "continue", "type": "Bool", "description": "Continuing"}, {"name": "cyclicOP", "type": "Bool", "description": "Repeat interpolation point table cyclically"}, {"name": "updateTime", "type": "Bool", "description": "Update time values"}, {"name": "reset", "type": "Bool", "description": "Complete reset of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output value"}, {"name": "actTimeTable", "type": "Bool", "description": "Interpolation point table will be edited"}, {"name": "stepNumber", "type": "Int", "description": "Current interpolation point number"}, {"name": "remainTime", "type": "Time", "description": "Remaining time until reaching the next interpolation point"}, {"name": "totalTime", "type": "Time", "description": "Total time for setpoint table"}, {"name": "remainTotalTime", "type": "Time", "description": "Total remaining time"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeRampTimeTable", "description": "Interpolation point table."}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_FURTHER_CALLS", "16#8200": "ERR_OB_UNAVAILABLE", "16#8201": "ERR_ARRAY_LOWER_BOUND", "16#8400": "ERR_QRY_CINT"}, "user_defined_types": [{"name": "LGF_typeRampTimeTable", "description": "Data type for setup a speed curve", "member": [{"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Setpoint Value to reach by the interpolation curve"}, {"name": "time", "type": "Time", "default": "T#0s", "description": "Time until the interpolation point is reached"}]}], "description_zh": "\n一个函数块FB，用于根据插值点表生成线性插值的速度曲线。该函数块可以处理启动、保持、继续、循环操作以及更新时间等功能。它接收一个包含设定值和达到该设定值所需时间的数组作为输入，并生成一个输出值，该值在设定的时间内线性变化。函数块还可以报告当前步骤编号、剩余时间、总时间、剩余总时间以及错误状态和状态代码。\n\n\n"}
{"title": "Unsigned Integer Histogram Calculation Function Block", "name": "LGF_Histogram_UDInt", "description": "The histogram shows the frequency distribution of a sample by class with unsigned integer values.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_UDInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算包含无符号整数（UDInt）数据系列的概率分布直方图。该直方图通过类（class）显示样本的频率分布。函数块接受一个布尔类型的执行信号（execute）和一个无符号整数类型（UInt）的类数量（numberOfClasses）作为输入。它还接受一个包含数据系列的数组（values）作为输入/输出参数。函数块的输出包括一个布尔类型的错误信号（error）、一个字类型的的状态（status）、一个字类型的子函数状态（subfunctionStatus）、一个包含相对频率和类中心的二维数组（histValues）、一个指定轴值的数组（axis）以及一个返回计算类宽度的实数（classWidth）。状态码包括执行完成、无调用的状态、第一次调用、Shell排序错误以及错误类数量等。该函数块使用了一个名为LGF_ShellSort_UDInt的Shell排序函数来进行数据排序，并根据排序后的数据计算直方图的相关参数。\n\n\n"}
{"title": "String Lower Case Converter", "name": "LGF_ToLower", "description": "This function converts the capital letters of a string into their lower case equivalents.", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，该函数能够将字符串中的所有大写字母转换为对应的小写字母。函数接受一个字符串作为输入参数，并返回转换后的字符串作为结果。\\n\\n示例：\\n假设输入字符串为\\\"Hello, World!\\\"，函数应返回字符串\\\"hello, world!\\\"作为转换结果。\n\n\n"}
{"title": "DInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_DInt", "description": "This function searches, in an array of the data type DInt, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "DInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于在DInt类型的数组中查找最小值和最大值，并返回这些值在数组中的索引。函数接受一个DInt类型的数组作为输入，并输出四个值：最小值、最小值索引、最大值和最大值索引。函数首先验证输入数组的上下界，然后从数组的第二个元素开始遍历，比较每个元素，记录下最小和最大值及其索引。最后，将找到的最小和最大值及其索引复制到输出参数中。\n\n\n"}
{"title": "Linear Scaler for Input Variable", "name": "LGF_ScaleLinear", "description": "This function scales an input variable (LReal) via a linear straight-line equation.", "type": "FUNCTION", "input": [{"name": "x", "type": "LReal", "description": "Input value `x` to be scaled"}, {"name": "x1", "type": "LReal", "description": "Point 1 (P1) -`x` coordinate of the linear function"}, {"name": "y1", "type": "LReal", "description": "Point 1 (P1) -`y` coordinate of the linear function"}, {"name": "x2", "type": "LReal", "description": "Point 2 (P2) -`x` coordinate of the linear function"}, {"name": "y2", "type": "LReal", "description": "Point 2 (P2) -`y` coordinate of the linear function"}, {"name": "yMin", "type": "LReal", "description": "Lower limit value of the output"}, {"name": "yMax", "type": "LReal", "description": "High limit value of the output"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Scaled output value `y`"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#6001": "WARN_Y_LIMITED_TO_YMIN", "16#6002": "WARN_Y_LIMITED_TO_YMAX", "16#8200": "ERR_LOW_LIM_OVER_UP_LIM"}, "user_defined_types": [], "description_zh": "\n该函数FC用于将输入变量（LReal类型）通过线性方程进行缩放。函数接受输入值x，以及线性函数的两个点坐标（x1, y1）和（x2, y2），还有输出y的最小值yMin和最大值yMax。函数将输入值x按照线性方程y = m*x + t进行缩放，其中m是斜率，t是截距。如果x1和x2的差值小于一个非常小的精度值PRECISION乘以x1的绝对值，则认为斜率接近于0，此时使用一个特殊情况的处理，即直接返回y1。缩放后的y值将被限制在yMin和yMax之间。如果y值超出了这个范围，函数将y值限制为yMin或yMax，并设置相应的状态码和错误标志。函数返回缩放后的输出值y，并输出状态码和错误标志。状态码用于指示是否发生了错误或警告，例如输出y值被限制在yMin或yMax。注意：ENO机制在这个函数中没有使用，强制设置为true。\n\n\n"}
{"title": "Rate of Change Limiter", "name": "LGF_LimRateOfChangeCI", "description": "Limits the rate of change of an input variable, turning a jump function into a ramp function.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "setChangeRate", "type": "LReal", "description": "Rate of change of ramp function"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "delayedValue", "type": "LReal", "description": "Output variable"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块限制输入变量的变化速率，将一个阶跃函数转换为斜坡函数。它接受一个输入信号（LReal类型），并限制其变化率，确保输出信号的变化不会超过设定的变化率。如果启用了默认输出值，则输出变量将被赋予默认值。函数块还处理OB调用，并读取OB的循环时间以进行计算。如果输入的变化率设置为负值，或者OB不可用，函数块将生成错误信息。最终，函数块将输出限制后的值，并可能报告错误状态。\n\n\n"}
{"title": "Polynomial Smoothing Function Block", "name": "LGF_SmoothByPolynomFB", "description": "This function calculates the smoothed values by polynomial cyclically using a 3rd degree polynomial.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a smoothed value."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块通过使用三阶多项式对输入值进行循环平滑处理。它接受一个布尔型使能输入（enable）和一个插入信号（insert），当插入信号发生上升沿时，输入的数值（value）将被存储，并在存储了五个数值后计算出平滑后的数值（smoothedValue）。\\n\\n状态码：\\n16#7000：STATUS_NO_CALL：函数块等待通过参数`enable`激活。\\n16#7001：STATUS_FIRST_CALL：使能后第一次调用FB。\\n16#7002：STATUS_SUBSEQUENT_CALL：处理活动，后续调用FB。\\n16#7010：STATUS_NOT_ENOUGH_VALUES：函数块需要五个（5）个值来计算平滑值。\\n\\n函数块使用一个数组来存储输入值，并在每次插入信号发生上升沿时更新这个数组。当数组中存储了足够的值时，它将计算出一个平滑值，并输出。如果发生错误，函数块将设置错误输出（error）并返回相应的状态码（status）。\n\n\n"}
{"title": "Kelvin to Fahrenheit Converter", "name": "LGF_KelvinToFahrenheit", "description": "This function converts a temperature value - from °Kelvin to °Fahrenheit.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Fahrenheit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将温度值从开尔文（°Kelvin）转换为华氏温度（°Fahrenheit）。转换公式为：华氏温度 = （开尔文温度 - 273.15）* 1.8 + 32。其中，273.15是水的冰点在开尔文温标下的值，1.8是华氏温度和开尔文温度的比例系数，32是华氏温度的偏移量。\\n\\n示例：\\n假设输入的开尔文温度为300K，则转换后的华氏温度为80.33°F。\n\n\n"}
{"title": "Temperature Unit Converter", "name": "LGF_ConvertTemperature", "description": "This function converts a temperature value from one into another unit by using an appropriate given mode parameter.", "type": "FUNCTION", "input": [{"name": "mode", "type": "Int", "description": "Conversion mode"}, {"name": "value", "type": "Real", "description": "Temperature value to be converted"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature result"}], "status_codes": {"16#8200": "ERR_WRONG_MODE"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据给定的模式参数，将温度值从一个单位转换为另一个单位。支持以下转换模式：\\n\\n1. 从摄氏度转换为华氏度\\n2. 从华氏度转换为摄氏度\\n3. 从摄氏度转换为开尔文\\n4. 从开尔文转换为摄氏度\\n5. 从华氏度转换为开尔文\\n6. 从开尔文转换为华氏度\\n7. 从兰金转换为开尔文\\n8. 从开尔文转换为兰金\\n\\n如果给定的模式参数不正确，函数将返回错误状态ERR_WRONG_MODE。\n\n\n"}
{"title": "LIFO Buffer Management", "name": "LGF_LIFO", "description": "LIFO (Last-In First-Out / Stack buffer memory) This function stores incoming data and outputs the latest/most recent not-yet-processed data.", "type": "FUNCTION_BLOCK", "input": [{"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value initialItem (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: 0 / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_LAST_ENTRY", "16#8612": "ERR_POP_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，实现了一个后进先出（LIFO）堆栈缓冲区的管理。该函数块可以存储传入的数据，并输出最新/最近未被处理的数据。\n\n该函数块支持以下操作：\n1. 入栈操作（push）：将一个元素添加到堆栈的顶部。\n2. 出栈操作（pop）：从堆栈顶部移除一个元素，并返回该元素的值。\n3. 堆栈查看操作（peek）：查看堆栈顶部的元素，但不从堆栈中移除它。\n4. 重置操作（reset）：初始化堆栈缓冲区（重置索引和计数器）。\n5. 清除操作（clear）：清除堆栈缓冲区，并用初始值initialItem初始化它（重置索引和计数器）。\n\n该函数块还提供了一些输出参数，以便用户可以了解堆栈缓冲区的状态，例如：\n- error：在执行FB期间是否发生错误\n- status：FB的状态，错误识别\n- subFunctionStatus：调用FB、FC和系统块的返回值或状态\n- elementCount：堆栈缓冲区中的元素数量\n- isEmpty：堆栈缓冲区是否为空\n\n该函数块使用了一个变体数组作为堆栈缓冲区，因此可以存储任何数据类型的数据。\n\n\n"}
{"title": "Pulse Generator", "name": "LGF_Impulse", "description": "This function generates pulses at a given frequency. The pulse is always present for one (control) cycle.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}], "output": [{"name": "impulse", "type": "Bool", "description": "Impulse signal output"}, {"name": "countdown", "type": "Time", "description": "Time until next pulse"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块FB能够生成具有给定频率的脉冲信号。脉冲信号在每个控制周期内持续一个周期。如果输入的频率小于或等于0，则脉冲发生器被禁用，输出脉冲信号为假，倒计时时间为0。如果输入频率大于0，则FB会根据输入频率计算脉冲周期，并在每个周期内输出一个脉冲信号。同时，FB还会计算并输出下一个脉冲信号产生之前的时间（倒计时）。使用的计时器是自重启计时器，其时间由输入频率计算得出。输出包括脉冲信号（impulse）和倒计时时间（countdown）。\n\n\n"}
{"title": "CRC-8 Calculator", "name": "LGF_CalcCRC8", "description": "The function LGF_CalcCRC8 uses 8 bits as the generator polynomial (mask) for CRC calculation.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n该函数LGF_CalcCRC8实现了CRC-8算法，用于计算一个数据流（数组）的循环冗余校验（CRC）值。函数使用8位生成多项式（掩码）进行CRC计算。用户可以指定计算的起始值（initValue）、生成多项式（mask）以及要参与计算的数据元素数量（noOfElements）。函数会遍历输入数组，对每个字节执行CRC计算，并返回最终的CRC值。如果指定的元素数量超出数组实际大小，函数会设置错误标志并返回错误状态码ERR_NO_OF_ELEMENTS (16#8400)。否则，函数会成功执行并返回计算出的CRC值，状态码为STATUS_NO_ERROR (16#0000)。\n\n\n"}
{"title": "4-Byte to DWord Merger", "name": "LGF_MergeBytesToDWord", "description": "This function merge 4 Byte variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "byte3", "type": "Byte", "description": "Input Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Input Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Input Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Byte sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC将四个单字节数据（byte3、byte2、byte1、byte0）合并成一个双字（DWord）数据。在合并过程中，byte3作为最高字节（MSB），byte0作为最低字节（LSB）。函数不对输入数据进行错误处理，假设输入数据总是有效的。\n\n\n"}
{"title": "Advanced CRC-32 Calculator", "name": "LGF_CalcCRC32Advanced", "description": "The function uses 32 bits as the generator polynomial (mask) and additional parameters for CRC calculation.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "DWord", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数根据CRC-32算法计算输入数据流的循环冗余校验（CRC）值。该函数支持多种参数，包括初始值、掩码（生成多项式）、最终异或值、输入/输出反射标志以及要用于CRC计算的数据元素数量。函数会检查输入数据元素的数量是否超出数组的大小，并在计算过程中根据需要反射输入字节和/或结果。最终计算出的CRC值可以与最终异或值进行异或操作。函数返回计算出的CRC值，并设置错误标志和状态代码以指示计算过程中是否存在错误。\n\n\n"}
{"title": "2-Word to DWord Merger", "name": "LGF_MergeWordsToDWord", "description": "This function merge 2 Word variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "word1", "type": "Word", "description": "Input Word 1 - MSB"}, {"name": "word0", "type": "Word", "description": "Input Word 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Word sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数\"LGF_MergeWordsToDWord\"将两个单字（Word）类型的输入变量合并成一个双字（DWord）类型的输出变量。其中，输入变量word1作为合并后的双字的高位字（MSB），输入变量word0作为合并后的双字的低位字（LSB）。函数不进行错误处理，因此ENO始终为TRUE。函数通过直接赋值操作完成两个单字到双字的合并。\n\n\n"}
{"title": "String Upper Case Converter", "name": "LGF_ToUpper", "description": "This function converts the lowercase letters of a string into their capital equivalents.", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数将输入字符串中的所有小写字母转换为大写字母。函数接受一个字符串作为输入参数，并返回转换后的字符串。函数不处理非字母字符，它们保持不变。\n\n\n"}
{"title": "German public holiday detection", "name": "LGF_IsGermanHoliday", "description": "The function determines whether a given date is a public holiday. All public holidays in Germany are taken into account.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date, which has to be evaluated"}, {"name": "threeKings", "type": "Bool", "description": "Three Kings"}, {"name": "roseMonday", "type": "Bool", "description": "Rose Monday"}, {"name": "ascension", "type": "Bool", "description": "Ascension"}, {"name": "corpusChristi", "type": "Bool", "description": "Corpus Christi"}, {"name": "augsburgerFriedensfest", "type": "Bool", "description": "Augsburger Friedensfest"}, {"name": "assumptionOfMary", "type": "Bool", "description": "Assumption Of Mary"}, {"name": "reformationDay", "type": "Bool", "description": "Reformation Day"}, {"name": "allSaintDay", "type": "Bool", "description": "All Saint Day"}, {"name": "bussUndBettag", "type": "Bool", "description": "Day of Prayer and Repentance (Buss und Bettag)"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "If the date at the input parameter is a public holiday - returning TRUE, otherwise returning FALSE"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数用于判断给定的日期是否为德国的公共假日。该函数考虑了德国所有的公共假日，包括一些区域性的假日，这些区域性的假日可以通过输入参数选择性地启用或禁用。\\n\\n函数首先计算给定日期距离当年1月1日的天数，然后计算当年复活节星期日的日期，并基于这两个计算结果判断给定日期是否为公共假日。\\n\\n示例：\\n假设输入日期为2023年10月3日，所有的区域性假日参数都设置为TRUE。\\n函数应返回TRUE，因为2023年10月3日是德国的统一日，是德国的公共假日。\n\n\n"}
{"title": "数字位分离显示", "description": "在一些自动化系统中，可能需要将一个整数的各个位分离出来，以便于显示或进一步处理。例如，在一些计数器或生产计数应用中，需要将当前的计数值分离成个位、十位、百位和千位。\n控制要求：\n系统需要接收一个最多四位整数作为输入。\n根据输入的整数，计算并输出其个位、十位、百位和千位数值。\n如果输入的整数少于四位，则在缺失的高位上显示0。\n输出结果应该是四个独立的整数，分别代表个位、十位、百位和千位。\n说明：\n1. 要求输入的整数InputNumber大于等于0且小于10000，否则输出错误状态error=true和错误代码status=16#8001。\n2. 在计算出个、十、百、千这四个数位的数值后，对这四个数位值中非0的值进行比较并输出最小值到Min；如果InputNumber=0，则输出Min=0。", "type": "FUNCTION_BLOCK", "name": "FB_SplitNumber", "input": [{"name": "InputNumber", "type": "Int", "description": "四位整数输入"}], "output": [{"name": "Thousands", "type": "Byte", "description": "千位数值输出"}, {"name": "Hundreds", "type": "Byte", "description": "百位数值输出"}, {"name": "Tens", "type": "Byte", "description": "十位数值输出"}, {"name": "Ones", "type": "Byte", "description": "个位数值输出"}, {"name": "Min", "type": "Byte", "description": "四个数位中的非0最小值"}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}]}
{"title": "DWord to 2-Word Splitter", "name": "LGF_SplitDWordToWords", "description": "This function splits a DWord variable into 2 Word variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "word1", "type": "Word", "description": "Output Word 1 - MSW"}, {"name": "word0", "type": "Word", "description": "Output Word 0 - LSW"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数\"LGF_SplitDWordToWords\"将一个双字（DWord）类型的输入变量分割成两个单字（Word）类型的输出变量。输入的双字变量包含一个32位的位序列，该函数将其分为两个16位的部分。输出的第一个单字（word1）包含双字的高16位（即Most Significant Word，MSW），而输出的第二个单字（word0）包含双字的低16位（即Least Significant Word，LSW）。这个函数没有错误处理，因为它认为分割操作总是成功的。\n\n\n"}
{"title": "DInt range random number generation", "name": "LGF_Random_DInt", "description": "This function generates a random value with each call.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random number in the DInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数在每次调用时生成一个范围为DInt的随机数。函数通过读取系统时间来生成随机数，并使用系统时间的纳秒部分来创建一个随机的起始值。然后，这个起始值通过位操作转换为一个DInt范围内的随机数。如果读取系统时间时出现错误，函数将返回一个错误标志和状态码。状态码16#0000表示函数执行没有错误，16#8600表示读取系统时间时出现错误。\n\n\n"}
{"title": "DInt to String Converter", "name": "LGF_IntToString", "description": "This function converts a variable of the data type DInt into a variable of the data type String.", "type": "FUNCTION", "input": [{"name": "value", "type": "DInt", "description": "Double-Integer value to convert"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Converted value as string. Example: '+16927'"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将32位有符号整型数（DInt）转换为字符串形式。函数接受一个DInt类型的输入值，并返回一个字符串，该字符串表示输入整数的文本形式，包括正负号。例如，输入值为123，则返回字符串\\\"123\\\"；输入值为-456，则返回字符串\\\"-456\\\"。\n\n\n"}
{"title": "Natural number factorial calculation", "name": "LGF_GetFactorial", "description": "The function calculates the faculty of a natural number (ℕ!) and returns the result.", "type": "FUNCTION", "input": [{"name": "naturalNumber", "type": "Int", "description": "Natural number (0..12)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Calculated factorial"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8101": "ERR_WRONG_VALUE_RANGE"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数计算自然数（0到12之间）的阶乘，并返回计算结果。函数能够处理输入值在0到12之间的自然数，如果输入值超出这个范围，函数将返回一个错误状态。阶乘的计算是通过预定义的常量来实现的，这些常量对应于0到12的阶乘值。函数的输出包括计算结果以及一个错误指示，如果输入值在有效范围内，则错误指示为FALSE，否则为TRUE。\n\n\n"}
{"title": "Odd Parity Checker for DWord", "name": "LGF_IsParityOdd", "description": "The function checks whether the parity of the input variable of type DWord is odd.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is odd"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数用于检查一个双字（DWord）类型输入变量的奇偶性。函数通过计算输入变量中置为`TRUE`的位数，如果位数是奇数，则返回`TRUE`。函数使用位操作来高效地计算奇偶性，避免了逐位检查的繁琐过程。函数不使用ENO机制，因为在执行过程中不可能产生错误。\n\n\n"}
{"title": "GPS-based Sunrise and Sunset Time Determination", "name": "LGF_AstroClock", "description": "This function calculates the times of sunrise and sunset based on the local time for a specific place on Earth.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and sunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at `isDaytime`, negative time allowed)"}, {"name": "positionGps", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at `isDaytime`, negative time allowed)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between “sunrise” and “sunset”"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_IN_OPERATION", "16#8204": "ERR_LATITUDE_VALUE", "16#8205": "ERR_LONGITUDE_VALUE", "16#8601": "ERR_RD_SYS_T", "16#8602": "ERR_RD_LOC_T"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees. For a whole GPS Data set.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places (Unit: degree decimal), North = positive; South = negative) valid value range [-90.00000..90.00000] "}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude with decimal places (Unit: degree decimal), East = positive; West = negative) valid value range [-180.00000..180.00000] "}]}], "description_zh": "\n该函数块FB用于根据地球上一个特定位置的本地时间计算日出和日落的时间。它接受GPS位置信息，并可以添加自定义的日出和日落时间偏移。FB将输出有效的计算结果，并指示是否处于白天时间。\n\n输入参数包括：\n- enable：激活FB的功能\n- positionGps：用于计算日出和日落时间的GPS位置\n- offsetSunrise：日出时间偏移（加到日出时间上）\n- offsetSunset：日落时间偏移（加到日落时间上）\n\n输出参数包括：\n- valid：输出值有效\n- busy：FB正在执行计算\n- error：执行过程中是否发生错误\n- status：FB的状态或错误代码\n- subFunctionStatus：调用FB、FC或系统块的状态或返回值\n- actualLocalTime：当前本地时间\n- sunriseTime：日出时间\n- sunsetTime：日落时间\n- isDaytime：当前控制器本地时间是否在日出和日落之间\n\nFB首先检查输入的经纬度值是否在有效范围内，然后根据这些值和系统时间计算日出和日落时间。如果输入值无效，FB将输出错误状态。如果计算成功，FB将输出有效的日出、日落时间和当前是否为白天。\n\n注意：该FB假设系统时间已经与UTC时间同步，并且没有使用ENO机制进行错误处理。\n\n\n"}
{"title": "Sawtooth Signal Profile Generator", "name": "LGF_SawTooth", "description": "Generates a sawtooth-shaped signal profile with a defined number of steps.", "type": "FUNCTION_BLOCK", "input": [{"name": "startValue", "type": "Int", "description": "0"}, {"name": "timeRange", "type": "Time", "description": "T#0s"}, {"name": "incrementRange", "type": "Int", "description": "0"}, {"name": "numberSteps", "type": "Int", "description": "0"}, {"name": "endlessSteps", "type": "Bool", "description": "FALSE"}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Int", "description": "Current value of the sawtooth signal."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成具有定义步数的锯齿形信号配置文件。输入参数包括起始值（startValue）、时间范围（timeRange）、增量范围（incrementRange）、步数（numberSteps）、是否无限循环（endlessSteps）以及重置信号（reset）。输出参数为当前锯齿信号的值（value）。\\n\\n当第一次调用函数块或接收到重置信号时，函数块将初始化所有静态值。如果定时器完成且没有重置信号，函数块将计算新的值，并增加步数计数器。如果步数未达到定义值，函数块将继续生成锯齿信号；如果步数达到定义值，则重启并从起始值开始生成锯齿信号。如果设置为无限循环，步数计数器将被重置。最后，函数块将当前值写入输出参数，并结束执行。\n\n\n"}
{"title": "Advanced CRC-16 Calculator", "name": "LGF_CalcCRC16Advanced", "description": "The function calculates the CRC value with additional parameters for error detection at data transmission.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Word", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n该函数FC根据CRC-16高级算法计算数据的循环冗余校验（CRC）值。函数支持多种参数，包括初始化值、掩码、最终异或值、输入输出反转标志以及要计算元素的数量。函数可以处理输入数组中的字节，并返回计算出的CRC值。如果指定的元素数量超出数组大小，函数将设置错误标志并返回错误状态代码。在计算过程中，函数会对输入字节进行位反转（如果reflectInput为真），并在每次迭代中将字节移位到CRC的最高有效位。然后，函数使用掩码进行除法运算，并通过异或函数计算CRC值。最后，如果reflectResult为真，函数会对计算出的CRC值进行位反转，并使用finalXorValue进行最终异或操作。函数不使用ENO机制，因为没有错误处理。\n\n\n"}
{"title": "DWORD falling edge counting", "name": "LGF_CountFalInDWord", "description": "The function analyzes a variable of the type DWORD and outputs how often a 1-0 sequence (falling edge) occurs in the variable.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the falling edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of falling edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块用于分析和统计DWORD类型变量中1-0序列（即下降沿）出现的次数。函数块将输出下降沿的总数。\\n\\n示例：\\n假设输入的DWORD值为2#1010111100111110，则下降沿的数量为4。\\n\\n注意：\\n1. 该函数块不使用ENO机制，因此ENO被强制设置为真。\\n2. 该函数块不执行错误处理。\n\n\n"}
{"title": "Device Activation and Deactivation State Machine", "name": "LGF_ActDeactDevice", "description": "Implements a state machine to activate and monitor or deactivate decentral devices.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enable functionality of FB"}, {"name": "activate", "type": "Bool", "description": "Rising edge: Activate device given by `hwId`"}, {"name": "deactivate", "type": "Bool", "description": "Rising edge: Deactivate device given by `hwId`"}, {"name": "hwId", "type": "HW_DEVICE", "description": "Hardware ID of the device which should be activated / deactivated"}, {"name": "parameter", "type": "LGF_typeActDeactDeviceParameter", "description": "Parameter dataset for the function `LGF_ActDeactDevice`"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification"}, {"name": "activating", "type": "Bool", "description": "Activation of device active"}, {"name": "isActivated", "type": "Bool", "description": "Device activated"}, {"name": "deactivating", "type": "Bool", "description": "Deactivating of device active"}, {"name": "isDeactivated", "type": "Bool", "description": "Device deactivated"}, {"name": "deviceStateOK", "type": "Bool", "description": "Device is activated and connected to IO-System"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#8600": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine", "16#8601": "ERR_LOG2GEO / ERR_GEO2LOG: Log2Geo or Geo2Log error, check diagnostics for more info", "16#8640": "ERR_DEVICE_DEACTIVATING: Error during device deactivation", "16#8641": "ERR_DEVICE_DEACTIVATING_TIME_OUT: Deactivation timeout error", "16#8660": "ERR_DEVICE_ACTIVATING: Error during device activation", "16#8661": "ERR_DEVICE_ACTIVATING_TIME_OUT: Activation timeout error", "16#8662": "ERR_READ_DEVICES_STATES_DURING_ACTIVATION: Error: Read Device states (DeviceStates) during device activation", "16#8670": "ERR_READ_DEVICES_STATES_WHILE_ACTIVE:Error: Read Device states (DeviceStates) while device active", "16#8671": "ERR_DEVICE_STATE_WHILE_ACTIVE: Device states present error and is unreachable, faulty Device or IO-System", "16#8672": "ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE:Activation state (D_ACT_DP) of device is wrong", "16#8690": "ERR_DISABLING_DEACT_DEVICE: Deactivation (D_ACT_DP) of device throws an error while disabling", "16#8691": "ERR_DISABLING_WATCHDOG:Watchdog timer expired while disabling"}, "user_defined_types": [{"name": "LGF_typeActDeactDeviceParameter", "description": "UDT for configuring the behavior of the activation and deactivation process.", "member": [{"name": "timeOutActDeact", "type": "Time", "default": "T#2500ms", "description": "Time to monitor activation and deactivation commands"}, {"name": "timeOutStateMonitoring", "type": "Time", "default": "T#100ms", "description": "Time to monitor device state"}, {"name": "enableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during startup"}, {"name": "enableAndActivate", "type": "Bool", "default": "FALSE", "description": "Enable device during startup"}, {"name": "disableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during module disabling"}]}, {"name": "LGF_typeDiagnostics", "description": "UDT for diagnostic information from blocks.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the block or error identification"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine where error occurred"}]}], "description_zh": "\n\n一个函数块FB，用于实现一个状态机，该状态机能够激活和监控或停用分布式设备。状态机处理以下操作：\\n\\n1. 启用和禁用FB功能。\\n2. 激活或停用由`hwId`指定的设备。\\n3. 监控设备状态，包括连接状态和错误状态。\\n\\n状态机具有以下状态：\\n\\n* FB_STATE_NO_PROCESSING：无处理状态\\n* FB_STATE_ENABLING_START：启用开始状态\\n* FB_STATE_ENABLING_WAIT：启用等待状态\\n* FB_STATE_DEACTIVATE_START：停用开始状态\\n* FB_STATE_DEACTIVATE_WAIT：停用等待状态\\n* FB_STATE_DEACTIVATED：已停用状态\\n* FB_STATE_ACTIVATE_START：激活开始状态\\n* FB_STATE_ACTIVATE_WAIT：激活等待状态\\n* FB_STATE_ACTIVATED：已激活状态\\n* FB_STATE_DISABLING_START：禁用开始状态\\n* FB_STATE_DISABLING_WAIT：禁用等待状态\\n\\n函数块还处理以下错误：\\n\\n* ERR_UNDEFINED_STATE：状态机中的状态未定义\\n* ERR_LOG2GEO / ERR_GEO2LOG：Log2Geo或Geo2Log错误\\n* ERR_DEVICE_DEACTIVATING：设备停用过程中发生错误\\n* ERR_DEVICE_DEACTIVATING_TIME_OUT：设备停用超时错误\\n* ERR_DEVICE_ACTIVATING：设备激活过程中发生错误\\n* ERR_DEVICE_ACTIVATING_TIME_OUT：设备激活超时错误\\n* ERR_READ_DEVICES_STATES_DURING_ACTIVATION：设备激活期间读取设备状态错误\\n* ERR_READ_DEVICES_STATES_WHILE_ACTIVE：设备激活时读取设备状态错误\\n* ERR_DEVICE_STATE_WHILE_ACTIVE：设备状态错误且无法访问，设备或IO系统故障\\n* ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE：设备激活状态错误\\n* ERR_DISABLING_DEACT_DEVICE：禁用设备时发生错误\\n* ERR_DISABLING_WATCHDOG：禁用设备时看门狗定时器超时\n\n\n"}
{"title": "配方管理系统", "description": "某工厂的生产线需要根据不同的配方生产多种产品。生产线的控制中心需要一个配方管理系统，允许操作员添加、删除、修改和查询配方数据。\n控制要求：\n配方数据应包括配方编号、原料类型、原料比例和生产温度。\n系统应允许输入新的配方数据，并将其存储在配方数据库中。\n系统应允许通过配方编号删除或修改现有的配方数据。\n系统应允许通过配方编号查询配方详情，并输出该配方。\n说明：\n1. 配方以结构体Struct数据类型构建，结构体内包括配方编号recipeID、原料类型ingredientType、原料比例ingredientRatio和生产温度productionTemperature。配方数据库最多可以存放10条配方，以数组Array[1..10] of Struct构建，配方编号不能重复，配方编号=0表示该位置空闲。\n2. 当触发查询配方请求信号queryRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8001。如果存在该编号，则把该条配方输出到配方查询结果recipeQueryResult。\n3. 当触发添加配方请求信号addRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果存在重号，则输出错误状态error=true和错误代码status=16#8002。如果配方数据库recipe中没有空余位置，则输出错误状态error=true和错误代码status=16#8003。如果不存在这些错误，则把输入配方recipeIn存入配方数据库recipe，优先存入数组编号小的空闲位置。\n4. 当触发删除配方请求信号deleteRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8004。如果存在该编号，则删除该配方，即把配方数据库recipe中的该条配方编号recipeID置为0。\n5. 当触发修改配方请求信号modifyRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8005。如果存在该编号，则把该条配方替换为输入配方recipeIn。", "type": "FUNCTION_BLOCK", "name": "FB_RecipeManager", "input": [{"name": "addRecipe", "type": "Bool", "description": "添加配方请求信号"}, {"name": "deleteRecipe", "type": "Bool", "description": "删除配方请求信号"}, {"name": "modifyRecipe", "type": "Bool", "description": "修改配方请求信号"}, {"name": "queryRecipe", "type": "Bool", "description": "查询配方请求信号"}, {"name": "recipeIn", "type": "Struct", "description": "输入配方", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}], "output": [{"name": "recipeAdded", "type": "Bool", "description": "配方添加成功指示"}, {"name": "recipeDeleted", "type": "Bool", "description": "配方删除成功指示"}, {"name": "recipeModified", "type": "Bool", "description": "配方修改成功指示"}, {"name": "recipeQueryResult", "type": "Struct", "description": "配方查询结果输出", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "recipe", "type": "Array[1..10] of Struct", "description": "配方数据库", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}]}
{"title": "Value tolerance range check", "name": "LGF_IsValueInTolerance", "description": "The function checks whether a value is within a defined value range with a tolerance in percent.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "tolerance", "type": "LReal", "description": "Tolerance range around the set point in percent"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the value exceeds the upper limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE if the value is below the lower limit"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if the value is in the value range"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": [], "description_zh": "\n该函数用于检查一个给定的值是否位于设定点的容忍范围内。设定点是参考值，容忍范围是相对于设定点的百分比。函数会计算上限和下限，并根据输入值判断是否超出这些界限。\\n\\n如果输入值大于上限或小于下限，函数将返回false，表示输入值不在容忍范围内。同时，函数还会输出一个标志，指示输入值是超出了上限还是低于下限。如果输入值在容忍范围内，函数将返回true。\\n\\n状态码：\\n16#0000：执行没有出错\\n16#8401：输入值超出设定范围\n\n\n"}
{"title": "International Date String to DTL Converter", "name": "LGF_StringToDTL_ISO", "description": "This function converts a character string in international format with date components into the data type DTL.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_JOB", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将符合国际格式（YYYY-MM-DD HH:mm:ss.nnnnnnnnn）的日期时间字符串转换为DTL类型。函数接受一个字符串输入，并根据分隔符将字符串分割成年、月、日、时、分、秒和纳秒等部分。然后，函数将这些部分转换为对应的数值，并检查它们是否在有效的范围内。如果输入字符串的格式正确，函数将返回一个包含转换后的日期和时间的DTL值。如果输入字符串的格式错误，函数将返回一个错误状态和相应的错误代码。此外，函数还输出一个布尔类型的错误标志，指示是否发生了错误。\n\n\n"}
{"title": "Shell Sort for DInt Arrays", "name": "LGF_ShellSort_DInt", "description": "This block sorts an array of type DInt with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块使用希尔排序算法对DInt类型的数组进行排序。数组可以包含任意数量的元素（最多1000个），并且可以根据参数选择升序或降序排序。排序后的数组将覆盖原始数组。\\n\\n示例：\\n假设有一个数组[5, 3, 1, 4, 2]，并且我们选择升序排序。\\n排序后的数组将是[1, 2, 3, 4, 5]。\n\n\n"}
{"title": "Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax", "description": "This function searches, in an array of the data type DInt, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}], "output": [{"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE", "16#8202": "ERR_NOT_EQUAL_TYPES", "16#8203": "ERR_MOVE_BLK_VARIANT"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数在一个DInt类型的数组中搜索最大值和最小值，并返回这些值在数组中的相应索引。函数接受一个Variant类型的数组作为输入，并输出最小值、最小值索引、最大值和最大值索引。如果输入不是数组或者数组元素类型与输出变量类型不匹配，函数将设置错误标志并返回相应的状态代码。函数支持多种数据类型，包括Int、UInt、DInt、UDInt、USInt、SInt、Real和LReal。如果MOVE_BLK_VARIANT子函数在复制值时出现错误，函数也会报告错误。\n\n\n"}
{"title": "TADDR_Param to String Converter", "name": "LGF_TaddrToString", "description": "The function converts a TADDR_Param system data type variable to a String data type variable.", "type": "FUNCTION", "input": [{"name": "ipAdressTaddr", "type": "TADDR_Param", "description": "IP-Address and Port number to convert into string"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "IP-Address and Port number as string"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将系统数据类型为TADDR_Param的变量转换为字符串数据类型。TADDR_Param包含了IP地址和端口号，函数将这两个部分连接起来，形成一个字符串输出。字符串格式为IP地址部分（四个十进制数，每部分之间用点分隔），如果存在端口号，则紧接着是一个冒号和端口号。注意，IP地址的每个部分如果小于10，前面不会补0。如果端口号为0，则不会在字符串中包含端口号部分。\\n\\n示例：\\n假设输入的TADDR_Param变量包含IP地址为192.168.1.1，端口号为8080。\\n函数应返回字符串\\\"192.168.1.1:8080\\\"作为转换结果。\n\n\n"}
{"title": "Numeric Differentiation Function", "name": "LGF_DifferenceQuotientFC", "description": "This function numerically differentiates a signal sampled equidistantly in time.", "type": "FUNCTION", "input": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_DELTA_T Error: Delta time `deltaT` must not be zero.", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": [], "description_zh": "\n该函数FC用于计算等时间间隔采样信号的一阶导数。函数接受一个LReal类型的输入参数deltaT，表示两个测量值之间的等距时间间隔。它还接受两个数组类型的输入/输出参数：values和derivatedValues。values数组包含将要进行微分的信号值，而derivatedValues数组将用于存储微分后的结果。\n\n函数执行时，首先检查输入数组的大小是否相等，以及是否至少包含4个元素，因为微分计算需要至少4个数据点。如果数组大小不匹配或元素数量不足，函数将返回错误状态。\n\n如果输入参数deltaT为0，函数也会返回错误状态，因为这将导致除以零的情况。\n\n如果所有检查都通过，函数将使用中心差分法计算信号的一阶导数，并将结果存储在derivatedValues数组中。计算公式考虑了数组边界的情况，并对边界点使用了特殊的差分公式。\n\n函数执行结束后，如果没有错误发生，将设置error输出为FALSE，status输出为STATUS_FINISHED_NO_ERROR状态码。如果发生错误，error输出将被设置为TRUE，并根据错误类型设置相应的status状态码。\n\n由于ENO机制未使用，函数强制将ENO设置为TRUE。\n\n\n"}
{"title": "Kelvin to Celsius Converter", "name": "LGF_KelvinToCelsius", "description": "This function converts a temperature value - from °Kelvin to °Celsius.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Celsius"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将温度值从开尔文（°Kelvin）转换为摄氏度（°Celsius）。该函数接受一个实数类型的输入参数，表示温度值（以开尔文为单位），并返回一个实数类型的输出参数，表示转换后的温度值（以摄氏度为单位）。转换公式为：摄氏度 = 开尔文 - 273.15。该函数不处理任何错误，并且不需要错误处理。\n\n\n"}
{"title": "Advanced CRC-8 Calculator", "name": "LGF_CalcCRC8Advanced", "description": "The function uses 8 bits as the generator polynomial (mask) and additional parameters for CRC calculation.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Byte", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据CRC-8高级算法进行CRC计算。该函数接受初始值、掩码、最终异或值、输入/输出反射标志以及要用于CRC计算的数据元素数量作为参数。函数计算输入数组（array）的CRC值，并支持位反射功能。最终计算出的CRC值可以与最终异或值进行异或操作，并可以选择是否对结果进行位反射。函数会检查提供的元素数量是否超出数组大小，并在发生错误时设置错误标志和状态码。最终返回计算出的CRC值。\n\n\n"}
{"title": "Profinet Interface Parameter Reader", "name": "LGF_ReadPnInterfaceParameter", "description": "Provides interface parameters such as IP Address, MAC Address, and PN Name.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "hardwareId", "type": "HW_ANY", "description": "Hardware ID of the Interface where the parameter should be read"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished, new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "DWord", "description": "Status of the FB and error identification"}, {"name": "address", "type": "IP_V4", "description": "IP Address from interface"}, {"name": "subnetMask", "type": "IP_V4", "description": "Subnet mask from interface"}, {"name": "standardGateway", "type": "IP_V4", "description": "Standard gateway address from interface"}, {"name": "macAddress", "type": "Array[0..5] of Byte", "description": "MAC Address from interface"}, {"name": "pnName", "type": "String", "description": "Profinet name from interface"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#9000": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于读取Profinet接口的参数，包括IP地址、子网掩码、默认网关、MAC地址和PN名称。当触发输入execute时，FB将开始执行读取操作。FB使用状态机来管理读取过程，包括读取记录和处理记录两个状态。在读取记录状态，FB将调用一个子函数块RDREC来读取接口参数。在处理记录状态，FB将解析读取到的记录并更新输出参数。当操作完成时，FB将设置输出参数done为TRUE，表示操作成功完成。如果过程中发生错误，FB将设置输出参数error为TRUE，并返回错误状态。状态代码用于表示FB的执行状态和错误信息。\n\n\n"}
{"title": "DWord to 4-Byte Splitter", "name": "LGF_SplitDWordToBytes", "description": "This function splits a DWord variable into 4 Byte variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "byte3", "type": "Byte", "description": "Output Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Output Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Output Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC将一个双字（DWord）类型的变量分割成4个字节（Byte）类型的变量。输入的双字变量包含32位信息，该函数将这32位分成4组，每组8位，分别存储在4个输出字节变量中。输出的字节变量分别为：byte3（最高字节，即最左边的8位），byte2（次高字节），byte1（次低字节），和byte0（最低字节，即最右边的8位）。\\n\\n示例：\\n假设输入的双字变量值为2#101011112233445566778899AABBCCDDEEFF，那么输出应为：\\nbyte3 = 2#10101111\\nbyte2 = 2#12233445\\nbyte1 = 2#56677889\\nbyte0 = 2#AABBCCDD\n\n\n"}
{"title": "浮点数区间线性化转换", "description": "在一些自动化控制系统中，可能需要将一个物理量（如温度、压力等）的测量值转换为另一个线性化或标准化的值，以便于控制算法的处理或显示。例如，一个传感器测量的物理量可能在特定的非线性区间内变化，但控制系统需要一个线性化的值来进行计算。\n控制要求：\n系统需要接收一个浮点数作为输入，表示原始测量值。\n根据输入值的大小，将其转换到不同的线性区间，输出转换后的线性化值。\n当输入值在1200到3600之间，则转换到150到240之间。\n当输入值在3600到4800之间，则转换到240到560之间。\n当输入值在4800到7000之间，则转换到560到720之间。\n如果输入值小于1200或大于7000，则转换后的值应为1200或7000对应的线性化值，并输出错误状态error=1，status=16#8001。", "type": "FUNCTION_BLOCK", "name": "FB_LinearizeValue", "input": [{"name": "InputValue", "type": "Real", "description": "浮点数输入，原始测量值"}], "output": [{"name": "LinearizedValue", "type": "Real", "description": "转换后的线性化值"}, {"name": "Error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "Status", "type": "Word", "description": "状态代码"}]}
{"title": "Even Parity Checker for DWord", "name": "LGF_IsParityEven", "description": "The function checks whether the parity of the input variable of type DWord is even.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is even"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n该函数用于检查一个双字（DWord）输入变量的奇偶性，并返回一个布尔值。如果输入变量中设置为`TRUE`的位数是偶数，则返回`TRUE`，否则返回`FALSE`。函数使用了位操作来计算输入变量的奇偶性，并且不使用ENO机制进行错误处理。\n\n\n"}
{"title": "Random UDInt Range Number Generator", "name": "LGF_RandomRange_UDInt", "description": "This function generates a random value in defined limits with each call. The random number has the data type UDInt in the specified range.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "UDInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random UDInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数功能是生成一个在指定范围内的随机数，数据类型为UDInt。函数的输入参数为随机数的最小值minValue和最大值maxValue，输出参数包括错误标志error，状态码status，子函数状态subfunctionStatus以及生成的随机数item。函数首先检查最大值是否小于最小值，如果是，则返回错误。然后，函数读取系统时间，并使用纳秒值来生成一个基于时间的随机起始值。接着，将这个随机起始值归一化到0.0到1.0之间，并最终将其缩放到minValue和maxValue指定的范围内。如果执行过程中没有错误，则返回生成的随机数。\n\n\n"}
{"title": "Single Byte CRC-8 Calculator", "name": "LGF_CalcCRC8For1Byte", "description": "The function calculates the CRC value from a single data byte for error detection at data transmission.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "value", "type": "Byte", "description": "Data byte for which the CRC value will be calculated"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n该函数用于计算单个数据字节的CRC-8校验值，以便在数据传输过程中进行错误检测。函数接受三个输入参数：initValue（初始值），mask（生成多项式）和value（待计算CRC值的数据字节）。函数通过CRC-8算法计算输入字节的CRC值，并返回计算结果。其中，CRC-8算法是一个循环冗余校验，它将数据看作是一个二进制数，通过除以生成多项式来计算校验值。输出结果为一个字节大小的CRC值，可以用于后续的数据校验过程。\n\n\n"}
{"title": "Kelvin to Rankine Converter", "name": "LGF_KelvinToRankine", "description": "This function converts a temperature value - from °Kelvin to °Rankine.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Rankine"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将温度值从开尔文（°Kelvin）转换为兰金（°Rankine）。转换公式为：兰金温度 = 开尔文温度 × 1.8。\\n\\n示例：\\n假设输入的开尔文温度为300K，则转换后的兰金温度为540°R。\n\n\n"}
{"title": "Cosine Signal Generator", "name": "LGF_CosinusCI", "description": "This function generates a cosinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the cosinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块用于生成一个余弦波信号，它利用调用它的周期性中断组织块（OB）的时间间隔来计算输出值。函数块接受以下输入参数：振幅（amplitude）、偏移量（offset）、周期（periode）、相移（phaseShift）、调用OB（callOB）和重置（reset）信号。它将输出当前的余弦波信号值（value）、错误状态（error）、状态字（status）和子函数状态（subFunctionStatus）。\n\n在每次OB被调用时，函数块会根据周期时间增加一个计数器，并将其转换为弧度。然后，它会计算当前时刻的余弦值，并考虑振幅、偏移量和相移来生成最终的输出值。如果重置信号为真，则计数器会被重置为0，输出值也会被设置为0。\n\n函数块还包含错误处理逻辑，用于处理查询周期性中断OB时可能出现的错误。如果查询函数QRY_CINT返回错误，或者OB不可用，函数块会将错误状态设置为真，并返回相应的错误代码。\n\n状态字和子函数状态用于提供函数块的执行状态信息。ENO机制在该函数块中不使用，因此被强制设置为真。\n\n\n"}
{"title": "Binary to Gray Code Converter", "name": "LGF_BinaryToGray", "description": "This function converts a binary coded value into a Gray-coded value.", "type": "FUNCTION", "input": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Gray-coded value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，实现二进制数到格雷码的转换。函数接受一个32位无符号整数的二进制编码值作为输入，并返回一个32位无符号整数的格雷码编码值作为输出。二进制到格雷码的转换是通过将输入值与其自身右移一位后的结果进行异或操作来完成的。例如，二进制数0110转换为格雷码0101。\n\n\n"}
{"title": "Histogram Calculation Function Block for Integer Data", "name": "LGF_Histogram_DInt", "description": "The histogram shows the frequency distribution of a sample by class.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Outputs the calculated values in a two-dimensional array."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_DInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算一系列整数型数据的直方图。该函数块接受一个布尔型输入execute来启动计算，以及一个无符号整型输入numberOfClasses来指定直方图的分类数量。函数块会输出一个二维数组histValues，其中包含每个分类的频率分布值和分类的中间值。此外，还会输出一个数组axis，其中包含直方图坐标轴的最小值、最大值、原点和最大频率值。函数块还会返回一个实型输出classWidth，表示每个分类的宽度。如果执行过程中出现错误，函数块会设置布尔型输出error为TRUE，并通过状态字status和子函数状态字subFunctionStatus返回具体的错误信息。直方图计算包括对输入数组values进行排序、确定最小值和最大值、计算分类宽度、统计每个分类的频率和相对频率，并计算每个分类的中间值。函数块使用LGF_ShellSort_DInt函数对输入数组进行排序，如果排序过程中出现错误，函数块会记录错误状态并返回相应的错误代码。如果指定的分类数量不正确，函数块也会返回错误代码。整个计算过程在execute信号的上升沿触发。\n\n\n"}
{"title": "Calendar day calculation", "name": "LGF_GetCalendarDay", "description": "This function uses the specified date to calculate the number of days that have passed since the beginning of the year (1st January).", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date for the calculation of the calendar days since 1 January."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Days past since January 1st."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": [], "description_zh": "\n一个函数FC，根据指定的日期计算从当年1月1日起已经过去的日历天数。该函数接受一个DTL类型的日期输入，并返回一个DInt类型的值，表示从1月1日到输入日期的天数差。如果输入日期超出有效范围，函数将返回一个错误状态。\n\n\n"}
{"title": "Arithmetic Mean and Standard Deviation Calculator", "name": "LGF_AverageAndDeviation", "description": "This function calculates the arithmetic mean and the standard deviation from a series of numbers.", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Array[*] of LReal", "description": "Sequence of numbers to calculate with"}], "output": [{"name": "arithmeticAverage", "type": "LReal", "description": "Calculated arithmetic average value"}, {"name": "standardDeviation", "type": "LReal", "description": "Calculated standard deviation"}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数计算一系列数的算术平均值和标准差。输入为一个LReal类型的数组，输出为算术平均值和标准差。函数首先检查输入数组的上下界，以确定数组中元素的数量。然后，通过求和并除以元素数量来计算算术平均值。接着，通过计算每个数值与平均值之差的平方，求和后除以元素数量，最后开方得到标准差。输出的算术平均值和标准差可以用于后续的数据分析。\n\n\n"}
{"title": "DTL to ISO 8601 Date String", "name": "LGF_DTLToString_ISO", "description": "This function converts a date of data type DTL into a character string of data type STRING in international format (YYYY MM DD).", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string in accordance with the ISO 8601 format."}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC将DTL格式的日期时间值转换为符合ISO 8601国际标准的字符串格式（YYYY MM DD）。函数接受两个输入参数：一个是需要转换的DTL日期时间值，另一个是用于分隔日期时间组件的自定义分隔符。如果未指定分隔符，则默认使用短横线（-）作为分隔符。函数会输出一个字符串，其中包含年、月、日，并且每个组件都按照ISO 8601的格式排列，即年份使用4位数字表示，月份和日期都使用2位数字表示，并且前面会补零。函数中没有错误处理机制，因此ENO始终设置为真。\n\n\n"}
{"title": "Bit assignment operation in DWORD", "name": "LGF_BitSetTo", "description": "This block sets a bit to TRUE or FALSE at a predefined position in a variable of the data type DWORD.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set / reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}, {"name": "setTo", "type": "Bool", "description": "Set bit to FALSE / TRUE"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with set bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于在DWORD类型的数据中设置或重置指定位置的位。函数接收三个输入参数：value（DWord类型）表示要设置位的变量，bitNo（USInt类型）表示要设置的具体位号，setTo（Bool类型）表示将该位设置为真（TRUE）或假（FALSE）。函数的返回值是一个DWORD类型的变量，其中指定位置的位已经根据setTo参数的值进行了设置或重置。如果setTo为TRUE，则将指定位置的位设置为1；如果setTo为FALSE，则将指定位置的位设置为0。函数内部使用位移和逻辑运算来实现位的设置或重置。\n\n\n"}
{"title": "DTL to Julian Date Converter", "name": "LGF_DTLToJulianDate", "description": "This function converts the date and time of data type DTL to the Julian date and as well the modified Julian Date to data type LReal (Double). The timestamp is calculated based on UTC.", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to Julian Date"}], "output": [{"name": "julianDate", "type": "LReal", "description": "Converted Julian date"}, {"name": "modifiedJulianDate", "type": "LReal", "description": "Converted modified Julian date"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "Void", "description": "---"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_DTL_INPUT_VALUE_INVALID", "16#8001": "ERR_TIME_BEFORE_1990"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为儒略日（Julian date）和修正儒略日（modified Julian date），结果以LReal（双精度浮点数）类型返回。函数计算的时间戳基于UTC时间，不考虑时区。只有1990年1月1日之后的日期时间被允许。\\n\\n示例：\\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789。\\n函数应返回儒略日和修正儒略日作为转换结果。\\n\\n注意：\\n如果输入的DTL日期时间格式无效或时间早于1990年1月1日，函数将返回错误状态。\n\n\n"}
{"title": "Simple Smoothing Function", "name": "LGF_SimpleSmoothingFC", "description": "The function calculates the linear mean value acyclically.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_NOT_ENOUGH_VALUES Error: Not enough values.", "16#8401": "ERR_ARRAY_DIFFERENT Error: The Arraysizes are not equal."}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数对输入的LReal型数组进行简单的平滑处理。它通过计算数组中每个元素及其相邻两个元素的平均值来实现平滑。如果输入数组和输出数组的长度不匹配或长度小于3，函数将返回错误状态。函数没有返回值。\n\n\n"}
{"title": "8-Bit to Byte Merger", "name": "LGF_MergeBitsToByte", "description": "This function merge 8 Bits / 8 Boolean variables into one Byte variable.", "type": "FUNCTION", "input": [{"name": "bit7", "type": "Bool", "description": "Input Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Composite Bit sequence stored as Byte variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数\"LGF_MergeBitsToByte\"将8个布尔类型的输入位（bit7至bit0）合并成一个字节类型的输出变量。每个布尔输入位对应于字节中的一个位，其中bit7是最高有效位（MSB），bit0是最低有效位（LSB）。函数通过直接赋值操作将这些位组合成一个字节。输出字节包含了输入位的组合状态，可以直接用于其他需要字节类型数据的场合。\n\n\n"}
{"title": "Boxplot Calculation for Real Data", "name": "LGF_Boxplot_LReal", "description": "Use a Boxplot diagram to get an overview of existing data.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "LReal", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "LReal", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块用于对一组实数数据进行盒须图（Boxplot）分析。盒须图是一种统计图表，用于显示一组数据的分布情况，包括最小值、第一四分位数（Q25）、中位数（Q50）、第三四分位数（Q75）和最大值。此外，该函数块还可以检测数据中的异常值，并计算偏度。\\n\\n示例：\\n假设输入的数据数组为[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，异常值检测参数为1.5。\\n函数块应计算出最小值为1，第一四分位数为3，中位数为5.5，第三四分位数为7，最大值为10，并检测出没有异常值，偏度为0。\n\n\n"}
{"title": "Structured data comparison", "name": "LGF_CompareVariant", "description": "The function compares two structured actual parameters and outputs whether they are of the same type and have the same values.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "variableA", "type": "Variant", "description": "First comparison variable with any data type"}, {"name": "variableB", "type": "Variant", "description": "Second comparison variable with any data type"}], "return_value": [{"type": "Bool", "description": "FALSE: Values of comparison variables or PLC data types are different. TRUE: Values of the comparison variables are equal and PLC data types are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_INPUT_TYPES_MUST_MATCH", "16#8202": "ERR_INPUT_TYPES_LENGTH_NOT_EQUAL", "16#8601": "ERR_SERIALIZE_VARIABLE_A", "16#8602": "ERR_SERIALIZE_VARIABLE_B"}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个结构化的变量，并输出它们是否具有相同的数据类型和相同的值。函数首先检查两个变量的数据类型是否相同，然后将其序列化为字节数组，并比较数组的大小。如果大小相同，函数将逐字节比较字节数组中的值。如果所有值都相同，函数返回真（TRUE），表示两个变量具有相同的数据类型和相同的值；如果有任何值不同，函数返回假（FALSE）。如果输入变量的数据类型不相同或大小不同，函数将返回错误状态。函数支持的最大序列化长度为200字节。\n\n\n"}
{"title": "Random Real Range Number Generator", "name": "LGF_RandomRange_Real", "description": "This function generates a random value in defined limits with each call. The random number has the data type Real in the specified range.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "Real", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "Real", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数FC旨在每次调用时生成一个指定范围内的随机实数。函数接受两个输入参数：最小值（minValue）和最大值（maxValue），这两个参数定义了随机数的范围。函数会检查最小值是否小于等于最大值，如果是，则使用系统时间作为随机数生成的种子，生成一个介于最小值和最大值之间的随机实数。如果发生错误（如最小值大于最大值，或者读取系统时间时出错），函数将返回一个错误标志和相应的状态码。函数不使用ENO机制进行错误处理。\n\n\n"}
{"title": "Simple Smoothing Function Block", "name": "LGF_SimpleSmoothingFB", "description": "The function calculates the linear mean value cyclically for smoothing a sequence of measured values.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if three values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires three (3) values to calculate a smoothed value."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于对一系列测量值进行平滑处理。该函数块通过计算输入值的线性平均值来实现平滑效果。它的工作原理是：当使能信号`enable`为真且`insert`信号发生上升沿时，将输入值`value`插入到一个数组中。当数组中积累了三个值后，函数块计算这三个值的平均值，并将这个平均值作为平滑后的值`smoothedValue`输出。如果积累的值不足三个，输出状态`status`将指示“STATUS_NOT_ENOUGH_VALUES”。函数块还提供一个错误输出`error`，用于指示在执行过程中是否发生错误。状态码用于表示函数块的当前状态，例如等待激活、首次调用、后续调用等。\n\n\n"}
{"title": "Bit status check operation", "name": "LGF_BitTest", "description": "This block checks whether a bit is TRUE or FALSE at a given position in a variable of the data type DWORD.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be tested"}, {"name": "bitNo", "type": "USInt", "description": "bit number to test in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Value of the checked bit."}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检查DWORD类型变量中指定位置的位是TURE还是FALSE。函数接收两个输入参数：一个DWORD类型的变量和一个USInt类型的位号。函数通过将一个TURE位左移指定的位数，然后与输入的DWORD变量进行按位与操作，来判断指定位置的位的状态。如果该位为TURE，则函数返回TURE；否则返回FALSE。\n\n\n"}
{"title": "Matrix Subtractor", "name": "LGF_MatrixSubtraction", "description": "This function subtracts a matrix of the data type ARRAY[*,*] of LREAL from another one.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First matrix - minuend"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second matrix - subtrahend"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算两个具有相同维度的LREAL类型矩阵的差值。该函数接受两个输入矩阵和一个输出矩阵，输出矩阵将包含两个输入矩阵对应元素的差值。函数会检查输入矩阵的维度是否一致，如果维度不匹配，则会设置错误标志并返回相应的状态代码。如果维度匹配，函数将计算差值并将结果写入输出矩阵。该函数没有返回值。\n\n\n"}
{"title": "LReal numbers comparison with fixed precision", "name": "LGF_CompareLReal", "description": "This function checks floating point numbers for equality, by using an approximation formula and a fixed precision by constant 1.0E-12 (pico)", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个LReal类型的浮点数是否近似相等。函数通过使用一个近似公式和固定的精度常量1.0E-12（皮克）来实现这一点。函数接受两个LReal类型的输入参数valueA和valueB，并返回一个布尔值，指示两个数是否近似相等。如果两个数之差的绝对值小于等于精度常量与两个输入数之一的乘积，则函数返回TRUE，表示两个数近似相等；否则返回FALSE。该函数不使用ENO机制，并且没有错误处理。\n\n\n"}
{"title": "DTL to Traditional German Date String", "name": "LGF_DTLToString_DE", "description": "This function converts a date of data type DTL into a character string of data type STRING in the traditional format (DD MM YYYY).", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string according to the traditional format."}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为字符串，并按照自定义的分隔符输出。转换后的字符串格式应为DD<分隔符>MM<分隔符>YYYY<分隔符>HH:mm:ss.nnnnnnnn，其中<分隔符>为函数参数指定的字符。这里HH代表小时（24小时制），mm代表分钟，ss代表秒，nnnnnnnn代表纳秒。注意，分隔符不应用于时分秒纳秒之间。\\n\\n示例：\\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789，自定义分隔符为-。\\n函数应返回字符串\\\"17-09-2023 12:34:56.123456789\\\"作为转换结果。\n\n\n"}
{"title": "FIFO Buffer Management", "name": "LGF_FIFO", "description": "FIFO (First-In First-Out / Queue / ring buffer memory) This function stores incoming data and outputs the oldest unprocessed data.", "type": "FUNCTION_BLOCK", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue item to the buffer"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue item from the buffer and return it on `item`"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value `initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: `0` / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8601": "ERR_INDEX_IN_ARRAY_LIMITS_1", "16#8602": "ERR_INDEX_IN_ARRAY_LIMITS_2", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_FIRST_ENTRY", "16#8612": "ERR_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": [], "description_zh": "\n该函数块实现了一个先进先出（FIFO）队列的管理功能。它使用一个变长数组作为循环缓冲区，支持以下操作：入队（enqueue）、出队（dequeue）、重置（reset）和清空（clear）。\\n\\n入队操作将新元素添加到队列的队尾，出队操作则从队首移除并返回最旧的未处理元素。重置操作将队列初始化为空状态，而清空操作则将队列中的所有元素清除，并用初始值重新初始化队列。\\n\\n函数块提供了错误和状态输出，以及队列中元素数量的信息。如果队列为空，则isEmpty输出为真。如果操作过程中发生错误，error输出将被设置为真，并相应地设置status和subFunctionStatus以指示错误类型。\\n\\n示例：\\n假设队列的初始长度为5，初始值为0。使用enqueue操作将新元素1、2、3、4和5添加到队列中。然后，使用dequeue操作连续移除并返回元素1、2、3、4和5。在每次dequeue操作后，elementCount将递减，直到为0，isEmpty将变为真。\n\n\n"}
{"title": "Pulse relay and toggle flip-flop operation", "name": "LGF_PulseRelay", "description": "This block corresponds to an impulse relay or a toggle flip-flop including set and reset input.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "FALSE Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "FALSE Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "FALSE Reset signal, rising edge (prior to set)"}], "output": [{"name": "out", "type": "Bool", "description": "Ooutput signal"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块实现了一个脉冲继电器或触发式触发器的功能，包括置位和复位输入。当触发信号（trigger）的上升沿到来时，输出信号（out）会进行切换（翻转）。当置位信号（set）的上升沿到来时，输出信号会被设置为TRUE。当复位信号（reset）的上升沿到来时，输出信号会被设置为FALSE。复位信号优先于置位信号或触发信号。\n\n\n"}
{"title": "自动化生产线控制", "description": "一个简单的自动化生产线由三个工作站组成：工作站A、工作站B和工作站C。产品需要经过这三个站的依次加工后才算全部完成。生产线有一个电机，负责将产品从一个工作站移动到下一个工作站，生成线的顺序是从工作站A到工作站B，再到工作站C。每个工作站都有一个传感器（用于检测产品是否到达）以及一个按钮（用于触发本站加工完成信号）。\n控制要求：\n1. 模式切换：转换开关（Mode）用于切换生产线的手动和自动模式。\n2. 手动模式：在手动模式下，电机正转按钮（ForwardButton）控制电机正转，电机反转按钮（ReverseButton）控制电机反转，正反转操作需要互锁，不能同时进行。\n3. 自动模式：\n   - 产品到达工作站A，SensorA检测到产品，操作员通过ButtonA触发加工完成信号后，电机启动正转，将产品移动到工作站B。\n   - 产品到达工作站B，SensorB检测到产品，电机停止，操作员通过ButtonB触发加工完成信号后，电机启动正转，将产品移动到工作站C。\n   - 产品到达工作站C，SensorC检测到产品，电机停止，操作员通过ButtonC触发加工完成信号后，加工完成指示灯（CompletionLight）亮起，指示产品加工完成。当产品被取走，也就是SensorC检测不到产品了，加工完成指示灯（CompletionLight）熄灭。", "type": "FUNCTION_BLOCK", "name": "FB_ProductionLineControl", "input": [{"name": "Mode", "type": "Bool", "description": "用于切换生产线的手动和自动模式，0=手动模式，1=自动模式"}, {"name": "ForwardButton", "type": "Bool", "description": "正转按钮"}, {"name": "ReverseButton", "type": "Bool", "description": "反转按钮"}, {"name": "SensorA", "type": "Bool", "description": "传感器A"}, {"name": "SensorB", "type": "Bool", "description": "传感器B"}, {"name": "SensorC", "type": "Bool", "description": "传感器C"}, {"name": "ButtonA", "type": "Bool", "description": "按钮A"}, {"name": "ButtonB", "type": "Bool", "description": "按钮B"}, {"name": "ButtonC", "type": "Bool", "description": "按钮C"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "电机正转输出"}, {"name": "MotorReverse", "type": "Bool", "description": "电机反转输出"}, {"name": "CompletionLight", "type": "Bool", "description": "产品加工完成指示灯"}]}
{"title": "Time to String Converter", "name": "LGF_TimeToString", "description": "The function converts a variable of the system data type Time into a variable of the data type String.", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "Time", "description": "Time value to convert Example: T#1D_3H_45M_6S"}], "output": [{"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "in/out": [], "return_value": [{"type": "String", "description": "Converted time as string. Example: 1D3H45M6S0MS"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将系统数据类型Time的时间值转换为字符串。转换后的字符串格式为\\\"天数D小时H分钟M秒S毫秒MS\\\"，其中只有存在的时间单位才会被添加到字符串中。例如，如果时间值只有小时和分钟，那么字符串将只包含小时和分钟。\\n\\n示例：\\n假设输入的时间值为T#1D_3H_45M_6S，那么函数应返回字符串\\\"1D3H45M6S0MS\\\"作为转换结果。\n\n\n"}
{"title": "Numeric Differentiation Function Block", "name": "LGF_DifferenceQuotientFB", "description": "This function numerically differentiates a signal sampled equidistantly in time.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `derivatedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that must be included in the differentiation."}, {"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "derivatedValue", "type": "LReal", "description": "The differentiated value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification of the FB"}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a differentiated value.", "16#8200": "ERR_DELTA_T: Delta time `deltaT` must not be zero."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算等时间间隔采样信号的一阶导数（微分）。当使能信号激活时，该FB开始工作。插入信号用于指示何时将输入值包含在微分计算中。FB需要至少五个等时间间隔的采样值来计算微分值，其中时间间隔由参数`deltaT`指定。如果`deltaT`为零，则会发生错误。计算出的微分值在`derivatedValue`输出中提供。状态和错误信息通过`error`和`status`输出传递。\n\n\n"}
{"title": "Rectangle Signal Generator", "name": "LGF_RectangleCI", "description": "This function generates a rectangular signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the rectangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个矩形信号波形。它利用调用它的循环中断OB的时间间隔来控制波形的周期。矩形波的参数包括振幅、偏移量、周期和相位偏移。函数块会根据这些参数和OB的时间间隔计算出当前信号值，并在输出参数value中返回。如果发生错误，比如OB不可用或者查询OB信息失败，函数块会在输出参数error中置位，并在status和subFunctionStatus中提供错误代码。状态代码16#0000表示没有错误，16#8600表示OB不可用，16#8601表示查询OB信息失败。如果输入参数reset为TRUE，函数块会将计数器和信号值重置。\n\n\n"}
{"title": "Linear Regression Calculator", "name": "LGF_RegressionLine", "description": "The simplest case of a regression is the regression line.", "type": "FUNCTION", "input": [], "output": [{"name": "slope", "type": "LReal", "description": "Gradient of straight line"}, {"name": "intercept", "type": "LReal", "description": "The intersection with the Y axis"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LGF_typeRegressionLine", "description": "The data points are transferred with their X- and Y-values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#8200": "ERR_NOT_ENOUGH_VALUES Error: Not enough Values."}, "user_defined_types": [{"name": "LGF_typeRegressionLine", "description": "UDT for transferring datapoints to LGF_RegressionLine", "member": [{"name": "x", "type": "Real", "default": "0.0", "description": "X-Axis value"}, {"name": "y", "type": "Real", "default": "0.0", "description": "Y-Axis value"}]}], "description_zh": "\n一个函数FC，用于计算数据点的线性回归线。该函数接收一个包含多个数据点的数组，每个数据点包含X和Y坐标。计算结果包括回归线的斜率（slope）和截距（intercept），如果没有足够的数据点，则返回错误状态。如果数据点的数量少于两个，函数将无法计算回归线，并返回错误状态。函数不返回任何值，但会通过输出参数提供计算结果。\n\n\n"}
{"title": "Sawtooth Signal Generator", "name": "LGF_SawToothCI", "description": "This function generates a sawtooth-shaped signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sawtooth signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个锯齿波形的信号。它利用调用周期性中断OB的时间间隔来生成信号，并可以设置信号的振幅、偏移量、周期和相移。函数块在每次周期性中断OB调用时更新信号的当前值，并输出该值。如果出现错误（如中断OB不可用），函数块会设置错误标志并输出相应的状态码。状态码16#0000表示执行没有错误，16#8600表示中断OB不可用，16#8601表示查询周期性中断时出错。\n\n\n"}
{"title": "Matrix Scalar Multiplier", "name": "LGF_MatrixScalarMultiplication", "description": "This function block multiplies a matrix of the data type ARRAY[*, *] of LREAL with a scalar.", "type": "FUNCTION", "input": [{"name": "scalar", "type": "LReal", "description": "Scalar value where the matrix is multiplied"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrixInput", "type": "Array[*, *] of LReal", "description": "Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "The result matrix of the multiplication"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_MATRICES_LOWER_BOUND_ROWS_DONT_MATCH", "16#8202": "ERR_MATRICES_UPPER_BOUND_ROWS_DONT_MATCH", "16#8203": "ERR_MATRICES_LOWER_BOUND_COLUMNS_DONT_MATCH", "16#8204": "ERR_MATRICES_UPPER_BOUND_COLUMNS_DONT_MATCH"}, "user_defined_types": [], "description_zh": "\n该函数用于将一个LREAL类型的二维数组（矩阵）与一个标量（scalar）相乘。函数会检查输入矩阵和结果矩阵的维度是否一致，如果一致，则将输入矩阵的每个元素乘以标量，并将结果存储在结果矩阵中。如果矩阵维度不一致，则函数会返回错误状态。成功执行后，函数将返回STATUS_NO_ERROR状态码。\n\n\n"}
{"title": "N-th root extraction", "name": "LGF_NthRoot", "description": "This function extracts the n-th root of a given value.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value from which the root should be calculated"}, {"name": "root", "type": "LReal", "description": "Exponent of root"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Returns the Nth root of a value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NEG_VAR"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数计算并返回给定数值的n次方根。函数接受两个输入参数：value（LReal类型），表示要计算其根的数值；root（LReal类型），表示根的指数。函数会检查输入的数值是否为负数，因为负数没有实数平方根。如果输入数值为负数，函数将返回错误标志和错误状态代码。否则，函数计算并返回给定数值的n次方根。\\n\\n示例：\\n假设输入数值为8，根的指数为3，函数应返回2作为立方根的结果。\n\n\n"}
{"title": "US calendar week calculation", "name": "LGF_GetCalendarWeek_US", "description": "This function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for the USA and many other countries.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算美国及其他一些国家使用的日历周数。该函数接收一个DTL类型的日期参数，并计算出该日期所处的日历周数以及距离当年1月1日以来的天数。日历周数以周日为一周的开始，并且包含1月1日的周总是第1周。一年可能有52周或53周，具体取决于1月1日是星期几以及当年是否为闰年。\\n\\n函数会检查输入日期是否超出有效范围，并在发生错误时返回相应的错误代码。如果输入日期有效，函数将返回日历周数和自1月1日起的天数。\\n\\n示例：\\n如果输入日期为2023年1月1日，则函数应返回日历周数为1，自1月1日起的天数为0。\n\n\n"}
{"title": "String to TADDR_Param Converter", "name": "LGF_StringToTaddr", "description": "The function converts a variable of data type String to a TADDR_Param system data type variable.", "type": "FUNCTION", "input": [{"name": "ipAddressString", "type": "String", "description": "IPV4 address string in the format of 192.168.1.200:55047 [Port number including colon : is optional]"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "TADDR_Param", "description": "IP-Address and Port number as TADDR_Param data type"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8110": "ERR_OCTET_WRONG_NUMBER_OF_CHAR", "16#8120": "ERR_OCTET_STRING_IS_EMPTY", "16#8130": "ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS", "16#8150": "ERR_PORT_WRONG_NUMBER_OF_CHAR", "16#8151": "ERR_PORT_STRING_IS_EMPTY", "16#8152": "ERR_PORT_EXCEEDS_MAX_PORT"}, "user_defined_types": [], "description_zh": "\n该函数FC将字符串格式的IPv4地址和端口号转换为TADDR_Param系统数据类型。IPv4地址字符串格式为\"192.168.1.200\"，端口号为可选参数，如果指定则格式为\"192.168.1.200:55047\"。\n\n函数首先对输入的字符串进行处理，将其分为四个IP段，并检查每个IP段是否为空，长度是否正确，数值是否超出最大IP地址范围。如果输入格式正确，则将每个IP段的值转换为数值，并存储在TADDR_Param数据类型的相应位置。如果输入字符串中包含端口号，则还会检查端口号的长度是否正确，数值是否超出最大端口号范围。如果端口号格式正确，则将其转换为数值，并存储在TADDR_Param数据类型的端口号位置。\n\n如果转换过程中出现错误，则函数会设置错误标志error，并返回相应的错误状态status。如果转换成功，则函数会返回包含IPv4地址和端口号的TADDR_Param数据类型。\n\n\n"}
{"title": "温度逻辑控制", "description": "编写一个函数块FB，实现一个温度控制逻辑。该程序应包含以下功能：\n1. 通过模拟量输入模块读取温度传感器的值。\n2. 将读取的温度值TemperatureSensorInput与设定的温度值SetTemperature进行比较。\n3. 如果实际温度低于设定温度，则启动加热器HeaterOutput。\n4. 如果实际温度高于设定温度，则关闭加热器HeaterOutput。\n5. 如果加热器连续工作超过一定时间（为方便测试，采用5s），应触发过热保护，自动关闭加热器，必须再过一定时间（为方便测试，采用3s）才能解除过热保护。\n6. 提供状态指示，显示当前温度、设定温度、加热器状态以及是否有过热保护触发。\n7. 提供温度传感器故障判断，如果读取的温度值TemperatureSensorInput小于0或大于100，则认为传感器故障，此时应关闭加热器。", "type": "FUNCTION_BLOCK", "name": "FB_TempCtrl", "input": [{"name": "TemperatureSensorInput", "type": "Real", "description": "温度传感器输入值，即实际温度"}, {"name": "SetTemperature", "type": "Real", "description": "设定温度值"}], "output": [{"name": "CurrentTemperature", "type": "Real", "description": "当前温度显示"}, {"name": "SetTempDisplay", "type": "Real", "description": "设定温度显示"}, {"name": "HeaterStatus", "type": "Bool", "description": "加热器状态显示"}, {"name": "OverheatProtection", "type": "Bool", "description": "过热保护状态显示"}], "in_out": [{"name": "HeaterOutput", "type": "Bool", "description": "加热器控制输出"}]}
{"title": "Value range limit check", "name": "LGF_IsValueInLimits", "description": "The function checks whether a value is within a defined value range.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_HIGH_BELOW_LOW_LIMIT"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检查一个给定的实数（LReal类型）是否位于两个指定界限之间。界限由输入参数lowLimit和highLimit定义。函数会返回一个布尔值，如果输入值value在界限之内，则返回TRUE；否则返回FALSE。此外，函数还提供了两个输出参数overHighLimit和belowLowLimit，分别指示输入值是否超过了上限或低于下限。如果上限值小于下限值，函数将报告一个错误，并将状态码设置为ERR_RANGE_HIGH_BELOW_LOW_LIMIT。\n\n\n"}
{"title": "Double word edge detection", "name": "LGF_GetBitStates", "description": "This function checks a DWord for falling as well as rising edges. It returns the number of edges, a DWord with the edge bits, and a boolean value if edge(s) are present.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Check input value for changes and edges"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "Input value has changed (compared to the previous cycle)"}, {"name": "hasRisingEdges", "type": "Bool", "description": "Input value has rising edges"}, {"name": "risingBits", "type": "DWord", "description": "Bitstream with the rising edges"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "Input value has falling edges"}, {"name": "fallingBits", "type": "DWord", "description": "Bitstream with the falling edges"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于检测32位双字（DWord）输入值中的每个比特的上升沿和下降沿。函数块会返回一个布尔值，指示输入值是否发生变化，以及两个布尔值，分别指示是否存在上升沿或下降沿。同时，函数块还会返回一个包含上升沿和下降沿位流的DWord，以及两个USInt类型的输出，分别表示上升沿和下降沿的数量。\\n\\n示例：\\n假设输入值从2#101变为2#11011，则上升沿数量为3，上升边沿的位流为2#11010，下降沿数量为1，下降边沿的位流为2#100。\n\n\n"}
{"title": "Non-Linear Interpolation Function", "name": "LGF_NonLinearInterpolation", "description": "Implements a characteristic curve defined via an interpolation point table with linear interpolation.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Input value for calculating the output value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow the value of the input without using the characteristic curve"}, {"name": "reset", "type": "Bool", "description": "Reset the interpolation if the point table is changed in running operation"}], "output": [{"name": "outputValue", "type": "LReal", "description": "The calculated output value from the input value"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeNonLinSetpoints", "description": "Setpoint table for defining the characteristic curve"}], "return_value": [], "status_codes": {}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}], "description_zh": "\n一个函数块FB，用于实现非线性插值功能。该函数块通过定义插值点表来实现特性曲线，并使用线性插值来计算输入值对应的输出值。特性曲线可以是非线性的，通过在插值点之间进行线性插值来实现曲线的平滑过渡。\n\n函数块具有以下功能：\n1. 计算输出值：根据输入值和插值点表，计算得到对应的输出值。\n2. 默认输出值：如果使能默认输出值，则将输入值直接作为输出值。\n3. 跟踪模式：如果处于跟踪模式，则输出值将跟随输入值变化，不使用特性曲线进行插值。\n4. 重置：如果检测到插值点表在运行过程中发生变化，可以重置插值过程。\n\n函数块具有以下输入输出参数：\n- 输入值（value）：用于计算输出值的输入参数。\n- 默认输出值（defaultOutValue）：预设的输出值。\n- 使能默认输出值（enDefaultOutValue）：布尔值，用于指示是否使用默认输出值。\n- 跟踪模式（track）：布尔值，用于指示是否使用跟踪模式。\n- 重置（reset）：布尔值，用于指示是否重置插值过程。\n- 输出值（outputValue）：计算得到的输出值。\n- 插值点表（setpoints）：用于定义特性曲线的插值点数组。\n\n函数块使用线性插值方法，在给定的插值点之间进行计算，得到输入值对应的输出值。\n\n\n"}
{"title": "32-Bit to DWord Merger", "name": "LGF_MergeBitsToDWord", "description": "This function merge 32 Bits / 32 Boolean variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "bit31", "type": "Bool", "description": "Input Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Input Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Input Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Input Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Input Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Input Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Input Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Input Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Input Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Input Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Input Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Input Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Input Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Input Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Input Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Input Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Input Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Bit sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数功能是将32个布尔型变量（每个代表一个比特位）合并成一个32位双字（DWord）变量。输入的32个布尔变量分别代表DWord变量的第31位到第0位（其中第31位是最高位，第0位是最低位）。函数通过逐位操作将这些布尔变量合并成一个DWord变量，并返回这个合并后的DWord变量。函数中没有错误处理，因此ENO始终设置为TRUE。\n\n\n"}
{"title": "Word to 16-Bit Splitter", "name": "LGF_SplitWordToBits", "description": "This function splits a Word variable into 16 Boolean / 16 Bit variables.", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "bit15", "type": "Bool", "description": "Output Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数将一个字（Word）类型的变量分割成16个布尔型（Bool）的输出，每个布尔型输出对应字中的一个位。输出的布尔型变量从bit15到bit0，其中bit15对应字的最高位（MSB），bit0对应字的最低位（LSB）。\n\n\n"}
{"title": "2-Byte to Word Merger", "name": "LGF_MergeBytesToWord", "description": "This function merge 2 Byte variables into one Word variable.", "type": "FUNCTION", "input": [{"name": "byte1", "type": "Byte", "description": "Input Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Byte sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数功能将两个单字节数据(byte1和byte0)合并成一个双字(word)数据。在合并过程中，byte1作为高字节，byte0作为低字节。函数使用字节访问指令，将输入的字节数据分别写入双字变量的高字节和低字节部分，然后将合并后的双字数据作为函数返回值输出。\n\n\n"}
{"title": "Matrix Inverter", "name": "LGF_MatrixInverse", "description": "This function inverts a square matrix of the data type ARRAY[*,*] of LREAL.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Square input matrix that will be inversed"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Inverted matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NOT_SQUARE_MATRIX", "16#8201": "ERR_ALGORITHM_NOT_POSSIBLE", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，用于计算并输出一个LREAL类型的二维数组（矩阵）的逆矩阵。函数首先检查输入矩阵是否为方阵，即行数和列数相等。如果输入矩阵不是方阵，函数将返回错误状态ERR_NOT_SQUARE_MATRIX。接下来，函数检查输入矩阵和输出矩阵的边界是否一致，如果不一致，将返回相应的错误状态。如果所有检查都通过，函数将计算输入矩阵的逆矩阵，并将其存储在输出矩阵中。计算过程中，函数使用高斯-约当消元法，并避免除以零的情况。如果算法无法执行，将返回错误状态ERR_ALGORITHM_NOT_POSSIBLE。如果计算成功，函数将返回状态STATUS_NO_ERROR，表示没有错误发生。\n\n\n"}
{"title": "自动化仓库货架位置管理系统", "description": "一个自动化仓库需要一个系统来管理工件的存放位置，确保工件能够高效地被存取。仓库里有一个货架，共有9层，每层编号从1到9，每层仅能存放一件工件。\n控制要求：\n1. 系统需要维护货架的存储状态，记录每层是否存放工件。\n2. 当工件入库时：\n   - 查询货架的存储状态。\n   - 如果有空闲位置，优先存放编号大的位置。\n   - 如果所有位置都被占用，则输出错误状态error=1和错误代码status16#8001。\n3. 当工件出库时：\n   - 查询货架的存储状态。\n   - 如果货架上有工件，优先取出位置编号小的工件。\n   - 如果所有位置都为空，则输出错误状态error=1和错误代码status16#8002。\n4. 系统应能输出当前工件库存数量和货架空闲位置数量。", "type": "FUNCTION_BLOCK", "name": "FB_WarehouseManagement", "input": [{"name": "requestIn", "type": "Bool", "description": "入库请求信号"}, {"name": "requestOut", "type": "Bool", "description": "出库请求信号"}], "output": [{"name": "productNum", "type": "Int", "description": "工件库存数量"}, {"name": "libFreeNum", "type": "Int", "description": "货架空闲位置数量"}, {"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "library", "type": "Array[1..9] of Bool", "description": "货架每层的占用状态，1表示占用，0表示空闲"}]}
{"title": "Bit toggle operation in DWORD", "name": "LGF_BitToggle", "description": "This block toggles (from TRUE to FALSE and vice versa) a bit at a predefined position in a variable of the data type DWORD.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be toggled"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to be toggled in the “value” parameter."}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with toggled bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数接受一个双字（DWord）类型的输入值和一个无符号短整型（USInt）的位号输入。函数的作用是切换输入双字中指定位置的位。如果该位原本是0，则切换为1；如果原本是1，则切换为0。位号从0开始计数，即最低位是位0。函数会返回切换位后的双字结果。\\n\\n示例：\\n假设输入的双字值为2#10101010，位号为3。函数应切换位3（从左数第四位），返回值为2#10100010。\n\n\n"}
{"title": "Boxplot Calculation for Unsigned Integer Data", "name": "LGF_Boxplot_UDInt", "description": "Use a Boxplot diagram to get an overview of existing data.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "UDInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "UDInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于对无符号整型数据数组进行盒须图（Boxplot）计算。该函数块接收一个布尔型输入信号`execute`，当该信号发生上升沿时激活计算。另一个输入参数`rangeOutlier`用于指定异常值检测的参数。函数块对输入的无符号整型数组`values`进行排序，并计算五个关键统计量：最小值（非异常值）、第一四分位数（Q25）、中位数（Q50）、第三四分位数（Q75）和最大值（非异常值）。此外，函数块还计算异常值的百分比和数据的偏度。如果输入数组为空或者`rangeOutlier`参数不合法，函数块将报告错误。最终，函数块输出计算结果，包括是否发生错误、状态码、子函数状态码、异常值百分比、五个关键统计量和偏度。\n\n\n"}
{"title": "计算一年中的第几天", "description": "在某些自动化系统中，可能需要根据当前日期计算出它是一年中的第几天。这可以用于追踪生产周期、维护计划或其他需要日期信息的场合。\n控制要求：\n系统需要接收日期输入，包括年、月、日。\n根据输入的日期，计算并输出它是一年中的第几天。\n考虑到不同年份的2月天数可能不同（平年28天，闰年29天），系统需要能够识别闰年并相应地计算。\n输出结果应该是一个整数，表示一年中的第几天。\n如果输入的日期不合法（如2月30日、4月31日等），系统应输出错误状态和错误代码。\n说明：\n1. 要求输入的年份Year在1000到3000之间（包括1000和3000），否则输出错误状态error=true和错误代码status=16#8001。如果输入的月份Month不合法，则输出错误状态error=true和错误代码status=16#8002。如果输入的日Day不合法，则输出错误状态error=true和错误代码status=16#8003。\n2. 计算的结果通过DayOfYear输出。", "type": "FUNCTION_BLOCK", "name": "FB_CalculateDayOfYear", "input": [{"name": "Year", "type": "Int", "description": "年份输入"}, {"name": "Month", "type": "Int", "description": "月份输入"}, {"name": "Day", "type": "Int", "description": "日输入"}], "output": [{"name": "DayOfYear", "type": "Int", "description": "一年中的第几天输出"}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE: 没有发生错误\nTRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}]}
{"title": "Function Curve Area Calculator", "name": "LGF_Integration", "description": "The function approximately calculates the area under a function curve.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enables integral calculation"}, {"name": "value", "type": "LReal", "description": "Analog value of the continuous function curve, based on [ms]"}, {"name": "reset", "type": "Bool", "description": "Sets the output 'integral' to '0.0'"}], "output": [{"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8600": "ERR_READ_SYS_TIME"}, "user_defined_types": [], "description_zh": "\n该函数块用于计算函数曲线下的面积。它使用梯形法则进行近似积分。当使能输入为真时，函数块会读取模拟输入值，并计算从上次读取时间以来的时间差。然后，它使用这些信息来更新曲线下的累积面积，并将结果存储在输出“integral”中。如果重置输入为真，则积分值会被重置为0.0。函数块还包括错误标志和状态码输出，用于指示执行过程中的任何问题。状态码包括执行完成且无错误以及读取系统时间出错。函数块不使用ENO机制，而是通过错误和状态输出进行错误处理。\n\n\n"}
{"title": "16-Bit to Word Merger", "name": "LGF_MergeBitsToWord", "description": "This function merge 16 Bits / 16 Boolean variables into one Word variable.", "type": "FUNCTION", "input": [{"name": "bit15", "type": "Bool", "description": "Input Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Bit sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将16个布尔类型的输入位合并成一个字（Word）类型的输出。输入的16个布尔值分别对应于输出的Word值中的16个位，其中最高有效位（MSB）为bit15，最低有效位（LSB）为bit0。\\n\\n示例：\\n假设输入的16个布尔值分别为：\\nbit15: TRUE\\nbit14: FALSE\\nbit13: TRUE\\nbit12: FALSE\\nbit11: TRUE\\nbit10: FALSE\\nbit9: TRUE\\nbit8: FALSE\\nbit7: TRUE\\nbit6: FALSE\\nbit5: TRUE\\nbit4: FALSE\\nbit3: TRUE\\nbit2: FALSE\\nbit1: TRUE\\nbit0: FALSE\\n\\n函数应将这些布尔值转换为对应的二进制序列，并将该序列存储在一个Word变量中，作为函数的返回值。转换后的Word值为0xAAAA。\n\n\n"}
{"title": "Shell Sort for LReal Arrays", "name": "LGF_ShellSort_LReal", "description": "This block sorts an array of type LReal with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块可以对任意长度的LReal数组（最大1000个元素）进行升序或降序排序。排序结果会覆盖原始数组。函数块接受一个布尔类型的输入参数sortDirection，当为FALSE时表示升序排序，为TRUE时表示降序排序。函数块还提供了错误输出error和状态输出status，用于指示排序过程中是否出现错误以及错误类型。如果输入数组为空或者元素数量超过1000，函数块会返回错误状态。\n\n\n"}
{"title": "CRC-32 Calculator", "name": "LGF_CalcCRC32", "description": "The function LGF_CalcCRC32 uses 32 bits as the generator polynomial (mask) for CRC calculation.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算输入数据流的CRC-32值。该函数使用32位生成多项式（掩码）来进行CRC计算，并允许指定计算的起始值。函数的输入包括初始化值、生成多项式、要计算元素的数量以及一个字节数组。函数的输出为计算得到的CRC值，以及错误标志和状态码。如果指定的元素数量超出数组大小，函数将返回错误状态ERR_NO_OF_ELEMENTS (16#8400)。否则，函数将计算并返回CRC值，状态码为STATUS_NO_ERROR (16#0000)。\n\n\n"}
{"title": "Boolean signal edge detection", "name": "LGF_CountBooleanEdges", "description": "This function evaluates an input signal for different states in a certain amount of time.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to evaluate signal"}, {"name": "monitorTime", "type": "Time", "description": "Time to monitor and count edges on `trigger` input"}], "output": [{"name": "single", "type": "Bool", "description": "Single edge until monitoring time expires"}, {"name": "double", "type": "Bool", "description": "Two edges in between the monitoring time"}, {"name": "long", "type": "Bool", "description": "Just a single edge in the monitoring time, the `trigger` input stays TRUE after the edge appears"}, {"name": "severalEdges", "type": "Bool", "description": "Numerous Edges occur within the monitoring time"}, {"name": "noOfEdges", "type": "USInt", "description": "Number of edges in between the monitoring time frame"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于监测一个布尔型输入信号，并在一定时间内评估该信号的不同状态。该函数块能够检测信号的上升沿，并根据监测时间内出现的边缘数量，输出不同的状态信号。具体来说，它可以检测以下状态：\\n\\n1. 单个边缘（single）：在监测时间内只检测到一个边缘，并且该边缘之后输入信号为FALSE。\\n2. 双边缘（double）：在监测时间内检测到两个边缘。\\n3. 长信号（long）：在监测时间内只检测到一个边缘，并且该边缘之后输入信号保持为TRUE。\\n4. 多个边缘（severalEdges）：在监测时间内检测到多个边缘。\\n\\n此外，该函数块还会输出在监测时间内检测到的边缘总数（noOfEdges）。\\n\\n示例：\\n假设输入信号在监测时间内先变为TRUE，然后又变为FALSE，然后再变为TRUE并保持为TRUE，则该函数块应输出单个边缘（single）和长信号（long）。\n\n\n"}
{"title": "Bit reset operation in DWORD", "name": "LGF_BitReset", "description": "This block resets a bit at a predefined position in a variable of the data type DWORD.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with reset bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，用于将DWORD数据类型变量中的指定位重置为0。函数接收两个输入参数：一个是要重置位的DWORD值，另一个是要重置的位的编号。位的编号从0开始，最大值为31，对应于DWORD的32位。函数通过将一个真实的位（即最低位为1，其他位为0的位）左移指定的位数，然后使用XOR操作将结果与全1的DWORD进行异或，从而创建一个只在指定位置为0的位掩码。最后，使用AND操作将这个位掩码与原始的DWORD值进行AND操作，从而重置指定的位。\n\n\n"}
{"title": "Shell Sort for UDInt Arrays", "name": "LGF_ShellSort_UDInt", "description": "This block sorts an array of type UDInt with any number of elements (max. 1000) in ascending or descending order and returns the sorted version of the array in the same variable.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of UDInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块使用希尔排序算法对UDInt类型的数组进行排序。该数组可以包含任意数量的元素（最多1000个），并且可以根据输入参数sortDirection选择升序或降序排列。排序后的数组将覆盖原始数组。如果数组为空或元素数量超过最大限制，函数将返回错误状态。\n\n\n"}
{"title": "Advanced Rate of Change Limiter", "name": "LGF_LimRateOfChangeAdvancedCI", "description": "Limits the rate of change of an input variable with various operating modes.", "type": "FUNCTION_BLOCK", "input": [{"name": "autoValue", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "manualValue", "type": "LReal", "description": "Manually controlled output value"}, {"name": "posUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the positive value range"}, {"name": "posDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the positive value range"}, {"name": "negUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the negative value range"}, {"name": "negDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the negative value range"}, {"name": "highLim", "type": "LReal", "description": "High limit value"}, {"name": "lowLim", "type": "LReal", "description": "Low limit value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow / tracking of Input variable"}, {"name": "manOp", "type": "Bool", "description": "Manual mode on"}, {"name": "reset", "type": "Bool", "description": "Complete restart of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output variable"}, {"name": "posUpRateLim", "type": "Bool", "description": "Rise limitation in positive range tripped"}, {"name": "posDownRateLim", "type": "Bool", "description": "Down rate limit in positive range reached"}, {"name": "negUpRateLim", "type": "Bool", "description": "Up rate limit in negative range reached"}, {"name": "negDownRateLim", "type": "Bool", "description": "Down rate limit in negative range reached"}, {"name": "highLim", "type": "Bool", "description": "High limit reached"}, {"name": "lowLim", "type": "Bool", "description": "Low limit reached"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8202": "ERR_NEG_RATE_OF_CHANGE", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table for function", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}], "description_zh": "\n该函数块FB用于限制输入变量的变化速率，具有多种操作模式。它能够处理并限制输入信号的变化速率，提供手动控制输出值，以及限制在正值和负值范围内的上升和下降斜率。此外，它还能够设置高限制值和低限制值，并提供默认输出值。该函数块支持自动模式、手动模式和跟踪模式，并能够在出现错误时进行重启。它还能够调用周期性中断组织块（OB）以进行唤醒警报。\n\n在自动模式下，函数块会根据设定的上升和下降速率限制以及周期时间来计算输出值。如果输入值超出了设定的速率限制，输出值将会被限制在最大或最小允许值内。在手动模式下，输出值将由手动控制值决定。在跟踪模式下，输出值将会跟随输入值的变化。\n\n该函数块还包括了错误处理和状态代码，以便在出现错误时进行诊断。状态代码包括完成且无错误、负速率限制错误、负速率变化错误、查询CINT错误和OB不可用错误。\n\n\n"}
{"title": "Word Endianness Adjuster", "name": "LGF_SwapBlockWord", "description": "Adjusts/switches the endianness of multibyte data typed values.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of Word", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC用于调整多字节数据类型值的字节序。函数接收一个Word类型的数组作为输入，并对数组中的每个Word元素进行字节交换，以实现大端和小端字节序之间的转换。函数不关心原始系统或目标系统的字节序，因此可以在任何系统上通用使用。函数通过一个循环迭代数组元素，并在内部交换字节顺序，从而实现字节序的调整。这个调整过程对于处理不同字节序系统之间的数据交换非常有用。函数没有返回值，所有的转换都在输入数组中进行。\n\n\n"}
{"title": "UTF-8 Byte Stream Decoder", "name": "LGF_DecodeUtf8", "description": "Decodes a UTF-8 encoded byte stream into a WString", "type": "FUNCTION", "input": [{"name": "byteStream", "type": "Array[*] of Byte", "description": "UTF-8 encoded byte stream"}, {"name": "startPos", "type": "DInt", "description": "Position in byte stream to start decoding from"}, {"name": "count", "type": "UInt", "description": "Number of character (not bytes) to decode; 0: byte stream is decoded until end"}], "output": [], "in/out": [{"name": "decodedString", "type": "WString", "description": "Decoded string"}], "return_value": [{"type": "Word", "description": "Status of the FC, Error identification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7FFD": "WARN_UNSUPPORTED_CHAR", "16#7FFE": "WARN_STREAM_EXCEEDS_MAX_LEN", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS", "16#8203": "ERR_COUNT_EXCEEDS_MAX_LEN"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将UTF-8编码的字节流解码为宽字符串WString。函数接收一个UTF-8编码的字节流数组、开始解码的位置和要解码的字符数量作为输入。如果字符数量为0，则函数会解码从开始位置到字节流末尾的所有字符。函数还会输出解码后的字符串和状态码，状态码用于指示解码过程中的错误或警告，例如字符超出支持范围、字节流长度超过最大限制等。函数内部使用了一些临时变量来存储解码过程中的中间结果，例如当前解码字符的Unicode码点、当前位置等。最后，函数将解码后的字符串和状态码输出。\n\n\n"}
{"title": "String to DInt Converter", "name": "LGF_StringToInt", "description": "This function converts a variable of data type String into a variable of data type DInt.", "type": "FUNCTION", "input": [{"name": "value", "type": "String", "description": "String value to be converted to Double-Integer. Example: ‘+16927’"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted Double-Integer value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，该函数能够将字符串转换为双整数（DInt）类型的数值。函数接受一个字符串类型的输入参数，并返回一个双整数类型的输出值。\\n\\n示例：\\n假设输入的字符串为\\\"+16927\\\"，函数应返回双整数值16927作为转换结果。\\n注意，输入的字符串可以是带符号的，也可以是不带符号的。如果字符串表示的数值超出了双整数类型的范围，函数可能会返回一个错误值。\n\n\n"}
{"title": "GPS-DD to GPS Direction DMS Converter", "name": "LGF_GpsDDToGps", "description": "This function converts a given GPS-DD data type (decimal degrees) into a GPS data type (direction, degrees, minutes, and seconds).", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS_DD", "description": "GPS-Data to be converted (decimal degrees)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS", "description": "Converted GPS-Data (direction, degrees, minutes, and seconds)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8201": "ERR_LATITUDE_VALUE", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}, {"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}], "description_zh": "\n一个函数FC，用于将GPS的十进制度数（DD）格式转换为方向、度、分、秒（DMS）格式的GPS数据。函数接受一个包含纬度和经度的十进制度数GPS数据作为输入，并返回一个包含方向、度、分、秒的GPS数据结构。同时，函数会检查输入值的有效性，并在输入值无效时报告错误状态。\n\n\n"}
{"title": "Celsius to Fahrenheit Converter", "name": "LGF_CelsiusToFahrenheit", "description": "This function converts a temperature value - from °Celsius to °Fahrenheit.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Fahrenheit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将摄氏温度值转换为华氏温度值。函数接受一个实数类型的输入参数，表示摄氏温度，并返回一个实数类型的输出参数，表示对应的华氏温度。转换公式为：华氏温度 = 摄氏温度 * 1.8 + 32。函数中未定义错误处理，因此ENO始终为TRUE。\n\n\n"}
{"title": "Endianness Detection Function", "name": "LGF_IsBigEndian", "description": "Detects the endianness of the executing system.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if big endianness is detected"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检测执行该函数的系统是大端还是小端。函数通过将一个特定的位模式移动到最高有效位，然后检查最低有效位是否为1来判断系统的端序。如果是大端系统，最低有效位应为1，函数返回TRUE；如果是小端系统，最低有效位应为0，函数返回FALSE。\n\n\n"}
{"title": "Value set point range check", "name": "LGF_IsValueInRange", "description": "The function checks whether a value is within a defined value range.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "range", "type": "LReal", "description": "Area where the setpoint is in range"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the “value” is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the “value” is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the “value” is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": [], "description_zh": "\n该函数用于检查一个给定的值是否位于设定点的指定范围内。函数接受三个输入参数：value（要检查的值），setpoint（设定点），range（设定点的有效范围）。函数将计算设定点的上下限，并判断value是否位于这个范围内。如果value大于上限或小于下限，相应的输出overHighLimit或belowLowLimit将被置为TRUE。如果value在范围内，函数返回TRUE。如果输入值超出数据范围，函数将返回错误状态ERR_RANGE_LIMIT_VALUES。函数不使用ENO机制进行错误处理，而是通过error和status输出进行错误报告。\n\n\n"}
{"title": "CRC-16 Calculator", "name": "LGF_CalcCRC16", "description": "The function calculates the CRC value from a data stream for error detection at data transmission.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据CRC-16算法计算数据流校验值，以便在数据传输过程中进行错误检测。函数接收初始值、生成多项式掩码和要用于CRC计算的数据元素数量作为输入，并返回计算出的CRC值。它还输出错误标志和状态码，指示是否发生错误。函数内部使用XOR函数和移位操作来实现CRC计算过程。\n\n\n"}
{"title": "DWORD rising edge counting", "name": "LGF_CountRisInDWord", "description": "The function analyzes a variable of the type DWORD and outputs how often a 0-1 sequence (rising edge) occurs in the variable.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the rising edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of rising edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块用于分析和计算一个DWORD类型变量中0-1序列（上升沿）出现的次数。函数块接收一个DWORD类型的输入值，并输出其中上升沿的数量。\n\n在每次执行时，函数块会比较当前周期的输入值与上一周期的输入值，以检测上升沿。具体来说，它会检查当前周期的输入值的最低位是否为1，而上一周期的输入值的次低位是否为0，如果是这种情况，则认为检测到一个上升沿，并将计数器加一。\n\n然后，函数块会通过一个循环，逐位检查输入值的每一位，重复上述检测过程。如果某一位的值为1，而前一位的值为0，则认为检测到一个上升沿，并将计数器再次加一。\n\n最后，函数块将当前周期的输入值复制到用于保存上一周期输入值的变量中，以便在下一周期进行比较。\n\n输出结果为Int类型的numberOfEdges，表示在DWORD变量中检测到的上升沿的总数。\n\n\n"}
{"title": "Random DInt Range Number Generator", "name": "LGF_RandomRange_DInt", "description": "This function generates a random value in defined limits with each call. The random number has the data type DInt in the specified range.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "DInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random DInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数FC用于生成一个指定范围内的随机DInt数值。函数接收两个DInt类型的输入参数：minValue和maxValue，分别代表随机数范围的下限和上限。函数会根据系统时间生成一个随机数，并确保该随机数在minValue和maxValue之间。如果minValue大于maxValue，函数将返回一个错误状态ERR_MAX_LESS_MIN。函数还会检查读取系统时间的操作是否成功，如果失败，将返回错误状态ERR_RD_SYS_T。成功执行后，函数返回一个在指定范围内的随机DInt数，并设置状态为STATUS_FINISHED_NO_ERROR。\n\n\n"}
{"title": "ISO 8601 calendar week calculation", "name": "LGF_GetCalendarWeek_ISO", "description": "This function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for ISO 8601 European countries.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于根据ISO 8601标准计算指定日期的日历周数和该日期距离年初的天数。函数考虑了欧洲国家遵循的ISO 8601标准，即新的一周从周一开始，每年的第一周包含该年的第一个星期四，一年有52或53周。函数还会检查前一年是否有53周，并根据1月1日的星期几对已过的天数进行校正。如果计算出的日期周数小于1，则需要根据前一年是否有53周来确定是第53周还是第52周。同样，如果计算出的周数为53周，则需要检查当年是否有53周来确定是第53周还是第1周。函数返回日历周数，并输出计算过程中是否发生错误的状态信息。\n\n\n"}
{"title": "Bit set operation in DWORD", "name": "LGF_BitSet", "description": "This block sets a bit at a given position in a variable of the data type DWORD.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with the set bit"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于在DWORD类型的数据中设置指定位置的位。函数接收两个输入参数：一个是需要设置位的DWORD值，另一个是要设置位的位置（bitNo）。函数会返回设置位后的DWORD值。位的编号从0开始，最大编号为31，对应DWORD的32位。如果输入的位编号超出范围，函数会自动取模运算，确保位编号在0到31之间。函数使用位移和按位或操作来实现位的设置。\n\n\n"}
{"title": "LReal Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_LReal", "description": "This function searches, in an array of the data type LReal, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "LReal", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于在LReal类型的数组中查找最小值和最大值，并返回它们在数组中的相应索引。函数接受一个LReal类型的数组作为输入，并输出四个值：最小值、最小值索引、最大值和最大值索引。函数首先获取数组的上下界，然后从数组的第二个元素开始遍历，比较每个元素的值，记录下最小值和最大值及其索引。最后，将找到的最小值和最大值以及它们的索引复制到输出参数中。\n\n\n"}
{"title": "LWord Endianness Adjuster", "name": "LGF_SwapBlockLWord", "description": "Adjusts/switches the endianness of multibyte data typed values.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of LWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于调整多字节数据类型值的字节序。函数接收一个LWord类型的数组作为输入，并原地（in-place）调整数组中每个LWord元素的字节序。调整过程是将每个LWord的高字节和低字节进行交换，以实现大端和小端字节序之间的转换。函数不关心原始系统或目标系统的字节序，因此可以通用使用。函数没有返回值，调整后的数组通过输入输出参数data返回。\n\n\n"}
{"title": "自动化灌装生产线控制", "description": "一个自动化灌装生产线负责对瓶子进行清洗、灌装、封盖和包装。生产线的每个步骤都由PLC控制，并且由传感器和操作员的输入信号触发。\n控制要求：\n当传感器bottleSensor检测到瓶子时，触发清洗泵启动并持续工作。\n清洗完成后，由操作员操作按钮cleaningConfirmButton触发清洗完成信号，自动启动灌装阀进行灌装。\n灌装完成后，由操作员操作按钮fillingConfirmButton触发灌装完成信号，自动启动封盖机进行封盖。\n封盖完成后，由操作员操作按钮cappingConfirmButton触发封盖完成信号，启动包装机进行包装。\n包装完成后，由操作员操作按钮packingConfirmButton触发包装完成信号，点亮包装完成指示灯。\n操作员取走包装好的瓶子后，按下确认按钮finishedButton复位指示灯，并为下一个瓶子的生产循环做准备。", "type": "FUNCTION_BLOCK", "name": "FB_BottleProcessing", "input": [{"name": "bottleSensor", "type": "Bool", "description": "瓶子到达传感器，检测到瓶子时触发信号"}, {"name": "cleaningConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认清洗工序完成"}, {"name": "fillingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认灌装工序完成"}, {"name": "cappingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认封盖工序完成"}, {"name": "packingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认包装工序完成"}, {"name": "finishedButton", "type": "Bool", "description": "操作员确认按钮，用于确认瓶子已取走"}], "output": [{"name": "Pump_Motor", "type": "Bool", "description": "控制清洗泵电机的运行输出"}, {"name": "Filling_Valve", "type": "Bool", "description": "控制灌装阀的运行输出"}, {"name": "Capping_Machine", "type": "Bool", "description": "控制封盖机的运行输出"}, {"name": "Packing_Machine", "type": "Bool", "description": "控制包装机的运行输出"}, {"name": "Completion_Light", "type": "Bool", "description": "包装完成指示灯"}]}
{"title": "String Position Finder in Character Array", "name": "LGF_FindStringInCharArray", "description": "The function searches for a specified String within an array of characters. Returning the position of the String in the Array, if the string is not found the return value is -1.", "type": "FUNCTION", "input": [{"name": "searchFor", "type": "String", "description": "Text that is searched for"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "DInt", "description": "Position (index) of the first character of the text that is searched for within the input array (index zero based). Return -1 if nothing found."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，该函数在一个字符数组中搜索指定的字符串，并返回字符串在数组中的位置。如果字符串未找到，则返回值为-1。函数接受三个参数：要搜索的字符串（searchFor），在数组中开始搜索的位置（startPos）以及要搜索的字符数组（searchIn）。函数会检查输入的数组是否为字符或字节类型，如果不是，则终止执行并返回错误状态ERR_NO_ARRAY。如果输入有效，函数会从指定的起始位置开始，将数组中的字符转换为字符串，并在其中搜索指定的字符串。如果找到字符串，则返回字符串在数组中的位置；如果未找到，则返回-1。\n\n\n"}
{"title": "16位二进制数分解为四个4位二进制数", "description": "在一些数据处理和通信应用中，需要将一个16位的二进制数分解成四个独立的4位二进制数。例如，在数据编码、解码或与外部系统的数据交换时，可能需要这种分解操作。\n控制要求：\n系统需要接收一个16位的二进制数InputWord作为输入。\n将输入的16位二进制数分解成四个4位的二进制数，分别对应输入数的最低位到最高位。\n输出这四个4位二进制数到独立的变量Byte0~Byte3中。\n同时对这4个变量Byte0~Byte3中非0的变量求取平均值，并输出到average。\n例如，InputWord=16#1203，则Byte0=3，Byte1=0，Byte2=2，Byte3=1，那么平均值average=(1+2+3)/3", "type": "FUNCTION_BLOCK", "name": "FB_SplitWordIntoBytes", "input": [{"name": "InputWord", "type": "Word", "description": "16位二进制数输入"}], "output": [{"name": "Byte0", "type": "Byte", "description": "最低的4位二进制数输出"}, {"name": "Byte1", "type": "Byte", "description": "次低的4位二进制数输出"}, {"name": "Byte2", "type": "Byte", "description": "次高的4位二进制数输出"}, {"name": "Byte3", "type": "Byte", "description": "最高的4位二进制数输出"}, {"name": "average", "type": "Real", "description": "四个字节中非零字节的平均值"}]}
{"title": "Histogram Calculation Function Block for Real Data", "name": "LGF_Histogram_LReal", "description": "The histogram shows the frequency distribution of a sample by class with real values.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_LReal`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算包含实数（LReal）数据系列的直方图。该直方图通过类（class）显示样本的频率分布。函数块接受一个布尔型输入execute，表示是否执行计算，以及一个无符号整型输入numberOfClasses，表示期望的类数量。函数块的输出包括一个布尔型错误标志error，一个字型状态status，一个字型子函数状态subfunctionStatus，一个二维LReal数组histValues，用于显示相对频率和类中心，一个LReal数组axis，用于指定轴值，以及一个LReal型输出classWidth，返回计算出的类宽度。函数块还接受一个LReal数组values作为输入/输出参数，包含用于计算的数据系列。\n\n当execute输入信号有上升沿时，函数块开始执行计算。首先，它检查输入的类数量是否在允许的范围内（1到15之间）。然后，它计算数组values中的元素数量，并对数组进行排序。接下来，函数块识别数组中的最大值和最小值，并计算类宽度。它遍历排序后的数组，统计每个类中的值数量，并计算相对频率。最后，函数块找到每个类的中间值，并将所有计算结果复制到输出数组中。\n\n函数块的状态码包括执行完成无错误、没有调用、第一次调用和类数量错误等。子函数状态码用于指示调用的子函数的状态或返回值。\n\n\n"}
{"title": "String to Time Converter", "name": "LGF_StringToTime", "description": "The function converts a variable of the data type String into a variable of the system data type Time.", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "String", "description": "Time to be converted as string Example: 1D3H45M6S0MS"}], "output": [], "in/out": [], "return_value": [{"type": "Time", "description": "Converted time value Example: T#1D_3H_45M_6S"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将字符串转换为系统数据类型Time的时间值。该函数能够处理包含天、小时、分钟、秒和毫秒的时间字符串，并按照指定格式转换。字符串中的每个时间单位前必须有一个数字，且时间单位之间可以包含任意数量的空格。转换后的时间值将按照Time数据类型表示。\\n\\n示例：\\n假设输入的时间字符串为\\\"1D3H45M6S0MS\\\"，函数应返回T#1D_3H_45M_6S_0MS作为转换结果。\n\n\n"}
{"title": "Value Tolerance Checker by Time", "name": "LGF_IsValueInToleranceByTime", "description": "Checks if a given value is within a specified tolerance in percent of a given set point.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "Lower limit/tolerance of the setpoint in percent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "Upper limit/tolerance of the setpoint in percent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUE_CALC", "16#8402": "ERR_SETPOINT_ABOVE_HIGH_LIMIT", "16#8403": "ERR_SETPOINT_BELOW_LOW_LIMIT"}, "user_defined_types": [{"name": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters", "member": [{"name": "disableLimits", "type": "Bool", "default": "FALSE", "description": "TRUE: Disable the monitoring timer. Leaving the tolerance triggers immediately"}, {"name": "limitsAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Limit given as absolut value / FALSE: Limits given as tolerance from setpoint"}, {"name": "toleranceAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Toleranze given as absolut value / FALSE: Toleranze in percent from Setpoint"}, {"name": "upperLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the upper limit violation"}, {"name": "lowerLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the lower limit violation"}, {"name": "setpointChangeMonitoringTime", "type": "Time", "default": "T#20S", "description": "Monitoring time for setpoint changes"}]}], "description_zh": "\n一个函数块FB，用于检查给定的值是否在设定点的指定百分比范围内。该FB可以配置为使用绝对值或百分比来表示容差，并提供监控时间以检测设定点变化、上限违反和下限违反。如果值超出设定的容差范围，FB将输出相应的信号。此外，如果设定点发生变化，FB也会进行检测并输出信号。\n\n\n"}
{"title": "System time, local time, and time zone setting", "name": "LGF_SetTime", "description": "This block combines the functions of system time, local time, and set time zone.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "systemTime", "type": "DTL", "description": "System time to be set in PLC"}, {"name": "isLocalTime", "type": "Bool", "description": "TRUE: `systemTime` is local time, FALSE: `systemTime` is UTC time"}, {"name": "timeZone", "type": "Int", "description": "Timezones HHMM [-1200.. -330.. 0.. 930.. 1200.. 1300]"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time changeover, TRUE: activated, FALSE: deactivated"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "lastSetTimeZone", "type": "String", "description": "Time zone that was set last by this block"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_SET_TIME_LOCAL", "16#8202": "ERR_SET_TIME_UTC", "16#8203": "ERR_SET_TIMEZONE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_WRONG_TIMEZONE"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于设置PLC的系统时间、本地时间以及时区。当\"execute\"输入信号出现上升沿时，FB开始执行操作。如果\"isLocalTime\"输入为TRUE，则\"systemTime\"输入被视为本地时间；如果为FALSE，则视为UTC时间。还可以设置时区（\"timeZone\"）和夏令时（\"isDaylightSavingTime\"）。\n\n函数块FB具有以下输出：\n- \"done\"：表示操作是否成功完成。\n- \"busy\"：表示FB是否正在执行操作。\n- \"error\"：表示是否在执行过程中发生错误。\n- \"lastSetTimeZone\"：返回上次设置的时区名称。\n- \"status\"：返回FB的状态或错误代码。\n- \"subFunctionStatus\"：返回调用子函数的状态或返回值。\n\n状态代码：\n- 16#0000：STATUS_EXECUTION_FINISHED_NO_ERROR - 操作完成且没有错误。\n- 16#7000：STATUS_NO_CALL - FB没有被调用。\n- 16#7001：STATUS_FIRST_CALL - FB被第一次调用。\n- 16#7002：STATUS_SUBSEQUENT_CALL - FB被后续调用。\n- 16#8201：ERR_SET_TIME_LOCAL - 设置本地时间时出错。\n- 16#8202：ERR_SET_TIME_UTC - 设置UTC时间时出错。\n- 16#8203：ERR_SET_TIMEZONE - 设置时区时出错。\n- 16#8600：ERR_UNDEFINED_STATE - 达到未定义的状态。\n- 16#8601：ERR_WRONG_TIMEZONE - 时区参数错误。\n\n\n"}
{"title": "Value Min/Max Storer", "name": "LGF_StoreMinMax", "description": "This function reads-in a value of a variable at each call and outputs the maximum and minimum value that has been read in since the first call.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation starts over again."}], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n这个函数块FB，在每次调用时接收一个LReal类型的变量值，并输出自第一次调用以来读取的最大值和最小值。如果输入参数'reset'为TRUE，则最小/最大值的历史记录将被重置，评估将重新开始。\n\n示例：\\n\\n假设首次调用时输入值为10.5，第二次调用时输入值为5.2，第三次调用时输入值为20.7，第四次调用时'reset'为TRUE，第五次调用时输入值为3.8。\\n则输出的最小值'minValue'为3.8，最大值'maxValue'为20.7。\n\n\n"}
{"title": "Gray to Binary Code Converter", "name": "LGF_GrayToBinary", "description": "This function converts a gray coded value into a binary coded value.", "type": "FUNCTION", "input": [{"name": "variableGray", "type": "DWord", "description": "Gray coded value to convert to binary value"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Binary value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将格雷码编码的值转换为二进制编码的值。格雷码是一种数字系统，其中相邻数值的二进制表示只有一个位不同，这样可以减少在数字信号中的错误。该函数接受一个DWord类型的格雷码输入值，并返回一个DWord类型的二进制值作为输出。函数使用了一系列的位移和异或操作来实现转换。\n\n\n"}
{"title": "Boxplot Calculation for Integer Data", "name": "LGF_Boxplot_DInt", "description": "Use a Boxplot diagram to get an overview of existing data.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": [], "description_zh": "\n一个函数块FB，该函数块能够对整数数据数组进行排序，并计算盒须图所需的统计量，包括最大值、最小值、四分位数（Q25、中位数、Q75）、异常值和偏度。函数块在接收到执行信号时开始计算，并使用另一个名为LGF_ShellSort_DInt的函数块进行排序。计算结果包括异常值，这些异常值是根据输入参数rangeOutlier来确定的。如果rangeOutlier参数大于1.0或等于0.0，则认为数据中的值是异常值。函数块还计算了数据系列的偏度，偏度描述了数据分布的对称性。\n\n\n"}
{"title": "Julian Date to DTL Time Converter", "name": "LGF_JulianTimeToDTL", "description": "This function converts a given Julian Date (regular or modified) of data type LReal (Double) to a date and time of data type DTL. The timestamp is calculated based on UTC.", "type": "FUNCTION", "input": [{"name": "julianDate", "type": "LReal", "description": "Julian date to convert (standard or modified, depends on isModifiedDate)"}, {"name": "isModifiedDate", "type": "Bool", "description": "TRUE: julianDate is the modified Julian date FALSE: julianDate is the regular Julian date"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error DTL default value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将儒略日（标准或修改后的）转换为数据类型为DTL的日期时间值。转换基于UTC时间，不考虑时区。只有1990年1月1日之后的时间才被允许。\\n\\n示例：\\n假设输入的儒略日为2459754.5（对应于2021年12月1日中午12点），isModifiedDate为FALSE。\\n函数应返回DTL类型的日期时间值，表示2021年12月1日中午12点。\\n\\n如果输入的儒略日小于或等于2440587.5（对应于1990年1月1日之前的某个时间点），函数将返回一个错误状态ERR_TIME_BEFORE_1990，表示时间在1990年之前不被支持。如果输入的儒略日刚好等于2440587.5，函数将返回一个警告状态WARN_CONVERSION_LIMIT，表示时间刚好在支持范围的下限。\n\n\n"}
{"title": "Random UDInt Number Generator", "name": "LGF_Random_UDInt", "description": "This function generates a random value with each call. The random number has the data type UDInt.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random number in the UDInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n该函数功能是生成一个随机数，类型为UDInt。它的工作原理是读取系统时间，并使用纳秒部分的值来生成随机数。具体来说，它将系统时间的纳秒值转换为一个双字（DWord），然后通过位运算来重新组合这个双字的不同字节，从而生成一个随机值。这个随机值最终被转换为UDInt类型并返回。如果读取系统时间时出现错误，函数将返回一个错误标志和状态码。\n\n\n"}
{"title": "Binary mask comparison", "name": "LGF_BinaryMaskCompare", "description": "This function compares two binary values source and compare by a given mask.", "type": "FUNCTION", "input": [{"name": "source", "type": "DWord", "description": "Source value to compare"}, {"name": "compare", "type": "DWord", "description": "Value to compare against"}, {"name": "mask", "type": "DWord", "description": "Mask the data - bits will pass if TRUE or block if FALSE"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Return TRUE if masked values are equal"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个32位二进制数值source和compare，比较过程中使用一个掩码mask来决定哪些位参与比较。函数的返回值为布尔类型，当且仅当在掩码指定的位上，source和compare的值完全相同时，返回值为真（TRUE）。如果掩码中某位为0，则该位不参与比较；如果为1，则该位参与比较。这种比较方式可以用于字（Word）或字节（Byte），只需将要比较的参数转换为DWord类型即可。\n\n\n"}
{"title": "Endianness Detection Function for Little Endian", "name": "LGF_IsLittleEndian", "description": "Detects the endianness of the executing system.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if little endianness is detected"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于检测执行程序的系统是否为小端字节序。函数通过将一个字（Word）类型的数据左移15位，然后检查最低位是否为0来判断系统的字节序。如果最低位为0，则认为系统是小端字节序，函数返回TRUE；否则返回FALSE。\n\n\n"}
{"title": "DWORD bit count operation", "name": "LGF_BitCount", "description": "This block counts in a variable of type DWord how many bits are set (TRUE) and how many are not set (FALSE) and outputs the number at the outputs.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of Byte=8, Word=16, DWord=32"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于统计一个DWORD类型变量中设置为1（真）和设置为0（假）的位的数量，并分别输出这两个数量。输入参数包括要统计的DWORD值和一个表示输入值中位数数量的USInt类型参数。输出的两个USInt类型参数分别表示设置为假的位数数量和设置为真的位数数量。函数通过遍历输入值的每个位，并使用位移操作来判断每一位的状态，最后统计真和假位的数量。\n\n\n"}
{"title": "WString to UTF-8 Byte Stream Encoder", "name": "LGF_EncodeUtf8", "description": "Encodes a WString into an UTF-8 encoded byte stream.", "type": "FUNCTION", "input": [{"name": "sourceString", "type": "WString", "description": "Character that shall be converted to UTF-8"}, {"name": "startPos", "type": "DInt", "description": "Position in encoded byte stream to start insert encoded WChars (Array lower bound is added)"}], "output": [{"name": "bytesUsed", "type": "UInt", "description": "Number of Bytes converted. Ranges from 1 to 3."}], "in/out": [{"name": "encodedByteStream", "type": "Array[*] of Byte", "description": "UTF-8 conformant byte sequence."}], "return_value": [{"type": "Word", "description": "Status of the FC, Erroridentification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将宽字符串（WString）编码为UTF-8编码的字节流。函数接收一个宽字符串和一个起始位置作为输入，从该位置开始在输出的字节流数组中插入编码后的宽字符。函数还会返回一个状态值，指示转换是否成功，以及实际使用的字节数。\\n\\n示例：\\n假设输入的宽字符串为\\\"你好世界\\\"，自定义起始位置为0，编码后的字节流应存储在输出的字节流数组中。函数应返回状态值STATUS_NO_ERROR，表示转换成功，并返回实际使用的字节数作为输出。\n\n\n"}
{"title": "Standalone Data Logger with Advanced Configuration", "name": "LGF_DataLogC", "description": "Function integrates all the datalog system functions and can be used as standalone data logger.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if `parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and lists all possible parameter to configure its behaviour."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set, start from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [{"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#7010": "STATUS_MAX_ENTRIES_REACHED", "16#8401": "ERR_WRONG_COMMAND_CALL_ORDER", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_DATALOG_OPEN", "16#8602": "ERR_DATALOG_CREATE", "16#8603": "ERR_DATALOG_CLOSE", "16#8604": "ERR_DATALOG_WRITE", "16#8605": "ERR_DATALOG_DELETE"}, "user_defined_types": [{"name": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module LGF_DataLogC and lists all possible parameter to configure its behaviour.", "member": [{"name": "header", "type": "String", "default": "", "description": "Headline of datalog, string of all data fields, separated by a comma: \"field1,field2,field3,...\""}, {"name": "maxNumberOfEntries", "type": "UDInt", "default": "1000", "description": "Maximum number of entries in datalog"}, {"name": "timestampFormat", "type": "USInt", "default": "0", "description": "Timestamp format"}, {"name": "clearOnOpen", "type": "Bool", "default": "FALSE", "description": "Clear datalog during opening datalog while enabling block"}, {"name": "deleteFile", "type": "Bool", "default": "FALSE", "description": "Delete as well datalog file during datalog delete"}, {"name": "enableRingBuffer", "type": "Bool", "default": "FALSE", "description": "TRUE: Overwrite old values and start from the beginning if datalog reaches its maximum entries FALSE: Stop logging if `maxNumberOfEntries` entries reached"}, {"name": "loggingByInterval", "type": "Bool", "default": "FALSE", "description": "TRUE: Log on interval time parameter FALSE: log on \"triggerEntry\""}, {"name": "loggingInterval", "type": "Time", "default": "T#1M", "description": "Time for automatic logging interval"}]}, {"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}], "description_zh": "\n一个独立的、具有高级配置功能的数据记录器FB，该函数块集成了所有数据记录系统功能，可以用作独立的数据记录器。\\n\\n主要功能：\\n1. 启用或禁用数据记录功能。\\n2. 设置数据记录的名称，该名称也用作文件名。\\n3. 通过上升沿触发数据记录中的一个条目（仅当`parameter.isLoggingByInterval` := FALSE时）。\\n4. 清除数据记录文件。\\n5. 删除数据记录文件（如果存在）。\\n6. 通过配置参数`parameter`，可以设置数据记录的行为，例如最大条目数、时间戳格式、是否清除旧条目等。\\n\\n示例：\\n假设数据记录被命名为\\\"MyDataLog\\\"，最大条目数为1000，时间戳格式为YYYY-MM-DD HH:MM:SS，如果达到最大条目数，则启用环形缓冲区，并覆盖旧的条目。\\n在这种情况下，数据记录器将创建一个名为\\\"MyDataLog\\\"的文件，其中包含1000个条目，并按照指定的时间戳格式记录数据。\n\n\n"}
{"title": "File Reading from UserFiles Folder", "name": "LGF_FileRead", "description": "This function block offers reading data as binary / serialized data stream from files stored on the PLC's memory card in the folder UserFiles.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "dataLengthMustMatch", "type": "Bool", "description": "The length of the file data set and the dataset in the PLC have to match."}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8411": "ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE", "16#8412": "ERR_FILE_SIZE_LESS_THEN_DATA_SIZE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8602": "ERR_DATA_SERIALIZE", "16#8603": "ERR_DATA_DESERIALIZE", "16#8604": "ERR_FILE_READ_INIT", "16#8605": "ERR_FILE_READ"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}], "description_zh": "\n一个函数块FB，该函数块提供从PLC的存储卡中位于UserFiles文件夹中的文件读取二进制/序列化数据流的功能。它具有以下特性：\\n\\n1. 通过在\\\"execute\\\"输入上检测上升沿来启动文件读取操作。\\n2. 如果\\\"dataLengthMustMatch\\\"输入为真，则文件数据集的长度必须与PLC中的数据集长度相匹配。\\n3. 使用\\\"fileName\\\"输入指定要读取的文件名，包括路径，例如：`UserFiles/test.dat`。\\n4. 读取完成后，\\\"done\\\"输出置为真，表示操作成功完成。\\n5. 如果函数块正在执行，\\\"busy\\\"输出为真。\\n6. 如果执行过程中发生错误，\\\"error\\\"输出为真，\\\"status\\\"输出包含了错误识别的状态代码。\\n7. \\\"dataLength\\\"输出包含了从文件中读取的数据长度（\\\"data\\\"的序列化长度）。\\n8. 使用\\\"bufferByteArray\\\"输入/输出参数作为读取/写入文件的字节数组缓冲区。\\n9. 使用\\\"data\\\"输入/输出参数存储从文件中读取的数据集。\\n\\n状态代码：\\n16#0000：STATUS_EXECUTION_FINISHED - 执行完成\\n16#7000：STATUS_NO_CALL - 没有调用\\n16#7001：STATUS_FIRST_CALL - 首次调用\\n16#7002：STATUS_SUBSEQUENT_CALL - 后续调用\\n16#8201：ERR_BUFFER_LOWERBOUND - 缓冲区下限错误\\n16#8202：ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY - 缓冲区数组太小无法复制\\n16#8401：ERR_FILE_PATH - 文件路径错误\\n16#8411：ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE - 文件大小大于数据大小\\n16#8412：ERR_FILE_SIZE_LESS_THEN_DATA_SIZE - 文件大小小于数据大小\\n16#8600：ERR_UNDEFINED_STATE - 未定义状态\\n16#8601：ERR_MOVE_BLK_VARIANT - 移动块变量错误\\n16#8602：ERR_DATA_SERIALIZE - 数据序列化错误\\n16#8603：ERR_DATA_DESERIALIZE - 数据反序列化错误\\n16#8604：ERR_FILE_READ_INIT - 文件读取初始化错误\\n16#8605：ERR_FILE_READ - 文件读取错误\n\n\n"}
{"title": "Polynomial Smoothing Function", "name": "LGF_SmoothByPolynomFC", "description": "This function calculates the smoothed values by polynomial acyclically.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算输入数组的平滑值。该函数使用多项式方法进行非周期性平滑，并输出平滑后的值数组。函数接受两个数组作为输入：values数组包含要平滑的原始值，smoothedValues数组用于存放平滑后的结果。函数会检查输入数组的长度，如果长度不匹配或长度不足，函数将返回错误状态。如果输入数组长度足够，函数将对每个元素应用多项式平滑公式，并存储结果在smoothedValues数组中。函数没有返回值，但会通过输出参数error和status报告执行状态。\n\n\n"}
{"title": "Matrix Multiplier", "name": "LGF_MatrixMultiplication", "description": "This function multiplies two matrices of the data type ARRAY[*,*] of LREAL.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First factor: Matrix to multiply"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second factor: Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Product: The resulting matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR2_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR2_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算两个LREAL类型的二维数组（矩阵）的乘积。函数接受两个输入矩阵和一个用于存放结果的输出矩阵。在执行乘法之前，函数首先检查输入矩阵的维度是否兼容，即第一个矩阵的列数是否等于第二个矩阵的行数。如果维度不兼容，函数将设置错误标志并返回相应的状态代码。如果维度兼容，函数将计算乘积并将结果存储在输出矩阵中。最后，函数清除错误标志并返回状态代码，指示操作成功完成。\n\n\n"}
{"title": "Byte to 8-Bit Splitter", "name": "LGF_SplitByteToBits", "description": "This function splits a Byte variable into 8 Boolean / 8 Bit variables.", "type": "FUNCTION", "input": [{"name": "byte", "type": "Byte", "description": "Bit sequence to be split"}], "output": [{"name": "bit7", "type": "Bool", "description": "Output Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC的功能是将一个字节类型的变量分割成8个布尔型/位变量。输入参数为一个字节（byte），输出参数为8个布尔型变量，分别代表该字节的最高位到最低位。\n\n\n"}
{"title": "Moving Average Calculation Function Block", "name": "LGF_FloatingAverage", "description": "This function calculates a moving arithmetic mean value from REAL values.", "type": "FUNCTION_BLOCK", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Read in `value` with every pulse at input `trigger`"}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be determined."}, {"name": "windowSize", "type": "Int", "description": "Window length for sliding averaging in the range from 1..100. The standard value is 100."}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts again."}], "output": [{"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached, TRUE: Maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR: Execution finished without errors", "16#8200": "ERR_WRONG_WINDOW_SIZE: Incorrect window size/width set."}, "user_defined_types": [], "description_zh": "\n一个函数块FB，用于计算一系列REAL类型数值的移动平均值。该函数块可以配置为周期性执行或由触发信号触发。它接受一个REAL类型的数值，并计算其移动平均值，窗口大小（即用于计算平均值的数值数量）可以在1到100之间调整，默认值为100。如果窗口大小改变或重置信号为TRUE，计算将重新开始。函数块还提供指示窗口大小是否已达到的输出，以及错误和状态信息。如果窗口大小设置不正确，将返回错误状态。函数块使用数组存储窗口内的数值，并在每次计算时更新平均值。\n\n\n"}
{"title": "Word to 2-Byte Splitter", "name": "LGF_SplitWordToBytes", "description": "This function splits a Word variable into 2 Byte variables.", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "byte1", "type": "Byte", "description": "Output Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将一个Word类型的变量分割成两个Byte类型的变量。Word变量是一个16位的位序列，该函数将其分割为高字节（MSB）和低字节（LSB），并分别输出。高字节包含Word变量的高8位，低字节包含Word变量的低8位。\\n\\n示例：\\n假设输入的Word值为16#2A3C。\\n函数应返回高字节为2A（16进制），低字节为3C（16进制）。\n\n\n"}
{"title": "Sinusoidal Signal Generator", "name": "LGF_SinusCI", "description": "This function generates a sinusoidal signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个正弦波形信号。它利用调用它的循环中断OB的时间间隔来计算每个周期内的正弦值。函数块接受以下输入参数：振幅（amplitude，默认为1.0）、偏移量（offset，默认为0.0）、周期（periode，默认为1000毫秒）、相位偏移（phaseShift，默认为0.0）、调用OB（callOB）和重置信号（reset，默认为FALSE）。函数块将计算出的正弦值输出为当前值（value），并提供错误状态（error）、状态码（status）和子函数状态码（subFunctionStatus）。如果发生错误，错误状态将被设置为TRUE，状态码将指示错误类型。正常情况下，状态码将设置为STATUS_FINISHED_NO_ERROR（16#0000）。如果调用OB不可用，将返回ERR_OB_UNAVAILABLE（16#8600）错误；如果查询循环中断OB时出现错误，将返回ERR_QRY_CINT（16#8601）错误。\n\n\n"}
{"title": "控制台指示灯顺序控制", "description": "某控制台装有3个指示灯，分别为绿色、红色和黄色。需要通过一个控制按钮来循环控制这些灯的状态。\n控制要求：\n使用一个输入参数controlButton表示控制按钮的状态，该按钮为脉冲信号，每次触发时产生一个从0到1的跳变。\n使用三个输出参数greenLight、redLight、yellowLight分别来控制对应的绿色、红色和黄色指示灯。\n控制按钮触发的顺序和对应指示灯的状态如下：\n第1次触发：只有绿灯greenLight亮。\n第2次触发：只有红灯redLight亮。\n第3次触发：只有黄灯yellowLight亮。\n第4次触发：3个灯都亮。\n第5次触发：3个灯都灭。\n第6次触发及以后：重复上述循环。", "type": "FUNCTION_BLOCK", "name": "FB_ColorLightControl", "input": [{"name": "controlButton", "type": "Bool", "description": "控制按钮开关，脉冲信号"}], "output": [{"name": "greenLight", "type": "Bool", "description": "绿色指示灯"}, {"name": "redLight", "type": "Bool", "description": "红色指示灯"}, {"name": "yellowLight", "type": "Bool", "description": "黄色指示灯"}]}
{"title": "LReal numbers comparison with variable precision", "name": "LGF_CompareLRealByPrecision", "description": "This function checks floating point numbers for equality, by using an approximation formula and a given precision.", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}, {"name": "precision", "type": "LReal", "description": "Accuracy with which the two values are compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数用于比较两个LReal类型的浮点数是否近似相等。函数通过比较两个数的差值与给定的精度参数之间的关系来判断它们是否相等。如果差值小于或等于精度乘以两个输入数中的一个，则认为这两个数近似相等。函数的返回值为布尔类型，FALSE表示不相等，TRUE表示近似相等。\n\n\n"}
{"title": "DWord Endianness Adjuster", "name": "LGF_SwapBlockDWord", "description": "Adjusts/switches the endianness of multibyte data typed values.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of DWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于调整/交换多字节数据类型值的字节序。该函数接收一个DWord数组作为输入，并对数组中的每个DWord值进行字节序调整。调整过程是通过遍历数组元素并在每个元素上内部交换字节来完成的。此函数不关心原始系统或目标系统的字节序，从而允许在各个系统上通用使用。函数没有返回值，调整后的数组通过输入/输出参数data直接修改。\n\n\n"}
{"title": "DWord to 32-Bit Splitter", "name": "LGF_SplitDWordToBits", "description": "This function splits a DWord variable into 32 Boolean / 32 Bit variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "bit31", "type": "Bool", "description": "Output Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Output Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Output Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Output Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Output Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Output Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Output Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Output Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Output Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Output Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Output Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Output Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Output Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Output Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Output Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Output Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Output Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数FC的功能是将一个32位双字（DWord）类型的变量分割成32个布尔型/位变量。输入参数为一个DWord类型的变量，输出为32个布尔型变量，分别代表DWord变量的第31位到第0位（最高有效位到最低有效位）。\n\n示例：\n假设输入的双字变量值为2#10101010000000000000000000000000。\n则输出的32个布尔型变量应分别为：\n- bit31: TRUE\n- bit30: FALSE\n- bit29: TRUE\n- bit28: FALSE\n- bit27: TRUE\n- bit26: FALSE\n- bit25: FALSE\n- bit24: FALSE\n- ... (中间略)\n- bit2: FALSE\n- bit1: FALSE\n- bit0: FALSE\n\n\n"}
{"title": "灯控程序", "description": "编写一个函数块FB，实现一个灯控功能。\n某控制台有3个指示灯，要求通过3个按钮开关进行控制。\n\n1. 输入参数#button1~#button3表示3个按钮开关，输出参数#greenLight、#redLight、#yellowLight表示指示灯。\n2. 当#button1=0时，表示手动模式，指示灯根据#button2和#button3的操作组合进行不同状态显示：\n   - 当#button2和#button3都为0时，所有指示灯熄灭（#greenLight、#redLight、#yellowLight都为0）。\n   - 当#button2为1且#button3为0时，#greenLight常亮，并且#redLight以0.5Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2为0且#button3为1时，#redLight常亮，并且#yellowLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2和#button3都为1时，#yellowLight常亮，并且#greenLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n3. 当#button1=1时，表示自动模式，指示灯自动按照如下说明循环执行：\n   - 首先#greenLight亮，保持1秒。\n   - 然后#greenLight熄灭，#redLight亮，保持1秒。\n   - 然后#redLight熄灭，#yellowLight亮，保持1秒。\n   - 然后回到初始状态#greenLight亮，保持1秒，如此循环。", "type": "FUNCTION_BLOCK", "name": "FB_LightsControl", "input": [{"name": "button1", "type": "Bool", "description": "按钮1"}, {"name": "button2", "type": "Bool", "description": "按钮2"}, {"name": "button3", "type": "Bool", "description": "按钮3"}], "output": [{"name": "greenLight", "type": "Bool", "description": "绿灯"}, {"name": "redLight", "type": "Bool", "description": "红灯"}, {"name": "yellowLight", "type": "Bool", "description": "黄灯"}]}
{"title": "String comparison operation", "name": "LGF_CompareString", "description": "Compares two strings and returns a number which indicates the result of the comparison.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "left", "type": "String", "description": "Left / first string to compare"}, {"name": "right", "type": "String", "description": "Right / second string to compare"}], "return_value": [{"type": "SInt", "description": "Return values: left < right := -1; left > right := 1; left == right := 0"}], "status_codes": {"0": "RETURN_STRINGS_ARE_EQUAL Strings are equal", "1": "RETURN_STRING_LEFT_GREATER_THAN_RIGHT Left string is greater than right string", "-1": "RETURN_STRING_LEFT_LESS_THAN_RIGHT Left string is less than right string"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于比较两个字符串，并返回一个表示比较结果的数值。如果第一个字符串小于第二个字符串，则返回-1；如果第一个字符串大于第二个字符串，则返回1；如果两个字符串相等，则返回0。\n\n\n"}
{"title": "GPS DMS to GPS-DD Converter", "name": "LGF_GpsToGpsDD", "description": "This function converts a given GPS data type (format direction, degrees, minutes, and seconds) into a GPS-DD data type (decimal degrees).", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS", "description": "GPS-Data to be converted (direction, degrees, minutes, and seconds)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS_DD", "description": "Converted GPS-Data (decimal degrees)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8200": "ERR_LATITUDE_DIRECTION", "16#8201": "ERR_LATITUDE_VALUE", "16#8202": "ERR_LONGITUDE_DIRECTION", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}, {"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}], "description_zh": "\n该函数FC用于将GPS坐标从度分秒（DMS）格式转换为十进制度（DD）格式。函数接受一个输入参数gps，该参数包含经纬度的方向、度、分和秒信息。函数将计算这些值并将其转换为十进制度数值，存储在返回值item中。如果输入的方向信息无效，或者在转换过程中出现其他错误，函数将设置错误标志error，并提供相应的状态码status。函数支持北纬（N）、南纬（S）、东经（E）和西经（W）的转换，并能够处理度、分、秒的值在合理范围内的输入。如果输入值超出范围，函数将返回错误。\n\n\n"}
{"title": "Array element counting", "name": "LGF_CountArrayElements", "description": "Count the number of array elements and returns the number of elements zero based (Array[0..x] of Type).", "type": "FUNCTION", "input": [{"name": "array", "type": "Variant", "description": "Input array to check for number of elements"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of elements in array (zero based); Returning `-1` if input variable is not type `array`; Returning `-2` if input variable is type `bool`"}], "status_codes": {"-1": "RETURN_NO_ARRAY No array is present at the input `array`", "-2": "RETURN_NO_BOOL_ARRAYS_NOT_SUPPORTED Boolean arrays not supported"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于计算输入数组中的元素数量，并以零为基返回元素的数量（即Array[0..x]的类型）。如果输入变量不是数组类型，则返回-1；如果输入变量是布尔数组，则返回-2。该函数不处理布尔数组。\n\n\n"}
{"title": "Random Real Number Generator", "name": "LGF_Random_Real", "description": "This function generates a random value with each call. The random number has the data type Real in the range from 0.0 to 1.0.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number between 0.0 and 1.0"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": [], "description_zh": "\n这是一个函数FC，它能够在每次调用时生成一个0.0到1.0之间的随机实数。函数使用了系统时间中的纳秒部分来生成随机数，首先将纳秒值转换为DWORD类型，然后通过位操作重新组合这个DWORD值，最后将其转换成实数类型并归一化到0.0到1.0的范围。函数还提供了错误处理机制，如果读取系统时间出错，会设置错误标志并返回相应的状态码。\n\n\n"}
{"title": "Matrix Transposer", "name": "LGF_MatrixTranspose", "description": "This function transposes a matrix of the data type ARRAY[*,*] of LREAL.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Matrix to be transposed"}, {"name": "matrixTranspose", "type": "Array[*, *] of LReal", "description": "Transposed matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_COLUMNS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_COLUMNS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_ROWS"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于转置一个数据类型为ARRAY[*,*]的LREAL矩阵。该函数不接受任何输入参数，但有两个输出参数：错误标志（error）和状态码（status）。函数有两个In/Out参数：要转置的矩阵（matrix）和转置后的矩阵（matrixTranspose）。转置操作会将矩阵的行转换为列，列转换为行。\\n\\n示例：\\n假设输入矩阵为一个2x3的矩阵，如下：\\n1.0  2.0  3.0\\n4.0  5.0  6.0\\n转置后的矩阵应该是一个3x2的矩阵，如下：\\n1.0  4.0\\n2.0  5.0\\n3.0  6.0\n\n\n"}
{"title": "3D distance calculation between points", "name": "LGF_CalcDistance_3D", "description": "The function calculates the distance between two points in 3D space.", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "z1", "type": "LReal", "description": "Z coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}, {"name": "z2", "type": "LReal", "description": "Z coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数用于计算三维空间中两点之间的距离。函数接受两个点的三维坐标作为输入，分别是第一点的x1、y1、z1坐标和第二点的x2、y2、z2坐标。计算距离的公式为两点坐标差的平方和的平方根。函数返回计算出的距离值。\n\n\n"}
{"title": "German Traditional Date String to DTL Converter", "name": "LGF_StringToDTL_DE", "description": "This function converts a character string in the traditional format (DE) with date components into the data type DTL.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数能够将符合德国传统日期格式（DD-MM-YYYY HH:MM:SS.nnnnnnnnn）的字符串转换为DTL数据类型。函数会检查输入字符串的格式，并在格式错误时返回错误状态和错误代码。如果转换成功，它会返回一个包含转换后的日期和时间的DTL值。\\n\\n示例：\\n假设输入的字符串为\\\"17-09-2023 12:34:56.123456789\\\"。\\n函数应返回一个DTL值，其中包含2023年9月17日12时34分56秒和123456789纳秒。\n\n\n"}
{"title": "UDInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_UDInt", "description": "This function searches, in an array of the data type UDInt, for the maximum and minimum value and the respective index in the array.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，该函数在一个无符号双整数数组中搜索最小和最大值，并返回这些值在数组中的索引。函数接受一个数组作为输入，该数组的类型为UDInt。函数执行后，将输出最小值、最小值的索引、最大值和最大值的索引。\\n\\n示例：\\n假设输入数组为{10, 30, 25, 50, 15}。\\n函数应返回最小值为10，索引为1；最大值为50，索引为4。\n\n\n"}
{"title": "Matrix Addition", "name": "LGF_MatrixAddition", "description": "This block adds two matrices of equal size of the data type ARRAY[*,*] of LREAL.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First summand (matrix)"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second summand (matrix)"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": [], "description_zh": "\n该函数用于计算两个相同大小的LREAL类型矩阵的和。输入为两个矩阵，输出为一个包含两矩阵和的矩阵。在计算和之前，会检查两个矩阵的大小是否完全一致，如果大小不一致，则报错并返回错误状态。如果大小一致，则将两个矩阵对应位置的元素相加，并将结果写入输出矩阵。函数没有返回值。\n\n\n"}
{"title": "Frequency Signal Generator", "name": "LGF_Frequency", "description": "This function generates a signal that changes between the values FALSE and TRUE depending on a defined frequency and a pulse pause ratio.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}, {"name": "pulsePauseRatio", "type": "Real", "description": "1.0"}], "output": [{"name": "clock", "type": "Bool", "description": "Output changes with defined frequency."}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current clock state."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个频率信号，该信号在设定频率和脉冲暂停比的条件下，在FALSE和TRUE之间变化。输入参数包括频率（Real型，默认值为0.0）和脉冲暂停比（Real型，默认值为1.0）。输出包括一个时钟信号（Bool型）和一个倒计时（Time型），表示当前时钟状态的剩余时间。函数块内部使用两个TOF_TIME类型的定时器来实现脉冲和暂停的时间控制。当输入频率或脉冲暂停比发生变化时，会重新计算脉冲和暂停时间，并通过两个定时器相互重置来生成时钟信号。当脉冲定时器运行时，倒计时表示脉冲剩余时间；当脉冲定时器不运行时，倒计时表示暂停剩余时间。函数块不使用ENO机制进行错误处理，而是强制ENO为真。\n\n\n"}
{"title": "Triangular Signal Generator", "name": "LGF_TriangleCI", "description": "This function generates a triangular signal profile. For this it uses the time interval of the calling Cyclic Interrupt OB.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the triangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": [], "description_zh": "\n该函数块FB用于生成一个三角波信号。它利用调用它的循环中断OB的时间间隔来生成信号。三角波信号的振幅、偏移、周期和相位偏移都可以通过输入参数进行调整。如果发生错误，例如OB不可用或查询循环中断错误，函数块会返回错误状态和相应的子功能状态。输出的value参数将提供当前三角波信号的值。\n\n\n"}
{"title": "DTL to UNIX Time Converter", "name": "LGF_DTLToUnixTime", "description": "This function converts the date and time of data type DTL to the UNIX time of data type DInt. The timestamp is calculated in UTC.", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to UNIX time"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted UNIX time"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_TIME_BEFORE_1990", "16#8001": "ERR_DTL_INPUT_VALUE_INVALID"}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将数据类型为DTL的日期时间值转换为UNIX时间戳，UNIX时间戳的数据类型为DInt。该时间戳是根据UTC时间计算的，不考虑时区。此函数只能处理1990年1月1日之后的时间。如果输入的时间早于这个日期，函数将返回一个错误状态。\n\n函数的输入是一个DTL类型的日期时间值。输出包括一个布尔类型的错误标志和一个Word类型的错误状态代码。如果转换成功，函数返回一个DInt类型的UNIX时间戳。\n\n状态代码：\n- 16#0000：转换完成，没有错误\n- 16#8000：时间早于1990年\n- 16#8001：输入的DTL值无效\n\n\n"}
{"title": "Celsius to Kelvin Converter", "name": "LGF_CelsiusToKelvin", "description": "This function converts a temperature value - from °Celsius to °Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Kelvin"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将摄氏温度转换为开尔文温度。函数接受一个实数类型的输入参数，表示摄氏温度，并返回一个实数类型的输出，表示相应的开尔文温度。转换公式为：开尔文温度 = 摄氏温度 + 273.15。\n\n\n"}
{"title": "Fahrenheit to Celsius Converter", "name": "LGF_FahrenheitToCelsius", "description": "This function converts a temperature value - from °Fahrenheit to °Celsius.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Celsius"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将华氏温度转换为摄氏温度。函数接受一个实数类型的输入参数，表示华氏温度，并返回一个实数类型的值，表示相应的摄氏温度。转换公式为：(华氏温度 - 32) / 1.8 = 摄氏温度。\\n\\n示例：\\n假设输入的华氏温度为98.6°F。\\n函数应返回37.0°C作为转换结果。\n\n\n"}
{"title": "Rankine to Kelvin Converter", "name": "LGF_RankineToKelvin", "description": "This function converts a temperature value - from °Rankine to °Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in °Rankine"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in °Kelvin"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n一个函数FC，用于将温度值从兰金温标(°Rankine)转换为开尔文温标(°Kelvin)。转换公式为：开尔文温度 = (5/9) * 兰金温度。其中，兰金温度为函数输入参数，开尔文温度为函数返回值。\n\n\n"}
{"title": "PLC数据库数据存储与管理系统", "description": "在一些自动化应用中，PLC需要收集和存储大量的数据，例如传感器读数、生产计数或其他过程变量。这些数据通常存储在PLC的内部数据库或外部数据库系统中。\n控制要求：\n系统需要接收一组数据dataInput，以字节数组构建，这组数据的第一个字节dataInput[0]表示要存入的数据字节长度。\n数据的存储操作由输入storeTrigger触发。\n数据需要依次存入数据库，每组数据长度可能不同。\n当数据库剩余空间不足以存入新的一组数据时，系统应触发报错error。\n系统应提供一个复位功能，通过输入resetTrigger来清空数据库，并重置error。\n系统应能够输出数据库的当前使用情况和剩余空间。\n说明：\n1. 当存储信号storeTrigger触发时，首先检查数据输入长度信息（即数组的首字节dataInput[0]）是否非法，如果小于等于0或大于5，则输出错误状态error=true和错误代码status=16#8001。如果数据库剩余空间不足以存入新数据，则输出错误状态error=true和错误代码status=16#8002。如果没有这些错误，则根据长度信息，把从输入数组的第二字节开始的数据取出，并存入数据库。存入时不能覆盖数据库原有的数据，从原有数据之后依次存入。\n2. 当复位信号resetTrigger触发时，清空数据库中所有数据，并复位错误状态error=0和status=0。\n3. 数据库已使用空间和剩余空间分别通过usedSpace和remainingSpace输出。", "type": "FUNCTION_BLOCK", "name": "FB_DatabaseManager", "input": [{"name": "dataInput", "type": "Array[0..5] of Byte", "description": "数据输入，字节数组"}, {"name": "storeTrigger", "type": "Bool", "description": "存储触发信号"}, {"name": "resetTrigger", "type": "Bool", "description": "复位触发信号"}], "output": [{"name": "usedSpace", "type": "Int", "description": "数据库已使用空间"}, {"name": "remainingSpace", "type": "Int", "description": "数据库剩余空间"}, {"name": "error", "type": "Bool", "description": "错误状态指示\nFALSE:没有发生错误\nTRUE:执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "dataBase", "type": "Array[1..20] of Byte", "description": "数据库，字节数组"}]}
{"title": "IEC_Timer implementation", "name": "LGF_IecTimerOnOff", "description": "The Block implements an IEC_Timer TON and TOF", "type": "FUNCTION_BLOCK", "input": [{"name": "in", "type": "Bool", "description": "FALSE Boolean Input value"}, {"name": "timeOnDelay", "type": "Time", "description": "T#0s Preset Time on Delay"}, {"name": "timeOffDelay", "type": "Time", "description": "T#0s Preset Time off Delay"}], "output": [{"name": "out", "type": "Bool", "description": "Delayed Input signal from input `in`"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [], "description_zh": "\n该函数块实现了一个IEC定时器，该定时器同时具有上升沿（TON）和下降沿（TOF）功能。当输入信号（in）为FALSE时，定时器不动作。当输入信号变为TRUE时，上升沿定时器（TON）开始计时，当计时达到预设时间（timeOnDelay）后，输出信号（out）变为TRUE。当输入信号再次变为FALSE时，下降沿定时器（TOF）开始计时，当计时达到预设时间（timeOffDelay）后，输出信号（out）变为FALSE。该函数块适用于需要延迟开启或关闭功能的场合。\n\n\n"}
{"title": "Shift Register for Datatype Variant", "name": "LGF_ShiftRegister", "description": "The Function represents a shift register for any kind of Datatype (using variant). It is possible to shift the elements in the array at bufferRegister to the left or right.", "type": "FUNCTION_BLOCK", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted left."}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted right."}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the bufferRegister input array"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in bufferRegister with initalItem"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the array at input bufferRegister is initialized."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_CLEARING_WITHOUT_INITIAL_ITEM", "16#8202": "ERR_FILL_WITHOUT_INITIAL_ITEM", "16#8203": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8401": "ERR_MORE_THAN_ONE_COMMAND", "16#8402": "ERR_IN_SHIFT_RANGE", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_SHIFT_BUFFER_LEFT", "16#8612": "ERR_SHIFT_BUFFER_LEFT_FILL", "16#8622": "ERR_SHIFT_BUFFER_RIGHT_FILL"}, "user_defined_types": [], "description_zh": "\n该函数块FB实现了一个可变数据类型的移位寄存器功能，可以左移或右移数组bufferRegister中的元素。它能够处理多种数据类型，并提供了清除缓冲区和使用初始项填充缓冲区的功能。\n\n输入参数包括：\n- shiftLeft (Bool): 上升沿触发时，将bufferRegister数组中的元素向左移。\n- shiftRight (Bool): 上升沿触发时，将bufferRegister数组中的元素向右移。\n- shiftRange (UInt): 指定移位的位数。\n- clear (Bool): 清除bufferRegister中的元素，并用initialItem初始化。\n- fill (Bool): 移位操作后，使用initialItem覆盖bufferRegister中的元素。\n- initialItem (Variant): 用于初始化bufferRegister数组的值。\n\n输出参数包括：\n- error (Bool): 执行FB过程中是否发生错误。\n- status (Word): FB的状态和错误识别。\n- subFunctionStatus (Word): 被调用FB、FC和系统块的返回值或状态。\n\nInOut参数包括：\n- bufferRegister (Variant): 作为数组的缓冲区/寄存器内存，用于保持数据。\n\n函数块执行逻辑：\n1. 检测边缘触发，如果shiftLeft、shiftRight或clear同时为真，则报告错误。\n2. 检查bufferRegister是否为数组，并获取数组元素的数量。\n3. 检查移位位数是否在有效范围内。\n4. 如果clear为真，则使用initialItem初始化bufferRegister数组。\n5. 如果移位操作（shiftLeft或shiftRight）为真，则执行相应的移位操作。\n6. 如果fill为真，则使用initialItem填充移位后的bufferRegister数组。\n7. 设置输出参数，表示操作是否成功。\n\n状态代码：\n- 16#0000: STATUS_NO_ERROR\n- 16#7000: STATUS_NO_CURRENT_JOBS\n- 16#8200: ERR_NO_ARRAY\n- 16#8201: ERR_CLEARING_WITHOUT_INITIAL_ITEM\n- 16#8202: ERR_FILL_WITHOUT_INITIAL_ITEM\n- 16#8203: ERR_WRONG_TYPE_INITIAL_ITEM\n- 16#8401: ERR_MORE_THAN_ONE_COMMAND\n- 16#8402: ERR_IN_SHIFT_RANGE\n- 16#8610: ERR_CLEAR_BUFFER\n- 16#8611: ERR_SHIFT_BUFFER_LEFT\n- 16#8612: ERR_SHIFT_BUFFER_LEFT_FILL\n- 16#8622: ERR_SHIFT_BUFFER_RIGHT_FILL\n\n\n"}
{"title": "String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArray", "description": "The function extracts a String specified by a text before and after from an array of characters.", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Status of the FB"}], "status_codes": {"16#0000": "STATUS_TEXT_FOUND", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": [], "description_zh": "\n该函数用于从字符数组中提取由前后文本指定的字符串。函数接受两个字符串参数（textBefore 和 textAfter）来指定要提取的字符串的前后文本，并返回提取的字符串和状态。如果数组是一个字符或字节类型的数组，函数将继续执行，否则程序将终止。如果找到了指定的前后文本，函数将返回找到的字符串和状态“STATUS_TEXT_FOUND”，如果在找到起始文本但未找到结束文本，则返回状态“WARNING_ONLY_START”，如果未找到任何文本，则返回状态“WARNING_NOTHING_FOUND”。\n\n\n"}
{"title": "Advanced String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArrayAdv", "description": "The function extracts a String specified by a text before and after from an array of characters with extended options.", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "TRUE: textBefore and textAfter are included in the extracted string"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "position", "type": "DInt", "description": "Position (index) within the array where text begins (index zero based)"}, {"name": "length", "type": "Int", "description": "Length of text that was extracted"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Return value: Status of the FB"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": [], "description_zh": "\n该函数用于从字符数组中提取一个由前后文本指定的字符串，并具有扩展选项。函数接受两个字符串参数textBefore和textAfter，用于指定要提取的字符串的前后文本。参数includeBeforeAfter决定是否在提取的字符串中包含前后文本。参数startPos指定在数组中开始搜索的位置（基于零的索引）。函数输出extractedString为提取的字符串，position为文本在数组中的起始位置（基于零的索引），length为提取文本的长度，status为函数块的状态。\n\n函数首先验证输入是否为字符或字节数组，并读取数组元素的数量。然后，它使用一个循环搜索数组，尝试找到与textBefore匹配的文本。如果找到了textBefore，它会根据includeBeforeAfter参数调整位置，并创建一个新的字符串以搜索textAfter。如果找到了textAfter，它会根据includeBeforeAfter参数截取字符串，并更新输出参数。如果在数组结束时没有找到textAfter，它会输出从textBefore之后开始的整个字符串。\n\n函数的状态码有STATUS_NO_ERROR表示没有错误，ERR_NO_ARRAY表示输入不是数组，WARNING_ONLY_START表示只找到了起始文本，WARNING_NOTHING_FOUND表示没有找到任何文本。\n\n\n"}
