{"title": "String Upper Case Converter", "name": "LGF_ToUpper", "description": "This function converts the lowercase letters of a string into their capital equivalents.", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": [], "description_zh": "\n FUNCTION \"LGF_ToUpper\" : String\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : 'Siemens Industry Online Support'\nFAMILY : LGF\nNAME : LGF_ToUpper\n   VAR_INPUT \n      In : String;\n   END_VAR\n\n   VAR_TEMP \n      tempCurrentCharIndex : UInt;\n      tempStringLength : UInt;\n      tempCurrentChar : Char;\n      tempResult : String;\n   END_VAR\n\n   VAR CONSTANT \n      TO_UPPER_OFFSET : USInt := 32;\n      LOWER_CASE_A : Char := 'a';\n      LOWER_CASE_Z : Char := 'z';\n      FIRST_CHARACTER_POSITION : UInt := 1;\n      NEXT_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2023\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_ToLower\n\t  // Comment/Function: This function converts the capital letters of a string into their lower case equivalents.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V4.0\n\t  // Engineering:      TIA Portal V16.0\n\t  // Restrictions:     ENO mechanism is not used, no error handling\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t(/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALIZATION\n\t  // 首先我们清理结果字符串，以避免返回随机数据\n\t  #tempResult := '';\n\t  #tempCurrentChar := '$00';\n\t  \n\t  // 为了避免连续的系统调用到LEN，我们只获取一次字符串长度\n\t  // 因为它在转换过程中不会改变\n\t  #tempStringLength := INT_TO_UINT(LEN(#In));\n\t  \n\t  // 我们从字符串的开始处开始转换。字符串的第一个索引是1（不是基于零的计数）\n\t  #tempCurrentCharIndex := #FIRST_CHARACTER_POSITION;\n\tEND_REGION\n\t\n\tREGION CONVERSION  \n\t  WHILE #tempCurrentCharIndex <= #tempStringLength DO\n\t    // 我们检查字符串中索引位置的字符\n\t    // 它的ASCII码必须在'a'和'z'（包括）之间才能进行转换\n\t    IF TRUE\n\t      AND #LOWER_CASE_A <= #In[#tempCurrentCharIndex]\n\t      AND #In[#tempCurrentCharIndex] <= #LOWER_CASE_Z\n\t    THEN\n\t      // 字符位于要转换的ASCII码范围内\n\t      // 让我们将其转换为大写\n\t      #tempCurrentChar := USINT_TO_CHAR(CHAR_TO_USINT(#In[#tempCurrentCharIndex]) - #TO_UPPER_OFFSET);\n\t    ELSE\n\t      // 字符不是转换的对象。因此，我们只将其复制到结果字符串中\n\t      #tempCurrentChar := #In[#tempCurrentCharIndex];\n\t    END_IF;\n\t    // 将缓冲区字符（可能已转换）附加到结果字符串\n\t    #tempResult := CONCAT(IN1 := #tempResult,\n\t                          IN2 := #tempCurrentChar);\n\t    // 移动到字符串中的下一个字符\n\t    #tempCurrentCharIndex += #NEXT_POSITION;\n\t  END_WHILE;\n\tEND_REGION\n\t\n\t// 返回转换后的字符串作为函数结果\n\t#LGF_ToUpper := #tempResult;\n\tENO := TRUE;\n\t\nEND_FUNCTION\n            \n "}