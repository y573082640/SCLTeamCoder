{"title": "International Date String to DTL Converter", "name": "LGF_StringToDTL_ISO", "description": "This function converts a character string in international format with date components into the data type DTL.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_JOB", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": [], "description_zh": "\n            FUNCTION \"LGF_StringToDTL_ISO\" : DTL\n{ S7_Optimized_Access := 'TRUE' }\nAUTHOR : Siemens_Digital_Industry\nFAMILY : LGF\nNAME : LGF_StringToDTL_ISO\n   VAR_INPUT \n      \"date\" : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempIndex : DInt;\n      tempDateAndTime  : DTL;\n      tempDateString : String;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      STATUS_NO_JOB : Word := 16#7000;\n      ERR_FORMAT_YEAR : Word := 16#8201;\n      ERR_FORMAT_MONTH : Word := 16#8202;\n      ERR_FORMAT_DAY : Word := 16#8203;\n      ERR_FORMAT_HOUR : Word := 16#8204;\n      ERR_FORMAT_MINUTE : Word := 16#8205;\n      ERR_FORMAT_SECOND : Word := 16#8206;\n      ERR_FORMAT_NANOSECOND : Word := 16#8207;\n      INITIAL_VALUE  : DTL := DTL#1970-01-01-00:00:00.0;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_DECIMAL : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n      CONVERT_START_POSITION_YEAR : SInt := 1;\n      CONVERT_START_POSITION_MONTH : SInt := 6;\n      CONVERT_START_POSITION_DAY : SInt := 9;\n      CONVERT_START_POSITION_HOUR : SInt := 12;\n      CONVERT_START_POSITION_MINUTE : SInt := 15;\n      CONVERT_START_POSITION_SECOND : SInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : SInt := 21;\n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      YEAR_MIN : UInt := 1970;\n      YEAR_MAX : UInt := 2262;\n      MONTH_MIN : USInt := 1;\n      MONTH_MAX : USInt := 12;\n      DAY_MIN : USInt := 1;\n      DAY_MAX : USInt := 31;\n      HOUR_MIN : USInt := 0;\n      HOUR_MAX : USInt := 23;\n      SECOND_MINUTE_MIN : USInt := 0;\n      SECOND_MINUTE_MAX : USInt := 59;\n      NANOSECOND_MIN : UDInt := 0;\n      NANOSECOND_MAX : UDInt := 999999999;\n      NANOSECOND_FOR_COUNTER : DInt := 9;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // SIEMENS AG / (c)Copyright 2019\n\t  //-------------------------------------------------------------------------------\n\t  // Title:            LGF_StringToDTL_ISO\n\t  // Comment/Function: This function converts a character string in international format\n\t  //                   with date components into the data type DTL.\n\t  // Library/Family:   LGF (Library General Functions)\n\t  // Author:           Siemens Digital Industry Support\n\t  // Tested with:      S7-PLCSIM Advanced V2.0 SP1\n\t  // Engineering:      TIA Portal V15.1\n\t  // Restrictions:     ENO mechanism is not used, Error handling done by error and status\n\t  // Requirements:     PLC (S7-1200 / S7-1500)\n\t  //-------------------------------------------------------------------------------\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION CONVERTER\n\t  IF #date = '' THEN\n\t    #error := true;\n\t    #status := #STATUS_NO_JOB;\n\t    #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t    RETURN;\n\t  END_IF;\n\t  \n\t  // Set format parameters for input string\n\t  // International ISO 8601\n\t  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  REGION YEAR\n\t    // Separating the input string into components of DTL\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_YEAR, P := #CONVERT_START_POSITION_YEAR);\n\t    // Converting separated String components into DTL values\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.YEAR,\n\t             P      := #CONVERT_START_POSITION);\n\t    // Format check\n\t    IF (#tempDateAndTime.YEAR < #YEAR_MIN) OR (#YEAR_MAX < #tempDateAndTime.YEAR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_YEAR;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MONTH\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MONTH);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MONTH,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MONTH < #MONTH_MIN) OR (#MONTH_MAX < #tempDateAndTime.MONTH) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MONTH;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION DAY\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_DAY);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.DAY,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.DAY < #DAY_MIN) OR (#DAY_MAX < #tempDateAndTime.DAY) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_DAY;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION HOUR\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_HOUR);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.HOUR,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.HOUR < #HOUR_MIN) OR (#HOUR_MAX < #tempDateAndTime.HOUR) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_HOUR;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION MINUTE\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MINUTE);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.MINUTE,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.MINUTE < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.MINUTE) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_MINUTE;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION SECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_SECOND);\n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.SECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.SECOND < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.SECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_SECOND;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  REGION NANOSECOND\n\t    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_NANOSECOND, P := #CONVERT_START_POSITION_NANOSECOND);\n\t    // Replacing of the \"blan\" in the nanosecond string by \"0\"\n\t    // Effect:   xx.1 --> xx.1 AND NOT xx.1 --> xx.000000001\n\t    FOR #tempIndex := 1 TO #NANOSECOND_FOR_COUNTER DO\n\t      IF #tempDateString[#tempIndex] = ' ' THEN\n\t        #tempDateString[#tempIndex] := '0';\n\t      END_IF;\n\t    END_FOR;\n\t    \n\t    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,\n\t             IN     := #tempDateString,\n\t             OUT    => #tempDateAndTime.NANOSECOND,\n\t             P      := #CONVERT_START_POSITION);\n\t    \n\t    IF (#tempDateAndTime.NANOSECOND < 0) OR (999999999 < #tempDateAndTime.NANOSECOND) THEN\n\t      #error := TRUE;\n\t      #status := #ERR_FORMAT_NANOSECOND;\n\t      #LGF_StringToDTL_ISO := #INITIAL_VALUE;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION\n\t  \n\t  // Correction of the weekday of DTL\n\t  #tempDateAndTime := #tempDateAndTime + t#0ms;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #LGF_StringToDTL_ISO := #tempDateAndTime;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  // no error handling needed because of error bit output\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n            \n "}