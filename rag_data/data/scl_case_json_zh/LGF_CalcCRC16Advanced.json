{"title": "Advanced CRC-16 Calculator", "name": "LGF_CalcCRC16Advanced", "description": "The function calculates the CRC value with additional parameters for error detection at data transmission.", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Word", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": [], "description_zh": "\n该函数\"LGF_CalcCRC16Advanced\"用于计算一个高级的CRC-16值，它提供了更多的参数来增强数据传输过程中的错误检测能力。函数接受以下输入参数：initValue（Word），用于设置计算的初始值；mask（Word），用于指定计算的生成多项式；finalXorValue（Word），用于最终XOR操作的值；reflectInput（Bool），指示是否需要对输入字节进行位镜像；reflectResult（Bool），指示是否需要对结果的位顺序进行镜像；noOfElements（UInt），指示在CRC计算中要使用的元素数量。\n\n函数的输出包括：error（Bool），表示错误标志；status（Word），表示状态码。\n\n函数还有一个In/Out参数：array（Array[*] of Byte），表示要计算CRC值的数据流。\n\n函数的返回值是一个Word类型的变量，表示计算出的CRC值。\n\n函数的状态码包括：16#0000表示执行没有出错；16#8400表示输入的元素数量参数错误。\n\n函数首先对输入数据进行处理，包括初始化CRC值、计算输入数组的尺寸、检查元素数量参数是否合理等。然后，函数通过循环遍历数组中的每个元素，对每个元素执行CRC计算。在计算过程中，函数根据reflectInput参数决定是否对输入字节进行位镜像。CRC计算是通过将输入字节的最高位移入CRC值的最高字节，然后对CRC值进行移位和XOR操作来实现的。在计算完所有元素后，函数根据reflectResult参数决定是否对结果的位顺序进行镜像，并执行最终的XOR操作。最后，函数将计算出的CRC值、错误标志和状态码赋值给输出参数。\n\n整个函数的执行过程中没有使用ENO进行错误处理，而是通过error和status参数来指示函数执行的状态。\n\n\n"}