{"variables": ["1. name: byteStream, type: Array[*] of Byte, initial: None, role: Input byte array that contains the UTF-8 encoded byte stream.", "2. name: startPos, type: DInt, initial: None, role: The starting position in the byte stream from where decoding should begin.", "3. name: count, type: UInt, initial: None, role: The number of characters to decode, if 0 then decode until the end of the stream.", "4. name: decodedString, type: WString, initial: None, role: In/Out parameter, the resulting decoded string after function execution.", "5. name: tempString, type: WString, initial: '', role: Temporary WString used to build the decoded string.", "6. name: tempStatus, type: Word, initial: STATUS_NO_ERROR, role: Holding the status of the decoding process.", "7. name: tempCodepoint, type: DWord, initial: None, role: Temporary variable to store the current code point during decoding.", "8. name: tempPos, type: DInt, initial: startPos, role: Temporary position tracker in the byte stream.", "9. name: tempLowerBound, type: DInt, initial: None, role: Holding the lower bound index of the byte stream array.", "10. name: tempUpperBound, type: DInt, initial: None, role: Holding the upper bound index of the byte stream array.", "11. name: tempMaxLen, type: DInt, initial: None, role: Holding the maximum length for the decoded string."], "instructions": ["CONCAT", "DWORD_TO_WCHAR", "SHL", "UPPER_BOUND", "LOWER_BOUND", "MAX_LEN", "LEN"], "planning": "# Step1. Initialize the temporary variables tempString, tempStatus, tempPos, tempLowerBound, tempUpperBound, and tempMaxLen.\n# Step2. Check if the input parameters startPos, count are within valid ranges, update tempStatus accordingly.\n# Step3. If no errors, enter a REPEAT loop to process each byte in the byteStream.\n# Step4. Inside the loop, check if the tempString has reached its maximum length, and update tempStatus if needed.\n# Step5. Determine how many bytes the current character is encoded with and calculate the codepoint accordingly.\n# Step6. Handle different character encoding lengths (1 to 4 bytes), update tempCodepoint and tempPos.\n# Step7. If the calculated codepoint is greater than MAX_CODEPOINT, replace it with REPLACEMENT_CHAR and update tempStatus.\n# Step8. Concatenate the decoded character to tempString.\n# Step9. Continue the loop until either the specified count of characters has been decoded or the end of the byte stream is reached.\n# Step10. If an error occurred, set decodedString to an empty string, otherwise, assign tempString to decodedString.\n# Step11. Set the ENO status and return tempStatus as the function result.", "name": "LGF_DecodeUtf8"}