{"variables": ["1. name: initValue, type: DWord, initial: 16#00, role: Initial value for CRC calculation.", "2. name: mask, type: DWord, initial: 16#00, role: Generator polynomial for CRC calculation.", "3. name: finalXorValue, type: DWord, initial: 16#00, role: Value for final XOR operation.", "4. name: reflectInput, type: Bool, initial: FALSE, role: Determines if input byte bits should be mirrored.", "5. name: reflectResult, type: Bool, initial: FALSE, role: Determines if result bits order should be mirrored.", "6. name: noOfElements, type: UInt, initial: 0, role: Number of elements to be used in CRC calculation.", "7. name: error, type: Bool, initial: Not directly initialized, role: Error flag for the function.", "8. name: status, type: Word, initial: Not directly initialized, role: Status code for the function.", "9. name: array, type: Array[*] of Byte, initial: Not applicable, role: Data stream for CRC calculation.", "10. name: tempInput, type: Byte, initial: Not directly initialized, role: Temporary variable to hold input byte for manipulation.", "11. name: tempCRC, type: DWord, initial: Not directly initialized, role: Temporary variable to hold intermediate CRC value.", "12. name: tempInvCRC, type: DWord, initial: Not directly initialized, role: Temporary variable to hold the inverted CRC value if needed.", "13. name: tempLowerLimit, type: DInt, initial: Not directly initialized, role: Temporary variable to hold the lower limit of array index.", "14. name: tempUpperLimit, type: DInt, initial: Not directly initialized, role: Temporary variable to hold the upper limit of array index.", "15. name: tempIndexArray, type: DInt, initial: Not directly initialized, role: Index variable for array iteration.", "16. name: tempIndexCRC, type: DInt, initial: Not directly initialized, role: Index variable for CRC bit iteration."], "instructions": ["SHL", "XOR", "BYTE_TO_DWORD", "LOWER_BOUND", "UPPER_BOUND"], "planning": "# Step1. Initialize the CRC value with `initValue`.\n# Step2. Calculate the size of the input array using LOWER_BOUND and UPPER_BOUND instructions.\n# Step3. Validate the `noOfElements` parameter against the array size and set error status if it does not fit.\n# Step4. Iterate through the array using a FOR loop, for each byte:\n# Step4.1. If required, reverse the bit order of the input byte.\n# Step4.2. XOR the current CRC value with the input byte shifted to the left by 24 bits.\n# Step4.3. Iterate through each bit of the CRC value using a nested FOR loop:\n# Step4.3.1. If the MSB of the CRC value is set, shift left and XOR with the `mask`, otherwise just shift left.\n# Step5. If required, reverse the bit order of the final CRC value.\n# Step6. XOR the final CRC value with `finalXorValue` and assign it as the function result.\n# Step7. Set the status to `STATUS_NO_ERROR` and clear the error flag.", "name": "LGF_CalcCRC32Advanced"}