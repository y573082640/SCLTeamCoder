{"variables": ["1. name: initValue, type: Word, initial: 16#00, role: Start value for CRC calculation.", "2. name: mask, type: Word, initial: 16#00, role: Generator polynomial for CRC calculation.", "3. name: finalXorValue, type: Word, initial: 16#00, role: Value for final XOR operation.", "4. name: reflectInput, type: Bool, initial: FALSE, role: Determines if the input byte should be mirrored.", "5. name: reflectResult, type: Bool, initial: FALSE, role: Determines if the result bits order should be mirrored.", "6. name: noOfElements, type: UInt, initial: 0, role: Number of elements to be used in CRC calculation.", "7. name: error, type: Bool, initial: Not directly initialized, role: Error flag for the function.", "8. name: status, type: Word, initial: Not directly initialized, role: Status code for the function.", "9. name: array, type: Array[*] of Byte, initial: Not applicable, role: Data stream for CRC calculation.", "10. name: tempInput, type: Byte, initial: Not directly initialized, role: Temporary variable for input byte manipulation.", "11. name: tempCRC, type: Word, initial: Not directly initialized, role: Temporary variable for CRC calculation.", "12. name: tempInvCRC, type: Word, initial: Not directly initialized, role: Temporary variable to hold the inverted CRC result.", "13. name: tempLowerLimit, type: DInt, initial: Not directly initialized, role: Temporary variable to hold the lower limit of the array.", "14. name: tempUpperLimit, type: DInt, initial: Not directly initialized, role: Temporary variable to hold the upper limit of the array.", "15. name: tempIndexArray, type: DInt, initial: Not directly initialized, role: Loop index for array iteration.", "16. name: tempIndexCRC, type: DInt, initial: Not directly initialized, role: Loop index for CRC bit manipulation."], "instructions": ["XOR", "SHL", "SHR", "LOWER_BOUND", "UPPER_BOUND", "BYTE_TO_WORD"], "planning": "# Step1. Initialize the temporary CRC variable with the initial value provided.\n# Step2. Calculate the size of the input array and check if the noOfElements fits within the array size.\n# Step3. If noOfElements is greater than zero and does not fit, set error flags and exit; otherwise adjust the tempUpperLimit.\n# Step4. Iterate over the array elements from tempLowerLimit to tempUpperLimit.\n# Step5. For each byte, if reflectInput is true, reverse the bit order; otherwise use the byte as is.\n# Step6. XOR the tempCRC with the current byte shifted left by one byte.\n# Step7. For each bit in the tempCRC (from 0 to 7), if the MSB is set, shift left and XOR with mask; otherwise just shift left.\n# Step8. After processing all bytes, if reflectResult is true, reverse the bit order of tempCRC to get tempInvCRC and XOR with finalXorValue; otherwise just XOR tempCRC with finalXorValue.\n# Step9. Assign the final CRC value to the function return variable, set status to no error, and clear the error flag.", "name": "LGF_CalcCRC16Advanced"}