{"variables": ["1. name: initValue, type: Byte, initial: 0x00, role: Initial value for the CRC calculation.", "2. name: mask, type: Byte, initial: 0x00, role: Generator polynomial for the CRC calculation.", "3. name: finalXorValue, type: Byte, initial: 0x00, role: Value for final XOR operation on the CRC result.", "4. name: reflectInput, type: Bool, initial: FALSE, role: Determines whether to mirror the bits within the input byte.", "5. name: reflectResult, type: Bool, initial: FALSE, role: Determines whether to mirror the order of bits within the CRC result.", "6. name: noOfElements, type: UInt, initial: 0, role: Number of elements to be used in CRC calculation.", "7. name: error, type: Bool, initial: Not applicable (output), role: Error flag indicating if an error has occurred.", "8. name: status, type: Word, initial: Not applicable (output), role: Status code providing information about the process.", "9. name: array, type: Array[*] of Byte, initial: Not applicable (in-out), role: Data stream for which the CRC value will be calculated.", "10. name: tempInput, type: Byte, initial: Not applicable (temp), role: Temporary variable to hold input byte for processing.", "11. name: tempCRC, type: Byte, initial: Not applicable (temp), role: Temporary variable holding the intermediate CRC calculation result.", "12. name: tempInvCRC, type: Byte, initial: Not applicable (temp), role: Temporary variable to hold the inverted CRC result.", "13. name: tempLowerLimit, type: DInt, initial: Not applicable (temp), role: Temporary variable to hold the lower limit of the array index range.", "14. name: tempUpperLimit, type: DInt, initial: Not applicable (temp), role: Temporary variable to hold the upper limit of the array index range.", "15. name: tempIndexArray, type: DInt, initial: Not applicable (temp), role: Index variable for looping through the array elements.", "16. name: tempIndexCRC, type: DInt, initial: Not applicable (temp), role: Index variable for looping through the bits of the CRC calculation."], "instructions": ["XOR", "SHL"], "planning": "# Step1. Initialize the CRC value with 'initValue'.\n# Step2. Calculate the input array size using LOWER_BOUND and UPPER_BOUND instructions.\n# Step3. Check if 'noOfElements' is greater than zero and within the range of the input array size. If not, set error status and return.\n# Step4. Loop through the array elements from 'tempLowerLimit' to 'tempUpperLimit'.\n# Step5. If 'reflectInput' is TRUE, reverse the bit order of the current array element. Otherwise, use the array element directly.\n# Step6. Perform XOR operation between the 'tempCRC' and 'tempInput' (current array element or its reversed version).\n# Step7. Loop through each bit of 'tempCRC' from the most significant bit to the least significant bit.\n# Step8. If the most significant bit of 'tempCRC' is set, shift 'tempCRC' left and perform XOR with 'mask'. If not, just shift 'tempCRC' left.\n# Step9. If 'reflectResult' is TRUE, reverse the bit order of 'tempCRC' and XOR with 'finalXorValue' to get the final CRC result. If FALSE, just XOR 'tempCRC' with 'finalXorValue'.\n# Step10. Set the status to 'STATUS_NO_ERROR' and clear the error flag. Return the CRC result.", "name": "LGF_CalcCRC8Advanced"}