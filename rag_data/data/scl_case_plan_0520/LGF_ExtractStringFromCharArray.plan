{"variables": ["1. name: textBefore, type: String, initial: None, role: Input text that is expected before the characters to be extracted.", "2. name: textAfter, type: String, initial: None, role: Input text that is expected after the characters to be extracted.", "3. name: extractedString, type: String, initial: '', role: Output string that contains the extracted characters.", "4. name: status, type: Word, initial: STATUS_NO_ERROR, role: Status code of the function block execution.", "5. name: searchIn, type: Variant, initial: None, role: Input array of Character or Byte to search in for the texts.", "6. name: tempNumElements, type: UDInt, initial: None, role: Temporary variable to hold the number of elements in the searchIn array.", "7. name: tempPosInArray, type: DInt, initial: 0, role: Temporary variable to keep track of the current position within the searchIn array.", "8. name: tempLenTextBefore, type: Int, initial: None, role: Temporary variable to store the length of textBefore.", "9. name: tempPosTextBefore, type: DInt, initial: 0, role: Temporary variable to store the position of textBefore in the searchIn array.", "10. name: tempLenTextAfter, type: Int, initial: None, role: Temporary variable to store the length of textAfter.", "11. name: tempPosTextAfter, type: DInt, initial: 0, role: Temporary variable to store the position of textAfter in the searchIn array.", "12. name: tempString, type: String, initial: None, role: Temporary variable to store strings extracted from the searchIn array for processing."], "instructions": ["Chars_TO_Strg", "FIND", "LEFT", "UDINT_TO_UINT", "MIN"], "planning": "# Step1. Initialize temporary variables and output variables.\n# Step2. Validate the input array to check whether it is an ARRAY and its elements are of CHAR or BYTE type.\n# Step3. If validation fails, set the status to ERR_NO_ARRAY and exit the function.\n# Step4. Search for the textBefore in the input array using a loop and Chars_TO_Strg to convert array elements to a string.\n# Step5. If textBefore is found, adjust the position to look for textAfter immediately following textBefore.\n# Step6. Search for the textAfter in the substring starting from the end of textBefore.\n# Step7. If textAfter is found, extract the string between textBefore and textAfter; if not, extract the string from textBefore to the end of the current substring.\n# Step8. Set the status to the appropriate code based on whether both texts were found, only the start text was found, or nothing was found.\n# Step9. Exit the loop if the end of the array is reached or the strings are successfully extracted.", "name": "LGF_ExtractStringFromCharArray"}