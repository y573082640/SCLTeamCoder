{"variables": ["1. name: sourceString, type: WString, initial: None, role: The WString to be converted to UTF-8.", "2. name: startPos, type: DInt, initial: None, role: The starting position in the encoded byte stream where encoded WChars will be inserted.", "3. name: bytesUsed, type: UInt, initial: None, role: The number of bytes converted, ranging from 1 to 3.", "4. name: encodedByteStream, type: Array[*] of Byte, initial: None, role: The UTF-8 conformant byte sequence to be filled with encoded characters.", "5. name: tempStatus, type: Word, initial: STATUS_NO_ERROR, role: Temporary variable to store the function's status code.", "6. name: tempConvertedUtf8, type: DWord, initial: DWORD_NULL, role: Temporary variable to store the converted UTF-8 encoded character.", "7. name: tempBytesUsed, type: UInt, initial: USINT_NULL, role: Temporary variable to keep track of the number of bytes used for encoding.", "8. name: tempCharacter, type: WChar, initial: None, role: Temporary variable to store a character from the sourceString for processing.", "9. name: tempIndex, type: DInt, initial: None, role: Index variable used in the FOR loop for iterating through the sourceString.", "10. name: tempArrayIndex, type: DInt, initial: None, role: Index variable for the encodedByteStream array, adjusted by the startPos.", "11. name: tempUpperBound, type: DInt, initial: None, role: Variable to store the upper bound of the encodedByteStream array."], "instructions": ["WCHAR_TO_WORD", "SHR", "WORD_TO_BYTE", "WCHAR_TO_BYTE", "AND", "OR"], "planning": "# Step1. Initialize the temporary variables tempConvertedUtf8, tempBytesUsed, and tempStatus.\n# Step2. Calculate the starting index for encodedByteStream by adding startPos to the lower bound of the array.\n# Step3. Verify if the startPos is outside the bounds of the encodedByteStream array. If it is, set tempStatus to ERR_START_POS_OUTSIDE.\n# Step4. Iterate through each character of sourceString using FOR loop.\n# Step5. For each character, determine if it's within the range of 1-byte, 2-byte, or 3-byte UTF-8 encoding.\n# Step6. Check if there is enough space in encodedByteStream to store the encoded character. If not, set tempStatus to ERR_COUNT_EXCEEDS_BOUNDS and exit the loop.\n# Step7. Convert the WChar character to the appropriate UTF-8 encoded sequence and store it in encodedByteStream, updating tempBytesUsed and tempArrayIndex accordingly.\n# Step8. After the loop, check if an error occurred by examining tempStatus. If an error occurred, set bytesUsed to 0; otherwise, set it to tempBytesUsed.\n# Step9. Set the ENO to reflect the success or failure of the function and return the tempStatus as the function's return value.", "name": "LGF_EncodeUtf8"}