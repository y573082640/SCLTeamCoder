{"variables": ["1. name: initValue, type: Word, initial: 16#00, role: Start value for the CRC calculation.", "2. name: mask, type: Word, initial: 16#00, role: Generator polynomial for the CRC calculation.", "3. name: noOfElements, type: UInt, initial: 0, role: Number of elements to be used in CRC calculation.", "4. name: error, type: Bool, initial: Not directly initialized, role: Error flag indicating if an error has occurred.", "5. name: status, type: Word, initial: Not directly initialized, role: Status code of the operation.", "6. name: array, type: Array[*] of Byte, initial: Not applicable (in-out variable), role: Data stream for which the CRC value will be calculated.", "7. name: tempCRC, type: Word, initial: Not directly initialized, role: Temporary variable to store the current CRC calculation value.", "8. name: tempLowerLimit, type: DInt, initial: Not directly initialized, role: Temporary variable to store the lower limit of the array range to be used.", "9. name: tempUpperLimit, type: DInt, initial: Not directly initialized, role: Temporary variable to store the upper limit of the array range to be used.", "10. name: tempIndexArray, type: DInt, initial: Not directly initialized, role: Index variable for iterating over the array.", "11. name: tempIndexCRC, type: DInt, initial: Not directly initialized, role: Index variable for CRC calculation loop."], "instructions": ["LOWER_BOUND", "UPPER_BOUND", "SHL", "BYTE_TO_WORD", "XOR"], "planning": "# Step1. Initialize the temporary CRC value `tempCRC` with the input `initValue`.\n# Step2. Calculate the lower and upper limits of the input array to be used in CRC calculation.\n# Step3. Validate the input parameter `noOfElements` to ensure it is within the array size and set error status if not.\n# Step4. Iterate over each byte of the data stream defined by `tempLowerLimit` and `tempUpperLimit`.\n# Step5. For each byte, shift it into the most significant bit (MSB) of a 16-bit word and XOR with the current `tempCRC` value.\n# Step6. For each bit in the resulting word (from MSB to LSB), check if the MSB is set and perform the necessary shifts and XOR operations with the `mask` polynomial.\n# Step7. After processing all bits of the current byte and all bytes in the stream, assign the final `tempCRC` to the function return value `LGF_CalcCRC16`.\n# Step8. Set the `status` to `STATUS_NO_ERROR`, `error` to `FALSE`, and `ENO` to `TRUE` to indicate successful execution without errors.", "name": "LGF_CalcCRC16"}