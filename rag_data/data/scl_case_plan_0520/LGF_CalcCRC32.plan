{"variables": ["1. name: initValue, type: DWord, initial: 16#00, role: Initial value for CRC calculation.", "2. name: mask, type: DWord, initial: 16#00, role: Generator polynomial for CRC calculation.", "3. name: noOfElements, type: UInt, initial: 0, role: Number of elements to be used in CRC calculation.", "4. name: error, type: Bool, initial: Not Applicable, role: Error flag for function output.", "5. name: status, type: Word, initial: Not Applicable, role: Status code for function output.", "6. name: array, type: Array[*] of Byte, initial: Not Applicable, role: Data stream for CRC calculation.", "7. name: tempCRC, type: DWord, initial: Not Applicable, role: Temporary variable to store CRC calculation intermediate results.", "8. name: tempLowerLimit, type: DInt, initial: Not Applicable, role: Lower limit of the array index range to be processed.", "9. name: tempUpperLimit, type: DInt, initial: Not Applicable, role: Upper limit of the array index range to be processed.", "10. name: tempIndexArray, type: DInt, initial: Not Applicable, role: Index variable for iterating over the array.", "11. name: tempIndexCRC, type: DInt, initial: Not Applicable, role: Index variable for CRC calculation loop."], "instructions": ["SHL", "XOR", "LOWER_BOUND", "UPPER_BOUND", "BYTE_TO_DWORD"], "planning": "# Step1. Initialize the tempCRC with the initValue provided as input.\n# Step2. Calculate the lower and upper limits of the array to be processed, storing them in tempLowerLimit and tempUpperLimit.\n# Step3. Check if noOfElements is greater than zero and does not exceed the array size, adjusting the tempUpperLimit if needed, else set error flag and status code accordingly and return.\n# Step4. Iterate through the array from tempLowerLimit to tempUpperLimit using tempIndexArray as the loop variable.\n# Step5. Within each iteration, convert the current byte of the array to DWord and shift it left by 24 bits, then XOR the result with tempCRC.\n# Step6. Perform a nested loop from CRC_LOOP_LOWER_LIMIT to CRC_LOOP_UPPER_LIMIT using tempIndexCRC as the loop variable to process each bit of tempCRC.\n# Step7. If the most significant bit of tempCRC is set, shift tempCRC left by one bit and XOR with mask, otherwise just shift tempCRC left by one bit.\n# Step8. After all iterations, assign tempCRC to the return value LGF_CalcCRC32.\n# Step9. Set status to STATUS_NO_ERROR, clear the error flag, and set ENO to TRUE.", "name": "LGF_CalcCRC32"}