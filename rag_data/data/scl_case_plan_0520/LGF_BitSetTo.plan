{"variables": ["1. name: value, type: DWord, initial: None, role: The original data in DWORD format where the bit will be set or reset.", "2. name: bitNo, type: USInt, initial: None, role: The position of the bit to be modified.", "3. name: setTo, type: Bool, initial: None, role: Determines if the bit should be set to TRUE or FALSE.", "4. name: BINARY_ONES, type: DWord, initial: 16#FFFFFFFF, role: Constant used to represent a DWORD with all bits set to TRUE.", "5. name: TRUE_BOOL_BIT, type: DWord, initial: 16#0001, role: Constant representing a DWORD with only the least significant bit set to TRUE.", "6. name: MAX_NO_OF_BITS, type: USInt, initial: 32, role: Constant representing the maximum number of bits in a DWORD."], "instructions": ["SHL", "MOD", "XOR", "OR", "AND"], "planning": "# Step1. Check if the setTo input is TRUE.\n# Step2. If setTo is TRUE, use the SHL instruction to shift the TRUE_BOOL_BIT constant to the left by the value of (bitNo MOD MAX_NO_OF_BITS) positions. Then use the OR instruction to set the designated bit in the value input to TRUE.\n# Step3. If setTo is FALSE, use the SHL instruction to shift the TRUE_BOOL_BIT constant to the left by the value of (bitNo MOD MAX_NO_OF_BITS) positions. Then use the XOR instruction with BINARY_ONES to flip all the bits in the shifted result, and the AND instruction with the original value input to reset the designated bit to FALSE.\n# Step4. Return the modified DWORD value as the result of the function.", "name": "LGF_BitSetTo"}