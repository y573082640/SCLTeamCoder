{"variables": ["1. name: cyclicExecution, type: Bool, initial: false, role: Determines if the operation is cyclic or triggered.", "2. name: trigger, type: Bool, initial: None, role: Triggers the calculation on a pulse.", "3. name: value, type: LReal, initial: None, role: The input value from which the moving average is calculated.", "4. name: windowSize, type: Int, initial: 100, role: Defines the window length for the sliding average calculation.", "5. name: reset, type: Bool, initial: None, role: Resets the block and starts the calculation again if true.", "6. name: statValues, type: Array of LReal, initial: None, role: Stores the values for the moving average calculation.", "7. name: statValuesSum, type: LReal, initial: 0.0, role: Keeps the sum of the values in the current window.", "8. name: statArithmeticAverage, type: LReal, initial: 0.0, role: Stores the calculated arithmetic average.", "9. name: statWindowSizeOld, type: Int, initial: 0, role: Stores the old window size to detect changes.", "10. name: statCounter, type: Int, initial: 0, role: Counts the number of values processed.", "11. name: statwindowSizeReached, type: Bool, initial: false, role: Indicates if the maximum window width has been reached.", "12. name: statTriggerOld, type: Bool, initial: false, role: Stores the previous state of the trigger to detect edge.", "13. name: tempValue, type: LReal, initial: None, role: Temporary variable to hold the current input value.", "14. name: tempIndex, type: Int, initial: None, role: Temporary variable to hold the current index for the sliding window.", "15. name: tempTriggerEdge, type: Bool, initial: None, role: Temporary variable to detect a positive edge of the trigger signal."], "instructions": ["MOD", "ADD", "MINUS", "DIV"], "planning": "# Step1. Copy the input value to a temporary variable and detect a positive edge for the trigger.\n# Step2. Check for reset or change in window size and reset the calculation if needed.\n# Step3. Validate the window size and set an error if it is out of the acceptable range.\n# Step4. If the operation is cyclic or a trigger edge is detected, perform the moving average calculation.\n# Step5. If the counter is less than the window size, fill the array with values and update the sum and average.\n# Step6. If the window size is reached, update the sum by subtracting the oldest value and adding the new value, then calculate the average.\n# Step7. Update the output variables with the calculated average, window size reached status, and error status.\n# Step8. Set the status to indicate successful execution without errors.", "name": "LGF_FloatingAverage"}