{"variables": ["1. name: cyclicExecution, type: Bool, initial: false, role: Determines whether the calculation is performed cyclically or upon trigger.", "2. name: trigger, type: Bool, initial: None, role: Input used for detecting the positive edge for calculation trigger.", "3. name: value, type: LReal, initial: None, role: The incoming REAL value used in the moving average calculation.", "4. name: windowSize, type: Int, initial: 100, role: Specifies the length of the sliding window for the moving average calculation.", "5. name: reset, type: Bool, initial: None, role: If TRUE, resets the moving average calculation.", "6. name: average, type: LReal, initial: None, role: Output representing the moving/floating average value.", "7. name: windowSizeReached, type: Bool, initial: None, role: Indicates if the window size has been reached in the moving average calculation.", "8. name: error, type: Bool, initial: None, role: Signals an error condition during execution of the FB.", "9. name: status, type: Word, initial: None, role: Provides status information about the FB execution and error identification.", "10. name: statValues, type: Array of LReal, initial: None, role: Stores the current values for the sliding window.", "11. name: statValuesSum, type: LReal, initial: 0.0, role: Accumulates the sum of the values in the sliding window.", "12. name: statArithmeticAverage, type: LReal, initial: 0.0, role: Stores the current arithmetic average of the sliding window.", "13. name: statWindowSizeOld, type: Int, initial: 0, role: Stores the previous window size for comparison.", "14. name: statCounter, type: Int, initial: 0, role: Counter for tracking the number of values processed in the window.", "15. name: statwindowSizeReached, type: Bool, initial: None, role: Internal flag to indicate if the window size has been reached.", "16. name: statTriggerOld, type: Bool, initial: false, role: Stores the previous state of the trigger for edge detection.", "17. name: tempValue, type: LReal, initial: None, role: Temporary variable to store the current input value.", "18. name: tempIndex, type: Int, initial: None, role: Temporary variable to store the current index for the sliding window.", "19. name: tempTriggerEdge, type: Bool, initial: None, role: Temporary variable to store the result of the trigger edge detection.", "20. name: ZERO_INT, type: Int, initial: 0, role: Constant representing the integer zero.", "21. name: ZERO_LREAL, type: LReal, initial: 0.0, role: Constant representing the REAL zero.", "22. name: MAX_WINDOW_SIZE, type: Int, initial: 100, role: Constant representing the maximum allowed window size.", "23. name: INCREMENT, type: Int, initial: 1, role: Constant representing the increment value for counters.", "24. name: STATUS_FINISHED_NO_ERROR, type: Word, initial: 16#0000, role: Constant representing the status code for no error.", "25. name: ERR WRONG_WINDOW_SIZE, type: Word, initial: 16#8200, role: Constant representing the status code for an incorrect window size."], "instructions": [""], "planning": "# Step1. Initialize variables and constants.\n# Step2. Copy the input value to a temporary variable.\n# Step3. Perform positive edge detection on the trigger input.\n# Step4. Check if a reset is required or if the window size has changed.\n# Step5. If reset or window size change, reset the calculation variables and return.\n# Step6. Check if the window size is set incorrectly and set the error status accordingly.\n# Step7. Perform the moving average calculation if triggered or cyclic execution is enabled.\n# Step8. Update the sum and the arithmetic average based on the current window size.\n# Step9. Update the counter and handle the case when the window size is reached.\n# Step10. Set the output variables to reflect the current state of the calculation.\n# Step11. Set the ENO output to TRUE, as error handling is done by the error and status outputs.", "name": "LGF_FloatingAverage"}