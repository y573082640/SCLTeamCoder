{"variables": ["1. name: initValue, type: Byte, initial: 16#00, role: The starting value used in the CRC calculation.", "2. name: mask, type: Byte, initial: 16#00, role: The generator polynomial used in the CRC calculation.", "3. name: value, type: Byte, initial: None, role: The data byte for which the CRC value will be calculated.", "4. name: tempCRC, type: Byte, initial: None, role: A temporary variable to hold the intermediate CRC calculation result.", "5. name: tempIndexCRC, type: DInt, initial: 0, role: A loop index variable used for iterating over the bits of the CRC.", "6. name: SHIFT_ONE_BIT, type: UInt, initial: 1, role: A constant used to shift bits by one position.", "7. name: CRC_LOOP_LOWER_LIMIT, type: DInt, initial: 0, role: The lower limit of the loop used for bit-wise CRC calculation.", "8. name: CRC_LOOP_UPPER_LIMIT, type: DInt, initial: 7, role: The upper limit of the loop used for bit-wise CRC calculation."], "instructions": ["SHL", "XOR"], "planning": "Step1. Initialize the tempCRC variable by XORing the initValue and value inputs.\nStep2. Perform a bit-wise CRC calculation by looping over each bit of the tempCRC variable from the least significant bit to the most significant bit (0 to 7).\nStep3. Inside the loop, check if the most significant bit (MSB) of tempCRC is set.\nStep4. If the MSB is set, shift tempCRC to the left by one bit and XOR it with the mask.\nStep5. If the MSB is not set, shift tempCRC to the left by one bit without XOR operation.\nStep6. After completing the loop, assign the final value of tempCRC to the function's return value.\nStep7. Set the ENO (Enable Output) to TRUE as there is no error handling required for this function.", "name": "LGF_CalcCRC8For1Byte"}