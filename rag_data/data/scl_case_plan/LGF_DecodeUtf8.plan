{"variables": ["1. name: byteStream, type: Array[*] of Byte, initial: None, role: The UTF-8 encoded byte stream input for decoding.", "2. name: startPos, type: DInt, initial: None, role: The starting position in the byte stream from which decoding should begin.", "3. name: count, type: UInt, initial: None, role: The number of characters to decode from the byte stream; if 0, decode until the end of the stream.", "4. name: decodedString, type: WString, initial: '', role: The variable where the decoded string is stored.", "5. name: tempString, type: WString, initial: '', role: A temporary string used to accumulate decoded characters.", "6. name: tempStatus, type: Word, initial: STATUS_NO_ERROR, role: A status variable to store the current state of the decoding process.", "7. name: tempCodepoint, type: DWord, initial: 0, role: A temporary variable to store the Unicode code point of the current character being decoded.", "8. name: tempPos, type: DInt, initial: startPos, role: A temporary position counter used to track the current position within the byte stream.", "9. name: tempLowerBound, type: DInt, initial: LOWER_BOUND(ARR := byteStream, DIM := 1), role: The lower bound of the byte stream array.", "10. name: tempUpperBound, type: DInt, initial: UPPER_BOUND(ARR := byteStream, DIM := 1), role: The upper bound of the byte stream array.", "11. name: tempMaxLen, type: DInt, initial: MAX_LEN(decodedString), role: The maximum length of the decoded string."], "instructions": ["LOWER_BOUND", "UPPER_BOUND", "MAX_LEN", "SHL", "CONCAT", "DWORD_TO_WCHAR"], "planning": "Step1. Initialize the tempString to an empty WString and tempPos to startPos.\nStep2. Determine the lower and upper bounds of the byte stream array and the maximum length of the decoded string.\nStep3. Check if the startPos is outside the bounds of the byte stream or if the count exceeds the bounds or the maximum length of the decoded string, setting the appropriate error status if so.\nStep4. If no error, enter a REPEAT loop to process each byte in the byte stream until the maximum length is reached or the end of the stream is found.\nStep5. Within the loop, check the encoding of the current byte and extract the Unicode code point accordingly, handling different byte patterns and setting warnings or errors where necessary.\nStep6. If a valid code point is found, convert it to a WChar and concatenate it to tempString.\nStep7. If the count is not zero and the length of tempString reaches the count, or if the position exceeds the upper bound, exit the loop.\nStep8. After the loop, or if an error occurred, set the decodedString to an empty WString or to tempString if no error or only a warning occurred.\nStep9. Set the function's return value and ENO based on the status of tempStatus.", "name": "LGF_DecodeUtf8"}