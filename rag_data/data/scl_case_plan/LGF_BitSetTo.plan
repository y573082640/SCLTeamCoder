{"variables": ["1. name: value, type: DWord, initial: None, role: The input DWORD on which the bit manipulation is performed.", "2. name: bitNo, type: USInt, initial: None, role: The bit position within the 'value' that needs to be set or reset.", "3. name: setTo, type: Bool, initial: None, role: Determines whether the bit at the specified position should be set to TRUE or FALSE.", "4. name: BINARY_ONES, type: DWord, initial: 16#FFFFFFFF, role: A constant used to hold all bits set to TRUE.", "5. name: TRUE_BOOL_BIT, type: DWord, initial: 16#0001, role: A constant used to hold a single bit set to TRUE.", "6. name: MAX_NO_OF_BITS, type: USInt, initial: 32, role: A constant used to define the maximum number of bits in a DWORD."], "instructions": ["SHL", "XOR", "AND", "OR"], "planning": "Step1. Define constants BINARY_ONES, TRUE_BOOL_BIT, and MAX_NO_OF_BITS to be used in bit manipulation operations.\nStep2. Check the value of the 'setTo' parameter to determine the action (set or reset) to be performed on the 'value'.\nStep3. If 'setTo' is TRUE, use the SHL instruction to shift the TRUE_BOOL_BIT to the left by the bitNo position (modulo MAX_NO_OF_BITS to ensure it's within range), then use the OR instruction to set the bit in 'value'.\nStep4. If 'setTo' is FALSE, use the SHL instruction to shift the TRUE_BOOL_BIT to the left by the bitNo position (modulo MAX_NO_OF_BITS to ensure it's within range), then use the XOR instruction with BINARY_ONES to create a mask, and finally use the AND instruction to reset the bit in 'value'.\nStep5. Assign the result of the bit manipulation to the function's return value LGF_BitSetTo.", "name": "LGF_BitSetTo"}