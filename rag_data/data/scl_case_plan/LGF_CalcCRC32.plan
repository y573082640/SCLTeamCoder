{"variables": ["1. name: initValue, type: DWord, initial: 16#00, role: The initial value for the CRC calculation.", "2. name: mask, type: DWord, initial: 16#00, role: The generator polynomial (mask) for the CRC calculation.", "3. name: noOfElements, type: UInt, initial: 0, role: The number of elements to be used in the CRC calculation.", "4. name: error, type: Bool, initial: None, role: An error flag indicating if an error has occurred during the calculation.", "5. name: status, type: Word, initial: None, role: The status code representing the result of the CRC calculation.", "6. name: array, type: Array[*] of Byte, initial: None, role: The data stream for which the CRC value will be calculated.", "7. name: tempCRC, type: DWord, initial: None, role: Temporary variable to hold the intermediate CRC value during the calculation.", "8. name: tempLowerLimit, type: DInt, initial: None, role: The calculated lower limit index for the array processing.", "9. name: tempUpperLimit, type: DInt, initial: None, role: The calculated upper limit index for the array processing.", "10. name: tempIndexArray, type: DInt, initial: None, role: Temporary loop index variable for iterating over the array.", "11. name: tempIndexCRC, type: DInt, initial: None, role: Temporary loop index variable for the inner CRC bit processing loop."], "instructions": ["LOWER_BOUND", "UPPER_BOUND", "SHL", "BYTE_TO_DWORD", "XOR", "SHL"], "planning": "Step1. Initialize the tempCRC variable with the initValue provided.\nStep2. Calculate the lower and upper bounds of the array to be processed.\nStep3. Check if the noOfElements parameter is greater than zero and does not exceed the array size. If it does, set the error flag, status code, and return the current CRC value.\nStep4. Iterate over the array elements from tempLowerLimit to tempUpperLimit.\nStep5. For each array element, convert it to a DWord and shift it left by three bytes, then XOR it with the current CRC value.\nStep6. For each bit of the CRC value, check if the most significant bit (MSB) is set. If it is, shift the CRC left by one bit and XOR it with the mask. If not, just shift the shift the CRC left by one bit.\nStep7. After processing all array elements, assign the final CRC value to LGF_CalcCRC32.\nStep8. Set the status to STATUS_NO_ERROR, error to FALSE, and ENO to TRUE to indicate successful completion.", "name": "LGF_CalcCRC32"}