{"variables": ["1. name: initValue, type: Byte, initial: 16#00, role: The starting value for the CRC calculation.", "2. name: mask, type: Byte, initial: 16#00, role: The generator polynomial (mask) used in the CRC calculation.", "3. name: noOfElements, type: UInt, initial: 0, role: The number of elements to be used from the data stream for the CRC calculation.", "4. name: error, type: Bool, initial: Unspecified, role: An error flag indicating if an error has occurred during the CRC calculation.", "5. name: status, type: Word, initial: Unspecified, role: A status code indicating the status of the CRC calculation.", "6. name: array, type: Array[*] of Byte, initial: Unspecified, role: The data stream for which the CRC value will be calculated.", "7. name: tempCRC, type: Byte, initial: None, role: A temporary variable used to store the intermediate CRC value.", "8. name: tempLowerLimit, type: DInt, initial: None, role: A temporary variable used to store the lower bound index of the array.", "9. name: tempUpperLimit, type: DInt, initial: None, role: A temporary variable used to store the upper bound index of the array.", "10. name: tempIndexArray, type: DInt, initial: None, role: A temporary iteration variable used for iterating over the array.", "11. name: tempIndexCRC, type: DInt, initial: None, role: A temporary iteration variable used for iterating over the bits of the CRC value."], "instructions": ["UPPER_BOUND", "LOWER_BOUND", "XOR", "SHL"], "planning": "Step 1. Initialize the temporary CRC variable tempCRC with the initValue.\nStep 2. Calculate the lower and upper bounds of the array that will be used for CRC calculation.\nStep 3. Check if the noOfElements parameter is greater than zero and fits within the array bounds. If not, set the error flag and status code, then exit the function.\nStep 4. Iterate over each byte in the specified range of the array. For each byte, perform an XOR operation with the current CRC value.\nStep 5. Within the byte iteration, iterate over each bit position. If the most significant bit (MSB) is set, shift the CRC left by one bit and perform an XOR operation with the mask. If not, just shift the CRC left by one bit.\nStep 6. After completing the bit iterations for all bytes, assign the final CRC value to the function's return value.\nStep 7. Set the status code to STATUS_NO_ERROR, the error flag to FALSE, and ENO to TRUE to indicate successful completion of the function.", "name": "LGF_CalcCRC8"}