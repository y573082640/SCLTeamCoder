FUNCTION "LGF_GetCalendarDay" : DInt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_GetCalendarDay
   VAR_INPUT 
      "date" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempDaysPassed : DInt;
      tempDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR CONSTANT 
      FIRST_DAY : USInt := 1;
      LAST_DAY : USInt := 31;
      JANUARY : USInt := 1;
      DECEMBER : USInt := 12;
      TIME_ZERO_FORCE_UPDATE : Time := t#0d;
      ONE_DAY : DInt := 1;
      STATUS_NO_ERROR : Word := 16#0000;
      ERR_LIM_DATE : Word := 16#8201;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_GetCalendarDay
	  // Comment/Function: This function calculates for a date the passed days since 1st January.
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 16.07.2019  Simatic Systems Support
	  //                      First release
	  //                      ENO used for internal error handling, interface has error and status
	  //                      temp tag naming, insert constant
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 19.01.2020  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION INITIALISATION
	  #tempDate := #date;
	  #tempDaysPassed := 0;
	END_REGION
	
	REGION COUNT DAYS
	  // Check #date
	  // adding zero forces the PLC to update the tag and eno check
	  #tempDate := #tempDate + #TIME_ZERO_FORCE_UPDATE;
	  IF ENO = FALSE THEN
	    #error := TRUE;
	    #status := #ERR_LIM_DATE;
	    #LGF_GetCalendarDay := #tempDaysPassed;
	    RETURN;
	  END_IF;
	  
	  // Weekday of 1st January in the current year
	  #tempDate.MONTH := #JANUARY;
	  #tempDate.DAY := #FIRST_DAY;
	  // adding zero forces the PLC to update the tag
	  // in this case especially the weekday
	  #tempDate := #tempDate + #TIME_ZERO_FORCE_UPDATE;
	  
	  // Days passed in the year since 1st January, "date" included
	  #tempDaysPassed := DATE_TO_DINT(DTL_TO_DATE(#date)) - DATE_TO_DINT(DTL_TO_DATE(#tempDate)) + #ONE_DAY;
	END_REGION
	
	REGION OUTPUTS
	  #error := FALSE;
	  #status := #STATUS_NO_ERROR;
	  #LGF_GetCalendarDay := #tempDaysPassed;
	  
	  // ENO is not used, forced to TRUE
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_GetCalendarWeek_ISO" : DInt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_GetCalendarWeek_ISO
   VAR_INPUT 
      "date" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR_OUTPUT 
      calendarDay : DInt;
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempCurrentYearWeekday1Jan : UDInt;
      tempNextYearWeekday1Jan : UDInt;
      tempCurrentYearWeekday31Dec : UDInt;
      tempPrevYearWeekday1Jan : UDInt;
      tempPrevYearWeekday31Dec : UDInt;
      tempDaysCorr : DInt;
      tempWeek : DInt;
      tempDays : DInt;
      tempCurrentYearIsLeapyear : Bool;
      tempPrevYearIsLeapyear : Bool;
      tempYearCurrentYear : UInt;
      tempPreviousYear : UInt;
      tempNextYear : UInt;
      tempIsCurrentYearWith53Weeks : Bool;
      tempIsPrevYearWith53Weeks : Bool;
   END_VAR

   VAR CONSTANT 
      SUNDAY : UDInt := 1;
      MONDAY : UDInt := 2;
      TUESDAY : UDInt := 3;
      WEDNESDAY : UDInt := 4;
      THURSDAY : UDInt := 5;
      FRIDAY : UDInt := 6;
      SATURDAY : UDInt := 7;
      FIRST_DAY : USInt := 1;
      LAST_DAY : USInt := 31;
      JANUARY : USInt := 1;
      DECEMBER : USInt := 12;
      ONE_YEAR : UInt := 1;
      ONE_DAY : DInt := 1;
      TWO_DAYS : DInt := 2;
      THREE_DAYS : DInt := 3;
      FOUR_DAYS : DInt := 4;
      FIVE_DAYS : DInt := 5;
      SEVEN_DAYS : DInt := 7;
      ONE_WEEK : DInt := 1;
      WEEK_1 : DInt := 1;
      WEEK_52 : DInt := 52;
      WEEK_53 : DInt := 53;
      WEEK_54 : DInt := 54;
      LEAP_YEAR_CHECK_4 : UInt := 4;
      LEAP_YEAR_CHECK_100 : UInt := 100;
      LEAP_YEAR_CHECK_400 : UInt := 400;
      STATUS_NO_ERROR : Word := 16#0000;
      ERR_LIM_DATE : Word := 16#8201;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_GetCalendarWeek_ISO
	  // Comment/Function: This function calculates the week number for ISO 8601 following countries
	  //                   - new week starts whith Monday
	  //                   - the week number 1, is the week which contains the first Thursday of the Year
	  //                   - a year has 52 or 53 weeks
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V14 Upd 1
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 27.01.2017  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.02 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.03 16.07.2019  Simatic Systems Support
	  //                      Renamed from LGF_CalenderWeek to LGF_CalenderWeek_ISO
	  //                      Function split into week for ISO and US Format and as well day counter.
	  //                      Result passed as return value.
	  //                      Standard header implemented
	  //                      Constant, temp variable naming
	  //                      Update function call of CalendarDay
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 19.01.2020  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION INITIALISATION
	  #tempDays := 0;
	  #tempWeek := 0;
	END_REGION
	
	REGION COUNT DAYS
	  // Days passed in the year since 1st January, "date" included
	  #tempDays := "LGF_GetCalendarDay"("date" := #date, error => #error, status => #status);
	  IF #error THEN
	    #LGF_GetCalendarWeek_ISO := #tempWeek;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION COUNT WEEKS
	  // Year of actual year, previous year and next year
	  #tempYearCurrentYear := #date.YEAR;
	  #tempPreviousYear := #date.YEAR - #ONE_YEAR;
	  #tempNextYear := #date.YEAR + #ONE_YEAR;
	  
	  // Check if current year is a leap year (29. February/366 days)
	  #tempCurrentYearIsLeapyear := (((#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_400 = 0));
	  // Check if previous year is a leap year (29. February/366 days)
	  #tempPrevYearIsLeapyear := (((#tempPreviousYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempPreviousYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempPreviousYear MOD #LEAP_YEAR_CHECK_400 = 0));
	  
	  // Weekday of 1st January in the current year
	  #tempDate := #date;
	  #tempDate.MONTH := #JANUARY;
	  #tempDate.DAY := #FIRST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempCurrentYearWeekday1Jan := #tempDate.WEEKDAY;
	  
	  // Weekday of 1st January in the next year
	  #tempDate.YEAR := #tempNextYear;
	  #tempDate.MONTH := #JANUARY;
	  #tempDate.DAY := #FIRST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempNextYearWeekday1Jan := #tempDate.WEEKDAY;
	  
	  // Weekday of 31st December in the current year
	  #tempDate := #date;
	  #tempDate.MONTH := #DECEMBER;
	  #tempDate.DAY := #LAST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempCurrentYearWeekday31Dec := #tempDate.WEEKDAY;
	  
	  // Weekday of 1st January in the previous year
	  #tempDate.YEAR := #tempPreviousYear;
	  #tempDate.MONTH := #JANUARY;
	  #tempDate.DAY := #FIRST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempPrevYearWeekday1Jan := #tempDate.WEEKDAY;
	  
	  // Weekday of 31st December in the previous year
	  #tempDate.YEAR := #tempPreviousYear;
	  #tempDate.MONTH := #DECEMBER;
	  #tempDate.DAY := #LAST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempPrevYearWeekday31Dec := #tempDate.WEEKDAY;
	  
	  // Calculate the week number for european countries (ISO 8601)
	  // - new week begins whith Monday
	  // - the week number 1, is the week which contains the first Thursday of the Year
	  // - a year has 52 or 53 weeks
	  
	  // Check if previous year had 53 weeks
	  #tempIsPrevYearWith53Weeks := (#tempPrevYearWeekday1Jan = #THURSDAY AND #tempPrevYearWeekday31Dec = #THURSDAY AND (NOT #tempPrevYearIsLeapyear))
	  OR (#tempPrevYearIsLeapyear AND ((#tempPrevYearWeekday1Jan = #WEDNESDAY AND #tempPrevYearWeekday31Dec = #THURSDAY) OR (#tempPrevYearWeekday1Jan = #THURSDAY AND #tempPrevYearWeekday31Dec = #FRIDAY)));
	  // Check if current year has 53 weeks
	  #tempIsCurrentYearWith53Weeks := (#tempCurrentYearWeekday1Jan = #THURSDAY AND #tempCurrentYearWeekday31Dec = #THURSDAY AND (NOT #tempCurrentYearIsLeapyear))
	  OR (#tempCurrentYearIsLeapyear AND ((#tempCurrentYearWeekday1Jan = #WEDNESDAY AND #tempCurrentYearWeekday31Dec = #THURSDAY) OR (#tempCurrentYearWeekday1Jan = #THURSDAY AND #tempCurrentYearWeekday31Dec = #FRIDAY)));
	  
	  // Correction of the number of #tempDays depending on the weekday of 1st January 
	  CASE #tempCurrentYearWeekday1Jan OF
	    #SUNDAY:
	      #tempDaysCorr := #tempDays - #TWO_DAYS;
	    #MONDAY:
	      #tempDaysCorr := #tempDays - #ONE_DAY;
	    #TUESDAY:
	      #tempDaysCorr := #tempDays;
	    #WEDNESDAY:
	      #tempDaysCorr := #tempDays + #ONE_DAY;
	    #THURSDAY:
	      #tempDaysCorr := #tempDays + #TWO_DAYS;
	    #FRIDAY:
	      #tempDaysCorr := #tempDays - #FOUR_DAYS;
	    #SATURDAY:
	      #tempDaysCorr := #tempDays - #THREE_DAYS;
	    ELSE
	      ;
	  END_CASE;
	  
	  IF #tempDaysCorr < 0 THEN
	    // 1., 2. and 3. January can belong to the last week of the previous year
	    IF #tempIsPrevYearWith53Weeks THEN
	      #tempWeek := #WEEK_53;
	    ELSE
	      #tempWeek := #WEEK_52;
	    END_IF;
	  ELSE
	    // calculate the number of the week
	    #tempWeek := #tempDaysCorr / #SEVEN_DAYS + #ONE_WEEK;
	    
	    // 29., 30. and 31. December can belong to the first week of the next year
	    IF #tempWeek = #WEEK_53 THEN
	      IF #tempIsCurrentYearWith53Weeks THEN
	        #tempWeek := #WEEK_53;
	      ELSE
	        #tempWeek := #WEEK_1;
	      END_IF;
	    END_IF;
	  END_IF;
	END_REGION
	
	REGION OUTPUTS
	  #calendarDay := #tempDays;
	  #error := FALSE;
	  #status := #STATUS_NO_ERROR;
	  #LGF_GetCalendarWeek_ISO := #tempWeek;
	  
	  // ENO is not used, forced to TRUE
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_GetCalendarWeek_US" : DInt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_GetCalendarWeek_US
   VAR_INPUT 
      "date" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR_OUTPUT 
      calendarDay : DInt;
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempDate {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempCurrentYearWeekday1Jan : UDInt;
      tempNextYearWeekday1Jan : UDInt;
      tempCurrentYearWeekday31Dec : UDInt;
      tempPrevYearWeekday1Jan : UDInt;
      tempPrevYearWeekday31Dec : UDInt;
      tempDaysCorr : DInt;
      tempWeek : DInt;
      tempDays : DInt;
      tempCurrentYearIsLeapyear : Bool;
      tempPrevYearIsLeapyear : Bool;
      tempYearCurrentYear : UInt;
      tempYearPrevYear : UInt;
      tempYearNextYear : UInt;
      tempIsCurrentYearWith53Weeks : Bool;
      tempIsPrevYearWith53Weeks : Bool;
   END_VAR

   VAR CONSTANT 
      SUNDAY : UDInt := 1;
      MONDAY : UDInt := 2;
      TUESDAY : UDInt := 3;
      WEDNESDAY : UDInt := 4;
      THURSDAY : UDInt := 5;
      FRIDAY : UDInt := 6;
      SATURDAY : UDInt := 7;
      FIRST_DAY : USInt := 1;
      LAST_DAY : USInt := 31;
      JANUARY : USInt := 1;
      DECEMBER : USInt := 12;
      ONE_YEAR : UInt := 1;
      ONE_DAY : DInt := 1;
      TWO_DAYS : DInt := 2;
      THREE_DAYS : DInt := 3;
      FOUR_DAYS : DInt := 4;
      FIVE_DAYS : DInt := 5;
      SEVEN_DAYS : DInt := 7;
      ONE_WEEK : DInt := 1;
      WEEK_1 : DInt := 1;
      WEEK_52 : DInt := 52;
      WEEK_53 : DInt := 53;
      WEEK_54 : DInt := 54;
      LEAP_YEAR_CHECK_4 : UInt := 4;
      LEAP_YEAR_CHECK_100 : UInt := 100;
      LEAP_YEAR_CHECK_400 : UInt := 400;
      STATUS_NO_ERROR : Word := 16#0000;
      ERR_LIM_DATE : Word := 16#8201;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_GetCalendarWeek_US
	  // Comment/Function: This function calculates the week number for USA and other countries.
	  //                   - new week starts with Sunday
	  //                   - the week wich contains the 1st January is always week number 1
	  //                   - a year has 52 or 53 weeks
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V14 Upd 1
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 13.11.2019  Simatic Systems Support
	  //                      First release
	  //                      based on spli from  LGF_CalenderWeek (previously LGF_CalenderWeek_ISO)
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 19.01.2020  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION INITIALISATION
	  #tempDays := 0;
	  #tempWeek := 0;
	END_REGION
	
	REGION COUNT DAYS
	  // Days passed in the year since 1st January, "date" included
	  #tempDays := "LGF_GetCalendarDay"("date" := #date, error => #error, status => #status);
	  IF #error THEN
	    #LGF_GetCalendarWeek_US := #tempWeek;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION COUNT WEEKS
	  // Year of actual year, previous year and next year
	  #tempYearCurrentYear := #date.YEAR;
	  #tempYearPrevYear := #date.YEAR - #ONE_YEAR;
	  #tempYearNextYear := #date.YEAR + #ONE_YEAR;
	  
	  // Check if current year is a leap year (29. February/366 days)
	  #tempCurrentYearIsLeapyear := (((#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearCurrentYear MOD #LEAP_YEAR_CHECK_400 = 0));
	  // Check if previous year is a leap year (29. February/366 days)
	  #tempPrevYearIsLeapyear := (((#tempYearPrevYear MOD #LEAP_YEAR_CHECK_4 = 0) AND NOT (#tempYearPrevYear MOD #LEAP_YEAR_CHECK_100 = 0)) OR (#tempYearPrevYear MOD #LEAP_YEAR_CHECK_400 = 0));
	  
	  // Weekday of 1st January in the current year
	  #tempDate := #date;
	  #tempDate.MONTH := #JANUARY;
	  #tempDate.DAY := #FIRST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempCurrentYearWeekday1Jan := #tempDate.WEEKDAY;
	  
	  // Weekday of 1st January in the next year
	  #tempDate.YEAR := #tempYearNextYear;
	  #tempDate.MONTH := #JANUARY;
	  #tempDate.DAY := #FIRST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempNextYearWeekday1Jan := #tempDate.WEEKDAY;
	  
	  // Weekday of 31st December in the current year
	  #tempDate := #date;
	  #tempDate.MONTH := #DECEMBER;
	  #tempDate.DAY := #LAST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempCurrentYearWeekday31Dec := #tempDate.WEEKDAY;
	  
	  // Weekday of 1st January in the previous year
	  #tempDate.YEAR := #tempYearPrevYear;
	  #tempDate.MONTH := #JANUARY;
	  #tempDate.DAY := #FIRST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempPrevYearWeekday1Jan := #tempDate.WEEKDAY;
	  
	  // Weekday of 31st December in the previous year
	  #tempDate.YEAR := #tempYearPrevYear;
	  #tempDate.MONTH := #DECEMBER;
	  #tempDate.DAY := #LAST_DAY;
	  #tempDate := #tempDate + T#0ms;
	  #tempPrevYearWeekday31Dec := #tempDate.WEEKDAY;
	  
	  // Calculate the week number for USA and other countries
	  // - new week begins whith Sunday
	  // - the week wich contains the 1st January is allways week number 1
	  // - a year has 52 or 53 weeks
	  
	  // Correction of the number of #tempDays depending on the weekday of 1st January
	  CASE #tempCurrentYearWeekday1Jan OF
	    #SUNDAY:
	      #tempDaysCorr := #tempDays - #ONE_DAY;
	    #MONDAY:
	      #tempDaysCorr := #tempDays;
	    #TUESDAY:
	      #tempDaysCorr := #tempDays + #ONE_DAY;
	    #WEDNESDAY:
	      #tempDaysCorr := #tempDays + #TWO_DAYS;
	    #THURSDAY:
	      #tempDaysCorr := #tempDays + #THREE_DAYS;
	    #FRIDAY:
	      #tempDaysCorr := #tempDays + #FOUR_DAYS;
	    #SATURDAY:
	      #tempDaysCorr := #tempDays + #FIVE_DAYS;
	  END_CASE;
	  // calculate the number of the week
	  #tempWeek := #tempDaysCorr / #SEVEN_DAYS + #ONE_WEEK;
	  
	  // Check if current year has 53 weeks
	  #tempIsCurrentYearWith53Weeks := (NOT #tempCurrentYearIsLeapyear AND (#tempCurrentYearWeekday1Jan = #SATURDAY AND #tempCurrentYearWeekday31Dec = #SATURDAY)) OR
	  (#tempCurrentYearIsLeapyear AND ((#tempCurrentYearWeekday1Jan = #SATURDAY AND #tempCurrentYearWeekday31Dec = #SUNDAY) OR (#tempCurrentYearWeekday1Jan = #FRIDAY AND #tempCurrentYearWeekday31Dec = #SATURDAY)));
	  
	  // Correct the week number depending on wheter the current year has 53 weeks
	  IF #tempWeek = #WEEK_53 THEN
	    IF #tempIsCurrentYearWith53Weeks THEN
	      #tempWeek := #WEEK_53;
	    ELSE
	      #tempWeek := #WEEK_1;
	    END_IF;
	  END_IF;
	  
	  IF #tempWeek = #WEEK_54 THEN
	    #tempWeek := #WEEK_1;
	  END_IF;
	END_REGION
	
	REGION OUTPUTS
	  #calendarDay := #tempDays;
	  #error := FALSE;
	  #status := #STATUS_NO_ERROR;
	  #LGF_GetCalendarWeek_US := #tempWeek;
	  
	  // ENO is not used, forced to TRUE
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_IsGermanHoliday" : Bool
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_IsGermanHoliday
   VAR_INPUT 
      "date" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      threeKings : Bool;
      roseMonday : Bool;
      ascension : Bool;
      corpusChristi : Bool;
      augsburgerFriedensfest : Bool;
      assumptionOfMary : Bool;
      reformationDay : Bool;
      allSaintDay : Bool;
      bussUndBettag : Bool;
   END_VAR

   VAR_TEMP 
      tempDaysPassedToActDay : DInt;
      tempOday : UInt;
      tempEasterInternal {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempDaysPassedToEaster : DInt;
      tempDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempEasterPartialCalc : UInt;
   END_VAR

   VAR CONSTANT 
      ZERO : UInt := 0;
      CLEAR_DTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      JANUARY : USInt := 1;
      MARCH : USInt := 3;
      APRIL : USInt := 4;
      MAY : USInt := 5;
      AUGUST : USInt := 8;
      OCTOBER : USInt := 10;
      NOVEMBER : USInt := 11;
      DECEMBER : USInt := 12;
      DAY_1 : USInt := 1;
      DAY_3 : USInt := 3;
      DAY_6 : USInt := 6;
      DAY_8 : USInt := 8;
      DAY_15 : USInt := 15;
      DAY_23 : USInt := 23;
      DAY_25 : USInt := 25;
      DAY_26 : USInt := 26;
      DAY_31 : USInt := 31;
      WEDNESDAY : USInt := 4;
      DAYS_BEFORE_EASTER_48 : USInt := 48;
      DAYS_BEFORE_EASTER_2 : USInt := 2;
      DAYS_AFTER_EASTER_1 : USInt := 1;
      DAYS_AFTER_EASTER_39 : USInt := 39;
      DAYS_AFTER_EASTER_49 : USInt := 49;
      DAYS_AFTER_EASTER_50 : USInt := 50;
      DAYS_AFTER_EASTER_60 : USInt := 60;
      EASTER_COEFF_1 : USInt := 1;
      EASTER_COEFF_3 : USInt := 3;
      EASTER_COEFF_4 : USInt := 4;
      EASTER_COEFF_7 : USInt := 7;
      EASTER_COEFF_11 : USInt := 11;
      EASTER_COEFF_13 : USInt := 13;
      EASTER_COEFF_19 : USInt := 19;
      EASTER_COEFF_27 : USInt := 27;
      EASTER_COEFF_28 : USInt := 28;
      EASTER_COEFF_30 : USInt := 30;
      EASTER_COEFF_204 : USInt := 204;
      BIT_SHIFT_BY_TWO : USInt := 2;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_IsGermanHoliday
	  // Comment/Function: Function determines whether a given date is a public holiday
	  //                   All public holidays in Germany are taken into account
	  //                   Holidays that are NOT uniform nationwide can be switched on or off
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V14 SP1 Upd 5
	  // Restrictions:     ENO disabled - no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 03.07.2018  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.02 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.03 17.07.2019  Simatic Systems Support
	  //                      Standard header, comments, style updated
	  //                      refactoring code
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 19.01.2020  Simatic Systems Support
	  //                      fix bug in Constant "DAYS_AFTER_EASTER_60" from 6 to 60
	  //                      Insert documentation
	  //=============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION INITIALISATION
	  #tempEasterPartialCalc := #ZERO;
	  #tempDaysPassedToEaster := #ZERO;
	  #tempOday := #ZERO;
	  #tempDaysPassedToActDay := #ZERO;
	  #tempDTL := #CLEAR_DTL;
	  #tempEasterInternal := #CLEAR_DTL;
	END_REGION
	
	REGION CALC OF EASTER SUNDAY
	  // Calculation of Easter Sunday
	  #tempEasterPartialCalc := (#EASTER_COEFF_204 - #EASTER_COEFF_11 * (#date.YEAR MOD #EASTER_COEFF_19)) MOD #EASTER_COEFF_30;
	  
	  IF #tempEasterPartialCalc > #EASTER_COEFF_27 THEN
	    #tempEasterPartialCalc := #tempEasterPartialCalc - #EASTER_COEFF_1;
	  END_IF;
	  
	  #tempOday := #EASTER_COEFF_28 + #tempEasterPartialCalc - ((#date.YEAR + WORD_TO_UINT(SHR(IN := UINT_TO_WORD(#date.YEAR), N := #BIT_SHIFT_BY_TWO)) + #tempEasterPartialCalc - #EASTER_COEFF_13) MOD #EASTER_COEFF_7);
	  
	  IF #tempOday > #DAY_31 THEN
	    #tempEasterInternal.YEAR := #date.YEAR;
	    #tempEasterInternal.MONTH := #APRIL;
	    #tempEasterInternal.DAY := UINT_TO_USINT(#tempOday - #DAY_31);
	  ELSE
	    #tempEasterInternal.YEAR := #date.YEAR;
	    #tempEasterInternal.MONTH := #MARCH;
	    #tempEasterInternal.DAY := UINT_TO_USINT(#tempOday);
	  END_IF;
	  
	  // Calculation of the days from Jan 1st till Easter Sunday and from Jan 1st to the actual day. 
	  #tempDTL := #date;
	  #tempDTL.MONTH := #APRIL;
	  #tempDTL.DAY := #DAY_1;
	  
	  #tempDaysPassedToEaster := DATE_TO_DINT(DTL_TO_DATE(#tempEasterInternal)) - DATE_TO_DINT(DTL_TO_DATE(#tempDTL)) + #DAY_1;
	  #tempDaysPassedToActDay := DATE_TO_DINT(DTL_TO_DATE(#date)) - DATE_TO_DINT(DTL_TO_DATE(#tempDTL)) + #DAY_1;
	END_REGION
	
	REGION GERMAN HOLIDAYS
	  // Check if actual day is holiday in Germany
	  // Change here for other countries than germany
	  IF (#date.MONTH = #JANUARY AND #date.DAY = #DAY_1) OR                             // 1st of January
	    (#date.MONTH = #JANUARY AND #date.DAY = #DAY_6 AND #threeKings) OR              // 6 of January (Holy Kings)
	    (#date.MONTH = #MAY AND #date.DAY = #DAY_1) OR                                  // 1st of May
	    (#date.MONTH = #AUGUST AND #date.DAY = #DAY_8 AND #augsburgerFriedensfest) OR   // Augsburger Friedensfest
	    (#date.MONTH = #AUGUST AND #date.DAY = #DAY_15 AND #assumptionOfMary) OR        // Assumption of Mary
	    (#date.MONTH = #OCTOBER AND #date.DAY = #DAY_3) OR                              // 3rd of October
	    (#date.MONTH = #OCTOBER AND #date.DAY = #DAY_31 AND #reformationDay) OR         // Reformation day
	    (#date.MONTH = #NOVEMBER AND #date.DAY = #DAY_1 AND #allSaintDay) OR            // 1st of November (all saints day)
	    (#date.MONTH = #NOVEMBER AND #date.WEEKDAY = #WEDNESDAY AND #date.DAY > #DAY_15 AND #date.DAY < #DAY_23 AND #bussUndBettag) OR //Buß- und Bettag (Day of Repentance and Prayer)
	    (#date.MONTH = #DECEMBER AND #date.DAY = #DAY_25) OR                              // 25th of December (1st christmas)
	    (#date.MONTH = #DECEMBER AND #date.DAY = #DAY_26) OR                              // 26th of December (2nd christmas)
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster - #DAYS_BEFORE_EASTER_48 AND #roseMonday) OR     // Rose Monday
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster - #DAYS_BEFORE_EASTER_2) OR                      // Good Friday
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster) OR                                              // Easter Sunday
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_1) OR                       // Easter Monday
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_39 AND #ascension) OR       // Feast of the Ascension
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_49) OR                      // Pentecost
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_50) OR                      // Pentecost Monday
	    (#tempDaysPassedToActDay = #tempDaysPassedToEaster + #DAYS_AFTER_EASTER_60 AND #corpusChristi) THEN // Corpus Christi
	    
	    #LGF_IsGermanHoliday := TRUE;
	  ELSE
	    #LGF_IsGermanHoliday := FALSE;
	  END_IF;
	  
	  // ENO is not used, forced to TRUE
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION_BLOCK "LGF_AstroClock"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_AstroClock
   VAR_INPUT 
      enable : Bool;
      positionGps : "LGF_typeGPS_DD";
      offsetSunrise : Time;
      offsetSunset : Time;
   END_VAR

   VAR_OUTPUT 
      valid { ExternalWritable := 'False'} : Bool;
      busy { ExternalWritable := 'False'} : Bool;
      error { ExternalWritable := 'False'} : Bool;
      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;
      subFunctionStatus { ExternalWritable := 'False'} : Word;
      actualLocalTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;
      sunriseTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;
      sunsetTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;
      isDaytime { ExternalWritable := 'False'} : Bool;
   END_VAR

   VAR 
      statEnableOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;
      statSubfunctionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      statLongitudeHour { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      statLatitudeRadiant { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
   END_VAR

   VAR_TEMP 
      tempRetval : Word;
      tempSysTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempOfficLocTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempDate1Jan {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempSunrise {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempSunset {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempTimeZone : Real;
      tempDayOfYear : Real;
      tempAproximateTime : Real;
      tempSunMeanAnomaly : Real;
      tempSunLongitude : Real;
      tempSunMeanRad : Real;
      tempSunLongitudeRadiant : Real;
      tempSunAscension : Real;
      tempSunAscensRad : Real;
      tempSinDeclination : Real;
      tempCosDeclination : Real;
      tempCosLocHourAngle : Real;
      tempLocalHourAngle : Real;
      tempLocalMeanTime : Real;
      tempUTC : Real;
      tempLocalTime : Real;
   END_VAR

   VAR CONSTANT 
      SUBSTATUS_DAYLIGHT_SAVING_TIME : Word := 16#0001;
      NO_ERROR : Word := 16#0000;
      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;
      STATUS_NO_CALL : Word := 16#7000;
      STATUS_IN_OPERATION : Word := 16#7001;
      ERR_LATITUDE_VALUE : Word := 16#8204;
      ERR_LONGITUDE_VALUE : Word := 16#8205;
      ERR_RD_SYS_T : Word := 16#8601;
      ERR_RD_LOC_T : Word := 16#8602;
      DEGREE_0 : Real := 0.0;
      DEGREE_15 : Real := 15.0;
      DEGREE_90 : Real := 90.0;
      DEGREE_180 : Real := 180.0;
      DEGREE_360 : Real := 360.0;
      PI : Real := 3.141593;
      DEGREE_TO_RADIANT : Real := 0.01745329;
      RADIANT_TO_DEGREE : Real := 57.29578;
      SUN_ZENIT : LReal := 1.58534073722818;
      MAX_MIN_OR_SEC_59 : UInt := 59;
      SECONDS_PER_HOUR : Real := 3600.0;
      MINUTES_PER_HOUR : Real := 60.0;
      HOURS_PER_DAY : Real := 24.0;
      MS_PER_HOUR : Real := 3600000.0;
      TIME_ZERO {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      FIRST_MONTH_AND_DAY : USInt := 1;
      APPROXIMATE_TIME_6 : Int := 6;
      APPROXIMATE_TIME_18 : Int := 18;
      SUN_MEAN_ANOMALY_0_9856 : Real := 0.9856;
      SUN_MEAN_ANOMALY_3_289 : Real := 3.289;
      SUN_TRUE_LONGITUDE_0_02 : Real := 0.02;
      SUN_TRUE_LONGITUDE_1_916 : Real := 1.916;
      SUN_TRUE_LONGITUDE_2_0 : Real := 2.0;
      SUN_TRUE_LONGITUDE_282_634 : Real := 282.634;
      SUN_RIGHT_ASCENSION_0_91764 : Real := 0.91764;
      SUN_RIGHT_ASCENSION_2_0 : Real := 2.0;
      SUN_RIGHT_ASCENSION_2_PI : Real := 6.283185;
      SUN_DECLINATION_0_39782 : Real := 0.39782;
      SUM_LOCAL_HOUR_ANGLE : Real := 1.0;
      LOCAL_MEAN_TIME_0_06571 : Real := 0.06571;
      LOCAL_MEAN_TIME_6_622 : Real := 6.622;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_AstroClock
	  // Comment/Function: Astronomical clock, optional offset, input format DD
	  //                   "LGF_typeGPS_DD" - GPS position as decimal degree
	  // Library/Family:   LGF
	  // Author:           Siemens Industry Online Support
	  // Tested with:      CPU1214C DC/DC/DC FW:V4.3
	  // Engineering:      TIA Portal (V15.1)
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 19.08.2015  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 01.10.2015  Siemens Industry Online Support
	  //                      T_ADD instruction is replaced with "+"
	  // 01.00.02 16.11.2015  Siemens Industry Online Support
	  //                      "offsetSunrise", "offsetSunset" is calculated in
	  //                      "daytime"
	  //                      Bug fix at "Adjust back TO UTC"
	  // 01.01.00 07.06.2015  Siemens Industry Online Support
	  //                      Add output actSystemTime and actLocalTime
	  // 01.01.01 15.06.2015  Siemens Industry Online Support
	  //                      Add comments
	  // 01.01.02 04.01.2017  Siemens Industry Online Support
	  //                      Bug fix at calculation sunrise and sunset
	  // 01.01.03 20.01.2017  Siemens Industry Online Support
	  //                      Upgrade: TIA V14 Update 1
	  // 01.01.04 22.02.2017  Siemens Industry Online Support
	  //                      Code optimization
	  // 01.01.05 09.07.2018  Siemens Industry Online Support
	  //                      Initialize #tempIntSunrise, #tempIntSunset,#tempDate1Jan 
	  // 01.01.06 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.01.07 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.08 30.08.2019  Simatic Systems Support
	  //                      Rename from Astro to AstroClock
	  //                      Update Type name to positionGps - "LGF_typeGPS_DD" - GPS position as decimal degree
	  //                      Refactoring of interface
	  //                      - one input type for GPS data
	  //                      - refactored for better usability
	  //                      - refactoring of whole block to "ENABLE" behavior
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 12.11.2020  Simatic Systems Support
	  //                      Bug fix - not enabled - block still running
	  //                      Insert documentation
	  //===============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION Extended description
	  // Function:
	  // Your position may be entered at LatitudeDD/LongitudeDD
	  // Format signed degree(decimal)
	  // 
	  // OffsetSunrise is added to Latitude and output at Sunrise
	  // OffsetSunset is added to Longitude and output at Sunset
	  // 
	  // daytime is set when the actual time is inbetween Sunrise and Sunset
	  // ============================================================================
	  // Advice:
	  // please take care that the system time is permanently synchronizes anyhow
	  // ============================================================================
	  // Abbreviations
	  // lon: Longitude
	  // lat: Latitude
	  // dir: direction (valid characters: n, N, s, S, e, E, w, W)
	  // DD: decimal degrees (type Real)
	  //=============================================================================
	  // If a faulty value is entered at LatitudeDD
	  // then the value of Sunrise is set to zero
	  // and the value of Sunset is set to zero
	  // and daytime is set to zero
	END_REGION
	
	REGION Block processing
	  // rising edge at enable
	  IF (#enable AND NOT #statEnableOld) AND (#statStatus = #STATUS_NO_CALL) THEN // Enable FB
	    // First call; initialize FB - set BUSY to TRUE
	    #statBusy := TRUE;
	    #statStatus := #STATUS_IN_OPERATION;
	    #statSubfunctionStatus := #NO_ERROR;
	    
	    // falling edge at enable
	  ELSIF (NOT #enable AND #statEnableOld) THEN  // Disable FB 
	    // disbaling FB; set BUSY to FALSE
	    #statBusy := FALSE;
	    #statStatus := #STATUS_NO_CALL;
	    #statSubfunctionStatus := #NO_ERROR;
	    
	    // just if block is in operation,
	    // otherwise jump over region -> End here to reduce "system load"
	  ELSIF (#enable AND #statEnableOld) THEN
	    REGION Process astro clock calculation
	      // reset internal status storage
	      #statStatus := #STATUS_IN_OPERATION;
	      #statSubfunctionStatus := #NO_ERROR;
	      
	      REGION System time, local time, time zone
	        // Reading system time UTC
	        #tempRetval := INT_TO_WORD(RD_SYS_T(#tempSysTime));
	        
	        IF (#tempRetval <> #NO_ERROR) THEN
	          #statStatus := #ERR_RD_SYS_T;
	          #statSubfunctionStatus := #tempRetval;
	        END_IF;
	        
	        // Reading official actual local time
	        #tempRetval := INT_TO_WORD(RD_LOC_T(#tempOfficLocTime));
	        
	        IF (#tempRetval <> #NO_ERROR) AND (#tempRetval <> #SUBSTATUS_DAYLIGHT_SAVING_TIME) THEN
	          #statStatus := #ERR_RD_LOC_T;
	          #statSubfunctionStatus := #tempRetval;
	        END_IF;
	        
	        // Calculation of time difference #tempSysTime - #tempOfficLocTime
	        #tempTimeZone := DINT_TO_REAL(TIME_TO_DINT(T_DIFF(IN1 := #tempSysTime, IN2 := #tempOfficLocTime))) / #MS_PER_HOUR;
	      END_REGION System time, local time, time zone
	      
	      REGION Day of the year
	        #tempDate1Jan.YEAR := #tempOfficLocTime.YEAR;
	        #tempDate1Jan.MONTH := #FIRST_MONTH_AND_DAY;
	        #tempDate1Jan.DAY := #FIRST_MONTH_AND_DAY;
	        #tempDayOfYear := UDINT_TO_REAL(DATE_TO_UDINT(DTL_TO_DATE(#tempOfficLocTime)) - DATE_TO_UDINT(DTL_TO_DATE(#tempDate1Jan)) + 1);
	      END_REGION Day of the year
	      
	      REGION input value check
	        // input latitude DD > 90°, set fault
	        IF (ABS(#positionGps.latitude) > #DEGREE_90) THEN
	          #statStatus := #ERR_LATITUDE_VALUE;
	        END_IF;
	        
	        // input longitude DD > 180°, set fault
	        IF (ABS(#positionGps.longitude) > #DEGREE_180) THEN
	          #statStatus := #ERR_LONGITUDE_VALUE;
	        END_IF;
	        
	        // Copy GPS DD values to work variables and the convert to work units
	        #statLatitudeRadiant := #positionGps.latitude * #DEGREE_TO_RADIANT;
	        #statLongitudeHour := #positionGps.longitude / #DEGREE_15;
	      END_REGION input value check      
	      
	      REGION Calculate Sunrise
	        // Aproximate time 
	        #tempAproximateTime := #tempDayOfYear + (#APPROXIMATE_TIME_6 - #statLongitudeHour) / #HOURS_PER_DAY;
	        
	        // Sun's mean anomaly
	        #tempSunMeanAnomaly := #SUN_MEAN_ANOMALY_0_9856 * #tempAproximateTime - #SUN_MEAN_ANOMALY_3_289;
	        #tempSunMeanRad := #tempSunMeanAnomaly * #DEGREE_TO_RADIANT;
	        
	        // Sun's true longitude
	        #tempSunLongitude := #tempSunMeanAnomaly + #SUN_TRUE_LONGITUDE_282_634
	        + #SUN_TRUE_LONGITUDE_1_916 * SIN(#tempSunMeanRad)
	        + #SUN_TRUE_LONGITUDE_0_02 * SIN(#SUN_TRUE_LONGITUDE_2_0 * #tempSunMeanRad);
	        
	        WHILE #tempSunLongitude > #DEGREE_360 DO
	          #tempSunLongitude -= #DEGREE_360;
	        END_WHILE;
	        
	        WHILE #tempSunLongitude < #DEGREE_0 DO
	          #tempSunLongitude += #DEGREE_360;
	        END_WHILE;
	        
	        #tempSunLongitudeRadiant := #tempSunLongitude * #DEGREE_TO_RADIANT;
	        
	        // Sun's right ascension
	        #tempSunAscensRad := ATAN(#SUN_RIGHT_ASCENSION_0_91764 * TAN(#tempSunLongitudeRadiant));
	        
	        WHILE #tempSunAscensRad > #SUN_RIGHT_ASCENSION_2_PI DO
	          #tempSunAscensRad -= #SUN_RIGHT_ASCENSION_2_PI;
	        END_WHILE;
	        
	        WHILE #tempSunAscensRad < #DEGREE_0 DO
	          #tempSunAscensRad += #SUN_RIGHT_ASCENSION_2_PI;
	        END_WHILE;
	        
	        #tempSunAscension := #tempSunAscensRad * #RADIANT_TO_DEGREE;
	        #tempSunAscension := (#tempSunAscension
	        + DINT_TO_REAL(FLOOR(#tempSunLongitude / #DEGREE_90)) * #DEGREE_90
	        - DINT_TO_REAL(FLOOR(#tempSunAscension / #DEGREE_90)) * #DEGREE_90)
	        / #DEGREE_15;
	        
	        // Sun's declination
	        #tempSinDeclination := #SUN_DECLINATION_0_39782 * SIN(#tempSunLongitudeRadiant);
	        #tempCosDeclination := COS(ASIN(#tempSinDeclination));
	        
	        // Sun's local hour angle angle
	        #tempCosLocHourAngle := LREAL_TO_REAL(
	                                              (COS(#SUN_ZENIT) - REAL_TO_LREAL(#tempSinDeclination * SIN(#statLatitudeRadiant)))
	                                              / (#tempCosDeclination * COS(#statLatitudeRadiant))
	        );
	        
	        IF (#tempCosLocHourAngle > #SUM_LOCAL_HOUR_ANGLE) THEN
	          #tempCosLocHourAngle := #SUM_LOCAL_HOUR_ANGLE;
	        ELSIF (#tempCosLocHourAngle < - #SUM_LOCAL_HOUR_ANGLE) THEN
	          #tempCosLocHourAngle := - #SUM_LOCAL_HOUR_ANGLE;
	        END_IF;
	        
	        // Calculate local hour angle for sunrise
	        #tempLocalHourAngle := (#DEGREE_360 - ACOS(#tempCosLocHourAngle) * #RADIANT_TO_DEGREE) / #DEGREE_15;
	        
	        // Local mean time of rising/setting
	        #tempLocalMeanTime := #tempLocalHourAngle + #tempSunAscension - (#LOCAL_MEAN_TIME_0_06571 * #tempAproximateTime) - #LOCAL_MEAN_TIME_6_622;
	        
	        // Adjust back TO UTC
	        #tempUTC := #tempLocalMeanTime - #statLongitudeHour;
	        
	        IF (#tempUTC > #HOURS_PER_DAY) THEN
	          #tempUTC -= #HOURS_PER_DAY;
	        ELSIF (#tempUTC < 0) THEN
	          #tempUTC += #HOURS_PER_DAY;
	        END_IF;
	        
	        #tempLocalTime := #tempUTC - #tempTimeZone;
	        
	        IF (#tempLocalTime >= #HOURS_PER_DAY) THEN
	          #tempLocalTime -= DINT_TO_REAL(TRUNC(#tempLocalTime / #HOURS_PER_DAY)) * #HOURS_PER_DAY;
	        ELSIF (#tempLocalTime < 0) THEN
	          #tempLocalTime += #HOURS_PER_DAY;
	        END_IF;
	        
	        // Convert #tempLocalTime to DTL (#tempIntSunrise) and add offset
	        #tempSunrise.YEAR := #tempOfficLocTime.YEAR;
	        #tempSunrise.MONTH := #tempOfficLocTime.MONTH;
	        #tempSunrise.DAY := #tempOfficLocTime.DAY;
	        #tempSunrise := #tempSunrise + UDINT_TO_TIME(REAL_TO_UDINT(#tempLocalTime * #MS_PER_HOUR));
	        #tempSunrise.NANOSECOND := 0;
	        #tempSunrise += #offsetSunrise;
	      END_REGION Calculate Sunrise
	      
	      REGION Calculate Sunset
	        // Aproximate time 
	        #tempAproximateTime := #tempDayOfYear + (#APPROXIMATE_TIME_18 - #statLongitudeHour) / #HOURS_PER_DAY;
	        
	        // Sun's mean anomaly
	        #tempSunMeanAnomaly := #SUN_MEAN_ANOMALY_0_9856 * #tempAproximateTime - #SUN_MEAN_ANOMALY_3_289;
	        #tempSunMeanRad := #tempSunMeanAnomaly * #DEGREE_TO_RADIANT;
	        
	        // Sun's true longitude
	        #tempSunLongitude := #tempSunMeanAnomaly + #SUN_TRUE_LONGITUDE_282_634
	        + #SUN_TRUE_LONGITUDE_1_916 * SIN(#tempSunMeanRad)
	        + #SUN_TRUE_LONGITUDE_0_02 * SIN(#SUN_TRUE_LONGITUDE_2_0 * #tempSunMeanRad);
	        
	        WHILE #tempSunLongitude > #DEGREE_360 DO
	          #tempSunLongitude -= #DEGREE_360;
	        END_WHILE;
	        
	        WHILE #tempSunLongitude < #DEGREE_0 DO
	          #tempSunLongitude += #DEGREE_360;
	        END_WHILE;
	        
	        #tempSunLongitudeRadiant := #tempSunLongitude * #DEGREE_TO_RADIANT;
	        
	        // Sun's right ascension
	        #tempSunAscensRad := ATAN(#SUN_RIGHT_ASCENSION_0_91764 * TAN(#tempSunLongitudeRadiant));
	        
	        WHILE #tempSunAscensRad > #SUN_RIGHT_ASCENSION_2_PI DO
	          #tempSunAscensRad -= #SUN_RIGHT_ASCENSION_2_PI;
	        END_WHILE;
	        
	        WHILE #tempSunAscensRad < #DEGREE_0 DO
	          #tempSunAscensRad += #SUN_RIGHT_ASCENSION_2_PI;
	        END_WHILE;
	        
	        #tempSunAscension := #tempSunAscensRad * #RADIANT_TO_DEGREE;
	        #tempSunAscension := (#tempSunAscension
	        + DINT_TO_REAL(FLOOR(#tempSunLongitude / #DEGREE_90)) * #DEGREE_90
	        - DINT_TO_REAL(FLOOR(#tempSunAscension / #DEGREE_90)) * #DEGREE_90)
	        / #DEGREE_15;
	        
	        // Sun's declination
	        #tempSinDeclination := #SUN_DECLINATION_0_39782 * SIN(#tempSunLongitudeRadiant);
	        #tempCosDeclination := COS(ASIN(#tempSinDeclination));
	        
	        // Sun's local hour angle
	        #tempCosLocHourAngle := LREAL_TO_REAL(
	                                              (COS(#SUN_ZENIT) - REAL_TO_LREAL(#tempSinDeclination * SIN(#statLatitudeRadiant)))
	                                              / (#tempCosDeclination * COS(#statLatitudeRadiant))
	        );
	        
	        IF (#tempCosLocHourAngle > #SUM_LOCAL_HOUR_ANGLE) THEN
	          #tempCosLocHourAngle := #SUM_LOCAL_HOUR_ANGLE;
	        ELSIF (#tempCosLocHourAngle < - #SUM_LOCAL_HOUR_ANGLE) THEN
	          #tempCosLocHourAngle := - #SUM_LOCAL_HOUR_ANGLE;
	        END_IF;
	        
	        // Calculation local hour angle for sunset
	        #tempLocalHourAngle := ACOS(#tempCosLocHourAngle) * #RADIANT_TO_DEGREE / #DEGREE_15;
	        
	        // Local mean time of rising/setting
	        #tempLocalMeanTime := #tempLocalHourAngle + #tempSunAscension - (#LOCAL_MEAN_TIME_0_06571 * #tempAproximateTime) - #LOCAL_MEAN_TIME_6_622;
	        
	        // Adjust back TO UTC
	        #tempUTC := #tempLocalMeanTime - #statLongitudeHour;
	        
	        IF (#tempUTC > #HOURS_PER_DAY) THEN
	          #tempUTC -= #HOURS_PER_DAY;
	        ELSIF (#tempUTC < 0) THEN
	          #tempUTC += #HOURS_PER_DAY;
	        END_IF;
	        
	        #tempLocalTime := #tempUTC - #tempTimeZone;
	        
	        IF (#tempLocalTime >= #HOURS_PER_DAY) THEN
	          #tempLocalTime -= DINT_TO_REAL(TRUNC(#tempLocalTime / #HOURS_PER_DAY)) * #HOURS_PER_DAY;
	        ELSIF (#tempLocalTime < 0) THEN
	          #tempLocalTime += #HOURS_PER_DAY;
	        END_IF;
	        
	        // Convert #tempLocalTime to DTL (#tempIntSunset) and add offset
	        #tempSunset.YEAR := #tempOfficLocTime.YEAR;
	        #tempSunset.MONTH := #tempOfficLocTime.MONTH;
	        #tempSunset.DAY := #tempOfficLocTime.DAY;
	        #tempSunset := #tempSunset + UDINT_TO_TIME(REAL_TO_UDINT(#tempLocalTime * #MS_PER_HOUR));
	        #tempSunset.NANOSECOND := 0;
	        #tempSunset += #offsetSunset;
	      END_REGION Calculate Sunset
	      
	    END_REGION Process astro clock calculation
	  END_IF;
	  
	  // Edge detection store 'enable' input to memory
	  #statEnableOld := #enable;
	END_REGION Block processing
	
	REGION OUTPUTS
	  // Write application specific values to outputs
	  #actualLocalTime := #tempOfficLocTime;
	  #sunriseTime := #tempSunrise;
	  #sunsetTime := #tempSunset;
	  // Evaluate Day (between Sunrise and Sunset)
	  #isDaytime := (#tempOfficLocTime >= #tempSunrise) AND (#tempOfficLocTime <= #tempSunset);
	  
	  // Write static values to outputs
	  #valid := NOT #statStatus.%X15 AND #statBusy;
	  #busy := #statBusy;
	  #error := #statStatus.%X15;
	  #status := #statStatus;
	  #subFunctionStatus := #statSubfunctionStatus;
	  
	  // ENO is not used, forced to TRUE
	  ENO := TRUE;
	END_REGION OUTPUTS
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "LGF_SetTime"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_SetTime
   VAR_INPUT 
      execute : Bool;
      systemTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      isLocalTime : Bool;
      timeZone : Int;
      isDaylightSavingTime : Bool;
   END_VAR

   VAR_OUTPUT 
      done { ExternalWritable := 'False'} : Bool;
      busy { ExternalWritable := 'False'} : Bool;
      error { ExternalWritable := 'False'} : Bool;
      lastSetTimeZone { ExternalWritable := 'False'} : String;
      status { ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;
      subFunctionStatus { ExternalWritable := 'False'} : Word;
   END_VAR

   VAR 
      statExecuteOld { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statDone { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statBusy { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statError { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      statStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word := #STATUS_NO_CALL;
      statSubFunctionStatus { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Word;
      statFBState { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : DInt := #FB_STATE_NO_PROCESSING;
      instSetTimeZone {InstructionName := 'SET_TIMEZONE'; LibVersion := '1.1'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : SET_TIMEZONE;
      statTimeZone {InstructionName := 'TimeTransformationRule'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'; S7_SetPoint := 'False'} : TimeTransformationRule := (0, 60, 3, 5, 1, 2, 0, 10, 5, 1, 3, 0, 'not even set by LGF_TimeZone');
   END_VAR

   VAR_TEMP 
      tempExecute : Bool;
      tempSetTimeZoneDone : Bool;
      tempSetTimeZoneBusy : Bool;
      tempSetTimeZoneError : Bool;
      tempSetTimeZoneStatus : Word;
      tempResultSetTime : Word;
   END_VAR

   VAR CONSTANT 
      FB_STATE_NO_PROCESSING : DInt := 0;
      FB_STATE_SET_TIME : DInt := 1;
      FB_STATE_SET_TIMEZONE : DInt := 2;
      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;
      STATUS_NO_CALL : Word := 16#7000;
      STATUS_FIRST_CALL : Word := 16#7001;
      STATUS_SUBSEQUENT_CALL : Word := 16#7002;
      ERR_UNDEFINED_STATE : Word := 16#8600;
      ERR_WRONG_TIMEZONE : Word := 16#8601;
      ERR_SET_TIME_LOCAL : Word := 16#8201;
      ERR_SET_TIME_UTC : Word := 16#8202;
      ERR_SET_TIMEZONE : Word := 16#8203;
      UTC_MINUS_1200 : Int := -1200;
      UTC_MINUS_1200_BIAS : Int := -720;
      UTC_MINUS_1200_NAME : String := '(UTC -12:00)';
      UTC_MINUS_1100 : Int := -1100;
      UTC_MINUS_1100_BIAS : Int := -660;
      UTC_MINUS_1100_NAME : String := '(UTC -11:00)';
      UTC_MINUS_1000 : Int := -1000;
      UTC_MINUS_1000_BIAS : Int := -600;
      UTC_MINUS_1000_NAME : String := '(UTC -10:00)';
      UTC_MINUS_0930 : Int := -930;
      UTC_MINUS_0930_BIAS : Int := -570;
      UTC_MINUS_0930_NAME : String := '(UTC -09:30)';
      UTC_MINUS_0900 : Int := -900;
      UTC_MINUS_0900_BIAS : Int := -540;
      UTC_MINUS_0900_NAME : String := '(UTC -09:00)';
      UTC_MINUS_0800 : Int := -800;
      UTC_MINUS_0800_BIAS : Int := -480;
      UTC_MINUS_0800_NAME : String := '(UTC -08:00)';
      UTC_MINUS_0700 : Int := -700;
      UTC_MINUS_0700_BIAS : Int := -420;
      UTC_MINUS_0700_NAME : String := '(UTC -07:00)';
      UTC_MINUS_0600 : Int := -600;
      UTC_MINUS_0600_BIAS : Int := -360;
      UTC_MINUS_0600_NAME : String := '(UTC -06:00)';
      UTC_MINUS_0500 : Int := -500;
      UTC_MINUS_0500_BIAS : Int := -300;
      UTC_MINUS_0500_NAME : String := '(UTC -05:00)';
      UTC_MINUS_0400 : Int := -400;
      UTC_MINUS_0400_BIAS : Int := -240;
      UTC_MINUS_0400_NAME : String := '(UTC -04:00)';
      UTC_MINUS_0330 : Int := -0330;
      UTC_MINUS_0330_BIAS : Int := -210;
      UTC_MINUS_0330_NAME : String := '(UTC -03:30)';
      UTC_MINUS_0300 : Int := -300;
      UTC_MINUS_0300_BIAS : Int := -180;
      UTC_MINUS_0300_NAME : String := '(UTC -03:00)';
      UTC_MINUS_0200 : Int := -200;
      UTC_MINUS_0200_BIAS : Int := -120;
      UTC_MINUS_0200_NAME : String := '(UTC -02:00)';
      UTC_MINUS_0100 : Int := -100;
      UTC_MINUS_0100_BIAS : Int := -60;
      UTC_MINUS_0100_NAME : String := '(UTC -01:00)';
      UTC_0 : Int := 0;
      UTC_0_BIAS : Int := 0;
      UTC_0_NAME : String := '(UTC)';
      UTC_100 : Int := 100;
      UTC_100_BIAS : Int := 60;
      UTC_100_NAME : String := '(UTC +01:00)';
      UTC_200 : Int := 200;
      UTC_200_BIAS : Int := 120;
      UTC_200_NAME : String := '(UTC +02:00)';
      UTC_300 : Int := 300;
      UTC_300_BIAS : Int := 180;
      UTC_300_NAME : String := '(UTC +03:00)';
      UTC_330 : Int := 330;
      UTC_330_BIAS : Int := 210;
      UTC_330_NAME : String := '(UTC +03:30)';
      UTC_400 : Int := 400;
      UTC_400_BIAS : Int := 240;
      UTC_400_NAME : String := '(UTC +04:00)';
      UTC_430 : Int := 430;
      UTC_430_BIAS : Int := 270;
      UTC_430_NAME : String := '(UTC +04:30)';
      UTC_500 : Int := 500;
      UTC_500_BIAS : Int := 300;
      UTC_500_NAME : String := '(UTC +05:00)';
      UTC_530 : Int := 530;
      UTC_530_BIAS : Int := 330;
      UTC_530_NAME : String := '(UTC +05:30)';
      UTC_545 : Int := 545;
      UTC_545_BIAS : Int := 345;
      UTC_545_NAME : String := '(UTC +05:45)';
      UTC_600 : Int := 600;
      UTC_600_BIAS : Int := 360;
      UTC_600_NAME : String := '(UTC +06:00)';
      UTC_630 : Int := 630;
      UTC_630_BIAS : Int := 390;
      UTC_630_NAME : String := '(UTC +06:30)';
      UTC_700 : Int := 700;
      UTC_700_BIAS : Int := 420;
      UTC_700_NAME : String := '(UTC +07:00)';
      UTC_800 : Int := 800;
      UTC_800_BIAS : Int := 480;
      UTC_800_NAME : String := '(UTC +08:00)';
      UTC_830 : Int := 830;
      UTC_830_BIAS : Int := 510;
      UTC_830_NAME : String := '(UTC +08:30)';
      UTC_845 : Int := 845;
      UTC_845_BIAS : Int := 525;
      UTC_845_NAME : String := '(UTC +08:45)';
      UTC_900 : Int := 900;
      UTC_900_BIAS : Int := 540;
      UTC_900_NAME : String := '(UTC +09:00)';
      UTC_930 : Int := 930;
      UTC_930_BIAS : Int := 570;
      UTC_930_NAME : String := '(UTC +09:30)';
      UTC_1000 : Int := 1000;
      UTC_1000_BIAS : Int := 600;
      UTC_1000_NAME : String := '(UTC +10:00)';
      UTC_1030 : Int := 1030;
      UTC_1030_BIAS : Int := 630;
      UTC_1030_NAME : String := '(UTC +10:30)';
      UTC_1100 : Int := 1100;
      UTC_1100_BIAS : Int := 660;
      UTC_1100_NAME : String := '(UTC +11:00)';
      UTC_1200 : Int := 1200;
      UTC_1200_BIAS : Int := 720;
      UTC_1200_NAME : String := '(UTC +12:00)';
      UTC_1245 : Int := 1245;
      UTC_1245_BIAS : Int := 765;
      UTC_1245_NAME : String := '(UTC +12:45)';
      UTC_1300 : Int := 1300;
      UTC_1300_BIAS : Int := 780;
      UTC_1300_NAME : String := '(UTC +13:00)';
      UTC_1400 : Int := 1400;
      UTC_1400_BIAS : Int := 840;
      UTC_1400_NAME : String := '(UTC +14:00)';
      DAYLIGHT_BIAS_ON : Int := 60;
      DAYLIGHT_BIAS_OFF : Int := 0;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_SetTime
	  // Comment/Function: Set system / local time, time zone
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 08.06.2015  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 02.01.2017  Siemens Industry Online Support
	  //                      Upgrade: TIA V14 Update 1
	  // 01.00.02 02.03.2017  Siemens Industry Online Support
	  //                      Bugfix: FB number: automatic
	  // 01.00.03 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.00.04 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.00.05 20.02.2019  Siemens Industry Online Support
	  //                      Bugfix: Rising edge at input REQ of SET_TIMEOUT
	  // 01.00.06 23.08.2019  Simatic Systems Support
	  //                      Reworked interface to PLC Open "execute" behavior
	  //                      Magic numbers removed, tag naming added, code reworked
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.02 13.01.2020  Simatic Systems Support
	  //                      Bug fix - bias correction for time offsets (330)
	  //                      Insert documentation
	  // 03.00.03 03.06.2022  Simatic Systems Support
	  //                      Bug fix - bias correction for time offsets (200)
	  //=============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	#tempExecute := #execute; // Work with temporary value / create process image
	
	REGION TRIGGERING
	  IF (#tempExecute = TRUE) AND (#statExecuteOld = FALSE) // Check if FB is triggered
	    // FB shall finish current job before new job can be started with rising edge of execute
	    AND (#statStatus = #STATUS_NO_CALL)
	  THEN // First call; initialize FB
	    #statDone := FALSE;
	    #statBusy := TRUE;
	    #statError := FALSE;
	    #statStatus := #STATUS_FIRST_CALL;
	    #statSubFunctionStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	    // State machine - start processing
	    #statFBState := #FB_STATE_SET_TIME;
	    
	    // Initialize functionality: reset of variables, diagnostics, etc.
	    // Set timzone values for systemfunction
	    CASE #timeZone OF
	      #UTC_MINUS_1200:  // (UTC -12:00) Eniwetok, Kwajalein
	        #statTimeZone.Bias := #UTC_MINUS_1200_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_1200_NAME;
	      #UTC_MINUS_1100:  // (UTC -11:00) Midway Island
	        #statTimeZone.Bias := #UTC_MINUS_1100_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_1100_NAME;
	      #UTC_MINUS_1000:  // (UTC -10:00) Hawaii
	        #statTimeZone.Bias := #UTC_MINUS_1000_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_1000_NAME;
	      #UTC_MINUS_0930:  // (UTC -09:30) (French) Polynesia
	        #statTimeZone.Bias := #UTC_MINUS_0930_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0930_NAME;
	      #UTC_MINUS_0900:  // (UTC -09:00) Alaska
	        #statTimeZone.Bias := #UTC_MINUS_0900_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0900_NAME;
	      #UTC_MINUS_0800:  // (UTC -08:00) Tijuana, Los Angeles, Seattle, Vancouver
	        #statTimeZone.Bias := #UTC_MINUS_0800_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0800_NAME;
	      #UTC_MINUS_0700:  // (UTC -07:00) Arizona, Denver, Salt Lake City, Calgary
	        #statTimeZone.Bias := #UTC_MINUS_0700_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0700_NAME;
	      #UTC_MINUS_0600:  // (UTC -06:00) Chicago, Dallas, Kansas City, Winnipeg
	        #statTimeZone.Bias := #UTC_MINUS_0600_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0600_NAME;
	      #UTC_MINUS_0500:  // (UTC -05:00) Eastern Time (USA & Canada)
	        #statTimeZone.Bias := #UTC_MINUS_0500_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0500_NAME;
	      #UTC_MINUS_0400:  // (UTC -04:00) La Paz, Georgetown
	        #statTimeZone.Bias := #UTC_MINUS_0400_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0400_NAME;
	      #UTC_MINUS_0330:  // (UTC -03:30) Newfoundland
	        #statTimeZone.Bias := #UTC_MINUS_0330_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0330_NAME;
	      #UTC_MINUS_0300:  // (UTC -03:00) Brasilia, Buenos Aires
	        #statTimeZone.Bias := #UTC_MINUS_0300_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0300_NAME;
	      #UTC_MINUS_0200:  // (UTC -02:00) Mid-Atlantic
	        #statTimeZone.Bias := #UTC_MINUS_0200_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0200_NAME;
	      #UTC_MINUS_0100:  // (UTC -01:00) Azores, Cape Verde Is.
	        #statTimeZone.Bias := #UTC_MINUS_0100_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_MINUS_0100_NAME;
	      #UTC_0:  // (UTC) Dublin, Edinburgh, Lisbon, London
	        #statTimeZone.Bias := #UTC_0_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_0_NAME;
	      #UTC_100:  // (UTC +01:00) Berlin, Bern, Brussels, Rome, Stockholm, Vienna
	        #statTimeZone.Bias := #UTC_100_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_100_NAME;
	      #UTC_200: // (UTC +02:00) Athens, Istanbul, Minsk, Bucharest
	        #statTimeZone.Bias := #UTC_200_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_200_NAME;
	      #UTC_300: // (UTC +03:00) Moscow, St. Petersburg, Baghdad, Kuwait, Riyadh
	        #statTimeZone.Bias := #UTC_300_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_300_NAME;
	      #UTC_330: // (UTC +03:00) Iran
	        #statTimeZone.Bias := #UTC_330_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_330_NAME;
	      #UTC_400: // (UTC +04:00) Abu Dhabi, Muscat
	        #statTimeZone.Bias := #UTC_400_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_400_NAME;
	      #UTC_430: // (UTC +04:30) Afghanistan
	        #statTimeZone.Bias := #UTC_430_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_430_NAME;
	      #UTC_500: // (UTC +05:00) Islamabad, Karachi, Tashkent
	        #statTimeZone.Bias := #UTC_500_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_500_NAME;
	      #UTC_530: // (UTC +05:30) India, Sri Lanka
	        #statTimeZone.Bias := #UTC_530_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_530_NAME;
	      #UTC_545: // (UTC +05:45) Nepal
	        #statTimeZone.Bias := #UTC_545_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_545_NAME;
	      #UTC_600: // (UTC +06:00) Astana, Almaty, Dhaka, Colombo, Banglatesh, Butan
	        #statTimeZone.Bias := #UTC_600_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_600_NAME;
	      #UTC_630: // (UTC +06:30) Coco Island, Mayanmar
	        #statTimeZone.Bias := #UTC_630_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_630_NAME;
	      #UTC_700: // (UTC +07:00) Bangkok, Hanoi, Jakarta
	        #statTimeZone.Bias := #UTC_700_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_700_NAME;
	      #UTC_800: // (UTC +08:00) Beijing, Chongqing, Hong Kong, Urumqi
	        #statTimeZone.Bias := #UTC_800_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_800_NAME;
	      #UTC_830: // (UTC +08:30) North Corea (old)
	        #statTimeZone.Bias := #UTC_830_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_830_NAME;
	      #UTC_845: // (UTC +08:45) Western Australia, Eucla
	        #statTimeZone.Bias := #UTC_845_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_845_NAME;
	      #UTC_900: // (UTC +09:00) Yakutsk, Osaka, Sapporo, Tokyo, Seoul
	        #statTimeZone.Bias := #UTC_900_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_900_NAME;
	      #UTC_930: // (UTC +09:30) Australia: Northern Territory, South Australia
	        #statTimeZone.Bias := #UTC_930_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_930_NAME;
	      #UTC_1000: // (UTC +10:00) Brisbane, Canberra, Melbourne, Sydney
	        #statTimeZone.Bias := #UTC_1000_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_1000_NAME;
	      #UTC_1030: // (UTC +10:30) Australia: Lord Howe Island
	        #statTimeZone.Bias := #UTC_1030_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_1030_NAME;
	      #UTC_1100: // (UTC +11:00) Vladivostok, Magadan, Solomon Is., New Caledonia
	        #statTimeZone.Bias := #UTC_1100_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_1100_NAME;
	      #UTC_1200: // (UTC +12:00) Auckland, Wellington
	        #statTimeZone.Bias := #UTC_1200_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_1200_NAME;
	      #UTC_1245: // (UTC +12:45) Chatham Islands
	        #statTimeZone.Bias := #UTC_1245_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_1245_NAME;
	      #UTC_1300: // (UTC +13:00) Tonga, Samoa, Kiribati (Phoenix isl.)
	        #statTimeZone.Bias := #UTC_1300_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_1300_NAME;
	      #UTC_1400: // (UTC +13:00) Kiribati (Line isl.)
	        #statTimeZone.Bias := #UTC_1400_BIAS;
	        #statTimeZone.TimeZoneName := #UTC_1400_NAME;
	      ELSE  // Error handling - wronge time zone parmater
	        #statStatus := #ERR_WRONG_TIMEZONE;
	        #subFunctionStatus := INT_TO_WORD(#timeZone);
	        #statFBState := #FB_STATE_NO_PROCESSING;
	    END_CASE;
	    
	    // Select daylight saving time on/off
	    IF #isDaylightSavingTime THEN
	      #statTimeZone.DaylightBias := #DAYLIGHT_BIAS_ON;
	    ELSE
	      #statTimeZone.DaylightBias := #DAYLIGHT_BIAS_OFF;
	    END_IF;
	    
	    // Initialize functionality: call subsidiary FBs with FALSE
	    #instSetTimeZone(REQ      := FALSE,
	                     TimeZone := #statTimeZone,
	                     DONE     => #tempSetTimeZoneDone,
	                     BUSY     => #tempSetTimeZoneBusy,
	                     ERROR    => #tempSetTimeZoneError,
	                     STATUS   => #tempSetTimeZoneStatus);
	    
	  ELSIF (#statStatus = #STATUS_FIRST_CALL) THEN
	    #statStatus := #STATUS_SUBSEQUENT_CALL;
	  END_IF;
	  
	  // Edge detection 'execute' input
	  #statExecuteOld := #tempExecute;
	END_REGION TRIGGERING
	
	IF (#statStatus = #STATUS_NO_CALL) THEN // Nothing to do -> End here to reduce "system load"
	  RETURN;
	END_IF;
	
	REGION STATE_MACHINE
	  CASE #statFBState OF // State machine of FB
	    #FB_STATE_NO_PROCESSING: // No processing active (Note: this state must always be present and left empty)
	      REGION No processing
	        ;
	      END_REGION
	      
	    #FB_STATE_SET_TIME:
	      REGION Set time
	        IF #isLocalTime THEN
	          #tempResultSetTime := INT_TO_WORD(WR_LOC_T(LOCTIME := #systemTime, DST := #isDaylightSavingTime));
	          
	          // In case of error - set error output an quit
	          IF #tempResultSetTime.%X15 = TRUE THEN
	            #statStatus := #ERR_SET_TIME_LOCAL;
	            #statSubFunctionStatus := #tempResultSetTime;
	          ELSE
	            #statFBState := #FB_STATE_SET_TIMEZONE;
	          END_IF;
	          
	        ELSE
	          #tempResultSetTime := INT_TO_WORD(WR_SYS_T(#systemTime));
	          
	          // In case of error - set error output an quit
	          IF #tempResultSetTime.%X15 = TRUE THEN
	            #statStatus := #ERR_SET_TIME_UTC;
	            #statSubFunctionStatus := #tempResultSetTime;
	          ELSE
	            #statFBState := #FB_STATE_SET_TIMEZONE;
	          END_IF;
	        END_IF;
	      END_REGION
	      
	    #FB_STATE_SET_TIMEZONE:
	      REGION Set timezone
	        // Set time zone by calling the system function
	        #instSetTimeZone(REQ      := TRUE,
	                         TimeZone := #statTimeZone,
	                         DONE     => #tempSetTimeZoneDone,
	                         BUSY     => #tempSetTimeZoneBusy,
	                         ERROR    => #tempSetTimeZoneError,
	                         STATUS   => #tempSetTimeZoneStatus);
	        
	        // If operation is done
	        IF #instSetTimeZone.DONE = TRUE THEN
	          // Reset function call
	          #instSetTimeZone(REQ      := FALSE,
	                           TimeZone := #statTimeZone,
	                           DONE     => #tempSetTimeZoneDone,
	                           BUSY     => #tempSetTimeZoneBusy,
	                           ERROR    => #tempSetTimeZoneError,
	                           STATUS   => #tempSetTimeZoneStatus);
	          // Next state
	          #statStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	        END_IF;
	        
	        // If operation is done
	        IF #instSetTimeZone.ERROR = TRUE THEN
	          // Set error message
	          #statStatus := #ERR_SET_TIMEZONE;
	          #statSubFunctionStatus := #instSetTimeZone.STATUS;
	          
	          // Reset function call
	          #instSetTimeZone(REQ      := FALSE,
	                           TimeZone := #statTimeZone,
	                           DONE     => #tempSetTimeZoneDone,
	                           BUSY     => #tempSetTimeZoneBusy,
	                           ERROR    => #tempSetTimeZoneError,
	                           STATUS   => #tempSetTimeZoneStatus);
	        END_IF;
	      END_REGION
	      
	    ELSE // Undefined state in state machine reached
	      #statStatus := #ERR_UNDEFINED_STATE;
	  END_CASE;
	END_REGION STATE_MACHINE
	
	REGION OUTPUTS
	  // Write outputs
	  IF (#statStatus = #STATUS_EXECUTION_FINISHED_NO_ERROR) AND (#statDone = FALSE) THEN // Execution finished without errors
	    #statDone := TRUE;
	    #statBusy := FALSE;
	    #statError := FALSE;
	    // Execution aborted --> set state no processing
	    #statFBState := #FB_STATE_NO_PROCESSING;
	    
	  ELSIF (#statStatus.%X15 = TRUE) AND (#statError = FALSE) THEN // Error occurred (#statStatus is 16#8000 to 16#FFFF)
	    #statDone := FALSE;
	    #statBusy := FALSE;
	    #statError := TRUE;
	    // Execution aborted --> set state no processing
	    #statFBState := #FB_STATE_NO_PROCESSING;
	    
	  ELSIF (#tempExecute = FALSE) AND ((#statDone = TRUE) OR (#statError = TRUE)) THEN // Reset outputs
	    #statDone := FALSE;
	    #statBusy := FALSE;
	    #statError := FALSE;
	    #statStatus := #STATUS_NO_CALL;
	  END_IF;
	  
	  // Write static values to outputs
	  #done := #statDone;
	  #busy := #statBusy;
	  #error := #statError;
	  #status := #statStatus;
	  #subFunctionStatus := #statSubFunctionStatus;
	  // Output the last set time zone
	  #lastSetTimeZone := #statTimeZone.TimeZoneName;
	  
	  // ENO is not used, forced to TRUE
	  ENO := TRUE;
	END_REGION OUTPUTS
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "LGF_TimerSwitch"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_TimerSwitch
   VAR_INPUT 
      onMonth : USInt;
      onDay : USInt;
      onWeekday : USInt;
      onHour : USInt;
      onMinute : USInt;
      offMonth : USInt;
      offDay : USInt;
      offWeekday : USInt;
      offHour : USInt;
      offMinute : USInt;
      mode : USInt;
   END_VAR

   VAR_OUTPUT 
      signal { ExternalWritable := 'False'} : Bool;
      actLocalTime {InstructionName := 'DTL'; LibVersion := '1.0'; ExternalWritable := 'False'} : DTL;
      error { ExternalWritable := 'False'} : Bool;
      status { ExternalWritable := 'False'} : Word;
      subFunctionStatus { ExternalWritable := 'False'} : Word;
   END_VAR

   VAR_TEMP 
      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempReadTimeStatus : Word;
      tempOnTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempOnTimeTod : Time_Of_Day;
      tempOffTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempOffTimeTod : Time_Of_Day;
      tempActTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempActTimeTod : Time_Of_Day;
   END_VAR

   VAR CONSTANT 
      ZERO : USInt := 0;
      CLEAR_DTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      STATUS_NO_ERROR : Word := 16#0000;
      ERR_NO_MODE_SELECTED : Word := 16#8200;
      ERR_RD_LOC_T : Word := 16#8600;
      MODE_PERMANENTLY_OFF : UInt := 0;
      MODE_DAILY : UInt := 1;
      MODE_WEEKLY : UInt := 2;
      MODE_MONTHLY : UInt := 3;
      MODE_YEARLY : UInt := 4;
      MODE_WEEK_DAYS : UInt := 5;
      MODE_WEEKEND_DAYS : UInt := 6;
      MODE_PERMANENTLY_ON : UInt := 10;
      MONTH_JANUARY : USInt := 1;
      MONTH_DECEMBER : USInt := 12;
      DAY_MONDAY : USInt := 2;
      DAY_FRIDAY : USInt := 6;
      DAY_SATURDAY : USInt := 7;
      DAY_SUNDAY : USInt := 1;
      DAY_NEXT_SUNDAY : USInt := 8;
      DAY_NEXT_MONDAY : USInt := 9;
      DATE_INCREMENT : USInt := 1;
      DAY_INCREMENT : Time := T#1d;
      WEEK_INCREMENT : Time := T#7d;
      DAYS_PER_WEEK : USInt := 7;
      DEFAULT_YEAR : UInt := 2015;
      DEFAULT_MONTH : USInt := 2;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_TimerSwitch
	  // Comment/Function: Timer Switch (daily, weekly, monthly, working days, ...)
	  //                   Mode: Daily: 1, weekly: 2, monthly: 3, yearly: 4, workday: 5, weekend: 6
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 19.08.2015  Siemens Industry Online Support
	  //                      First released version
	  // 01.00.01 16.11.2015  Siemens Industry Online Support
	  //                      Fix in mode 2
	  // 01.01.00 23.05.2016  Siemens Industry Online Support
	  //                      New mode 5 + 6
	  //                      New output: actLocalTime
	  // 01.01.01 02.01.2017  Siemens Industry Online Support
	  //                      Upgrade: TIA V14 Update 1
	  // 01.01.02 14.09.2018  Siemens Industry Online Support
	  //                      Fix in modes 1, 3, 5, 6                    
	  // 01.01.03 17.09.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.01.04 10.10.2018  Siemens Industry Online Support
	  //                      Connection to type restored
	  // 01.01.05 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 01.01.10 13.11.2019  Simatic Systems Support
	  //                      Magic numbers removed, tag naming added, code reworked
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 19.01.2020  Simatic Systems Support
	  //                      Insert documentation
	  // 03.01.00 03.06.2022  Simatic Systems Support
	  //                      Insert mode `permanently On`: `10`, `permanently Off`: `0`
	  //=============================================================================
	END_REGION BLOCK INFO HEADER
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION INITIALISATION
	  // Time ON init
	  #tempOnTimeDtl.HOUR := #onHour;
	  #tempOnTimeDtl.MINUTE := #onMinute;
	  #tempOnTimeDtl.SECOND := #ZERO;
	  #tempOnTimeDtl.NANOSECOND := #ZERO;
	  // Time OFF init
	  #tempOffTimeDtl.HOUR := #offHour;
	  #tempOffTimeDtl.MINUTE := #offMinute;
	  #tempOffTimeDtl.SECOND := #ZERO;
	  #tempOffTimeDtl.NANOSECOND := #ZERO;
	END_REGION
	
	REGION READ LOCAL TIME
	  #tempReadTimeStatus := INT_TO_WORD(RD_LOC_T(#tempTime));
	  
	  // check result for error --> 16#8000 / MSB .X15
	  IF #tempReadTimeStatus.%X15 THEN
	    #error := TRUE;
	    #status := #ERR_RD_LOC_T;
	    #subFunctionStatus := #tempReadTimeStatus;
	    #actLocalTime := #CLEAR_DTL;
	    #signal := FALSE;
	    RETURN;
	  END_IF;
	  
	  // Store time of the current day
	  #tempActTimeDtl := #tempTime;
	  #tempActTimeTod := DTL_TO_TOD(#tempTime);
	END_REGION
	
	REGION TIMER SWITCH LOGIC
	  CASE #mode OF
	    #MODE_DAILY:
	      REGION DAILY MODE
	        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;
	        #tempOnTimeDtl.MONTH := #tempActTimeDtl.MONTH;
	        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;
	        #tempOnTimeDtl.DAY := #tempActTimeDtl.DAY;
	        // Store time of the on day
	        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);
	        
	        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;
	        #tempOffTimeDtl.MONTH := #tempActTimeDtl.MONTH;
	        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;
	        #tempOffTimeDtl.DAY := #tempActTimeDtl.DAY;
	        // Store time of the off day
	        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);
	        
	        // Timer setting - overnight
	        IF #tempOnTimeTod > #tempOffTimeTod THEN
	          // Increase the day of the timeOff when midnight happens
	          IF #tempActTimeTod > #tempOffTimeTod THEN
	            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;
	          ELSE
	            // Decrease the day of the timeOn when midnight happens
	            // Activate signal from the midnight
	            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;
	          END_IF;
	        END_IF;
	      END_REGION
	      
	    #MODE_WEEKLY:
	      REGION WEEKLY MODE
	        // Set the default date
	        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempOnTimeDtl.DAY := #onWeekday;  // Synchronize DTL.WEEKDAY with date
	        
	        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);
	        
	        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempOffTimeDtl.DAY := #offWeekday;
	        
	        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);
	        
	        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;
	        
	        IF #onWeekday > #offWeekday OR
	          (#onWeekday = #offWeekday AND #tempOnTimeTod > #tempOffTimeTod) THEN
	          #tempOffTimeDtl.DAY := #offWeekday + #DAYS_PER_WEEK;
	          
	          IF #onWeekday > #tempActTimeDtl.WEEKDAY OR
	            (#onWeekday = #offWeekday AND #tempActTimeTod < #tempOffTimeTod) THEN
	            #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY + #DAYS_PER_WEEK;
	          END_IF;
	        END_IF;
	      END_REGION
	      
	    #MODE_MONTHLY:
	      REGION MONTHLY MODE
	        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;
	        #tempOnTimeDtl.MONTH := #tempActTimeDtl.MONTH;
	        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;
	        #tempOnTimeDtl.DAY := #onDay;
	        
	        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);
	        
	        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;
	        #tempOffTimeDtl.MONTH := #tempActTimeDtl.MONTH;
	        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;
	        #tempOffTimeDtl.DAY := #offDay;
	        
	        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);
	        
	        // Timer setting - over new year
	        IF #onDay > #offDay OR
	          (#onDay = #offDay AND #tempOnTimeTod > #tempOffTimeTod) THEN
	          IF #tempActTimeDtl.DAY > #offDay OR
	            (#tempActTimeDtl.DAY = #offDay AND #tempActTimeTod > #tempOffTimeTod) THEN
	            // Increase the month of the timeOff over new year
	            IF #tempOffTimeDtl.MONTH = #MONTH_DECEMBER THEN
	              #tempOffTimeDtl.MONTH := #MONTH_JANUARY;
	              #tempOffTimeDtl.YEAR := #tempOffTimeDtl.YEAR + #DATE_INCREMENT;
	            ELSE
	              #tempOffTimeDtl.MONTH := #tempOffTimeDtl.MONTH + #DATE_INCREMENT;
	            END_IF;
	          ELSE
	            // Decrease the month of the timeOn over new year
	            IF #tempOnTimeDtl.MONTH = #MONTH_JANUARY THEN
	              #tempOnTimeDtl.MONTH := #MONTH_DECEMBER;
	              #tempOnTimeDtl.YEAR := #tempOnTimeDtl.YEAR - #DATE_INCREMENT;
	            ELSE
	              #tempOnTimeDtl.MONTH := #tempOnTimeDtl.MONTH - #DATE_INCREMENT;
	            END_IF;
	            
	          END_IF;
	        END_IF;
	      END_REGION
	      
	    #MODE_YEARLY:
	      REGION YEARLY MODE
	        #tempOnTimeDtl.YEAR := #tempActTimeDtl.YEAR;
	        #tempOnTimeDtl.MONTH := #onMonth;
	        #tempOnTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;
	        #tempOnTimeDtl.DAY := #onDay;
	        
	        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);
	        
	        #tempOffTimeDtl.YEAR := #tempActTimeDtl.YEAR;
	        #tempOffTimeDtl.MONTH := #offMonth;
	        #tempOffTimeDtl.WEEKDAY := #tempActTimeDtl.WEEKDAY;
	        #tempOffTimeDtl.DAY := #offDay;
	        
	        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);
	        
	        // Timer setting - over new year
	        IF #onMonth > #offMonth OR
	          (#onMonth = #offMonth AND #tempOnTimeTod > #tempOffTimeTod) THEN
	          IF #tempActTimeDtl.MONTH > #offMonth OR
	            (#tempActTimeDtl.MONTH = #offMonth AND #tempActTimeTod > #tempOffTimeTod) THEN
	            // Increase the year of the timeOff when new year happens
	            #tempOffTimeDtl.YEAR := #tempOffTimeDtl.YEAR + #DATE_INCREMENT;
	          ELSE
	            // Decrease the year of the timeOn when new year happens
	            #tempOnTimeDtl.YEAR := #tempOnTimeDtl.YEAR - #DATE_INCREMENT;
	          END_IF;
	        END_IF;
	      END_REGION
	      
	    #MODE_WEEK_DAYS:  // Working days (Monday - Friday)
	      REGION WEEK DAYS MODE  
	        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempOnTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;
	        
	        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);
	        
	        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempOffTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;
	        
	        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);
	        
	        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;
	        
	        // Timer setting - overnight
	        IF #tempOnTimeTod > #tempOffTimeTod THEN
	          IF #tempActTimeTod > #tempOffTimeTod THEN
	            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;
	          ELSE
	            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;
	          END_IF;
	        END_IF;
	        
	        IF #tempOnTimeDtl.DAY <= #DAY_MONDAY THEN
	          #tempOnTimeDtl.DAY := #DAY_MONDAY;
	        ELSIF #tempOnTimeDtl.DAY > #DAY_FRIDAY THEN
	          #tempOnTimeDtl.DAY := #DAY_FRIDAY;
	        END_IF;
	        
	        IF #tempOffTimeDtl.DAY > #DAY_FRIDAY AND
	          #tempOnTimeTod > #tempOffTimeTod THEN // #tempOffTime > Friday AND crossed midnight
	          #tempOffTimeDtl.DAY := #DAY_SATURDAY;
	        ELSIF #tempOffTimeDtl.DAY > #DAY_FRIDAY THEN
	          #tempOffTimeDtl.DAY := #DAY_FRIDAY;
	        END_IF;
	      END_REGION
	      
	    #MODE_WEEKEND_DAYS:  // Weekend (Saturday and Sunday)    
	      REGION WEEKEND DAYS MODE
	        #tempOnTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempOnTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempOnTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;
	        
	        IF #tempOnTimeDtl.DAY < #DAY_SATURDAY THEN
	          #tempOnTimeDtl := #tempOnTimeDtl + #WEEK_INCREMENT;
	        END_IF;
	        
	        #tempOnTimeTod := DTL_TO_TOD(#tempOnTimeDtl);
	        
	        #tempOffTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempOffTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempOffTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;
	        
	        IF #tempOffTimeDtl.DAY < #DAY_SATURDAY THEN
	          #tempOffTimeDtl := #tempOffTimeDtl + #WEEK_INCREMENT;
	        END_IF;
	        
	        #tempOffTimeTod := DTL_TO_TOD(#tempOffTimeDtl);
	        
	        #tempActTimeDtl.YEAR := #DEFAULT_YEAR;
	        #tempActTimeDtl.MONTH := #DEFAULT_MONTH;
	        #tempActTimeDtl.DAY := #tempActTimeDtl.WEEKDAY;
	        
	        IF #tempActTimeDtl.DAY < #DAY_SATURDAY THEN
	          #tempActTimeDtl := #tempActTimeDtl + #WEEK_INCREMENT;
	        END_IF;
	        
	        #tempActTimeTod := DTL_TO_TOD(#tempTime);
	        
	        // Timer setting - overnight
	        IF #tempOnTimeTod > #tempOffTimeTod THEN
	          IF #tempActTimeTod > #tempOffTimeTod THEN
	            #tempOffTimeDtl := #tempOffTimeDtl + #DAY_INCREMENT;
	          ELSE
	            #tempOnTimeDtl := #tempOnTimeDtl - #DAY_INCREMENT;
	          END_IF;
	        END_IF;
	        
	        IF #tempOnTimeDtl.DAY < #DAY_SATURDAY THEN
	          #tempOnTimeDtl.DAY := #DAY_SATURDAY;
	        ELSIF #tempOnTimeDtl.DAY > #DAY_NEXT_SUNDAY THEN
	          #tempOnTimeDtl.DAY := #DAY_NEXT_SUNDAY;
	        END_IF;
	        
	        IF #tempOffTimeDtl.DAY > #DAY_NEXT_SUNDAY AND
	          #tempOnTimeTod > #tempOffTimeTod THEN // #tempOffTime.DAY > Sunday AND crossed midnight
	          #tempOffTimeDtl.DAY := #DAY_NEXT_MONDAY;
	        ELSIF #tempOffTimeDtl.DAY > #DAY_NEXT_SUNDAY THEN
	          #tempOffTimeDtl.DAY := #DAY_NEXT_SUNDAY;
	        END_IF;
	      END_REGION
	      
	    #MODE_PERMANENTLY_ON:
	      REGION PERMANENTLY ON
	        ;
	      END_REGION
	      
	    #MODE_PERMANENTLY_OFF:
	      REGION PERMANENTLY ON
	        ;
	      END_REGION
	      
	    ELSE
	      #signal := FALSE;
	      #actLocalTime := #CLEAR_DTL;
	      #error := TRUE;
	      #status := #ERR_NO_MODE_SELECTED;
	      #subFunctionStatus := USINT_TO_WORD(#mode);
	      RETURN;
	  END_CASE;
	END_REGION
	
	REGION OUTPUT
	  #actLocalTime := #tempTime;
	  #signal := ((#tempActTimeDtl >= #tempOnTimeDtl) AND (#tempActTimeDtl < #tempOffTimeDtl) AND ((#mode <> #MODE_PERMANENTLY_OFF))) OR (#mode = #MODE_PERMANENTLY_ON);
	  
	  #error := false;
	  #status := #STATUS_NO_ERROR;
	  #subFunctionStatus := #STATUS_NO_ERROR;
	  
	  // ENO is not used, forced to TRUE
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK

