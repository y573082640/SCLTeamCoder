FUNCTION "LGF_BinaryToGray" : DWord
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_BinaryToGray
   VAR_INPUT 
      variableBinary : DWord;
   END_VAR

   VAR CONSTANT 
      BIT_SHIFT_1 : USInt := 1;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_BinaryToGray
	  // Comment/Function: This function converts a binary value to a gray coded value
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO disabled - no error handling needed
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 19.08.2015 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 28.10.2015 | Siemens Industry Online Support
	  //                         Name changed
	  // 01.00.02 | 02.01.2017 | Siemens Industry Online Support
	  //                         Upgrade: TIA Portal V14 Update 1
	  // 01.00.03 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.04 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.05 | 11.06.2019 | Simatic Systems Support
	  //                         Standard header and block parameters update
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //===============================================================================
	END_REGION Block info header
	
	REGION OUTPUTS
	  #LGF_BinaryToGray := #variableBinary XOR SHR(IN := #variableBinary, N := #BIT_SHIFT_1);
	  
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_TaddrToString" : String
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_TaddrToString
   VAR_INPUT 
      ipAdressTaddr {InstructionName := 'TADDR_Param'; LibVersion := '1.0'} : TADDR_Param;
   END_VAR

   VAR_TEMP 
      tempIpAddressString : String[#MAX_IP_ADDRESS_STRING_LENGHT];
      tempSpacePosition : Int;
   END_VAR

   VAR CONSTANT 
      CONVERT_SIZE_OF_IP : USInt := 3;
      CONVERT_SIZE_OF_PORT : USInt := 5;
      CONVERT_PREC : USInt := 0;
      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;
      CONVERT_START_POSITION_OCTET_1 : UInt := 1;
      CONVERT_START_POSITION_OCTET_2 : UInt := 5;
      CONVERT_START_POSITION_OCTET_3 : UInt := 9;
      CONVERT_START_POSITION_OCTET_4 : UInt := 13;
      CONVERT_START_POSITION_PORT : UInt := 17;
      DOT_POSITION_OCTET_1 : UInt := 4;
      DOT_POSITION_OCTET_2 : UInt := 8;
      DOT_POSITION_OCTET_3 : UInt := 12;
      COLON_POSITION_PORT_ADDRESS : Int := 16;
      OCTET_1 : UInt := 1;
      OCTET_2 : UInt := 2;
      OCTET_3 : UInt := 3;
      OCTET_4 : UInt := 4;
      CHAR_DOT : Char := '.';
      CHAR_COLON : Char := ':';
      CHAR_BLANK : Char := ' ';
      MAX_IP_ADDRESS_STRING_LENGHT : DInt := 21;
      NO_BLANK_SPACE_FOUND : Int := 0;
      NUMBER_OF_CHAR_TO_DEL : Int := 1;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_TaddrToString
	  // Comment/Function: This function converts a TADDR Parameter format into a string IP Address.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO mechanism is not used, no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 19.01.2017 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.02 | 23.11.2018 | Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.03 | 17.06.2019 | Simatic Systems Support
	  //                         Standard header and block parameters update
	  // 01.00.04 | 10.07.2019 | Simatic Systems Support
	  //                         Refactoring of While to Do/While and constants inserted
	  // 01.00.05 | 30.07.2019 | Simatic Systems Support
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //===============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION Initialization
	  #tempIpAddressString := '';
	END_REGION
	
	REGION Convert octets
	  // Convert the first IP-V4 Octet to a string
	  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_1],
	           SIZE   := #CONVERT_SIZE_OF_IP,
	           PREC   := #CONVERT_PREC,
	           FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	           P      := #CONVERT_START_POSITION_OCTET_1,
	           OUT    => #tempIpAddressString);
	  
	  #tempIpAddressString[#DOT_POSITION_OCTET_1] := #CHAR_DOT;
	  
	  // Convert the second IP-V4 Octet to a string
	  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_2],
	           SIZE   := #CONVERT_SIZE_OF_IP,
	           PREC   := #CONVERT_PREC,
	           FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	           P      := #CONVERT_START_POSITION_OCTET_2,
	           OUT    => #tempIpAddressString);
	  
	  #tempIpAddressString[#DOT_POSITION_OCTET_2] := #CHAR_DOT;
	  
	  // Convert the third IP-V4 Octet to a string
	  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_3],
	           SIZE   := #CONVERT_SIZE_OF_IP,
	           PREC   := #CONVERT_PREC,
	           FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	           P      := #CONVERT_START_POSITION_OCTET_3,
	           OUT    => #tempIpAddressString);
	  
	  #tempIpAddressString[#DOT_POSITION_OCTET_3] := #CHAR_DOT;
	  
	  // Convert the fourth IP-V4 Octet to a string
	  VAL_STRG(IN     := #ipAdressTaddr.REM_IP_ADDR[#OCTET_4],
	           SIZE   := #CONVERT_SIZE_OF_IP,
	           PREC   := #CONVERT_PREC,
	           FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	           P      := #CONVERT_START_POSITION_OCTET_4,
	           OUT    => #tempIpAddressString);
	END_REGION
	
	REGION Port number
	  // If the Port number is specified, copy it to the string following the ':' seperator
	  IF #ipAdressTaddr.REM_PORT_NR > 0 THEN
	    // add colon as seperator sign
	    #tempIpAddressString[#COLON_POSITION_PORT_ADDRESS] := #CHAR_COLON;
	    //Convert the port number to string
	    VAL_STRG(IN     := #ipAdressTaddr.REM_PORT_NR,
	             SIZE   := #CONVERT_SIZE_OF_PORT,
	             PREC   := #CONVERT_PREC,
	             FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	             P      := #CONVERT_START_POSITION_PORT,
	             OUT    => #tempIpAddressString);
	  END_IF;
	END_REGION
	
	REGION Delete spaces  
	  REPEAT // run trough String and delete all spaces
	    // search for blank's
	    #tempSpacePosition := FIND(IN1 := #tempIpAddressString, IN2 := #CHAR_BLANK);
	    // blank found, delet it from string
	    IF #tempSpacePosition > #NO_BLANK_SPACE_FOUND THEN
	      #tempIpAddressString := DELETE(IN := #tempIpAddressString, L := #NUMBER_OF_CHAR_TO_DEL, P := #tempSpacePosition);
	    END_IF;
	    // run until no more blanks found in string
	  UNTIL #tempSpacePosition <= #NO_BLANK_SPACE_FOUND END_REPEAT;
	END_REGION
	
	REGION Output
	  #LGF_TaddrToString := #tempIpAddressString;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_StringToTime" : Time
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_StringToTime
   VAR_INPUT 
      timeValue : String;
   END_VAR

   VAR_TEMP 
      tempStringTime : String;
      tempCharacterPosition : Int;
      tempTimeNumber : DInt;
   END_VAR

   VAR CONSTANT 
      MS_PER_DAY : DInt := 86400000;
      MS_PER_HOUR : DInt := 3600000;
      MS_PER_MINUTE : DInt := 60000;
      MS_PER_SECOND : DInt := 1000;
      DAY_CHAR : Char := 'D';
      HOUR_CHAR : Char := 'H';
      MINUTE_CHAR : Char := 'M';
      SECOND_CHAR : Char := 'S';
      MILLISECOND_CHAR : String := 'MS';
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_StringToTime
	  // Comment/Function: This function converts a string time value to a time
	  //                   input format is the following := '10D20H30M20S630MS',
	  //                   just existing parts would be added to the string
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO mechanism is not used, no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 02.07.2019 | Simatic Systems Support
	  //                         First released version
	  // 01.00.01 | 09.07.2019 | Simatic Systems Support
	  //                         Further improvements and code optimization 
	  // 01.00.02 | 30.07.2019 | Simatic Systems Support
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //===============================================================================
	END_REGION Block info header
	
	REGION INITIALISATION
	  #tempStringTime := #timeValue;
	  #tempTimeNumber := 0;
	END_REGION
	
	REGION CONVERT
	  // determine number of days and add to time number in DInt
	  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #DAY_CHAR);
	  IF (#tempCharacterPosition <> 0) THEN
	    #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_DAY;
	    #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);
	  END_IF;
	  
	  // determine number of hours and add to time number in DInt
	  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #HOUR_CHAR);
	  IF (#tempCharacterPosition <> 0) THEN
	    #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_HOUR;
	    #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);
	  END_IF;
	  
	  // determine number of minutes and add to time number in DInt
	  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #MINUTE_CHAR);
	  IF (#tempCharacterPosition <> 0) THEN
	    #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_MINUTE;
	    #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);
	  END_IF;
	  
	  // determine number of seconds and add to time number in DInt
	  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #SECOND_CHAR);
	  IF (#tempCharacterPosition <> 0) THEN
	    #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition)) * #MS_PER_SECOND;
	    #tempStringTime := DELETE(IN := #tempStringTime, L := #tempCharacterPosition, P := 1);
	  END_IF;
	  
	  // determine number of milliseconds and add to time number in DInt
	  #tempCharacterPosition := FIND(IN1 := #tempStringTime, IN2 := #MILLISECOND_CHAR);
	  IF (#tempCharacterPosition <> 0) THEN
	    #tempTimeNumber += STRING_TO_DINT(LEFT(IN := #tempStringTime, L := #tempCharacterPosition));
	  END_IF;
	END_REGION
	
	REGION OUTPUTS
	  // convert number given in milliseconds from DInt to Time
	  #LGF_StringToTime := DINT_TO_TIME(#tempTimeNumber);
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_StringToTaddr" : TADDR_Param
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_StringToTaddr
   VAR_INPUT 
      ipAddressString : String;
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempOctetIndex : Int;
      tempCharPosition : Int;
      tempAddressString : String;
      tempOctetString : String[#MAX_CHAR_FOR_IP_OCTET_NUMBER];
      tempNumber : UDInt;
      tempPortNumberIsSpecified : Bool;
      tempIpAdressTaddr {InstructionName := 'TADDR_Param'; LibVersion := '1.0'} : TADDR_Param;
   END_VAR

   VAR CONSTANT 
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;
      ERR_OCTET_WRONG_NUMBER_OF_CHAR : Word := 16#8110;
      ERR_OCTET_STRING_IS_EMPTY : Word := 16#8120;
      ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS : Word := 16#8130;
      ERR_PORT_WRONG_NUMBER_OF_CHAR : Word := 16#8150;
      ERR_PORT_STRING_IS_EMPTY : Word := 16#8151;
      ERR_PORT_EXCEEDS_MAX_PORT : Word := 16#8152;
      MAX_IP_ADDRESS_OCTET_NUMBER : USInt := 255;
      MAX_PORT_NUMBER : UInt := 65535;
      EMPTY_STRING : Int := 0;
      MAX_CHAR_FOR_IP_OCTET_NUMBER : Int := 4;
      MAX_CHAR_FOR_PORT_NUMBER : Int := 5;
      INIT_VAL : USInt := 0;
      NUMBER_OF_IP_OCTETS : Int := 4;
      CHAR_DOT : Char := '.';
      CHAR_COLON : Char := ':';
      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;
      CONVERT_START_POSITION : UInt := 1;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_StringToTaddr
	  // Comment/Function: This function converts a string IP Address into TADDR Parameter format.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO mechanism is not used - Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 30.01.2017 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.03 | 10.06.2019 | Simatic Systems Support
	  //                         Standard header and block parameters update
	  // 01.00.04 | 10.07.2019 | Simatic Systems Support
	  //                         Code refactoring and performance improvements
	  // 01.00.06 | 14.11.2019 | Simatic Systems Support
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION Initialization
	  #tempAddressString := #ipAddressString;
	  #tempIpAdressTaddr.REM_IP_ADDR[1] := #INIT_VAL;
	  #tempIpAdressTaddr.REM_IP_ADDR[2] := #INIT_VAL;
	  #tempIpAdressTaddr.REM_IP_ADDR[3] := #INIT_VAL;
	  #tempIpAdressTaddr.REM_IP_ADDR[4] := #INIT_VAL;
	  #tempIpAdressTaddr.REM_PORT_NR := #INIT_VAL;
	  #LGF_StringToTaddr := #tempIpAdressTaddr;
	END_REGION
	
	REGION Process Address String  
	  REGION Process octests 1-4
	    FOR #tempOctetIndex := 1 TO #NUMBER_OF_IP_OCTETS BY 1 DO
	      // check if loop has not reached the last octet
	      IF #tempOctetIndex < #NUMBER_OF_IP_OCTETS THEN
	        // search for dot as octet seperator
	        // there has to be a dot present between the octets
	        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_DOT);
	        
	      ELSE
	        // search for colon as port seperator after the last Octet
	        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_COLON);
	        
	        // if colon is present, there is a port number specified / check if Port number added
	        #tempPortNumberIsSpecified := (#tempCharPosition > 0);
	        
	        // if no port is spezified, its just the last octet
	        IF NOT #tempPortNumberIsSpecified THEN
	          // need to set the char position to the end of string + one for later cobesion and checks
	          #tempCharPosition := LEN(#tempAddressString) + 1;
	        END_IF;
	      END_IF;
	      
	      REGION Octet conversion
	        // check if IP Octet contains more then three digits --> Error
	        IF #tempCharPosition > #MAX_CHAR_FOR_IP_OCTET_NUMBER THEN
	          #error := TRUE;
	          #status := #ERR_OCTET_WRONG_NUMBER_OF_CHAR OR INT_TO_WORD(#tempOctetIndex);
	          #LGF_StringToTaddr := #tempIpAdressTaddr;
	          RETURN;
	        END_IF;
	        
	        // extract octet string
	        #tempOctetString := LEFT(IN := #tempAddressString, L := #tempCharPosition - 1);
	        // Check if Octet string is empty --> Error
	        IF LEN(#tempOctetString) = #EMPTY_STRING THEN
	          #error := TRUE;
	          #status := #ERR_OCTET_STRING_IS_EMPTY OR INT_TO_WORD(#tempOctetIndex);
	          #LGF_StringToTaddr := #tempIpAdressTaddr;
	          RETURN;
	        END_IF;
	        
	        // Convert the octet string to numerical value
	        STRG_VAL(IN     := #tempOctetString,
	                 FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	                 P      := #CONVERT_START_POSITION,
	                 OUT    => #tempNumber);
	        
	        // check if the octet number exeeds the maximum possible range of 255 of USInt --> Error
	        IF #tempNumber > #MAX_IP_ADDRESS_OCTET_NUMBER THEN
	          #error := TRUE;
	          #status := #ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS OR INT_TO_WORD(#tempOctetIndex);
	          #LGF_StringToTaddr := #tempIpAdressTaddr;
	          RETURN;
	        END_IF;
	        
	        // add address octet to temp address tag
	        #tempIpAdressTaddr.REM_IP_ADDR[#tempOctetIndex] := UDINT_TO_USINT(#tempNumber);
	        
	        // delete octet string from address string
	        #tempAddressString := DELETE(IN := #tempAddressString, P := 1, L := #tempCharPosition);
	      END_REGION Octet conversion
	    END_FOR;
	  END_REGION Process octests 1-4
	  
	  REGION PORT number conversion
	    // If the string contains a port number too, parse it
	    IF #tempPortNumberIsSpecified THEN
	      // lenght of string exceeds length of port string --> Error
	      IF LEN(#tempAddressString) > #MAX_CHAR_FOR_PORT_NUMBER THEN
	        #error := TRUE;
	        #status := #ERR_PORT_WRONG_NUMBER_OF_CHAR;
	        #LGF_StringToTaddr := #tempIpAdressTaddr;
	        RETURN;
	        
	        // Check if string is empty --> Error
	      ELSIF LEN(#tempAddressString) = #EMPTY_STRING THEN
	        #error := TRUE;
	        #status := #ERR_PORT_STRING_IS_EMPTY;
	        #LGF_StringToTaddr := #tempIpAdressTaddr;
	        RETURN;
	      END_IF;
	      
	      // Convert the port number string to numerical value
	      STRG_VAL(IN     := #tempAddressString,
	               FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	               P      := #CONVERT_START_POSITION,
	               OUT    => #tempNumber);
	      
	      // check if the Port number exeeds the maximum possible range of 65535 of UInt --> Error
	      IF #tempNumber > #MAX_PORT_NUMBER THEN
	        #error := TRUE;
	        #status := #ERR_PORT_EXCEEDS_MAX_PORT;
	        #LGF_StringToTaddr := #tempIpAdressTaddr;
	        RETURN;
	      END_IF;
	      
	      // add port number to temp address tag
	      #tempIpAdressTaddr.REM_PORT_NR := UDINT_TO_UINT(#tempNumber);
	    END_IF;
	  END_REGION PORT number conversion
	  
	END_REGION
	
	REGION Outputs
	  #error := FALSE;
	  #status := #STATUS_FINISHED_NO_ERROR;
	  #LGF_StringToTaddr := #tempIpAdressTaddr;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_StringToInt" : DInt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_StringToInt
   VAR_INPUT 
      value : String;
   END_VAR

   VAR_TEMP 
      tempDoubleInteger : DInt;
   END_VAR

   VAR CONSTANT 
      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;
      CONVERT_START_POSITION : UInt := 1;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_StringToInt
	  // Comment/Function: This function converts a string to an integer value
	  //                   Vice versa of the LGF_IntToString - wrapper of the system function VAL_STRG.
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO handling done by STRG_VAL
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.01 | 12.06.2019 | Simatic Systems Support
	  //                         First released version
	  // 01.00.03 | 30.07.2019 | Simatic Systems Support
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //                         ENO handling done by STRG_VAL system function
	  //===============================================================================
	END_REGION Block info header
	
	REGION CONVERSION
	  STRG_VAL(IN     := #value,
	           FORMAT := #CONVERT_FORMAT_TO_INTEGER,
	           P      := #CONVERT_START_POSITION,
	           OUT    => #tempDoubleInteger);
	END_REGION
	
	REGION OUTPUT
	  #LGF_StringToInt := #tempDoubleInteger;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_StringToDTL_ISO" : DTL
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_StringToDTL_ISO
   VAR_INPUT 
      "date" : String;
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempIndex : DInt;
      tempDateAndTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempDateString : String;
   END_VAR

   VAR CONSTANT 
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;
      STATUS_NO_JOB : Word := 16#7000;
      ERR_FORMAT_YEAR : Word := 16#8201;
      ERR_FORMAT_MONTH : Word := 16#8202;
      ERR_FORMAT_DAY : Word := 16#8203;
      ERR_FORMAT_HOUR : Word := 16#8204;
      ERR_FORMAT_MINUTE : Word := 16#8205;
      ERR_FORMAT_SECOND : Word := 16#8206;
      ERR_FORMAT_NANOSECOND : Word := 16#8207;
      INITIAL_VALUE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00.0;
      CONVERT_PRECISION : USInt := 0;
      CONVERT_FORMAT_TO_DECIMAL : Word := 16#0000;
      CONVERT_START_POSITION : UInt := 1;
      CONVERT_START_POSITION_YEAR : SInt := 1;
      CONVERT_START_POSITION_MONTH : SInt := 6;
      CONVERT_START_POSITION_DAY : SInt := 9;
      CONVERT_START_POSITION_HOUR : SInt := 12;
      CONVERT_START_POSITION_MINUTE : SInt := 15;
      CONVERT_START_POSITION_SECOND : SInt := 18;
      CONVERT_START_POSITION_NANOSECOND : SInt := 21;
      CONVERT_SIZE_YEAR : USInt := 4;
      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;
      CONVERT_SIZE_NANOSECOND : USInt := 9;
      YEAR_MIN : UInt := 1970;
      YEAR_MAX : UInt := 2262;
      MONTH_MIN : USInt := 1;
      MONTH_MAX : USInt := 12;
      DAY_MIN : USInt := 1;
      DAY_MAX : USInt := 31;
      HOUR_MIN : USInt := 0;
      HOUR_MAX : USInt := 23;
      SECOND_MINUTE_MIN : USInt := 0;
      SECOND_MINUTE_MAX : USInt := 59;
      NANOSECOND_MIN : UDInt := 0;
      NANOSECOND_MAX : UDInt := 999999999;
      NANOSECOND_FOR_COUNTER : DInt := 9;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_StringToDTL_ISO
	  // Comment/Function: This function converts a character string in international format
	  //                   with date components into the data type DTL.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO mechanism is not used, Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 15.06.2016 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 02.01.2017 | Siemens Industry Online Support
	  //                         Upgrade: TIA Portal V14 Update 1
	  // 01.00.02 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.03 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.04 | 17.07.2019 | Simatic Systems Support
	  //                         Reworked from "LGF_StringToDTL" to "LGF_StringToDTL_ISO"
	  //                         Removed format and split into two blocks
	  //                         Bugfix - set weekday correctly
	  //                         Correction of the weekday of DTL, comments added
	  //                         Add ENO handling, adjust comments in interface
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION CONVERTER
	  IF #date = '' THEN
	    #error := true;
	    #status := #STATUS_NO_JOB;
	    #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	    RETURN;
	  END_IF;
	  
	  // Set format parameters for input string
	  // International ISO 8601
	  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS
	  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--
	  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29
	  
	  REGION YEAR
	    // Separating the input string into components of DTL
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_YEAR, P := #CONVERT_START_POSITION_YEAR);
	    // Converting separated String components into DTL values
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.YEAR,
	             P      := #CONVERT_START_POSITION);
	    // Format check
	    IF (#tempDateAndTime.YEAR < #YEAR_MIN) OR (#YEAR_MAX < #tempDateAndTime.YEAR) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_YEAR;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION MONTH
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MONTH);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.MONTH,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.MONTH < #MONTH_MIN) OR (#MONTH_MAX < #tempDateAndTime.MONTH) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_MONTH;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION DAY
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_DAY);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.DAY,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.DAY < #DAY_MIN) OR (#DAY_MAX < #tempDateAndTime.DAY) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_DAY;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION HOUR
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_HOUR);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.HOUR,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.HOUR < #HOUR_MIN) OR (#HOUR_MAX < #tempDateAndTime.HOUR) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_HOUR;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION MINUTE
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MINUTE);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.MINUTE,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.MINUTE < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.MINUTE) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_MINUTE;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION SECOND
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_SECOND);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.SECOND,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.SECOND < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.SECOND) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_SECOND;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION NANOSECOND
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_NANOSECOND, P := #CONVERT_START_POSITION_NANOSECOND);
	    // Replacing of the "blan" in the nanosecond string by "0"
	    // Effect:   xx.1 --> xx.1 AND NOT xx.1 --> xx.000000001
	    FOR #tempIndex := 1 TO #NANOSECOND_FOR_COUNTER DO
	      IF #tempDateString[#tempIndex] = ' ' THEN
	        #tempDateString[#tempIndex] := '0';
	      END_IF;
	    END_FOR;
	    
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.NANOSECOND,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.NANOSECOND < 0) OR (999999999 < #tempDateAndTime.NANOSECOND) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_NANOSECOND;
	      #LGF_StringToDTL_ISO := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  // Correction of the weekday of DTL
	  #tempDateAndTime := #tempDateAndTime + t#0ms;
	END_REGION
	
	REGION OUTPUTS
	  #LGF_StringToDTL_ISO := #tempDateAndTime;
	  #error := FALSE;
	  #status := #STATUS_FINISHED_NO_ERROR;
	  // no error handling needed because of error bit output
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_StringToDTL_DE" : DTL
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_StringToDTL_DE
   VAR_INPUT 
      "date" : String;
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempIndex : DInt;
      tempDateAndTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempDateString : String;
   END_VAR

   VAR CONSTANT 
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;
      STATUS_NO_CURRENT_JOBS : Word := 16#7000;
      ERR_FORMAT_YEAR : Word := 16#8201;
      ERR_FORMAT_MONTH : Word := 16#8202;
      ERR_FORMAT_DAY : Word := 16#8203;
      ERR_FORMAT_HOUR : Word := 16#8204;
      ERR_FORMAT_MINUTE : Word := 16#8205;
      ERR_FORMAT_SECOND : Word := 16#8206;
      ERR_FORMAT_NANOSECOND : Word := 16#8207;
      INITIAL_VALUE {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1970-01-01-00:00:00.0;
      CONVERT_PRECISION : USInt := 0;
      CONVERT_FORMAT_TO_DECIMAL : Word := 16#0000;
      CONVERT_START_POSITION : UInt := 1;
      CONVERT_START_POSITION_YEAR : SInt := 7;
      CONVERT_START_POSITION_MONTH : SInt := 4;
      CONVERT_START_POSITION_DAY : SInt := 1;
      CONVERT_START_POSITION_HOUR : SInt := 12;
      CONVERT_START_POSITION_MINUTE : SInt := 15;
      CONVERT_START_POSITION_SECOND : SInt := 18;
      CONVERT_START_POSITION_NANOSECOND : SInt := 21;
      CONVERT_SIZE_YEAR : USInt := 4;
      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;
      CONVERT_SIZE_NANOSECOND : USInt := 9;
      YEAR_MIN : UInt := 1970;
      YEAR_MAX : UInt := 2262;
      MONTH_MIN : USInt := 1;
      MONTH_MAX : USInt := 12;
      DAY_MIN : USInt := 1;
      DAY_MAX : USInt := 31;
      HOUR_MIN : USInt := 0;
      HOUR_MAX : USInt := 23;
      SECOND_MINUTE_MIN : USInt := 0;
      SECOND_MINUTE_MAX : USInt := 59;
      NANOSECOND_MIN : UDInt := 0;
      NANOSECOND_MAX : UDInt := 999999999;
      NANOSECOND_FOR_COUNTER : DInt := 9;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_StringToDTL_DE
	  // Comment/Function: This function converts a character string in the traditional format (DE)
	  //                   with date components into the data type DTL.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO mechanism is not used, Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 22.07.2019 | Simatic Systems Support
	  //                         First released version
	  //                         Split from "LGF_StringToDTL"
	  //                         Correction of the weekday of DTL, comments added
	  //                         Add ENO handling, adjust comments in interface
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION CONVERTER
	  IF #date = '' THEN
	    #error := False;
	    #status := #STATUS_NO_CURRENT_JOBS;
	    #LGF_StringToDTL_DE := #INITIAL_VALUE;
	    RETURN;
	  END_IF;
	  
	  // Set format parameters for input string
	  // Traditional (EU)
	  // DTL  | D| D| -| M| M| -| Y| Y| Y| Y|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS
	  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--
	  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29
	  
	  REGION YEAR
	    // Separating the input string into components of DTL
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_YEAR, P := #CONVERT_START_POSITION_YEAR);
	    // Converting separated String components into DTL values
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.YEAR,
	             P      := #CONVERT_START_POSITION);
	    // Format check
	    IF (#tempDateAndTime.YEAR < #YEAR_MIN) OR (#YEAR_MAX < #tempDateAndTime.YEAR) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_YEAR;
	      #LGF_StringToDTL_DE := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION MONTH
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MONTH);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.MONTH,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.MONTH < #MONTH_MIN) OR (#MONTH_MAX < #tempDateAndTime.MONTH) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_MONTH;
	      #LGF_StringToDTL_DE := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION DAY
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_DAY);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.DAY,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.DAY < #DAY_MIN) OR (#DAY_MAX < #tempDateAndTime.DAY) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_DAY;
	      #LGF_StringToDTL_DE := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION HOUR
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_HOUR);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.HOUR,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.HOUR < #HOUR_MIN) OR (#HOUR_MAX < #tempDateAndTime.HOUR) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_HOUR;
	      #LGF_StringToDTL_DE := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION MINUTE
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_MINUTE);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.MINUTE,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.MINUTE < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.MINUTE) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_MINUTE;
	      #LGF_StringToDTL_DE := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION SECOND
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND, P := #CONVERT_START_POSITION_SECOND);
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.SECOND,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.SECOND < #SECOND_MINUTE_MIN) OR (#SECOND_MINUTE_MAX < #tempDateAndTime.SECOND) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_SECOND;
	      #LGF_StringToDTL_DE := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  REGION NANOSECOND
	    #tempDateString := MID(IN := #date, L := #CONVERT_SIZE_NANOSECOND, P := #CONVERT_START_POSITION_NANOSECOND);
	    // Replacing of the "blan" in the nanosecond string by "0"
	    // Effect:   xx.1 --> xx.1 AND NOT xx.1 --> xx.000000001
	    FOR #tempIndex := 1 TO #NANOSECOND_FOR_COUNTER DO
	      IF #tempDateString[#tempIndex] = ' ' THEN
	        #tempDateString[#tempIndex] := '0';
	      END_IF;
	    END_FOR;
	    
	    STRG_VAL(FORMAT := #CONVERT_FORMAT_TO_DECIMAL,
	             IN     := #tempDateString,
	             OUT    => #tempDateAndTime.NANOSECOND,
	             P      := #CONVERT_START_POSITION);
	    
	    IF (#tempDateAndTime.NANOSECOND < #NANOSECOND_MIN) OR (#NANOSECOND_MAX < #tempDateAndTime.NANOSECOND) THEN
	      #error := TRUE;
	      #status := #ERR_FORMAT_NANOSECOND;
	      #LGF_StringToDTL_DE := #INITIAL_VALUE;
	      RETURN;
	    END_IF;
	  END_REGION
	  
	  // Correction of the weekday of DTL
	  #tempDateAndTime := #tempDateAndTime + t#0ms;
	END_REGION
	
	REGION OUTPUTS
	  #error := FALSE;
	  #status := #STATUS_FINISHED_NO_ERROR;
	  #LGF_StringToDTL_DE := #tempDateAndTime;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_JulianTimeToDTL" : DTL
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_JulianTimeToDTL
   VAR_INPUT 
      julianDate : LReal;
      isModifiedDate { S7_PredefinedAssignment := 'FALSE'} : Bool;
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempJulianDate : LReal;
      tempUnixTime : DInt;
      tempDate : DInt;
      tempTime : DInt;
      tempDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR CONSTANT 
      DELTA_1970_1990 : DInt := 631_152_000;
      SEC_PER_DAY : DInt := 86400;
      SEC_PER_HOUR : DInt := 3600;
      SEC_PER_MINUTE : DInt := 60;
      OFFSET_JULIAN_DATE_TO_UNIX : LReal := 2440587.5;
      OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE : LReal := 2400000.5;
      STATUS_NO_ERRROR : Word := 16#0000;
      ERR_TIME_BEFORE_1990 : Word := 16#8000;
      WARN_CONVERSION_LIMIT : Word := 16#6001;
      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Comment/Function: This function converts a given Julian Date (regular or modified) of data type LReal (Double) to a date and time of data type DTL.  
	  //                   The timestamp is calculated based on UTC. This means that the time zone is not considered.
	  //                   Only times after 01/01/1990 are permitted.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15
	  // Restrictions:     ENO mechanism is not used, Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 14.04.2023 | Siemens Industry Online Support
	  //                         First released version
	  //=============================================================================
	END_REGION Block info header
	
	REGION CONVERT
	  // convert from Julian Date to UNIX time
	  IF #isModifiedDate THEN
	    #tempJulianDate := #julianDate + #OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE;
	  ELSE
	    #tempJulianDate := #julianDate;
	  END_IF;
	  #tempUnixTime := LREAL_TO_DINT((#tempJulianDate - #OFFSET_JULIAN_DATE_TO_UNIX) * #SEC_PER_DAY);
	  
	  // Check if timeUnix less than 01.01.1990
	  IF (#tempUnixTime < #DELTA_1970_1990) THEN
	    #LGF_JulianTimeToDTL := #CONVERSION_LIMIT;
	    #error := TRUE;
	    #status := #ERR_TIME_BEFORE_1990;
	    RETURN;
	    
	    // Check if timeUnix is exactly on lower limitation of 01.01.1990
	  ELSIF (#tempUnixTime = #DELTA_1970_1990) THEN
	    #LGF_JulianTimeToDTL := #CONVERSION_LIMIT;
	    #error := FALSE;
	    #status := #WARN_CONVERSION_LIMIT;
	    RETURN;
	  END_IF;
	  
	  // Convert date
	  #tempDate := (#tempUnixTime - #DELTA_1970_1990) / #SEC_PER_DAY;
	  #tempDTL := DATE_TO_DTL(DINT_TO_DATE(#tempDate));
	  
	  // Convert time
	  #tempTime := #tempUnixTime - #DELTA_1970_1990 - (#tempDate * #SEC_PER_DAY);
	  #tempDTL.HOUR := DINT_TO_USINT(#tempTime / #SEC_PER_HOUR);
	  #tempDTL.MINUTE := DINT_TO_USINT(#tempTime MOD #SEC_PER_HOUR / #SEC_PER_MINUTE);
	  #tempDTL.SECOND := DINT_TO_USINT(#tempTime MOD #SEC_PER_MINUTE);
	END_REGION
	
	REGION OUTPUTS
	  #LGF_JulianTimeToDTL := #tempDTL;
	  #error := FALSE;
	  #status := #STATUS_NO_ERRROR;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_IntToString" : String
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_IntToString
   VAR_INPUT 
      value : DInt;
   END_VAR

   VAR_TEMP 
      tempString : String;
   END_VAR

   VAR CONSTANT 
      CONVERT_SIZE : USInt := 0;
      CONVERT_PRECISION : USInt := 0;
      CONVERT_FORMAT_TO_STRING : Word := 16#0000;
      CONVERT_START_POSITION : UInt := 1;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_IntToString
	  // Comment/Function: This function converts a variable of the system data type `DInt` into a variable of the data type `String`.
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 SP1 Upd 5
	  // Restrictions:     ENO disabled - no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 04.07.2018 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.05 | 07.06.2019 | Simatic Systems Support
	  //                         Standard header and block parameters update
	  //                         Program changed to VAL_STRG wrapper
	  // 01.00.06 | 30.07.2019 | Simatic Systems Support
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //===============================================================================
	END_REGION Block info header
	
	REGION CONVERSION
	  VAL_STRG(IN     := #value,
	           SIZE   := #CONVERT_SIZE,
	           PREC   := #CONVERT_PRECISION,
	           FORMAT := #CONVERT_FORMAT_TO_STRING,
	           P      := #CONVERT_START_POSITION,
	           OUT    => #tempString);
	END_REGION
	
	REGION OUTPUT
	  #LGF_IntToString := #tempString;
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
END_FUNCTION

FUNCTION "LGF_GrayToBinary" : DWord
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_GrayToBinary
   VAR_INPUT 
      variableGray : DWord;
   END_VAR

   VAR_TEMP 
      tempBinaryBits : DWord;
   END_VAR

   VAR CONSTANT 
      BIT_SHIFT_16 : USInt := 16;
      BIT_SHIFT_8 : USInt := 8;
      BIT_SHIFT_4 : USInt := 4;
      BIT_SHIFT_2 : USInt := 2;
      BIT_SHIFT_1 : USInt := 1;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_GrayToBinary
	  // Comment/Function: This function converts a gray coded value to a binary.
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO disabled - no error handling needed
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 19.08.2015 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 28.10.2015 | Siemens Industry Online Support
	  //                         Name changed
	  // 01.00.02 | 02.01.2017 | Siemens Industry Online Support
	  //                         Upgrade: TIA Portal V14 Update 1
	  // 01.00.03 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.04 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.05 | 11.06.2019 | Simatic Systems Support
	  //                         Standard header, block parameters update and performance update
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //===============================================================================
	END_REGION Block info header
	
	REGION INITIALISATION
	  #tempBinaryBits := #variableGray;
	END_REGION
	
	REGION PROGRAM LOGIC
	  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_16);
	  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_8);
	  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_4);
	  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_2);
	  #tempBinaryBits := #tempBinaryBits XOR SHR(IN := #tempBinaryBits, N := #BIT_SHIFT_1);
	END_REGION
	
	REGION OUTPUTS
	  #LGF_GrayToBinary := #tempBinaryBits;
	  
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_GpsToGpsDD" : "LGF_typeGPS_DD"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_GpsToDD
   VAR_INPUT 
      gps : "LGF_typeGPS";
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempGPS : "LGF_typeGPS_DD";
      tempStatus : Word;
   END_VAR

   VAR CONSTANT 
      NORTH1 : Char := 'n';
      NORTH2 : Char := 'N';
      SOUTH1 : Char := 's';
      SOUTH2 : Char := 'S';
      EAST1 : Char := 'e';
      EAST2 : Char := 'E';
      WEST1 : Char := 'w';
      WEST2 : Char := 'W';
      MINUTES_PER_HOUR : Real := 60.0;
      SECONDS_PER_HOUR : Real := 3600.0;
      MAX_MIN_OR_SEC_59 : UInt := 59;
      DEGREE_0 : Real := 0.0;
      DEGREE_15 : Real := 15.0;
      DEGREE_90 : Real := 90.0;
      DEGREE_180 : Real := 180.0;
      DEGREE_360 : Real := 360.0;
      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;
      ERR_LATITUDE_DIRECTION : Word := 16#8200;
      ERR_LATITUDE_VALUE : Word := 16#8201;
      ERR_LONGITUDE_DIRECTION : Word := 16#8202;
      ERR_LONGITUDE_VALUE : Word := 16#8203;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_GpsToGpsDD
	  // Comment/Function: This function converts a give GPS type to GPS Type DD
	  //                   GPS native to GPS decimal Degree
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO mechanism is not used, Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge        | Changes applied
	  //----------|------------|-------------------------|------------------------------
	  // 01.00.00 | 2019.09.11 | SIMATIC Systems Support | First released version
	  // 03.00.00 | 2019.04.23 | Siemens Industry Support | Set version to V3.0.0
	  //                         harmonize the version of the whole library
	  // 03.00.02 | 20.01.2021 | Simatic Systems Support
	  //                         Fix `tempStatus` initialization
	  //                         Insert documentation
	  //===============================================================================
	END_REGION
	
	REGION Converion
	  // init status
	  #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	  
	  REGION Latitude
	    // Convert seconds to decimal degrees
	    #tempGPS.latitude := UINT_TO_REAL(#gps.latitude.sec) / #SECONDS_PER_HOUR;
	    
	    // Convert minutes to decimal degrees
	    #tempGPS.latitude += UINT_TO_REAL(#gps.latitude.min) / #MINUTES_PER_HOUR;
	    
	    // Convert degreesto decimal degrees
	    #tempGPS.latitude += #gps.latitude.deg;
	    
	    // Negate value if south 's' OR 'S'
	    IF (#gps.latitude.dir = #SOUTH1) OR (#gps.latitude.dir = #SOUTH2) THEN
	      #tempGPS.latitude := - (#tempGPS.latitude);
	      
	      // Positive value if north 'n' OR 'N'
	    ELSIF (#gps.latitude.dir = #NORTH1) OR (#gps.latitude.dir = #NORTH2) THEN
	      ;
	      
	      // Error direction
	    ELSE
	      #tempStatus := #ERR_LATITUDE_DIRECTION;
	    END_IF;
	    
	    // Check value input limits,  degrees > 90°, set fault
	    IF (ABS(#tempGPS.latitude) > #DEGREE_90) THEN
	      #tempStatus := #ERR_LATITUDE_VALUE;
	      
	      // Check value input limits, latitude minutes > 59, set fault
	    ELSIF (#gps.latitude.min > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LATITUDE_VALUE;
	      
	      // Check value limits input, latitude seconds > 59, set fault
	    ELSIF (#gps.latitude.sec > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LATITUDE_VALUE;
	    END_IF;
	    
	  END_REGION Latitude
	  
	  REGION Longitude
	    // Convert seconds to decimal degrees
	    #tempGPS.longitude := UINT_TO_REAL(#gps.longitude.sec) / #SECONDS_PER_HOUR;
	    
	    // Convert minutes to decimal degrees
	    #tempGPS.longitude += UINT_TO_REAL(#gps.longitude.min) / #MINUTES_PER_HOUR;
	    
	    // Convert degress to decimal degrees 
	    #tempGPS.longitude += #gps.longitude.deg;
	    
	    // Negate value if west 'w' OR 'W'
	    IF (#gps.longitude.dir = #WEST1) OR (#gps.longitude.dir = #WEST2) THEN
	      #tempGPS.longitude := - (#tempGPS.longitude);
	      
	      // Positive value if east 'e' OR 'E'
	    ELSIF (#gps.longitude.dir = #EAST1) OR (#gps.longitude.dir = #EAST2) THEN
	      ;
	      
	      // Error direction
	    ELSE
	      #tempStatus := #ERR_LONGITUDE_DIRECTION;
	    END_IF;
	    
	    // Sum of longitude decimal degrees, minutes and seconds > 180°
	    IF (ABS(#tempGPS.longitude) > #DEGREE_180) THEN
	      #tempStatus := #ERR_LONGITUDE_VALUE;
	      
	      // Check value limits input, longitude minutes > 59, set fault
	    ELSIF (#gps.longitude.min > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LONGITUDE_VALUE;
	      
	      // Check value limits input,  longitude seconds > 59, set fault
	    ELSIF (#gps.longitude.sec > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LONGITUDE_VALUE;
	    END_IF;
	    
	  END_REGION Longitude
	  
	  // Case of wrong DMS input 
	  IF (#tempStatus.%X15 = true) THEN
	    #tempGPS.latitude := #DEGREE_0; // Set value latitude to zero
	    #tempGPS.longitude := #DEGREE_0; // Set value longitude to zero
	  ELSE
	    #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	  END_IF;
	END_REGION Conversion
	
	REGION OUTPUTS
	  // Copy DMS values to work variables
	  #LGF_GpsToGpsDD := #tempGPS;
	  // Error outputs
	  #error := #tempStatus.%X15;
	  #status := #tempStatus;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	  RETURN;
	END_REGION
END_FUNCTION

FUNCTION "LGF_GpsDDToGps" : "LGF_typeGPS"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_GpsToDD
   VAR_INPUT 
      gps : "LGF_typeGPS_DD";
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempGPS_DD : "LGF_typeGPS_DD";
      tempGPS : "LGF_typeGPS";
      tempRealStorage : Real;
      tempStatus : Word;
   END_VAR

   VAR CONSTANT 
      NORTH : Char := 'N';
      SOUTH : Char := 'S';
      EAST : Char := 'E';
      WEST : Char := 'W';
      MINUTES_PER_HOUR : Real := 60.0;
      SECONDS_PER_MINUTE : Real := 60.0;
      MAX_MIN_OR_SEC_59 : UInt := 59;
      DEGREE_0 : Real := 0.0;
      DEGREE_90 : UInt := 90;
      DEGREE_180 : UInt := 180;
      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;
      ERR_LATITUDE_VALUE : Word := 16#8201;
      ERR_LONGITUDE_VALUE : Word := 16#8203;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_GpsDDToGps
	  // Comment/Function: This function converts a given GPS DD type to GPS Type native
	  //                   GPS DD (decimal degree) to native GPS format
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU1212C DC/DC/DC FW:V4.2
	  // Engineering:      TIA Portal V14 Update 1
	  // Restrictions:     ENO mechanism is not used, Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge        | Changes applied
	  //----------|------------|-------------------------|------------------------------
	  // 01.00.00 | 2019.09.11 | SIMATIC Systems Support | First released version
	  // 03.00.00 | 2019.04.23 | Siemens Industry Support | Set version to V3.0.0
	  //                         harmonize the version of the whole library
	  // 03.00.02 | 20.01.2021 | Simatic Systems Support
	  //                         Fix `tempStatus` initialization
	  //                         Insert documentation
	  //===============================================================================
	END_REGION
	
	REGION Converion
	  // init status
	  #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	  // copy input to temp
	  #tempGPS_DD := #gps;
	  
	  REGION Latitude
	    // convert direction
	    IF #tempGPS_DD.latitude >= #DEGREE_0 THEN
	      #tempGPS.latitude.dir := #NORTH;
	    ELSE
	      #tempGPS.latitude.dir := #SOUTH;
	      #tempGPS_DD.latitude := - (#tempGPS_DD.latitude);
	    END_IF;
	    
	    // Convert decimal degrees to nativ GPS coordinates
	    #tempGPS.latitude.deg := REAL_TO_UINT(#tempGPS_DD.latitude);
	    
	    #tempRealStorage := FRAC(#tempGPS_DD.latitude) * #MINUTES_PER_HOUR;
	    #tempGPS.latitude.min := REAL_TO_UINT(#tempRealStorage);
	    
	    #tempRealStorage := FRAC(#tempRealStorage) * #SECONDS_PER_MINUTE;
	    #tempGPS.latitude.sec := REAL_TO_UINT(#tempRealStorage);
	    
	    // check valueinput limits, latitude decimal degrees > 90°, set fault
	    IF (#tempGPS.latitude.deg > #DEGREE_90) THEN
	      #tempStatus := #ERR_LATITUDE_VALUE;
	      
	      // Check value input limits, latitude minutes > 59, set fault
	    ELSIF (#tempGPS.latitude.min > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LATITUDE_VALUE;
	      
	      // Check value limits input, latitude seconds > 59, set fault
	    ELSIF (#tempGPS.latitude.sec > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LATITUDE_VALUE;
	    END_IF;
	  END_REGION Latitude
	  
	  REGION Longitude
	    // convert direction
	    IF #tempGPS_DD.longitude >= #DEGREE_0 THEN
	      #tempGPS.longitude.dir := #EAST;
	    ELSE
	      #tempGPS.longitude.dir := #WEST;
	      #tempGPS_DD.longitude := - (#tempGPS_DD.longitude);
	    END_IF;
	    
	    // Convert decimal degrees to nativ GPS coordinates
	    #tempGPS.longitude.deg := REAL_TO_UINT(#tempGPS_DD.longitude);
	    
	    #tempRealStorage := FRAC(#tempGPS_DD.longitude) * #MINUTES_PER_HOUR;
	    #tempGPS.longitude.min := REAL_TO_UINT(#tempRealStorage);
	    
	    #tempRealStorage := FRAC(#tempRealStorage) * #SECONDS_PER_MINUTE;
	    #tempGPS.longitude.sec := REAL_TO_UINT(#tempRealStorage);
	    
	    // Sum of longitude decimal degrees, minutes and seconds > 180°
	    IF (#tempGPS.longitude.deg > #DEGREE_180) THEN
	      #tempStatus := #ERR_LONGITUDE_VALUE;
	      
	      // Check value limits input, longitude minutes > 59, set fault
	    ELSIF (#tempGPS.longitude.min > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LONGITUDE_VALUE;
	      
	      // Check value limits input,  longitude seconds > 59, set fault
	    ELSIF (#tempGPS.longitude.sec > #MAX_MIN_OR_SEC_59) THEN
	      #tempStatus := #ERR_LONGITUDE_VALUE;
	    END_IF;
	    
	    // Case of wrong DMS input 
	    IF (#tempStatus.%X15 = true) THEN
	      #tempGPS.latitude.deg := 0; // Set value latitude to zero
	      #tempGPS.longitude.deg := 0; // Set value longitude to zero
	    ELSE
	      #tempStatus := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	    END_IF;
	  END_REGION Longitude
	END_REGION Conversion
	
	REGION OUTPUTS
	  // Copy DMS values to work variables
	  #LGF_GpsDDToGps := #tempGPS;
	  // Error outputs
	  #error := #tempStatus.%X15;
	  #status := #tempStatus;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	  RETURN;
	END_REGION
END_FUNCTION

FUNCTION "LGF_EncodeUtf8" : Word
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Siemens Online Support'
FAMILY : LGF
NAME : LGF_EncodeUtf8
   VAR_INPUT 
      sourceString : WString;
      startPos : DInt;
   END_VAR

   VAR_OUTPUT 
      bytesUsed : UInt;
   END_VAR

   VAR_IN_OUT 
      encodedByteStream : Array[*] of Byte;
   END_VAR

   VAR_TEMP 
      tempStatus : Word;
      tempConvertedUtf8 : DWord;
      tempBytesUsed : UInt;
      tempCharacter : WChar;
      tempIndex : DInt;
      tempArrayIndex : DInt;
      tempUpperBound : DInt;
   END_VAR

   VAR CONSTANT 
      USINT_NULL : USInt := 0;
      DWORD_NULL : DWord := 16#0000_0000;
      EMPTY_WCHAR : WChar := WCHAR#' ';
      BELOW_7F : Word := 16#007F;
      BELOW_7FF : Word := 16#07FF;
      BELOW_MAX_FFFF : Word := 16#FFFF;
      BYTE_3F : Byte := 16#3F;
      BYTE_80 : Byte := 16#80;
      BYTE_C0 : Byte := 16#C0;
      BYTE_E0 : Byte := 16#E0;
      USINT_ONE : USInt := 1;
      USINT_TWO : USInt := 2;
      USINT_THREE : USInt := 3;
      STATUS_NO_ERROR : Word := 16#0000;
      ERR_START_POS_OUTSIDE : Word := 16#8201;
      ERR_COUNT_EXCEEDS_BOUNDS : Word := 16#8202;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS / (c)Copyright 2021
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_EncodeUtf8
	  // Function:         Encodes a WString into an UTF-8 encoded byte stream.
	  // Library:          LGF
	  // Author:           Siemens Industry Online Support
	  // Tested with:      CPU 1516-3 PN/DP
	  // Engineering:      TIA Portal V17
	  // Restrictions:     --
	  // Requirements:     S7-1200/1500
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 2022-12-16 | Siemens Online Support | First released version
	  //===============================================================================
	END_REGION
	
	REGION INITIALISATION  
	  // Initialize functionality: reset of variables, diagnostics, etc.
	  #tempConvertedUtf8 := #DWORD_NULL;
	  #tempBytesUsed := #USINT_NULL;
	  #tempStatus := #STATUS_NO_ERROR;
	  #tempArrayIndex := LOWER_BOUND(ARR := #encodedByteStream, DIM := 1) + #startPos;
	  #tempUpperBound := UPPER_BOUND(ARR := #encodedByteStream, DIM := 1);
	  
	  // Check parameters
	  IF #tempArrayIndex < #tempArrayIndex OR #startPos > #tempUpperBound THEN
	    #tempStatus := #ERR_START_POS_OUTSIDE;
	  END_IF;
	END_REGION
	
	REGION PROGRAM LOGIC
	  FOR #tempIndex := 1 TO LEN(#sourceString) DO
	    // Assign temp value from input
	    #tempCharacter := #sourceString[#tempIndex];
	    
	    // Use this region for application specific code
	    IF FALSE
	      OR (#tempCharacter = #EMPTY_WCHAR)
	      OR (WCHAR_TO_WORD(#tempCharacter) <= (#BELOW_7F))
	    THEN
	      IF #tempArrayIndex > #tempUpperBound THEN
	        #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;
	        EXIT;
	      ELSE
	        //will be only 1 byte occupied
	        #tempConvertedUtf8 := WCHAR_TO_DWORD(#tempCharacter);
	        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B0;
	        #tempArrayIndex += #USINT_ONE;
	        #tempBytesUsed += #USINT_ONE;
	      END_IF;
	      
	    ELSIF (WCHAR_TO_WORD(#tempCharacter) <= (#BELOW_7FF)) THEN
	      IF #tempArrayIndex + #USINT_ONE > #tempUpperBound THEN
	        #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;
	        EXIT;
	      ELSE
	        //will be 2 byte occupied
	        #tempConvertedUtf8.%B1 := (WCHAR_TO_BYTE(#tempCharacter) AND #BYTE_3F) OR #BYTE_80;
	        #tempConvertedUtf8.%B0 := WORD_TO_BYTE(SHR(IN := WCHAR_TO_WORD(#tempCharacter), N := 6)) OR #BYTE_C0;
	        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B0;
	        #tempArrayIndex += #USINT_ONE;
	        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B1;
	        #tempArrayIndex += #USINT_ONE;
	        #tempBytesUsed += #USINT_TWO;
	      END_IF;
	      
	    ELSIF (WCHAR_TO_WORD(#tempCharacter) <= (#BELOW_MAX_FFFF)) THEN
	      IF #tempArrayIndex + #USINT_ONE > #tempUpperBound THEN
	        #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;
	        EXIT;
	      ELSE
	        //will be 3 byte occupied
	        #tempConvertedUtf8.%B2 := (WCHAR_TO_BYTE(#tempCharacter) AND #BYTE_3F) OR #BYTE_80;
	        #tempConvertedUtf8.%B1 := (WORD_TO_BYTE(SHR(IN := WCHAR_TO_WORD(#tempCharacter), N := 6)) AND #BYTE_3F) OR #BYTE_80;
	        #tempConvertedUtf8.%B0 := WORD_TO_BYTE(SHR(IN := WCHAR_TO_WORD(#tempCharacter), N := 12)) OR #BYTE_E0;
	        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B0;
	        #tempArrayIndex += #USINT_ONE;
	        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B1;
	        #tempArrayIndex += #USINT_ONE;
	        #encodedByteStream[#tempArrayIndex] := #tempConvertedUtf8.%B2;
	        #tempArrayIndex += #USINT_ONE;
	        #tempBytesUsed += #USINT_THREE;
	      END_IF;
	    END_IF;
	  END_FOR;
	END_REGION
	
	REGION OUTPUTS
	  // Write application specific temp values to outputs
	  IF #tempStatus.%X15 = TRUE THEN // An error occured
	    #bytesUsed := 0;
	  ELSE
	    #bytesUsed := #tempBytesUsed;
	  END_IF;
	  
	  // Write status
	  ENO := #tempStatus.%X15;
	  #LGF_EncodeUtf8 := #tempStatus;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_DTLToUnixTime" : DInt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_DTLToUnixTime
   VAR_INPUT 
      timeDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempUnixTime : DInt;
   END_VAR

   VAR CONSTANT 
      DELTA_1970_1990 : DInt := 631_152_000;
      SEC_PER_DAY : DInt := 86400;
      TIME_ZERO_FORCE_UPDATE : Time := t#0d;
      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;
      ERR_TIME_BEFORE_1990 : Word := 16#8000;
      ERR_DTL_INPUT_VALUE_INVALID : Word := 16#8001;
      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_DTLToUnixTime
	  // Comment/Function: This function converts the date and time of data type DTL to a Unix time of data type DInt.
	  //                   The timestamp is calculated in UTC. This means that the time zone is not taken into account.
	  //                   Only times after 01/01/1990 are permitted.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15
	  // Restrictions:     Date type (range from 01.01.1990) is used in the "Function" therefore the conversion limit is set.
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 16.10.2018 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 20.06.2019 | Simatic Systems Support
	  //                         Standard header and block parameters update, status parameter added
	  // 01.00.02 | 10.07.2019 | Simatic Systems Support
	  //                         Commends added and code refactoring
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  // 03.00.02 | 14.04.2023 | Simatic Systems Support
	  //                         Improve data verification for input `timeDTL` for valid data
	  //===============================================================================
	END_REGION Block info header
	
	REGION INITIALISATION
	  #tempUnixTime := 0;
	END_REGION
	
	REGION CONVERT  IF NOT ENO THEN
	  // adding zero forces the PLC to update the tag and sets EON in case an error happend to the DTL value
	  #tempTimeDtl := #timeDTL + #TIME_ZERO_FORCE_UPDATE;
	  
	  IF NOT ENO THEN // Check if DTL has valid format and data
	    #LGF_DTLToUnixTime := #tempUnixTime;
	    #error := TRUE;
	    #status := #ERR_DTL_INPUT_VALUE_INVALID;
	    RETURN;
	    
	  ELSIF (#tempTimeDtl < #CONVERSION_LIMIT) THEN // Check if timeUnix less than 01.01.1990
	    #LGF_DTLToUnixTime := #tempUnixTime;
	    #error := TRUE;
	    #status := #ERR_TIME_BEFORE_1990;
	    RETURN;
	  END_IF;
	  
	  // Convert System Time (UTC) to UNIX time
	  // DATE range D#1990-01-01 to D#2169-06-06
	  // DATE_TO_DINT conversion - The number of days since 1/1/1990 is returned as result.
	  #tempUnixTime := (DATE_TO_DINT(DTL_TO_DATE(#tempTimeDtl)) * #SEC_PER_DAY) + (TOD_TO_DINT(DTL_TO_TOD(#tempTimeDtl)) / 1000) + #DELTA_1970_1990;
	END_REGION
	
	REGION OUTPUTS
	  #LGF_DTLToUnixTime := #tempUnixTime;
	  #error := FALSE;
	  #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_DTLToString_ISO" : String
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_DTLtoString_ISO
   VAR_INPUT 
      "date" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      separator : Char;
   END_VAR

   VAR_TEMP 
      tempString : String;
      tempIndex : DInt;
   END_VAR

   VAR CONSTANT 
      CONVERT_SIZE_YEAR : USInt := 4;
      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;
      CONVERT_SIZE_NANOSECOND : USInt := 9;
      CONVERT_PRECISION : USInt := 0;
      CONVERT_FORMAT_TO_STRING : Word := 16#0000;
      CONVERT_START_POSITION_YEAR : UInt := 1;
      CONVERT_START_POSITION_MONTH : UInt := 6;
      CONVERT_START_POSITION_DAY : UInt := 9;
      CONVERT_START_POSITION_HOUR : UInt := 12;
      CONVERT_START_POSITION_MINUTE : UInt := 15;
      CONVERT_START_POSITION_SECOND : UInt := 18;
      CONVERT_START_POSITION_NANOSECOND : UInt := 21;
      SEPARATOR_POSITION_YEAR_MONTH : UInt := 5;
      SEPARATOR_POSITION_MONTH_DAY : UInt := 8;
      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;
      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;
      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;
      SEPARATOR_NANOSECOND : Char := '.';
      SEPARATOR_TIME : Char := ':';
      SEPARATOR_DATE : Char := '-';
      REPLACE_NANOSECOND_COUNT : DInt := 8;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_DTLtoString_ISO
	  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in international format (YYYY MM DD…).
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO mechanism is not used, no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 15.06.2016 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 02.01.2017 | Siemens Industry Online Support
	  //                         Upgrade: TIA Portal V14 Update 1
	  // 01.00.02 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.03 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.04 | 17.07.2019 | Simatic Systems Support
	  //                         Bugfix - nanosecond precision and '0' filling
	  // 01.00.05 | 18.07.2019 | Simatic Systems Support
	  //                         Renamed from "LGF_DTLtoString" to "LGF_DTLtoString_ISO"
	  //                         Split into two blocks, removed "format" input
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION INITIALISATION
	  #tempString := '';
	END_REGION
	
	REGION CONVERTER
	  // Set format parameters for output string
	  // International ISO 8601
	  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS
	  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--
	  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29
	  
	  // Convert "Value" into "String" and place at the right position
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.YEAR,
	           P      := #CONVERT_START_POSITION_YEAR,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_YEAR,
	           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.MONTH,
	           P      := #CONVERT_START_POSITION_MONTH,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.DAY,
	           P      := #CONVERT_START_POSITION_DAY,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.HOUR,
	           P      := #CONVERT_START_POSITION_HOUR,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.MINUTE,
	           P      := #CONVERT_START_POSITION_MINUTE,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.SECOND,
	           P      := #CONVERT_START_POSITION_SECOND,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.NANOSECOND,
	           P      := #CONVERT_START_POSITION_NANOSECOND,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_NANOSECOND,
	           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond
	  
	  // Place separators at the right position in the string
	  IF #separator = '' THEN
	    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;
	    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;
	  ELSE
	    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;
	    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;
	  END_IF;
	  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;
	  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;
	  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;
	  
	  // Correcting the string, due to the conversion of a leading "0" value into a "blank".
	  // Replacing of "blank" by "0"
	  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_MONTH] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_DAY] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_HOUR] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_SECOND] := '0';
	  END_IF;
	  
	  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO
	    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN
	      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';
	    ELSE
	      EXIT;
	    END_IF;
	  END_FOR;
	END_REGION
	
	REGION OUTPUTS
	  #LGF_DTLtoString_ISO := #tempString;
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_DTLToString_DE" : String
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_DTLtoString_DE
   VAR_INPUT 
      "date" {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      separator : Char;
   END_VAR

   VAR_TEMP 
      tempString : String;
      tempIndex : DInt;
   END_VAR

   VAR CONSTANT 
      CONVERT_SIZE_YEAR : USInt := 4;
      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;
      CONVERT_SIZE_NANOSECOND : USInt := 9;
      CONVERT_PRECISION : USInt := 0;
      CONVERT_FORMAT_TO_STRING : Word := 16#0000;
      CONVERT_START_POSITION_YEAR : UInt := 7;
      CONVERT_START_POSITION_MONTH : UInt := 4;
      CONVERT_START_POSITION_DAY : UInt := 1;
      CONVERT_START_POSITION_HOUR : UInt := 12;
      CONVERT_START_POSITION_MINUTE : UInt := 15;
      CONVERT_START_POSITION_SECOND : UInt := 18;
      CONVERT_START_POSITION_NANOSECOND : UInt := 21;
      SEPARATOR_POSITION_YEAR_MONTH : UInt := 6;
      SEPARATOR_POSITION_MONTH_DAY : UInt := 3;
      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;
      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;
      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;
      SEPARATOR_NANOSECOND : Char := '.';
      SEPARATOR_TIME : Char := ':';
      SEPARATOR_DATE : Char := '-';
      REPLACE_NANOSECOND_COUNT : DInt := 8;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_DTLtoString_DE
	  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in the traditional format (DD MM YYYYY…).
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15.1
	  // Restrictions:     ENO mechanism is not used, no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 18.07.2019 | Simatic Systems Support
	  //                         First released version
	  //                         Split from "LGF_DTLtoString"
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION INITIALISATION
	  #tempString := '';
	END_REGION
	
	REGION CONVERTER
	  // Set format parameters for output string
	  // Traditional (EU)
	  // DTL  | D| D| -| M| M| -| Y| Y| Y| Y|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS
	  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--
	  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29
	  
	  // Convert "Value" into "String" and place at the right position
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.YEAR,
	           P      := #CONVERT_START_POSITION_YEAR,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_YEAR,
	           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.MONTH,
	           P      := #CONVERT_START_POSITION_MONTH,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.DAY,
	           P      := #CONVERT_START_POSITION_DAY,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.HOUR,
	           P      := #CONVERT_START_POSITION_HOUR,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.MINUTE,
	           P      := #CONVERT_START_POSITION_MINUTE,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.SECOND,
	           P      := #CONVERT_START_POSITION_SECOND,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,
	           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond
	  
	  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,
	           IN     := #date.NANOSECOND,
	           P      := #CONVERT_START_POSITION_NANOSECOND,
	           PREC   := #CONVERT_PRECISION,
	           SIZE   := #CONVERT_SIZE_NANOSECOND,
	           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond
	  
	  // Place separators at the right position in the string
	  IF #separator = '' THEN
	    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;
	    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;
	  ELSE
	    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;
	    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;
	  END_IF;
	  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;
	  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;
	  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;
	  
	  // Correcting the string, due to the conversion of a leading "0" value into a "blank".
	  // Replacing of "blank" by "0"
	  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_MONTH] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_DAY] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_HOUR] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';
	  END_IF;
	  
	  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN
	    #tempString[#CONVERT_START_POSITION_SECOND] := '0';
	  END_IF;
	  
	  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO
	    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN
	      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';
	    ELSE
	      EXIT;
	    END_IF;
	  END_FOR;
	END_REGION
	
	REGION OUTPUTS
	  #LGF_DTLtoString_DE := #tempString;
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_DTLToJulianDate" : Void
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_DTLToJulianDate
   VAR_INPUT 
      timeDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR_OUTPUT 
      julianDate : LReal;
      modifiedJulianDate : LReal;
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempTimeDtl {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
      tempUnixTime : DInt;
      tempJulianDate : LReal;
      tempModifiedJulianDate : LReal;
   END_VAR

   VAR CONSTANT 
      DELTA_1970_1990 : DInt := 631_152_000;
      SEC_PER_DAY : DInt := 86400;
      OFFSET_JULIAN_DATE_TO_UNIX : LReal := 2440587.5;
      OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE : LReal := 2400000.5;
      TIME_ZERO_FORCE_UPDATE : Time := t#0d;
      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;
      ERR_DTL_INPUT_VALUE_INVALID : Word := 16#8000;
      ERR_TIME_BEFORE_1990 : Word := 16#8001;
      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Comment/Function: This function converts the date and time of data type DTL to the Julian date and as well the modified Julian Date to data type LReal (Double).  
	  //                   The timestamp is calculated based on UTC. This means that the time zone is not considered.
	  //                   Only times after 01/01/1990 are permitted.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-1516F (V2.9)
	  // Engineering:      TIA Portal V17
	  // Restrictions:     Date type (range from 01.01.1990) is used in the "Function" therefore the conversion limit is set.
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 14.04.2023 | Siemens Industry Online Support
	  //                         First released version
	  //===============================================================================
	END_REGION Block info header
	
	REGION INITIALISATION
	  #tempUnixTime := 0;
	  #tempJulianDate := 0.0;
	  #tempModifiedJulianDate := 0.0;
	END_REGION
	
	REGION CONVERT
	  // adding zero forces the PLC to update the tag and sets EON in case an error happend to the DTL value
	  #tempTimeDtl := #timeDTL + #TIME_ZERO_FORCE_UPDATE;
	  
	  IF NOT ENO THEN // Check if DTL has valid format and data
	    #julianDate := #tempJulianDate;
	    #modifiedJulianDate := #tempModifiedJulianDate;
	    #error := TRUE;
	    #status := #ERR_DTL_INPUT_VALUE_INVALID;
	    RETURN;
	  ELSIF (#tempTimeDtl < #CONVERSION_LIMIT) THEN // Check if timeUnix less than 01.01.1990
	    #julianDate := #tempJulianDate;
	    #modifiedJulianDate := #tempModifiedJulianDate;
	    #error := TRUE;
	    #status := #ERR_TIME_BEFORE_1990;
	    RETURN;
	  END_IF;
	  
	  // Convert System Time (UTC) to UNIX time
	  // DATE range D#1990-01-01 to D#2169-06-06
	  // DATE_TO_DINT conversion - The number of days since 1/1/1990 is returned as result.
	  #tempUnixTime := (DATE_TO_DINT(DTL_TO_DATE(#tempTimeDtl)) * #SEC_PER_DAY) + (TOD_TO_DINT(DTL_TO_TOD(#tempTimeDtl)) / 1000) + #DELTA_1970_1990;
	  
	  // Convert Unix time to Julian Date
	  #tempJulianDate := (DINT_TO_LREAL(#tempUnixTime) / #SEC_PER_DAY) + #OFFSET_JULIAN_DATE_TO_UNIX;
	  // Convert regular Julian date to modified Julian date
	  #tempModifiedJulianDate := #tempJulianDate - #OFFSET_MODIFIED_JULIAN_DATE_TO_JULIAN_DATE;
	END_REGION
	
	REGION OUTPUTS
	  #julianDate := #tempJulianDate;
	  #modifiedJulianDate := #tempModifiedJulianDate;
	  #error := FALSE;
	  #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_DecodeUtf8" : Word
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Siemens Online Support'
FAMILY : LGF
NAME : LGF_DecodeUtf8
   VAR_INPUT 
      byteStream : Array[*] of Byte;
      startPos : DInt;
      count : UInt;
   END_VAR

   VAR_IN_OUT 
      decodedString : WString;
   END_VAR

   VAR_TEMP 
      tempString : WString;
      tempStatus : Word;
      tempCodepoint : DWord;
      tempPos : DInt;
      tempLowerBound : DInt;
      tempUpperBound : DInt;
      tempMaxLen : DInt;
   END_VAR

   VAR CONSTANT 
      FOLLOW_BYTE : Byte := 2#10000000;
      START_BYTE_TWO : Byte := 2#11000000;
      START_BYTE_THREE : Byte := 2#11100000;
      START_BYTE_FOUR : Byte := 2#11110000;
      NUM_NET_BITS : USInt := 6;
      REPLACEMENT_CHAR : Word := 16#003F;
      MAX_CODEPOINT : Word := 16#D7FF;
      STATUS_NO_ERROR : Word := 16#0000;
      WARN_UNSUPPORTED_CHAR : Word := 16#7FFD;
      WARN_STREAM_EXCEEDS_MAX_LEN : Word := 16#7FFE;
      ERR_START_POS_OUTSIDE : Word := 16#8201;
      ERR_COUNT_EXCEEDS_BOUNDS : Word := 16#8202;
      ERR_COUNT_EXCEEDS_MAX_LEN : Word := 16#8203;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS / (c)Copyright 2021
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_DecodeUtf8
	  // Function:         Decodes a UTF-8 encoded byte stream into a WString
	  // Library:          LGF
	  // Author:           Siemens Industry Online Support
	  // Tested with:      CPU 1516-3 PN/DP
	  // Engineering:      TIA Portal V16
	  // Restrictions:     --
	  // Requirements:     S7-1200/1500
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 2022-12-16 | Online Support         | First released version
	  //===============================================================================
	END_REGION
	
	REGION INITIALISATION
	  #tempString := WString#'';
	  #tempPos := #startPos;
	  #tempLowerBound := LOWER_BOUND(ARR := #byteStream, DIM := 1);
	  #tempUpperBound := UPPER_BOUND(ARR := #byteStream, DIM := 1);
	  #tempMaxLen := MAX_LEN(#decodedString);
	  #tempStatus := #STATUS_NO_ERROR;
	  
	  // Check parameters
	  IF #startPos < #tempLowerBound OR #startPos > #tempUpperBound THEN
	    #tempStatus := #ERR_START_POS_OUTSIDE;
	  ELSIF #startPos + #count > #tempUpperBound THEN
	    #tempStatus := #ERR_COUNT_EXCEEDS_BOUNDS;
	  ELSIF #count > #tempMaxLen THEN
	    #tempStatus := #ERR_COUNT_EXCEEDS_MAX_LEN;
	  END_IF;
	END_REGION
	
	REGION PROGRAM LOGIC
	  IF #tempStatus = 0 THEN // No error
	    REPEAT
	      // Check length of decoded string
	      IF LEN(#tempString) >= #tempMaxLen THEN // Max. length reached and more data to decode
	        #tempStatus := #WARN_STREAM_EXCEEDS_MAX_LEN; // Output warning and exit loop
	        EXIT;
	      END_IF;
	      
	      IF #byteStream[#tempPos].%X7 = FALSE THEN // Character is encoded in 1 byte
	        IF #byteStream[#tempPos] <> 16#00 THEN // Character is not NUL
	          #tempCodepoint := #byteStream[#tempPos];
	          #tempPos += 1;
	        ELSE
	          EXIT; // End of stream found, exit loop
	        END_IF;
	        
	      ELSIF #tempPos = #tempUpperBound THEN // Character is last byte in byte stream but not encoded in 1 byte
	        #tempCodepoint := #REPLACEMENT_CHAR;
	        #tempPos += 1;
	        #tempStatus := #WARN_UNSUPPORTED_CHAR;
	        
	      ELSIF (#byteStream[#tempPos] AND #START_BYTE_FOUR) = #START_BYTE_FOUR THEN // Character is encoded in 4 bytes
	        // #tempCodepoint := #bytestream[#tempPos] AND NOT #START_BYTE_FOUR; // Mask start byte
	        
	        // FOR #tempPos := #tempPos + 1 TO #tempPos + 3 DO // Next byte and two more
	        //   #tempCodepoint := SHL(IN := #tempCodepoint, N := #NUM_NET_BITS); // Make space for follow byte
	        //   #tempCodepoint := #tempCodepoint OR (#bytestream[#tempPos] AND NOT #FOLLOW_BYTE); // Add follow byte
	        // END_FOR;
	        
	        #tempCodepoint := #REPLACEMENT_CHAR; // WChar only supports codepoints <= 16#D7FF
	        #tempPos += 4;
	        #tempStatus := #WARN_UNSUPPORTED_CHAR;
	        
	      ELSIF (#byteStream[#tempPos] AND #START_BYTE_THREE) = #START_BYTE_THREE THEN // Character is encoded in 3 bytes
	        #tempCodepoint := #byteStream[#tempPos] AND NOT #START_BYTE_THREE; // Mask start byte
	        
	        FOR #tempPos := #tempPos + 1 TO #tempPos + 2 DO // Next byte and one more
	          #tempCodepoint := SHL(IN := #tempCodepoint, N := #NUM_NET_BITS); // Make space for follow byte
	          #tempCodepoint := #tempCodepoint OR (#byteStream[#tempPos] AND NOT #FOLLOW_BYTE); // Add follow byte
	        END_FOR;
	        
	        // Check compatibility, WChar only supports codepoints <= 16#D7FF
	        IF #tempCodepoint > #MAX_CODEPOINT THEN
	          #tempCodepoint := #REPLACEMENT_CHAR;
	          #tempStatus := #WARN_UNSUPPORTED_CHAR;
	        END_IF;
	        
	      ELSIF (#byteStream[#tempPos] AND #START_BYTE_TWO) = #START_BYTE_TWO THEN // Character is encoded in 2 bytes
	        #tempCodepoint := #byteStream[#tempPos] AND NOT #START_BYTE_TWO; // Mask start byte
	        #tempCodepoint := SHL(IN := #tempCodepoint, N := #NUM_NET_BITS); // Make space for follow byte
	        #tempCodepoint := #tempCodepoint OR (#byteStream[#tempPos + 1] AND NOT #FOLLOW_BYTE); // Add follow byte
	        #tempPos += 2;
	        
	      ELSIF (#byteStream[#tempPos] AND #FOLLOW_BYTE) = #FOLLOW_BYTE THEN // Character starts with follow byte
	        #tempPos += 1; // Ignore unexpected follow bytes
	        CONTINUE;
	        
	      ELSE // Unsupported character
	        #tempCodepoint := #REPLACEMENT_CHAR;
	        #tempPos += 1;
	        #tempStatus := #WARN_UNSUPPORTED_CHAR;
	      END_IF;
	      
	      // Concatenate decoded characters
	      #tempString := CONCAT(IN1 := #tempString, IN2 := DWORD_TO_WCHAR(#tempCodepoint));
	      
	    UNTIL ((#count <> 0 AND LEN(#tempString) >= #count) OR #tempPos > #tempUpperBound) END_REPEAT;
	  END_IF;
	END_REGION
	
	REGION OUTPUTS
	  // Write application specific temp values to outputs
	  IF #tempStatus.%X15 = TRUE THEN // An error occured
	    #decodedString := WString#'';
	  ELSE // Successful or with warning
	    #decodedString := #tempString;
	  END_IF;
	  
	  // Write status
	  ENO := #tempStatus.%X15;
	  #LGF_DecodeUtf8 := #tempStatus;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_TimeToString" : String
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_TimeToString
   VAR_INPUT 
      timeValue : Time;
   END_VAR

   VAR_OUTPUT 
      stringDay : String;
      stringHour : String;
      stringMinute : String;
      stringSecond : String;
      stringMilliSecond : String;
   END_VAR

   VAR_TEMP 
      tempTimeResult : String;
      tempTimeMilliseconds : DInt;
      tempDays : DInt;
      tempHours : DInt;
      tempMinutes : DInt;
      tempSecond : DInt;
      tempMillisecond : DInt;
   END_VAR

   VAR CONSTANT 
      MS_PER_DAY : DInt := 86400000;
      MS_PER_HOUR : DInt := 3600000;
      MS_PER_MINUTE : DInt := 60000;
      MS_PER_SECOND : DInt := 1000;
      NUMBER_OF_CHAR_TO_DEL : Int := 1;
      FIRST_POSITION : Int := 1;
      NO_REMAINDER : Int := 0;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_TimeToString
	  // Comment/Function: This function converts a time value to a string
	  //                   When more than one time unit is specified, the value must not exceed 24 days, 23 hours, 59 minutes, 59 seconds or 999 milliseconds.
	  //                   Output format is the folowing := '10D20H30M20S630MS', just existing parts would be added to the string
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V14 SP1 Upd 5
	  // Restrictions:     ENO mechanism is not used, no error handling
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 03.07.2018 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 17.08.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15 Update 2
	  // 01.00.02 | 23.11.2018 | Siemens Industry Online Support
	  //                         Upgrade: TIA V15.1
	  // 01.00.03 | 02.07.2019 | Simatic Systems Support
	  //                         Standard header and block parameters update, status parameter added
	  // 01.00.05 | 09.07.2019 | Simatic Systems Support
	  //                         Further improvements minimization and commends added
	  // 01.00.06 | 30.07.2019 | Simatic Systems Support
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //===============================================================================
	END_REGION Block info header
	
	REGION INITIALISATION
	  #tempTimeResult := '';
	END_REGION
	
	REGION CONVERT
	  // convert from time to millisecond
	  #tempTimeMilliseconds := TIME_TO_DINT(#timeValue);
	  
	  // calculate the days and remaining hours
	  #tempDays := #tempTimeMilliseconds / #MS_PER_DAY;
	  #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_DAY;
	  
	  // calculate the hours and remaining minutes
	  #tempHours := #tempTimeMilliseconds / #MS_PER_HOUR;
	  #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_HOUR;
	  
	  // calculate the minutes and remaining seconds
	  #tempMinutes := #tempTimeMilliseconds / #MS_PER_MINUTE;
	  #tempTimeMilliseconds := #tempTimeMilliseconds MOD #MS_PER_MINUTE;
	  
	  // calculate the seconds and remaining milliseconds
	  #tempSecond := #tempTimeMilliseconds / #MS_PER_SECOND;
	  #tempMillisecond := #tempTimeMilliseconds MOD #MS_PER_SECOND;
	  
	  // check if value is greater then zero and add to result string without leading "+"
	  IF (#tempMillisecond > #NO_REMAINDER) THEN
	    #stringMilliSecond := DELETE(IN := DINT_TO_STRING(#tempMillisecond), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);
	    #tempTimeResult := CONCAT(IN1 := #stringMilliSecond, IN2 := 'MS');
	  END_IF;
	  
	  // check if value is greater then zero and add to result string without leading "+"
	  IF (#tempSecond > #NO_REMAINDER) THEN
	    #stringSecond := DELETE(IN := DINT_TO_STRING(#tempSecond), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);
	    #tempTimeResult := CONCAT(IN1 := #stringSecond, IN2 := 'S', IN3 := #tempTimeResult);
	  END_IF;
	  
	  // check if value is greater then zero and add to result string without leading "+"
	  IF (#tempMinutes > #NO_REMAINDER) THEN
	    #stringMinute := DELETE(IN := DINT_TO_STRING(#tempMinutes), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);
	    #tempTimeResult := CONCAT(IN1 := #stringMinute, IN2 := 'M', IN3 := #tempTimeResult);
	  END_IF;
	  
	  // check if value is greater then zero and add to result string without leading "+"
	  IF (#tempHours > #NO_REMAINDER) THEN
	    #stringHour := DELETE(IN := DINT_TO_STRING(#tempHours), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);
	    #tempTimeResult := CONCAT(IN1 := #stringHour, IN2 := 'H', IN3 := #tempTimeResult);
	  END_IF;
	  
	  // check if value is greater then zero and add to result string without leading "+"
	  IF (#tempDays > #NO_REMAINDER) THEN
	    #stringDay := DELETE(IN := DINT_TO_STRING(#tempDays), L := #NUMBER_OF_CHAR_TO_DEL, P := #FIRST_POSITION);
	    #tempTimeResult := CONCAT(IN1 := #stringDay, IN2 := 'D', IN3 := #tempTimeResult);
	  END_IF;
	END_REGION
	
	REGION OUTPUTS
	  #LGF_TimeToString := #tempTimeResult;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "LGF_UnixTimeToDTL" : DTL
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industry
FAMILY : LGF
NAME : LGF_UnixTimeToDTL
   VAR_INPUT 
      timeUnix : DInt;
   END_VAR

   VAR_OUTPUT 
      error : Bool;
      status : Word;
   END_VAR

   VAR_TEMP 
      tempDate : DInt;
      tempTime : DInt;
      tempDTL {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR

   VAR CONSTANT 
      DELTA_1970_1990 : DInt := 631_152_000;
      SEC_PER_DAY : DInt := 86400;
      SEC_PER_HOUR : DInt := 3600;
      SEC_PER_MINUTE : DInt := 60;
      STATUS_NO_ERRROR : Word := 16#0000;
      ERR_TIME_BEFORE_1990 : Word := 16#8000;
      WARN_CONVERSION_LIMIT : Word := 16#6001;
      CONVERSION_LIMIT {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL := DTL#1990-01-01-00:00:00;
   END_VAR


BEGIN
	REGION BLOCK INFO HEADER
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2017
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_UnixTimeToDTL
	  // Comment/Function: This function converts a Unix time of data type DInt to a date and time of data type DTL.
	  //                   The timestamp is calculated in UTC. This means that the time zone is not taken into account.
	  //                   Only times after 01/01/1990 are permitted.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15
	  // Restrictions:     ENO mechanism is not used, Error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 | 16.10.2018 | Siemens Industry Online Support
	  //                         First released version
	  // 01.00.01 | 18.06.2019 | Simatic Systems Support
	  //                         Standard header and block parameters update, status parameter added
	  // 01.00.02 | 10.07.2019 | Simatic Systems Support
	  //                         Commends added and code intention adjusted
	  //                         Add ENO handling
	  // 03.00.00 | 23.04.2020 | Simatic Systems Support | Set version to V3.0.0
	  //                         Harmonize the version of the whole library
	  // 03.00.01 | 23.02.2021 | Simatic Systems Support
	  //                         Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION CONVERT
	  // Check if timeUnix less than 01.01.1990
	  IF (#timeUnix < #DELTA_1970_1990) THEN
	    #LGF_UnixTimeToDTL := #CONVERSION_LIMIT;
	    #error := TRUE;
	    #status := #ERR_TIME_BEFORE_1990;
	    RETURN;
	    
	    // Check if timeUnix is exactly on lower limitation of 01.01.1990
	  ELSIF (#timeUnix = #DELTA_1970_1990) THEN
	    #LGF_UnixTimeToDTL := #CONVERSION_LIMIT;
	    #error := FALSE;
	    #status := #WARN_CONVERSION_LIMIT;
	    RETURN;
	  END_IF;
	  
	  // Convert date
	  #tempDate := (#timeUnix - #DELTA_1970_1990) / #SEC_PER_DAY;
	  #tempDTL := DATE_TO_DTL(DINT_TO_DATE(#tempDate));
	  
	  // Convert time
	  #tempTime := #timeUnix - #DELTA_1970_1990 - (#tempDate * #SEC_PER_DAY);
	  #tempDTL.HOUR := DINT_TO_USINT(#tempTime / #SEC_PER_HOUR);
	  #tempDTL.MINUTE := DINT_TO_USINT(#tempTime MOD #SEC_PER_HOUR / #SEC_PER_MINUTE);
	  #tempDTL.SECOND := DINT_TO_USINT(#tempTime MOD #SEC_PER_MINUTE);
	END_REGION
	
	REGION OUTPUTS
	  #LGF_UnixTimeToDTL := #tempDTL;
	  #error := FALSE;
	  #status := #STATUS_NO_ERRROR;
	  //ENO mechanism is not used - forced to true.
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

