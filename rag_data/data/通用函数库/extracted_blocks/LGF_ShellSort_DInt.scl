FUNCTION_BLOCK "LGF_ShellSort_DInt"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Industry_Support
FAMILY : LGF
NAME : LGF_ShellSort_DInt
   VAR_INPUT 
      sortDirection : Bool;
   END_VAR

   VAR_OUTPUT 
      error { ExternalWritable := 'False'} : Bool;
      status { ExternalWritable := 'False'} : Word;
   END_VAR

   VAR_IN_OUT 
      "array" : Array[*] of DInt;
   END_VAR

   VAR 
      tempArray { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Array[1..#MAX_ARRAY_ELEMENTS] of DInt;
   END_VAR

   VAR_TEMP 
      tempLowerLimit : DInt;
      tempUpperLimit : DInt;
      tempNoOfElements : DInt;
      tempGap : DInt;
      tempLoopIndex : DInt;
      tempExchangeIndex : DInt;
      tempExchangeVariable : DInt;
      tempArrayOffset : DInt;
   END_VAR

   VAR CONSTANT 
      ARRAY_FIRST_DIMENSION : UInt := 1;
      ARRAY_START_INDEX : UInt := 1;
      SINGLE_ARRAY_ELEMENT : DInt := 1;
      GAP_INIT : Int := 1;
      GAP_THRESHOLD : Int := 1;
      GAP_RATIO : DInt := 3;
      INCREMENT : Int := 1;
      ELEMENTS_COUNT_CORRECTION : DInt := 1;
      MAX_ARRAY_ELEMENTS : Int := 1000;
      STATUS_NO_ERROR : Word := 16#0000;
      ERR_NO_ARRAY : Word := 16#8200;
      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;
   END_VAR


BEGIN
	REGION Block info header
	  //===============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-------------------------------------------------------------------------------
	  // Title:            LGF_ShellSort_DInt
	  // Comment/Function: This block sorts an array with any number of elements (max. 1000)
	  //                   in ascending or descending order and returns the sorted version of the array in the same variable.
	  // Library/Family:   LGF (Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      CPU 1515F-2 PN FW:V2.6
	  // Engineering:      TIA Portal V15.1 Update 2
	  // Restrictions:     ENO disabled - error handling done with error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 19.08.2015  Siemens Industry Online Support
	  //                      First released version
	  // 01.01.00 19.05.2016  Siemens Industry Online Support
	  //                      New function: reverse sort
	  // 01.01.01 02.01.2017  Siemens Industry Online Support
	  //                      Upgrade: TIA Portal V14 Update 1
	  // 01.01.02 17.08.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15 Update 2
	  // 01.01.03 23.11.2018  Siemens Industry Online Support
	  //                      Upgrade: TIA V15.1
	  // 02.00.00 29.01.2019  Siemens Industry Online Support
	  //                      Output "done" removed (not necessary, because only one cycle)
	  // 02.00.01 15.10.2019  Simatic Systems Support
	  //                      Code refactoring, comments added,
	  //                      change data type from Int to DInt
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 15.02.2021  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/**/)
	END_REGION DESCRIPTION
	
	REGION Special description
	  // Space note: If you wish to reduce the space of this block, you may reduce the
	  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose
	  // It is not recommended to increase the size significantly.
	END_REGION
	
	REGION Initialization and input data processing
	  // Input array size calculation
	  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);
	  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);
	  
	  // Array elements calculation
	  // (for example: 6 - 2 = 4; but real number of elements is 5)
	  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;
	  
	  // Shift array index to range 1..MAX_ARRAY_ELEMENTS
	  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;
	  
	  // Check whether the array contains less than the maximum possible amount of elements
	  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN
	    #error := true;
	    #status := #ERR_TOO_MANY_ELEMENTS;
	    RETURN;
	  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN
	    // If there are 0 elements in the array, set status to "Error: Parameter is an empty array"
	    #error := true;
	    #status := #ERR_NO_ARRAY;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION Sorting
	  // Read the elements of the incoming array and write into the local array
	  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO
	    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];
	  END_FOR;
	  
	  REGION Shell sort algorithm
	    #tempGap := #GAP_INIT;
	    
	    // Evaluation of the maximal gap size
	    REPEAT
	      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;
	    UNTIL #tempGap > #tempNoOfElements END_REPEAT;
	    
	    REPEAT
	      #tempGap := #tempGap / #GAP_RATIO;
	      
	      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO
	        #tempExchangeVariable := #tempArray[#tempLoopIndex];
	        #tempExchangeIndex := #tempLoopIndex;
	        
	        // sort descending 
	        IF #sortDirection THEN
	          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO
	            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];
	            #tempExchangeIndex := #tempExchangeIndex - #tempGap;
	            
	            IF (#tempExchangeIndex <= #tempGap) THEN
	              EXIT;
	            END_IF;
	          END_WHILE;
	          
	          // sort ascending
	        ELSE
	          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO
	            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];
	            #tempExchangeIndex := #tempExchangeIndex - #tempGap;
	            
	            IF (#tempExchangeIndex <= #tempGap) THEN
	              EXIT;
	            END_IF;
	          END_WHILE;
	        END_IF;
	        
	        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;
	      END_FOR;
	      
	    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;
	  END_REGION
	  
	  // Write the elements of the local array back to the inOut array
	  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO
	    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];
	  END_FOR;
	  
	  // Set "No error" status
	  #error := false;
	  #status := #STATUS_NO_ERROR;
	  
	  // no error handling needed
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION_BLOCK