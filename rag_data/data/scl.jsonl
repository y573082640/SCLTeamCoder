{"title":"积分功能","description":"编写一个函数块FB，该函数块实现输入信号的积分功能，并带有启动和复位功能。积分是对输入信号随时间的累积求和，通常用于计算流量、位移等物理量的累积值。启动功能用于开始积分计算，而复位功能用于将积分值重置为零。\n当读取系统时间出错时，则输出错误状态和错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#8600：读取系统时间错误","type":"FUNCTION_BLOCK","name":"Integration","input":[{"name":"enable","type":"Bool","description":"启动信号，当该信号为TRUE时，启用积分计算；如果为FALSE，积分计算将停止，integral输出将显示最后一次计算的值。"},{"name":"value","type":"LReal","description":"需要积分的输入信号值"},{"name":"reset","type":"Bool","description":"复位信号，当该信号为TRUE时，将积分值重置为零"}],"output":[{"name":"integral","type":"LReal","description":"积分值"},{"name":"error","type":"Bool","description":"FALSE: 没有发生错误; TRUE: 执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"}],"prompt":"<任务标题>积分功能</任务标题>\n        <任务描述>编写一个函数块FB，该函数块实现输入信号的积分功能，并带有启动和复位功能。积分是对输入信号随时间的累积求和，通常用于计算流量、位移等物理量的累积值。启动功能用于开始积分计算，而复位功能用于将积分值重置为零。\n当读取系统时间出错时，则输出错误状态和错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#8600：读取系统时间错误</任务描述>\n\n        <函数名称> Integration</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: enable, 类型: Bool, 描述: 启动信号，当该信号为TRUE时，启用积分计算；如果为FALSE，积分计算将停止，integral输出将显示最后一次计算的值。\n - 名称: value, 类型: LReal, 描述: 需要积分的输入信号值\n - 名称: reset, 类型: Bool, 描述: 复位信号，当该信号为TRUE时，将积分值重置为零\n</输入参数>\n<输出参数>\n - 名称: integral, 类型: LReal, 描述: 积分值\n - 名称: error, 类型: Bool, 描述: FALSE: 没有发生错误; TRUE: 执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"字符串转换为IP地址和端口号","description":"在西门子PLC编程中，经常需要从用户输入或外部设备接收包含IP地址和端口号的字符串，并将其解析为相应的整数格式以便进行网络通信。\n编写一个函数FC，用于将包含IP地址和可能包含端口号的字符串转换为整数形式的IP地址和端口号。字符串的格式应为\"xxx.xxx.xxx.xxx[:port]\"，其中xxx代表0-255之间的数字，port代表0-65535之间的端口号（可选）。如果字符串包含端口号，则同时返回端口号；如果不包含，则返回默认的端口号（比如0）。把转换后的IP地址和端口号返回给系统数据类型TADDR_Param结构体的相应位置。\n函数应检查输入字符串是否符合\"IP_ADDRESS:PORT\"的格式要求，其中IP地址由四个用点分隔的0到255之间的整数组成，端口号为一个0到65535之间的整数。\n如果字符串格式正确，函数应将其解析为四个字节的整数数组表示的IP地址和一个整数表示的端口号，并将这些值返回。\n如果字符串格式不正确，函数应输出一个表示错误的状态和一个错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#811x：IP地址含有过多字符，其中x表示出错的最低字节序号，例如，IP地址的第2个字节有错，则x=2\n16#812x：IP地址字符串是空字符串，x表示的含义同上\n16#813x：超过IP地址最大值（255），x表示的含义同上\n16#8150：端口号字符过多\n16#8151：端口号字符串为空\n16#8152：超过端口号最大值（65535）","type":"FUNCTION","name":"StringToTaddr","input":[{"name":"ipAddressString","type":"String","description":"输入的字符串"}],"output":[{"name":"error","type":"Bool","description":"FALSE: 没有发生错误; TRUE: 执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"}],"return_value":[{"type":"TADDR_Param","description":"转换后的IP地址和端口号"}],"prompt":"<任务标题>字符串转换为IP地址和端口号</任务标题>\n        <任务描述>在西门子PLC编程中，经常需要从用户输入或外部设备接收包含IP地址和端口号的字符串，并将其解析为相应的整数格式以便进行网络通信。\n编写一个函数FC，用于将包含IP地址和可能包含端口号的字符串转换为整数形式的IP地址和端口号。字符串的格式应为\"xxx.xxx.xxx.xxx[:port]\"，其中xxx代表0-255之间的数字，port代表0-65535之间的端口号（可选）。如果字符串包含端口号，则同时返回端口号；如果不包含，则返回默认的端口号（比如0）。把转换后的IP地址和端口号返回给系统数据类型TADDR_Param结构体的相应位置。\n函数应检查输入字符串是否符合\"IP_ADDRESS:PORT\"的格式要求，其中IP地址由四个用点分隔的0到255之间的整数组成，端口号为一个0到65535之间的整数。\n如果字符串格式正确，函数应将其解析为四个字节的整数数组表示的IP地址和一个整数表示的端口号，并将这些值返回。\n如果字符串格式不正确，函数应输出一个表示错误的状态和一个错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#811x：IP地址含有过多字符，其中x表示出错的最低字节序号，例如，IP地址的第2个字节有错，则x=2\n16#812x：IP地址字符串是空字符串，x表示的含义同上\n16#813x：超过IP地址最大值（255），x表示的含义同上\n16#8150：端口号字符过多\n16#8151：端口号字符串为空\n16#8152：超过端口号最大值（65535）</任务描述>\n\n        <函数名称> StringToTaddr</函数名称>\n        <函数类型> FUNCTION</函数类型>\n        <输入参数>\n - 名称: ipAddressString, 类型: String, 描述: 输入的字符串\n</输入参数>\n<输出参数>\n - 名称: error, 类型: Bool, 描述: FALSE: 没有发生错误; TRUE: 执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n</输出参数>\n<返回值>\n - 类型: TADDR_Param, 描述: 转换后的IP地址和端口号\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"排序","description":"编写一个函数块FB，实现一个可选的升序或降序排序功能。该函数块应接受一个可变长度的整数数组（最大长度为1000个元素）以及一个指示排序方向的参数（升序或降序），并将排序后的结果写回到原数组中。如果数组元素超过了1000或不超过1个，函数块应输出一个表示错误的状态和一个错误代码。状态代码：\n16#0000：执行FB没有出错\n16#8200：数组元素没超过1个\n16#8201：数组元素超过了1000个","type":"FUNCTION_BLOCK","name":"ShellSort_DInt","input":[{"name":"sortDirection","type":"Bool","description":"当为FALSE时表示升序排列，当为TRUE时表示降序排列"}],"output":[{"name":"error","type":"Bool","description":"FALSE: 没有发生错误; TRUE: 执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"}],"in_out":[{"name":"array","type":"Array[*] of DInt","description":"待排序的数组"}],"prompt":"<任务标题>排序</任务标题>\n        <任务描述>编写一个函数块FB，实现一个可选的升序或降序排序功能。该函数块应接受一个可变长度的整数数组（最大长度为1000个元素）以及一个指示排序方向的参数（升序或降序），并将排序后的结果写回到原数组中。如果数组元素超过了1000或不超过1个，函数块应输出一个表示错误的状态和一个错误代码。状态代码：\n16#0000：执行FB没有出错\n16#8200：数组元素没超过1个\n16#8201：数组元素超过了1000个</任务描述>\n\n        <函数名称> ShellSort_DInt</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: sortDirection, 类型: Bool, 描述: 当为FALSE时表示升序排列，当为TRUE时表示降序排列\n</输入参数>\n<输出参数>\n - 名称: error, 类型: Bool, 描述: FALSE: 没有发生错误; TRUE: 执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"矩阵加法","description":"编写一个函数FC，实现两个矩阵的加法功能。\n\n该函数接受两个可变长度的二维浮点数数组matrix1和matrix2作为输入参数。函数应检查两个输入矩阵以及用于返回结果的输出矩阵是否具有相同的行数和列数，如果不相同，则返回错误状态和特定的错误代码。\n\n状态代码：\n16#0000：执行FB没有出错\n16#8200：第一矩阵数组行的下界值与第二矩阵行的下界值不同\n16#8201：第一矩阵数组行的下界值与结果矩阵行的下界值不同\n16#8202：第一矩阵数组列的下界值与第二矩阵列的下界值不同\n16#8203：第一矩阵数组列的下界值与结果矩阵列的下界值不同\n16#8204：第一矩阵数组行的上界值与第二矩阵行的上界值不同\n16#8205：第一矩阵数组行的上界值与结果矩阵行的上界值不同\n16#8206：第一矩阵数组列的上界值与第二矩阵列的上界值不同\n16#8207：第一矩阵数组列的上界值与结果矩阵列的上界值不同","type":"FUNCTION","name":"MatrixAddition","input":[{"name":"matrix1","type":"Array[* *] of LReal","description":"第一矩阵"},{"name":"matrix2","type":"Array[* *] of LReal","description":"第二矩阵"}],"output":[{"name":"error","type":"Bool","description":"FALSE: 没有发生错误; TRUE: 执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"}],"in_out":[{"name":"matrixResult","type":"Array[* *] of LReal","description":"存放计算结果的矩阵"}],"prompt":"<任务标题>矩阵加法</任务标题>\n        <任务描述>编写一个函数FC，实现两个矩阵的加法功能。\n\n该函数接受两个可变长度的二维浮点数数组matrix1和matrix2作为输入参数。函数应检查两个输入矩阵以及用于返回结果的输出矩阵是否具有相同的行数和列数，如果不相同，则返回错误状态和特定的错误代码。\n\n状态代码：\n16#0000：执行FB没有出错\n16#8200：第一矩阵数组行的下界值与第二矩阵行的下界值不同\n16#8201：第一矩阵数组行的下界值与结果矩阵行的下界值不同\n16#8202：第一矩阵数组列的下界值与第二矩阵列的下界值不同\n16#8203：第一矩阵数组列的下界值与结果矩阵列的下界值不同\n16#8204：第一矩阵数组行的上界值与第二矩阵行的上界值不同\n16#8205：第一矩阵数组行的上界值与结果矩阵行的上界值不同\n16#8206：第一矩阵数组列的上界值与第二矩阵列的上界值不同\n16#8207：第一矩阵数组列的上界值与结果矩阵列的上界值不同</任务描述>\n\n        <函数名称> MatrixAddition</函数名称>\n        <函数类型> FUNCTION</函数类型>\n        <输入参数>\n - 名称: matrix1, 类型: Array[* *] of LReal, 描述: 第一矩阵\n - 名称: matrix2, 类型: Array[* *] of LReal, 描述: 第二矩阵\n</输入参数>\n<输出参数>\n - 名称: error, 类型: Bool, 描述: FALSE: 没有发生错误; TRUE: 执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"计算移动平均值","description":"编写一个函数块FB，该函数块计算并更新一个移动算术平均值。移动算术平均值是一种在连续数据点上进行平均的方法，其中每个新的数据点都会替换掉最旧的数据点，然后重新计算平均值。\n\n1. cyclicExecution为TRUE时，每个扫描周期自动读取一次新数据value，并更新移动平均值average。\n2. 提供外部触发信号trigger，当触发上升沿时，立即读取一次新数据并更新移动平均值。\n3. 提供复位功能reset，当复位信号为TRUE时，重置移动平均值计算。如果窗口大小小于1或大于100，则输出错误状态和状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：窗口长度设置错误，请设置一个介于1到100之间的值。","type":"FUNCTION_BLOCK","name":"FloatingAverage","input":[{"name":"cyclicExecution","type":"Bool","description":"为TRUE时，周期性读取，trigger不起作用"},{"name":"trigger","type":"Bool","description":"外部触发信号，每次上升沿读取value"},{"name":"value","type":"LReal","description":"新读取的数据值"},{"name":"windowSize","type":"Int","description":"移动平均值的窗口大小，要求范围在1到100之间"},{"name":"reset","type":"Bool","description":"复位信号，当为TRUE时重置移动平均值计算"}],"output":[{"name":"average","type":"LReal","description":"移动平均值"},{"name":"windowSizeReached","type":"Bool","description":"FALSE:尚未达到最大窗口宽度 TRUE:已经达到最大窗口宽度"},{"name":"error","type":"Bool","description":"FALSE:没有发生错误 TRUE:执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"}],"prompt":"<任务标题>计算移动平均值</任务标题>\n        <任务描述>编写一个函数块FB，该函数块计算并更新一个移动算术平均值。移动算术平均值是一种在连续数据点上进行平均的方法，其中每个新的数据点都会替换掉最旧的数据点，然后重新计算平均值。\n\n1. cyclicExecution为TRUE时，每个扫描周期自动读取一次新数据value，并更新移动平均值average。\n2. 提供外部触发信号trigger，当触发上升沿时，立即读取一次新数据并更新移动平均值。\n3. 提供复位功能reset，当复位信号为TRUE时，重置移动平均值计算。如果窗口大小小于1或大于100，则输出错误状态和状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：窗口长度设置错误，请设置一个介于1到100之间的值。</任务描述>\n\n        <函数名称> FloatingAverage</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: cyclicExecution, 类型: Bool, 描述: 为TRUE时，周期性读取，trigger不起作用\n - 名称: trigger, 类型: Bool, 描述: 外部触发信号，每次上升沿读取value\n - 名称: value, 类型: LReal, 描述: 新读取的数据值\n - 名称: windowSize, 类型: Int, 描述: 移动平均值的窗口大小，要求范围在1到100之间\n - 名称: reset, 类型: Bool, 描述: 复位信号，当为TRUE时重置移动平均值计算\n</输入参数>\n<输出参数>\n - 名称: average, 类型: LReal, 描述: 移动平均值\n - 名称: windowSizeReached, 类型: Bool, 描述: FALSE:尚未达到最大窗口宽度 TRUE:已经达到最大窗口宽度\n - 名称: error, 类型: Bool, 描述: FALSE:没有发生错误 TRUE:执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"查找最大最小值","description":"编写一个函数FC，该函数能够接收一个可变长度的整数数组作为输入，并返回数组中的最大值和最小值以及他们所在数组的位置。\n\n示例：\n假设输入数组为array[1..5]=[5, 10, 2, 25, 1]，函数应返回最大值25，最小值1，最大值所在位置4，最小值所在位置5。","type":"FUNCTION","name":"SearchMinMax_DInt","input":[{"name":"values","type":"Array[*] of DInt","description":"待查找的数组"}],"output":[{"name":"minValue","type":"DInt","description":"数组中的最小值"},{"name":"minValueIndex","type":"DInt","description":"最小值在数组中的位置"},{"name":"maxValue","type":"DInt","description":"数组中的最大值"},{"name":"maxValueIndex","type":"DInt","description":"最大值在数组中的位置"}],"prompt":"<任务标题>查找最大最小值</任务标题>\n        <任务描述>编写一个函数FC，该函数能够接收一个可变长度的整数数组作为输入，并返回数组中的最大值和最小值以及他们所在数组的位置。\n\n示例：\n假设输入数组为array[1..5]=[5, 10, 2, 25, 1]，函数应返回最大值25，最小值1，最大值所在位置4，最小值所在位置5。</任务描述>\n\n        <函数名称> SearchMinMax_DInt</函数名称>\n        <函数类型> FUNCTION</函数类型>\n        <输入参数>\n - 名称: values, 类型: Array[*] of DInt, 描述: 待查找的数组\n</输入参数>\n<输出参数>\n - 名称: minValue, 类型: DInt, 描述: 数组中的最小值\n - 名称: minValueIndex, 类型: DInt, 描述: 最小值在数组中的位置\n - 名称: maxValue, 类型: DInt, 描述: 数组中的最大值\n - 名称: maxValueIndex, 类型: DInt, 描述: 最大值在数组中的位置\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"生成脉冲信号","description":"编写一个函数块FB，该函数块生成一个周期性的信号，该信号在FALSE和TRUE之间变化。每个周期中TRUE状态的持续时间和FALSE状态的持续时间由给定的频率和脉冲间歇比决定。脉冲间歇比定义的是每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。\n\n示例：\n假设frequency为0.5Hz，pulsePauseRatio为3。这意味着每个周期是2秒，其中TRUE状态持续1.5秒，FALSE状态持续0.5秒。","type":"FUNCTION_BLOCK","name":"Frequency","input":[{"name":"frequency","type":"Real","description":"以Hz为单位的时钟频率"},{"name":"pulsePauseRatio","type":"Real","description":"脉冲间歇比，定义为每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。例如，如果pulsePauseRatio为2，则TRUE状态的持续时间将是FALSE状态的两倍。"}],"output":[{"name":"clock","type":"Bool","description":"脉冲输出"},{"name":"countdown","type":"Time","description":"当前状态的剩余时间"}],"prompt":"<任务标题>生成脉冲信号</任务标题>\n        <任务描述>编写一个函数块FB，该函数块生成一个周期性的信号，该信号在FALSE和TRUE之间变化。每个周期中TRUE状态的持续时间和FALSE状态的持续时间由给定的频率和脉冲间歇比决定。脉冲间歇比定义的是每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。\n\n示例：\n假设frequency为0.5Hz，pulsePauseRatio为3。这意味着每个周期是2秒，其中TRUE状态持续1.5秒，FALSE状态持续0.5秒。</任务描述>\n\n        <函数名称> Frequency</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: frequency, 类型: Real, 描述: 以Hz为单位的时钟频率\n - 名称: pulsePauseRatio, 类型: Real, 描述: 脉冲间歇比，定义为每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。例如，如果pulsePauseRatio为2，则TRUE状态的持续时间将是FALSE状态的两倍。\n</输入参数>\n<输出参数>\n - 名称: clock, 类型: Bool, 描述: 脉冲输出\n - 名称: countdown, 类型: Time, 描述: 当前状态的剩余时间\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"温度逻辑控制","description":"编写一个函数块FB，实现一个温度控制逻辑。该程序应包含以下功能：\n1. 通过模拟量输入模块读取温度传感器的值。\n2. 将读取的温度值TemperatureSensorInput与设定的温度值SetTemperature进行比较。\n3. 如果实际温度低于设定温度，则启动加热器HeaterOutput。\n4. 如果实际温度高于设定温度，则关闭加热器HeaterOutput。\n5. 如果加热器连续工作超过一定时间（为方便测试，采用5s），应触发过热保护，自动关闭加热器，必须再过一定时间（为方便测试，采用3s）才能解除过热保护。\n6. 提供状态指示，显示当前温度、设定温度、加热器状态以及是否有过热保护触发。\n7. 提供温度传感器故障判断，如果读取的温度值TemperatureSensorInput小于0或大于100，则认为传感器故障，此时应关闭加热器。","type":"FUNCTION_BLOCK","name":"TempCtrl","input":[{"name":"TemperatureSensorInput","type":"Real","description":"温度传感器输入值，即实际温度"},{"name":"SetTemperature","type":"Real","description":"设定温度值"}],"output":[{"name":"CurrentTemperature","type":"Real","description":"当前温度显示"},{"name":"SetTempDisplay","type":"Real","description":"设定温度显示"},{"name":"HeaterStatus","type":"Bool","description":"加热器状态显示"},{"name":"OverheatProtection","type":"Bool","description":"过热保护状态显示"}],"in_out":[{"name":"HeaterOutput","type":"Bool","description":"加热器控制输出"}],"prompt":"<任务标题>温度逻辑控制</任务标题>\n        <任务描述>编写一个函数块FB，实现一个温度控制逻辑。该程序应包含以下功能：\n1. 通过模拟量输入模块读取温度传感器的值。\n2. 将读取的温度值TemperatureSensorInput与设定的温度值SetTemperature进行比较。\n3. 如果实际温度低于设定温度，则启动加热器HeaterOutput。\n4. 如果实际温度高于设定温度，则关闭加热器HeaterOutput。\n5. 如果加热器连续工作超过一定时间（为方便测试，采用5s），应触发过热保护，自动关闭加热器，必须再过一定时间（为方便测试，采用3s）才能解除过热保护。\n6. 提供状态指示，显示当前温度、设定温度、加热器状态以及是否有过热保护触发。\n7. 提供温度传感器故障判断，如果读取的温度值TemperatureSensorInput小于0或大于100，则认为传感器故障，此时应关闭加热器。</任务描述>\n\n        <函数名称> TempCtrl</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: TemperatureSensorInput, 类型: Real, 描述: 温度传感器输入值，即实际温度\n - 名称: SetTemperature, 类型: Real, 描述: 设定温度值\n</输入参数>\n<输出参数>\n - 名称: CurrentTemperature, 类型: Real, 描述: 当前温度显示\n - 名称: SetTempDisplay, 类型: Real, 描述: 设定温度显示\n - 名称: HeaterStatus, 类型: Bool, 描述: 加热器状态显示\n - 名称: OverheatProtection, 类型: Bool, 描述: 过热保护状态显示\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"灯控程序","description":"编写一个函数块FB，实现一个灯控功能。\n某控制台有3个指示灯，要求通过3个按钮开关进行控制。\n\n1. 输入参数#button1~#button3表示3个按钮开关，输出参数#greenLight、#redLight、#yellowLight表示指示灯。\n2. 当#button1=0时，表示手动模式，指示灯根据#button2和#button3的操作组合进行不同状态显示：\n   - 当#button2和#button3都为0时，所有指示灯熄灭（#greenLight、#redLight、#yellowLight都为0）。\n   - 当#button2为1且#button3为0时，#greenLight常亮，并且#redLight以0.5Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2为0且#button3为1时，#redLight常亮，并且#yellowLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2和#button3都为1时，#yellowLight常亮，并且#greenLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n3. 当#button1=1时，表示自动模式，指示灯自动按照如下说明循环执行：\n   - 首先#greenLight亮，保持1秒。\n   - 然后#greenLight熄灭，#redLight亮，保持1秒。\n   - 然后#redLight熄灭，#yellowLight亮，保持1秒。\n   - 然后回到初始状态#greenLight亮，保持1秒，如此循环。","type":"FUNCTION_BLOCK","name":"LightsControl","input":[{"name":"button1","type":"Bool","description":"按钮1"},{"name":"button2","type":"Bool","description":"按钮2"},{"name":"button3","type":"Bool","description":"按钮3"}],"output":[{"name":"greenLight","type":"Bool","description":"绿灯"},{"name":"redLight","type":"Bool","description":"红灯"},{"name":"yellowLight","type":"Bool","description":"黄灯"}],"prompt":"<任务标题>灯控程序</任务标题>\n        <任务描述>编写一个函数块FB，实现一个灯控功能。\n某控制台有3个指示灯，要求通过3个按钮开关进行控制。\n\n1. 输入参数#button1~#button3表示3个按钮开关，输出参数#greenLight、#redLight、#yellowLight表示指示灯。\n2. 当#button1=0时，表示手动模式，指示灯根据#button2和#button3的操作组合进行不同状态显示：\n   - 当#button2和#button3都为0时，所有指示灯熄灭（#greenLight、#redLight、#yellowLight都为0）。\n   - 当#button2为1且#button3为0时，#greenLight常亮，并且#redLight以0.5Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2为0且#button3为1时，#redLight常亮，并且#yellowLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2和#button3都为1时，#yellowLight常亮，并且#greenLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n3. 当#button1=1时，表示自动模式，指示灯自动按照如下说明循环执行：\n   - 首先#greenLight亮，保持1秒。\n   - 然后#greenLight熄灭，#redLight亮，保持1秒。\n   - 然后#redLight熄灭，#yellowLight亮，保持1秒。\n   - 然后回到初始状态#greenLight亮，保持1秒，如此循环。</任务描述>\n\n        <函数名称> LightsControl</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: button1, 类型: Bool, 描述: 按钮1\n - 名称: button2, 类型: Bool, 描述: 按钮2\n - 名称: button3, 类型: Bool, 描述: 按钮3\n</输入参数>\n<输出参数>\n - 名称: greenLight, 类型: Bool, 描述: 绿灯\n - 名称: redLight, 类型: Bool, 描述: 红灯\n - 名称: yellowLight, 类型: Bool, 描述: 黄灯\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"FIFO先进先出队列","description":"编写一个函数块FB，实现一个先进先出（FIFO）循环队列的功能，其中队列的最大长度和数据类型都是可变的。循环队列应能够支持以下操作：\n\n1. 入队操作（enqueue）：在队列未满的情况下，将一个元素添加到队列的队尾。\n2. 出队操作（dequeue）：在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。\n3. 判断队列是否为空：检查队列中是否没有元素。\n4. 判断队列是否已满：检查队列是否已达到最大容量。\n5. 获取队列元素数量：返回队列中当前元素的数量。\n状态代码：\n16#0000：执行FB没有出错\n16#8001：队列是空的\n16#8002：队列是满的","type":"FUNCTION_BLOCK","name":"FIFO","input":[{"name":"enqueue","type":"Bool","description":"入队操作，在队列未满的情况下，将一个元素添加到队列的队尾"},{"name":"dequeue","type":"Bool","description":"出队操作，在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。"},{"name":"reset","type":"Bool","description":"复位操作，复位头尾指针，元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"},{"name":"clear","type":"Bool","description":"清除操作，复位头尾指针，队列将被清空并用初始值initialItem进行初始化。元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"},{"name":"initialItem","type":"Variant","description":"用于初始化队列的值"}],"output":[{"name":"error","type":"Bool","description":"FALSE:没有发生错误 TRUE:执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"},{"name":"elementCount","type":"DInt","description":"队列中元素的数量"},{"name":"isEmpty","type":"Bool","description":"当为TRUE时表示队列是空的"}],"in/out":[{"name":"item","type":"Variant","description":"用于加入队列或从队列返回的值"},{"name":"buffer","type":"Variant","description":"用于作为队列的数组"}],"status_codes":{"16#0000":"执行FB没有出错","16#8001":"队列是空的","16#8002":"队列是满的"},"prompt":"<任务标题>FIFO先进先出队列</任务标题>\n        <任务描述>编写一个函数块FB，实现一个先进先出（FIFO）循环队列的功能，其中队列的最大长度和数据类型都是可变的。循环队列应能够支持以下操作：\n\n1. 入队操作（enqueue）：在队列未满的情况下，将一个元素添加到队列的队尾。\n2. 出队操作（dequeue）：在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。\n3. 判断队列是否为空：检查队列中是否没有元素。\n4. 判断队列是否已满：检查队列是否已达到最大容量。\n5. 获取队列元素数量：返回队列中当前元素的数量。\n状态代码：\n16#0000：执行FB没有出错\n16#8001：队列是空的\n16#8002：队列是满的</任务描述>\n\n        <函数名称> FIFO</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: enqueue, 类型: Bool, 描述: 入队操作，在队列未满的情况下，将一个元素添加到队列的队尾\n - 名称: dequeue, 类型: Bool, 描述: 出队操作，在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。\n - 名称: reset, 类型: Bool, 描述: 复位操作，复位头尾指针，元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。\n - 名称: clear, 类型: Bool, 描述: 清除操作，复位头尾指针，队列将被清空并用初始值initialItem进行初始化。元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。\n - 名称: initialItem, 类型: Variant, 描述: 用于初始化队列的值\n</输入参数>\n<输出参数>\n - 名称: error, 类型: Bool, 描述: FALSE:没有发生错误 TRUE:执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n - 名称: elementCount, 类型: DInt, 描述: 队列中元素的数量\n - 名称: isEmpty, 类型: Bool, 描述: 当为TRUE时表示队列是空的\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"随机数","description":"编写一个函数FC，该函数使用PLC的时钟值在指定的范围内生成一个随机整数。\n如果指定的范围不正确或读取系统时间出错，则输出错误状态和错误代码。\n\n状态代码\n16#0000：执行FB没有出错\n16#8200：指定的范围不正确：minValue 大于 maxValue\n16#8600：读取系统时间错误","type":"FUNCTION","name":"RandomRange_DInt","input":[{"name":"minValue","type":"DInt","description":"随机数范围的最小值"},{"name":"maxValue","type":"DInt","description":"随机数范围的最大值"}],"output":[{"name":"error","type":"Bool","description":"FALSE: 没有发生错误; TRUE: 执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"}],"return_value":[{"type":"DInt","description":"产生的随机数"}],"prompt":"<任务标题>随机数</任务标题>\n        <任务描述>编写一个函数FC，该函数使用PLC的时钟值在指定的范围内生成一个随机整数。\n如果指定的范围不正确或读取系统时间出错，则输出错误状态和错误代码。\n\n状态代码\n16#0000：执行FB没有出错\n16#8200：指定的范围不正确：minValue 大于 maxValue\n16#8600：读取系统时间错误</任务描述>\n\n        <函数名称> RandomRange_DInt</函数名称>\n        <函数类型> FUNCTION</函数类型>\n        <输入参数>\n - 名称: minValue, 类型: DInt, 描述: 随机数范围的最小值\n - 名称: maxValue, 类型: DInt, 描述: 随机数范围的最大值\n</输入参数>\n<输出参数>\n - 名称: error, 类型: Bool, 描述: FALSE: 没有发生错误; TRUE: 执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n</输出参数>\n<返回值>\n - 类型: DInt, 描述: 产生的随机数\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"双字边沿检测","description":"编写一个函数块FB，该函数块每周期检查一个双字（DWord）输入值中的每一位的上升沿和下降沿。函数块应能够检测并报告输入值中的变化、上升边沿和下降边沿。\n\n示例：\n假设输入值从2#101变为2#11011，则上升沿数量为3，上升边沿的位流为2#11010，下降沿数量为1，下降边沿的位流为2#100。","type":"FUNCTION_BLOCK","name":"GetBitStates","input":[{"name":"value","type":"DWord","description":"待检查变化和边沿触发的输入值"}],"output":[{"name":"hasChanged","type":"Bool","description":"为True时表示输入值已改变"},{"name":"hasRisingEdges","type":"Bool","description":"为True时表示输入值出现上升边沿"},{"name":"risingBits","type":"DWord","description":"上升边沿的位流，其中每个位表示相应位置的输入值是否发生了上升沿（1表示有上升沿，0表示无上升沿）"},{"name":"noOfRisingBits","type":"USInt","description":"输入值中的上升边沿数量"},{"name":"hasFallingEdges","type":"Bool","description":"为True时表示输入值出现下降边沿"},{"name":"fallingBits","type":"DWord","description":"下降边沿的位流，其中每个位表示相应位置的输入值是否发生了下降沿（1表示有下降沿，0表示无下降沿）"},{"name":"noOfFallingBits","type":"USInt","description":"输入值中的下降边沿数量"}],"prompt":"<任务标题>双字边沿检测</任务标题>\n        <任务描述>编写一个函数块FB，该函数块每周期检查一个双字（DWord）输入值中的每一位的上升沿和下降沿。函数块应能够检测并报告输入值中的变化、上升边沿和下降边沿。\n\n示例：\n假设输入值从2#101变为2#11011，则上升沿数量为3，上升边沿的位流为2#11010，下降沿数量为1，下降边沿的位流为2#100。</任务描述>\n\n        <函数名称> GetBitStates</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: value, 类型: DWord, 描述: 待检查变化和边沿触发的输入值\n</输入参数>\n<输出参数>\n - 名称: hasChanged, 类型: Bool, 描述: 为True时表示输入值已改变\n - 名称: hasRisingEdges, 类型: Bool, 描述: 为True时表示输入值出现上升边沿\n - 名称: risingBits, 类型: DWord, 描述: 上升边沿的位流，其中每个位表示相应位置的输入值是否发生了上升沿（1表示有上升沿，0表示无上升沿）\n - 名称: noOfRisingBits, 类型: USInt, 描述: 输入值中的上升边沿数量\n - 名称: hasFallingEdges, 类型: Bool, 描述: 为True时表示输入值出现下降边沿\n - 名称: fallingBits, 类型: DWord, 描述: 下降边沿的位流，其中每个位表示相应位置的输入值是否发生了下降沿（1表示有下降沿，0表示无下降沿）\n - 名称: noOfFallingBits, 类型: USInt, 描述: 输入值中的下降边沿数量\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"特殊堆栈","description":"编写一个函数块FB，实现一个特殊堆栈功能，在出栈时移除栈内的最小值。\n1. 入栈操作：当新元素入栈时，首先检查栈是否为满。如果栈为满，则不进行任何操作。否则，将其添加到数组的栈顶位置，并更新栈顶位置。\n2. 出栈操作：当执行出栈操作时，首先检查栈是否为空。如果栈为空，则不进行任何操作。否则，移除栈内的最小值，并返回该元素的值，同时更新栈顶位置。\n状态代码：\n16#0000：执行FB没有出错\n16#8A04：堆栈是满的\n16#8A05：堆栈是空的","type":"FUNCTION_BLOCK","name":"StackMin","input":[{"name":"push","type":"Bool","description":"入栈操作，在栈未满的情况下，将一个元素添加到栈内"},{"name":"pop","type":"Bool","description":"出栈操作，在栈不空的情况下，从栈内移除最小值元素，并返回该元素的值。"},{"name":"reset","type":"Bool","description":"复位操作，栈顶位置将被重置。"}],"output":[{"name":"error","type":"Bool","description":"FALSE: 没有发生错误; TRUE: 执行FB时出错"},{"name":"status","type":"Word","description":"状态代码"}],"in_out":[{"name":"item","type":"Int","description":"用于入栈或从栈内返回的值"},{"name":"stack","type":"Array[0..3] of Int","description":"用于作为栈的数组"}],"prompt":"<任务标题>特殊堆栈</任务标题>\n        <任务描述>编写一个函数块FB，实现一个特殊堆栈功能，在出栈时移除栈内的最小值。\n1. 入栈操作：当新元素入栈时，首先检查栈是否为满。如果栈为满，则不进行任何操作。否则，将其添加到数组的栈顶位置，并更新栈顶位置。\n2. 出栈操作：当执行出栈操作时，首先检查栈是否为空。如果栈为空，则不进行任何操作。否则，移除栈内的最小值，并返回该元素的值，同时更新栈顶位置。\n状态代码：\n16#0000：执行FB没有出错\n16#8A04：堆栈是满的\n16#8A05：堆栈是空的</任务描述>\n\n        <函数名称> StackMin</函数名称>\n        <函数类型> FUNCTION_BLOCK</函数类型>\n        <输入参数>\n - 名称: push, 类型: Bool, 描述: 入栈操作，在栈未满的情况下，将一个元素添加到栈内\n - 名称: pop, 类型: Bool, 描述: 出栈操作，在栈不空的情况下，从栈内移除最小值元素，并返回该元素的值。\n - 名称: reset, 类型: Bool, 描述: 复位操作，栈顶位置将被重置。\n</输入参数>\n<输出参数>\n - 名称: error, 类型: Bool, 描述: FALSE: 没有发生错误; TRUE: 执行FB时出错\n - 名称: status, 类型: Word, 描述: 状态代码\n</输出参数>\n<返回值>\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"数据类型为DTL的日期时间转换为字符串","description":"编写一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为字符串，并按照自定义的分隔符输出。转换后的字符串格式应为YYYY<分隔符>MM<分隔符>DD<分隔符>HH:mm:ss.nnnnnnnn，其中<分隔符>为函数参数指定的字符。这里HH代表小时（24小时制），mm代表分钟，ss代表秒，nnnnnnnn代表纳秒。注意，分隔符不应用于时分秒纳秒之间。\n\n示例：\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789，自定义分隔符为-。\n函数应返回字符串\"2023-09-17 12:34:56.123456789\"作为转换结果。","type":"FUNCTION","name":"DTLToString_ISO","input":[{"name":"date","type":"DTL","description":"数据类型为DTL的日期"},{"name":"separator","type":"Char","description":"转换后的日期中年和月之间，以及月和日之间的分隔符"}],"return_value":[{"type":"String","description":"转换后的日期字符串"}],"prompt":"<任务标题>数据类型为DTL的日期时间转换为字符串</任务标题>\n        <任务描述>编写一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为字符串，并按照自定义的分隔符输出。转换后的字符串格式应为YYYY<分隔符>MM<分隔符>DD<分隔符>HH:mm:ss.nnnnnnnn，其中<分隔符>为函数参数指定的字符。这里HH代表小时（24小时制），mm代表分钟，ss代表秒，nnnnnnnn代表纳秒。注意，分隔符不应用于时分秒纳秒之间。\n\n示例：\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789，自定义分隔符为-。\n函数应返回字符串\"2023-09-17 12:34:56.123456789\"作为转换结果。</任务描述>\n\n        <函数名称> DTLToString_ISO</函数名称>\n        <函数类型> FUNCTION</函数类型>\n        <输入参数>\n - 名称: date, 类型: DTL, 描述: 数据类型为DTL的日期\n - 名称: separator, 类型: Char, 描述: 转换后的日期中年和月之间，以及月和日之间的分隔符\n</输入参数>\n<输出参数>\n</输出参数>\n<返回值>\n - 类型: String, 描述: 转换后的日期字符串\n</返回值>","sample_io":[],"sample_io_prompt":""}
{"title":"从字符数组中截取字符串","description":"编写一个函数FC，该函数能够根据给定的起始字符串和结束字符串，从字符数组中截取符合要求的子字符串。\n\n1. 函数应遍历searchIn，查找textBefore首次出现的位置，然后查找随后出现的textAfter的位置。\n2. 如果找到了textBefore和textAfter，函数应截取这两个边界之间的字符串（不包括边界字符串本身），并返回这个子字符串。\n3. 如果textBefore或textAfter在searchIn中不存在，函数应返回特定的状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：输入参数searchIn不是字符数组或字节数组\n\n返回值表示查找的结果：\n- 16#0000：查找成功，头部字符和尾部字符均已找到\n- 16#9001：查找不成功，只找到了起始边界，未找到结束边界\n- 16#9002：查找不成功，起始边界未找到。\n\n示例：\n假设searchIn为\"This is a [sample] string with [multiple] boundaries.\"，textBefore为\"[\"，textAfter为\"]\"。函数应返回\"sample\"作为截取到的子字符串。","type":"FUNCTION","name":"ExtractStringFromCharArray","input":[{"name":"textBefore","type":"String","description":"要截取的字符串的起始边界"},{"name":"textAfter","type":"String","description":"要截取的字符串的结束边界"}],"output":[{"name":"extractedString","type":"String","description":"截取的字符串"},{"name":"status","type":"Word","description":"状态代码，具体见说明"}],"in/out":[{"name":"searchIn","type":"Variant","description":"要在其中进行搜索的字符或字节数组"}],"return_value":[{"type":"Word","description":"状态代码，具体见说明"}],"prompt":"<任务标题>从字符数组中截取字符串</任务标题>\n        <任务描述>编写一个函数FC，该函数能够根据给定的起始字符串和结束字符串，从字符数组中截取符合要求的子字符串。\n\n1. 函数应遍历searchIn，查找textBefore首次出现的位置，然后查找随后出现的textAfter的位置。\n2. 如果找到了textBefore和textAfter，函数应截取这两个边界之间的字符串（不包括边界字符串本身），并返回这个子字符串。\n3. 如果textBefore或textAfter在searchIn中不存在，函数应返回特定的状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：输入参数searchIn不是字符数组或字节数组\n\n返回值表示查找的结果：\n- 16#0000：查找成功，头部字符和尾部字符均已找到\n- 16#9001：查找不成功，只找到了起始边界，未找到结束边界\n- 16#9002：查找不成功，起始边界未找到。\n\n示例：\n假设searchIn为\"This is a [sample] string with [multiple] boundaries.\"，textBefore为\"[\"，textAfter为\"]\"。函数应返回\"sample\"作为截取到的子字符串。</任务描述>\n\n        <函数名称> ExtractStringFromCharArray</函数名称>\n        <函数类型> FUNCTION</函数类型>\n        <输入参数>\n - 名称: textBefore, 类型: String, 描述: 要截取的字符串的起始边界\n - 名称: textAfter, 类型: String, 描述: 要截取的字符串的结束边界\n</输入参数>\n<输出参数>\n - 名称: extractedString, 类型: String, 描述: 截取的字符串\n - 名称: status, 类型: Word, 描述: 状态代码，具体见说明\n</输出参数>\n<返回值>\n - 类型: Word, 描述: 状态代码，具体见说明\n</返回值>","sample_io":[],"sample_io_prompt":""}
