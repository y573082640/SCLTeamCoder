{"variables": [], "instructions": [], "planning": "\n- 概述\n这段代码是一个名为“LGF_ExtractStringFromCharArrayAdv”的SCL函数，它从一个字符数组中提取一个由前后文本指定的字符串，并具有扩展选项。\n\n- 变量定义\n代码中定义了以下几类变量：\n - 输入变量：textBefore, textAfter, includeBeforeAfter, startPos\n - 输出变量：extractedString, position, length, status\n - 输入/输出变量：searchIn\n - 临时变量：tempNumElements, tempPosInArray, tempLenTextBefore, tempPosTextBefore, tempLenTextAfter, tempPosTextAfter, tempString\n - 常量：LEN_STRING, STATUS_TEXT_FOUND, WARNING_ONLY_START, WARNING_NOTHING_FOUND, STATUS_NO_ERROR, ERR_NO_ARRAY\n\n- \n- 主逻辑部分\n-- REGION BLOCK INFO HEADER\n   此区域包含函数的元信息，如标题、功能、库、作者、测试环境等。\n-- REGION Initialization\n   此区域初始化函数的变量，包括设置临时变量的默认值，初始化位置、长度和提取的字符串，以及设置状态为“无错误”。\n   -- REGION Validation of inputs\n      此区域验证输入变量searchIn是否是一个字符或字节类型的数组。如果是，则获取数组的元素数量。如果不是，则终止程序执行并设置状态为“ERR_NO_ARRAY”。\n-- REGION Process  \n   此区域包含函数的主要处理逻辑，它使用一个循环来搜索数组中的文本。循环中，首先将字符转换为字符串，然后搜索文本前的位置。如果找到了文本前，则根据是否包含前后文本设置数组中的位置，并创建新的字符串。然后搜索文本后的位置。如果找到了文本后，则根据是否包含前后文本设置提取字符串的长度，并更新位置和提取的字符串。如果没有找到文本后，则输出整个字符串。循环继续执行，直到到达数组的末尾。\n   - 在循环中，首先使用Chars_TO_Strg函数将字符数组的一部分转换为字符串。然后，使用FIND函数在转换后的字符串中搜索文本前的位置。\n   - 如果找到了文本前，则根据是否包含前后文本更新数组中的位置。如果包含前后文本，则将位置设置为文本前之前的位置。如果不包含前后文本，则将位置设置为文本后之后的位置。\n   - 然后，再次使用Chars_TO_Strg函数创建新的字符串。接下来，使用FIND函数在新的字符串中搜索文本后的位置。\n   - 如果找到了文本后，则根据是否包含前后文本设置提取字符串的长度。如果包含前后文本，则将长度设置为从文本前开始到文本后结束的长度。如果不包含前后文本，则将长度设置为从文本后开始到字符串末尾的长度。\n   - 如果没有找到文本后，则输出整个字符串，并设置位置为数组中的当前位置，长度为字符串的长度。然后，根据是否找到了文本前设置返回值。如果找到了文本前，则返回“STATUS_TEXT_FOUND”。如果没有找到文本前，则返回“WARNING_ONLY_START”。\n   - 如果在循环中没有找到文本前，则将位置加LEN_STRING的值减去tempLenTextBefore的值，以确保关键词不会被字符串的末尾拆分，从而错过。\n   - 循环继续执行，直到到达数组的末尾。循环结束后，根据是否找到了文本前设置返回值。如果找到了文本前，则返回“STATUS_TEXT_FOUND”。如果没有找到文本前，则返回“WARNING_NOTHING_FOUND”。\n\n\n", "name": "LGF_ExtractStringFromCharArrayAdv"}