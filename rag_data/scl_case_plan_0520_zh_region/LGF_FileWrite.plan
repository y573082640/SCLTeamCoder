{"variables": [], "instructions": [], "planning": "\n- 概述\n这段代码是一个使用SCL编写的功能块，名为“LGF_FileWrite”，用于将数据作为二进制/序列化数据流写入文件，然后将文件存储在PLC的内存卡上的“UserFiles”文件夹中。\n\n- 变量定义\n代码中定义了以下几类变量：\n- 输入变量：执行、文件名\n- 输出变量：完成、忙、错误、状态、数据长度、诊断\n- 输入/输出变量：缓冲区字节数组、数据\n- 内部变量：状态内部、文件写入实例、状态主状态、状态参数数据是字节数组、状态异步模式、状态缓冲区大小、状态数据长度、状态文件长度\n- 临时变量：临时执行、临时退出状态循环、临时结果、临时缓冲区位置、临时路径前缀\n- 常量：路径前缀、FB状态无处理、FB状态初始化、FB状态参数、FB状态文件写入、状态执行完成、状态无调用、状态第一次调用、状态后续调用、错误未定义状态、错误缓冲区下限、错误缓冲区数组太小而无法复制、错误文件路径、错误移动块变体、错误数据序列化、错误文件写入初始化、错误文件写入\n\n- \n- 主逻辑部分\n  -- REGION TRIGGERING\n     此区域处理功能块的触发逻辑。首先，使用临时变量存储执行输入的值。如果执行输入为真且上一个周期为假，并且诊断状态为“无调用”，则初始化功能块并开始处理。这包括设置内部状态、错误和诊断信息，并将状态设置为“第一次调用”。然后，初始化功能块，将请求设置为假。如果诊断状态为“第一次调用”，则将状态设置为“后续调用”。最后，使用边缘检测来跟踪执行输入的变化。\n     \n     // 初始化功能块\n     #statInternal.done := FALSE;\n     #statInternal.busy := TRUE;\n     #statInternal.error := FALSE;\n     \n     // 设置状态机开始处理\n     #statMainState := #FB_STATE_INIT;\n     \n     // 初始化诊断信息\n     #statInternal.diagnostics := #statInternal.emptyDiagnostics;\n     #statInternal.diagnostics.status := #STATUS_FIRST_CALL;\n     #diagnostics := #statInternal.emptyDiagnostics;\n     \n     // 初始化文件写入实例\n     #instFileWrite(REQ := FALSE);\n     \n  -- REGION STATE_MACHINE\n     此区域实现了功能块的状态机。首先，使用一个循环来处理状态之间的转换。在循环中，首先将退出循环的标志设置为真。然后，根据当前状态，执行不同的逻辑。每个状态都有相应的处理逻辑，包括错误处理等。在处理完一个状态后，检查是否有必要再次运行循环。如果是，则继续循环。否则，退出循环。\n     \n     // 状态机循环\n     REPEAT\n       // 重置退出循环标志\n       #tempExitStateLoop := TRUE;\n       \n       // 根据当前状态执行相应的逻辑\n       CASE #statMainState OF\n         // 无处理状态\n         #FB_STATE_NO_PROCESSING:\n           // 不执行任何操作\n           \n         // 初始化状态\n         #FB_STATE_INIT:\n           // 验证文件路径\n           #tempPathPrefix := #PATH_PREFIX;\n           \n           // 比较文件名前缀\n           FOR #tempBufferPosition := 1 TO DINT_TO_INT(LEN(#tempPathPrefix)) DO\n             IF #fileName[#tempBufferPosition] <> #tempPathPrefix[#tempBufferPosition] THEN\n               // 文件名前缀不匹配\n               #statInternal.diagnostics.status := #ERR_FILE_PATH;\n               #statInternal.diagnostics.subfunctionStatus := DINT_TO_WORD(#tempBufferPosition);\n               // 停止执行并退出状态机\n               EXIT;\n             END_IF;\n           END_FOR;\n           \n           // 检查是否有文件路径错误\n           IF #statInternal.diagnostics.status.%X15 THEN\n             EXIT;\n           END_IF;\n           \n           // 验证缓冲区边界\n           // 检查缓冲区下限\n           #tempResult := DINT_TO_WORD(LOWER_BOUND(ARR := #bufferByteArray, DIM := 1));\n           \n           IF 0 <> #tempResult THEN\n             // 错误：缓冲区下限必须为0\n             #statInternal.diagnostics.status := #ERR_BUFFER_LOWERBOUND;\n             #statInternal.diagnostics.subfunctionStatus := #tempResult;\n             // 停止执行并退出状态机\n             EXIT;\n           ELSE\n             ; // 无需操作，继续执行\n           END_IF;\n           \n           // 获取缓冲区上限并计算缓冲区大小\n           #statBufferSize := UPPER_BOUND(ARR := #bufferByteArray, DIM := 1) + 1;\n           \n           // 验证参数数据类型\n           // 检查附加到输入/输出的参数类型\n           // 如果是数组，则继续执行，数组界限由移动块变体检查\n           IF IS_ARRAY(#data) AND TypeOfElements(#data) = Byte THEN\n             // 数据类型匹配 - 无需操作\n             #statParameterDataIsByteArray := TRUE;\n             // 获取数组大小\n             #statLengthData := UDINT_TO_DINT(CountOfElements(#data));\n             \n             // 验证缓冲区是否足够大以存储数据\n             IF #statBufferSize < #statLengthData THEN\n               // 错误：缓冲区数组对于数据数组来说太小\n               #statInternal.diagnostics.status := #ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY;\n               #statInternal.diagnostics.subfunctionStatus := 16#0000;\n               // 停止执行并退出状态机\n               EXIT;\n             ELSE\n               ; // 无需操作，继续执行\n             END_IF;\n             \n           ELSE\n             #statParameterDataIsByteArray := FALSE;\n             #statLengthData := 0;\n           END_IF;\n           \n           // 文件句柄初始化\n           // 使用假初始化文件写入\n           #instFileWrite(REQ := FALSE);\n           \n           IF #instFileWrite.Error THEN\n             // 文件写入初始化错误\n             #statInternal.diagnostics.status := #ERR_FILE_WRITE_INIT;\n             #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n             // 停止执行并退出状态机\n             EXIT;\n           ELSE // 如果 #instFileWriteC.Done = TRUE 则\n             // 下一个状态\n             #statMainState := #FB_STATE_PARAMETER;\n             // 异步 - 设置为真：\n             #tempExitStateLoop := #statAsynchronusMode;\n           END_IF;\n           \n         // 参数处理状态\n         #FB_STATE_PARAMETER:\n           // 如果参数是字节数组 - 直接复制\n           IF #statParameterDataIsByteArray THEN\n             // 将参数数组复制到缓冲区数组\n             #tempResult := INT_TO_WORD(\n                                        MOVE_BLK_VARIANT(SRC := #data,\n                                                         COUNT := DINT_TO_UDINT(#statLengthData),\n                                                         SRC_INDEX := DINT#0,\n                                                         DEST_INDEX := DINT#0,\n                                                         DEST => #bufferByteArray)\n             );\n             \n             // 检查是否成功复制参数结构，否则设置错误\n             IF 16#0000 <> #tempResult THEN\n               // 移动块变体错误\n               #statInternal.diagnostics.status := #ERR_MOVE_BLK_VARIANT;\n               #statInternal.diagnostics.subfunctionStatus := #tempResult;\n               // 停止执行并退出状态机\n               EXIT;\n               \n             ELSE\n               // 下一个状态\n               #statMainState := #FB_STATE_FILE_WRITE;\n               // 异步 - 设置为真：\n               #tempExitStateLoop := #statAsynchronusMode;\n             END_IF;\n             \n           ELSE\n             // 初始化缓冲区大小/位置指针\n             #tempBufferPosition := 0;\n             // 将数据序列化到缓冲区\n             #tempResult := INT_TO_WORD(\n                                        Serialize(SRC_VARIABLE := #data,\n                                                  DEST_ARRAY => #bufferByteArray,\n                                                  POS := #tempBufferPosition)\n             );\n             \n             // 检查是否成功序列化参数结构，否则设置错误\n             IF 16#0000 <> #tempResult THEN\n               // 数据序列化错误\n               #statInternal.diagnostics.status := #ERR_DATA_SERIALIZE;\n               #statInternal.diagnostics.subfunctionStatus := #tempResult;\n               // 停止执行并退出状态机\n               EXIT;\n             ELSE\n               // 序列化后，将数组大小指针设置为序列化元素的数量\n               #statLengthData := #tempBufferPosition;\n               // 下一个状态\n               #statMainState := #FB_STATE_FILE_WRITE;\n               // 异步 - 设置为真：\n               #tempExitStateLoop := #statAsynchronusMode;\n             END_IF;\n           END_IF;\n           \n         // 文件处理状态\n         #FB_STATE_FILE_WRITE:\n           // 将文件句柄请求设置为真\n           #instFileWrite(REQ    := TRUE,\n                          Name   := #fileName,\n                          Offset := UDINT#0,\n                          Length := DINT_TO_UDINT(#statLengthData),\n                          Data   := #bufferByteArray);\n           \n           IF #instFileWrite.Error THEN\n             // 文件写入错误\n             #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n             #statInternal.diagnostics.status := #ERR_FILE_WRITE;\n             #statInternal.diagnostics.subfunctionStatus := #instFileWrite.Status;\n             // 停止执行并退出状态机\n             EXIT;\n             \n           ELSIF #instFileWrite.Done THEN\n             // 文件写入完成\n             #statLengthFile := UDINT_TO_DINT(#instFileWrite.ResultLength);\n             // 下一个状态由状态切换\n             #statInternal.diagnostics.status := #STATUS_EXECUTION_FINISHED;\n             #statInternal.diagnostics.subfunctionStatus := 16#0000;\n             \n           ELSE\n             ; // 无需操作，继续执行\n           END_IF;\n           \n         ELSE // 状态机达到未定义的状态\n           // 未定义状态错误\n           #statInternal.diagnostics.status := #ERR_UNDEFINED_STATE;\n           #statInternal.diagnostics.subfunctionStatus := 16#0000;\n       END_CASE;\n       \n       // 如果在同一个周期中需要执行一次或多次，请设置 #tempExitStateLoop := FALSE;\n       // 检查状态，如果条件 = TRUE --> #tempExitStateLoop = TRUE --> 退出循环\n     UNTIL (TRUE = #tempExitStateLoop)\n     END_REPEAT;\n     \n  -- REGION OUTPUTS\n     此区域将内部变量的值写入输出变量。首先，检查是否执行完成且没有错误。如果是，则将完成输出设置为真，并将状态设置为“无处理”。然后，检查是否有错误发生。如果有，则将错误输出设置为真，并写入诊断信息。否则，检查执行输入是否为假且完成或错误输出为真。如果是，则重置输出。最后，写入一些静态值到输出。\n     \n     // 检查是否执行完成且没有错误\n     IF (#statInternal.diagnostics.status = #STATUS_EXECUTION_FINISHED) AND (#statInternal.done = FALSE) THEN\n       // 执行完成且没有错误\n       #statInternal.done := TRUE;\n       #statInternal.busy := FALSE;\n       #statInternal.error := FALSE;\n       #statMainState := #FB_STATE_NO_PROCESSING; // 将状态机切换到“无处理”\n       \n     ELSIF (#statInternal.diagnostics.status.%X15 = TRUE) AND (#statInternal.error = FALSE) THEN\n       // 发生错误\n       #statInternal.done := FALSE;\n       #statInternal.busy := FALSE;\n       #statInternal.error := TRUE;\n       // 写入诊断信息\n       #statInternal.diagnostics.stateNumber := #statMainState;\n       #diagnostics := #statInternal.diagnostics;\n       #statMainState := #FB_STATE_NO_PROCESSING; // 将状态机切换到“无处理”\n       \n     ELSIF (#tempExecute = FALSE) AND ((#statInternal.done = TRUE) OR (#statInternal.error = TRUE)) THEN\n       // 重置输出\n       #statInternal.done := FALSE;\n       #statInternal.busy := FALSE;\n       #statInternal.error := FALSE;\n       #statInternal.diagnostics.status := #STATUS_NO_CALL;\n       #statLengthData := 0;\n       #statLengthFile := 0;\n     END_IF;\n     \n     // 写入静态值到输出\n     #done := #statInternal.done;\n     #busy := #statInternal.busy;\n     #error := #statInternal.error;\n     #status := #statInternal.diagnostics.status;\n     \n     #dataLength := #statLengthData;\n     ENO := #statInternal.error;\n\n\n", "name": "LGF_FileWrite"}